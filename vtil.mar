;
	.title	VTIL -- VAX Threaded Interpretive Language
	.ident	/v1.01/			; version number
;******************************************************************************
;
; VTIL -- VAX Threaded Interpretive Language
;
;	Program:	V T I L . MAR
;	Written By:	Thomas Kurt Bond
;	Version:	v1.01
;	Date:		7 February 1988
;
; Description:
;     This program was written for my Senior Seminar Project at West Virginia
; Wesleyan College in the spring of 1988.
;
;     This program implements a Threaded Interpretive Language (TIL) in
; VAX Macro, using subroutine threading.  Essentially, it is an interactive
; compiler.
;
; History
; Ver	  When	   Who	What
; 1.00	  020788   tkb	Initial version.
; 1.01	  021288   tkb	Uses a smudge bit to prevent word being defined from
;			being found while defining it.	({ recurse } allows
;			recursion.)  Also limits length of names to 80 characters
;			allowing the name-length byte to have the smudge bit
;			in it.
;******************************************************************************
;!> VTIL.MAR -- VAX Threaded Interpretive Langague, an interactive compiler.

;
; Set up source code formatting macros.
;

;+++
;m> newpage -- change the subtitle and move to a new page.
;---
	.macro	newpage subtitle
	.page
	.sbttl	subtitle
	.endm

;******************************************************************************
;
; Conditional Assembly Control Symbols
;
;******************************************************************************
;ca_trapping = 0		; If this is defined, code for a condition handler
			; is assembled.	 We don't always want the condition
			; handler because it also catched breakpoints in the
			; debugger.
;ca_controlc = 0		; If this is defined, code to trap control/c and
			; return to the VTIL interpreter is assembled.
			; Note that this uses the trapping so it is useless
			; if `ca_trapping' is not defined.

	newpage <External Symbols>
;******************************************************************************
;
; External Symbols
;
;******************************************************************************
	.dsabl	global
	.extrn	dc$_term
	.extrn	dsc$k_dtype_t, dsc$k_class_s
	.extrn	io$_setmode, io$m_ctrlcast
	.extrn	lib$_inpstrtru
	.extrn	lib$get_input, lib$put_output, lib$signal
	.extrn	ots$cvt_l_ti
	.extrn	rms$_eof, rms$_fnf
	.extrn	tpu$tpu
	.extrn	vtil_ctrlc, vtil_maxerrors
	$chfdef				; condition handling facility


newpage <General Notes>
;******************************************************************************
;
; General Notes
;
;******************************************************************************
;
; Word -- A VTIL word is the equivalent of the procedure and/or function of
; Pascal or other langauges.  (Context will have to determine whethere we
; are talking about VTIL words or memory 2-byte words.)	   A word finds any
; parameters it needs on the data stack, and leaves any result on the stack
; also.	 VTIL words (or sequences of words) will be singled out from normal text
; by enclosing them in { } pairs, since many of them include punctuation marks
; that might be otherwise confusing.  Also, the string `...' inside a { }
; pair will indicate a sequence of VTIL words omitted as irrelevent to the
; explaination.
;
; Stack Comments.  A stack comment shows what a word expects to find on the
; stack and what results it leaves on the stack after execution.
; A stack comment looks like the following: ( n1 n2 -- n1 ).  The rightmost
; item on each side of the `--' is the top of the stack, so the items in the
; stack comment are in the same order as they would be if you entered them from
; the terminal.	 The `--' separates the items that word expects to find on
; the stack from the items that it leaves on the stack.	 Ex: After you enter
; { 1 2 3 }, 3 is on the top of the stack.  In ( n1 n2 n3 -- x1 x2 ) n3 is
; on top of the stack before the word executes, and x2 is on top of
; the stack after that word executes.
;
; Items in stack comments:
;	?	-- `?' is not an item on the stack itself.  Instead, it
;		   indicates that items to the left of the `?' (further
;		   down on the stack) may or may not be present, depending
;		   on the value of items to the right of the `?' (which
;		   are on top of the stack).  For instance, a stack comment
;		   of ( a -- a ? f ) indicates that the word leaves a
;		   flag on the top of the stack, and depending on the value
;		   of the flag will also leave an address on the stack.
;	a	-- address
;	b	-- unsigned byte (integer, 1 byte)
;	c	-- unsigned characcter (1 byte)
;	f	-- boolean flag; 0 = false, true <> 0 (usually 1)
;	l	-- long (integer, 4 bytes)
;	n	-- integer (usually meaning number.  A longword)
;	s	-- short (integer, 2 bytes)
;
;	Note that *all* stack items are at least a longword in width.
;	a ( b ) stack item merely says that the programmer should consider
;	the stack as containing a value that will fit in an unsigned
;	byte.  Words that use data types that are smaller than a longword
;	will only use th first part of the longword in their calculations,
;	but will still pop the whole longword containing the smaller data
;	type from the stack, not just the smaller data type.  In other words,
;	the stack pointer can only be manipulated in 4 byte increments or
;	decrements.
;
; Starting Vocabularies -- At the moment, there are only two starting
; vocabularies `compiler' and `kernel', which are independent of each other.
; All later vocabularies should be linked into one of thse.  But See v1_*.
;
;******************************************************************************
	newpage <Implementation Notes>
;******************************************************************************
;
; Implementation Notes
;
;******************************************************************************
;
; r11, ds	-- data stack pointer
; r10, ls	-- loop stack pointer
; r9, eodp	-- end of dictionary pointer
; r8-r4 are used for temporary storage when using character instructions.
;
; header format for a word
;	long	-- back link to next word in dictionary (hfa, lfa)
;	byte	-- count of name byes (nfa)
;	byte(s) -- bytes of name
;	code	-- executable code for this word (cfa)
;	data	-- optional data for this word (pfa)
;
; Names
; Since none of the VTIL kernel and compiler words contain underscores,
; the following conventions were followed so there would be no conflict
; between names in the MACRO-32 source and in the VTIL.	 For instance,
; { context } is the name of a word in the kernel that pushes the address
; of the current vocabulary variable on the stack.  However, the definition
; of context in the MACRO source makes `context' a label wich jsb'ing to
; executes the word, so `context' can't be used in MACRO as a label for
; the variable as well.
;
;	<name>	   -- label of start of a VTIL word called <name>
;	_<name>	   -- internal branch points
;	adm_<name> -- addressing mode constant value
;	c_<name>   -- constant value
;	ca_<name>  -- conditional assembly control symbols
;	i_<name>   -- label of start of a VTIL word whose <name> doesn't
;		      otherwise fit this naming convention, du to the
;		      character limitations in VAX MACRO symbols.
;		      For eample, i_plus = { + }, i_plus_store = { +! }
;	op_<name>  -- opcode constant value
;	r_<name>   -- internal routine <name> that is readed by branching and
;		      not by jumping to subroutine.
;	s_<name>   --  internal subroutine that is reached by a call.
;	q_<name>   -- label of start of a VTIL word with name `?<name>'.
;	v_<name>   -- internal variable name.
;	vl_<name>  -- internal vocabulary link symbol used by the header macro
;		      to link built-in vocabularies together.
;
;	Names of words other than looping words or branching words that should
;	occur in pairs generally have VTIL names like { name( } and
;	{ )name } or { name< } and { >name } and internal names like
;	i_name_begin and i_name_end.
;
; To make finding words easie, all the words have a header comment
; like this:
;	;+++
;	;s> name -- explanation
;	;---
; where `s' is `c' for the compiler words, `k' for the kernel words,
; `m' for macros, `r' for routines, and `s' for subroutines.
;
; The string `;??? starts an internal note to the programmer.  These notes
; generally comment about an alternate method of doing something or suggest
; areas that should be improved.  ~~~ indicates a note made while typing this back in.
;
;******************************************************************************
	newpage <Constants>
;******************************************************************************
;
; Constants -- Symbol definitions for constant values
;
;******************************************************************************
;
; General constants
;
c_true		= -1			; true value, actually anything
					;  but 0 is true
c_false		= 0			; false value
c_max_errs	= 20			; Maximum number of fatal errors allowed
c_max_name_len	= 80			; Maximum length of word names
c_blank		= 32			; ascii blank
c_com1_begin	= ^a/\/			; start first type of comment with `\'
c_com1_end	= 0			; end w/something not in a line of text
					; so it will skip the whole line
c_com2_begin	= ^a/(/			; start second type of comment with `('
c_com2_end	= ^a/)/			; end with `)'
c_inuse		= 1			; buffer in use flag
c_modified	= 2			; bufffer updated flag
c_max_blocks	= 3			; number of block i/o buffers
c_block_size	= 1024			; size for block i/o buffer
c_keysize	= 4			; size of key (longword record number)
c_d_blks_in_blk = c_block_size / 512	; number of disk blocks in VTIL block
c_max_len	= 160			; maximum length of input line
c_screen_len	= 80			; screen is 80 chars wide
c_pad_moat	= 265			; distance of pad from eodp
c_ds_size	= 1024 * 4		; data stack size: 1024 items of
					; 4 bytes each
c_ls_size	= 512 * 4		; loop stack size: 512 items of
					; 4 bytes each
;
; opcodes == constants for compiling opcodes into dictionary
;
op_acbl		= ^xf1
op_addl2	= ^xc0
op_bneq		= ^x12
op_brw		= ^x31
op_jsb		= ^x16
op_movab	= ^x9e
op_moval	= ^xde
op_movaw	= ^x3e
op_movb		= ^x90
op_movc3	= ^x28
op_movl		= ^xd0
op_rsb		= ^x05
op_tstl		= ^xd5
;
; addressing modes -- constants for compiling addressing modes into dictionary.
;	In order by register and addressing mode.
;
adm_r0		= ^x50			; r0
adm_r9		= ^x59			; r9
adm_def_r9	= ^x69			; (r9)
adm_ainc_r9	= ^x89			; (r9)+
adm_r10		= ^x5a			; r10
adm_def_r10	= ^x6a			; (r10)
adm_adec_r10	= ^x7a			; -(r10)
adm_ainc_r10	= ^x8a			; (r10)+
adm_b_dis_r10	= ^xaa			; b^(r10)
adm_def_r11	= ^x6b			; (r11)
adm_adec_r11	= ^x7b			; -(r11)
adm_ainc_r11	= ^x8b			; (r11)+
adm_immediate	= ^x8f			; immediate mode
adm_absolute	= ^x9f			; absolute mode
adm_b_rel	= ^xaf			; byte relative

;
; Assembly-time vocabulary links -- symbols used during assembly to link
;	the starting vocabularies together.   These start out at 0 so that
;	all vocabularies will end with a null pointer.	During assembly,
;	each link holds the address of the link fields of the most recently
;	defined.  When a word is defined with the `header' macro then
;	link field of the new word is initialized to the valu of the
;	link and the link is changed to the address of the link field of the
;	new word.
;
vl_compiler = 0		   ; Links the compiler vocabulary together
vl_kernel = 0		   ; Links the kernel vocabulary together
;******************************************************************************
	newpage <Macros>
;******************************************************************************
;
; Macros -- Macro Definitions
;
;******************************************************************************
;!+++t
;m> header -- macro to start all words in code
;	This macro sets up the header for the VTIL words, and inserts it
;	into the linked vocabulary list.  Because it uses backslash delimited
;	strings, none of the words in the starting vocabularies built in
;	the macro source code should have backslashes in their names.
;
;!---
	.macro	header	macname,name=<>,branch=vl_kernel
	.long	branch		; back link to the previous word in this branch
	branch = . - 4		; where to link the next word to in this branch
	.nchr  nchr, ^\name\	; nchr = length( name )
	.if    le, nchr		; nchr <= 0
	   .ascic \macname\	; no auxillary name, use principle one
	.if_false		; else
	  .ascic \name\		; use auxillary name
	.endc			; end if
macname:			; use name of word as branch label
	.endm			; end of macro header


;!+++
;m> iserror -- simplistic error checking routine.  If error code in r0,
;	die messily.
;!---
	.macro	iserror badwhere=_error_exit,?goodwhere
	blbs	r0,goodwhere	; no error, go on
	brw	badwhere	; error, branch to error handler
goodwhere:
	.endm	iserror


;!+++
;m> isstrerr -- simplistic error checking routine.  If error code in r0,
;	unless lib$_inpstrtru, die messily
;!---
	.macro	isstrerr badwhere=_error_exit,?goodwhere
	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
	beql	goodwhere		; yes, ignore and go on
	blbs	r0,goodwhere		; no error, go on
	brw	badwhere		; error, branch to error handler
goodwhere:
	.endm	isstrerr

	newpage <Data Section>
;******************************************************************************
;
; Data Section -- Contains the stacks, i/o buffers, misc buffers,
;	and the system variables.
;
;******************************************************************************
	.psect	vtildata,long,noexe
;
; data stack allocation
;
c_ds_end:
	.blkb	c_ds_size	; reserve c_ds_size bytes for data stack
c_ds_start:
;
; Loop stack allocation
;
c_ls_end:
	.blkb	c_ls_size	; reserve c_ls_size bytes for loop stack
c_ls_start:


;
; message string variables
;	.ascid strings are used by lib$get_input and lib$put_output
;	.ascic strings are used by { write }
;
v_greeting:
	.ascid	/VTIL v1.01 -- Welcome to TIL-land!/	; Greet the user
v_vtilprompt:
	.ascid	/VTIL> /	; prompt for system input
v_usrprompt:
	.ascid	/? /		; prompt for programmer input
v_undermess:
	.ascid	/Stack Underflow!/
v_overmess:
	.ascid	/Stack Overflow!/
v_unknown:
	.ascic	/Unknown token: { /
v_unknown2:
	.ascic	/ } in line: /
v_infilemess:
	.ascic	/In file: /
v_filenotfound:
	.ascid	/File not found!/
v_unkn_blk_mess:
	.ascic	/Uknown Block Number: /
v_wordnotfound:
	.ascic	/Word Not Found: /
v_nametoolong:
	.ascic	/Name too long: /
v_nametrunc:
	.ascic	/Truncated to: /


;
; variables for system input
;
v_inbuf:
	.blkb	c_max_len	; buffer for system input
v_org_inlen:
	.word	0		; original length of line
v_inlen:			; word to hold length of remaining unprocessed
	.word	0		; characters
v_inptr:
	.long	v_inbuf		; pointer to current location in string
v_in_dsc:
	.word	c_max_len	; maximum length for system input
	.byte	dsc$k_dtype_t	; data type text
	.byte	dsc$k_class_s	; descriptor class
	.long	v_inbuf		; pointer to input buffer


;
; rms buffers for loading source from a file instead of keyboard
;
	.align	long			; so rms macros won't complain
v_infab:
	$fab
;		fnm=<infile>,-		; primary input file name
;		dnm=<vtil.vtil>		; default input file extension
v_inrab:
	$rab	fab=v_infab,-		; pointer to fab
		rop=rah,-		; read-ahead option
		ubf=v_inbuf,-		; record buffer
		usz=c_max_len		; and size
v_fnamelen:
	.byte	0		; length of file name for { load }
v_fname:
	.blkb	c_max_len	; buffer for file name for { load }


;
; rms buffers for VTIL block i/o (which is actually rms record i/o)
;
	.align long
v_blkfab:
	$fab	dnm=<vtilblocks.dat>,-	; default input file name
		fac=<get,upd>,-		; block i/o operations
		fnm=<vtilblocks>,-	; input file name
		mrs=c_block_size,-	; maximum record size
		rfm=<fix>		; fixed length records
v_blkrab:
	$rab	fab=v_blkfab,-		; pointer to fab
		kbf=v_blkkey,-		; pointer to key
		ksz=c_keysize,-		; size of key
		rac=<key>,-		; random access by record number
		ubf=v_blkbuff,-		; address of user buffer
		usz=c_block_size	; and the record size
v_blkkey:
	.long				; buffer for key (longword pos rec #)
v_blockio:
	.byte	c_false			; true when block file is open
v_current_buff:				; Buffer # of most recently accessed
	.long	0			; block

v_buf_inuse:
	.blkb	c_max_blocks		; flags for inuse and modified
v_buf_blk_nums:
	.blkl	c_max_blocks		; block numbers in buffers

;
; Moved the Block i/o buffers away from the rest of the block i/o stuff
; to the end of the dictionary because that is safer.  They are away from
; other variables that might get overwritten if someone tries to write
; too long a string to the buffers, for instance.
;


;
; variables for terminal input
;
v_readlen:
	.word			; length of returned input
v_readdsc:
	.word	c_max_len	; maximum length
	.byte	dsc$k_dtype_t	; data type text
	.byte	dsc$k_class_s	; descriptor class
v_readaddr:
	.long	0		; pointer to the input buffer
; v_static_dsc is the middle of a descriptor so it can be copied onto ds
; to make full desciptor when top fo stack is ( addr count )
v_static_dsc:
	.byte	dsc$k_dtype_t	; data type text
	.byte	dsc$k_class_s	; descriptor class
v_outlen:
	.word	0		; length of output
v_outbuf:
	.blkb	c_max_len	; output bufer


;
; Variables for calling the EVE editor using its callable interface.
;
v_tpu_com:			; buffer for constant section of command
	.ascii	\tpu \          ; Don't specify a specific section file, instead of \tpu/section=eve$dir:eve_edt \ ; use my version of eve
c_tpu_com_len = . - v_tpu_com	; length of command is a constant
v_tpu_com2:			; buffer for user section of command
	.blkb	c_max_len
v_tpu_dsc:
	.word	0		; descriptor for command to pass to tpu$tpu
	.byte	dsc$k_dtype_t	; data type text
	.byte	dsc$k_class_s	; descriptor class
	.long	 v_tpu_com	; pointer to tpu command buffer
;
; Buffers for $ASSIGN, $DASSIGN, and $QIO
;
v_input_name:
	.ascid	/sys$command/
v_input_chan:
	.blkw	1
;
; Buffers for $GETCHN_S
;
v_getchn_ret_len:		; returned length of buffer info
	.long	0
v_getchn_in_buf:		; input buffer for getchn, tells about output
				; buffer
	.long	8		; length of output buffer
v_getchn_buf_adr:
	.long	v_getchn_buf	; address of output buffer
v_getchn_buf:			; output buffer
	.quad	0		; cleared to begin

;
; System Variables
;
v_trap_depth:		; depth to unwind stack in trap handler
	.long	1	; unwind to establisher, i.e, main body, 1 deep
v_ctrlc_depth:		; depth to unwind stack in control/c handler
	.long	2	; unwind to main program, 2 deep (ctrlc and a_start)
v_errors:
	.long	0	; Number of errors caught by condition handler so far
v_returnstack:		; original return stack pointer.  Save it when we
	.long	0	; abort out of jsb's we return from the right spot
v_context:		; points to data field of the word for the vocabulary
	.long	0	; in which words are searched for.
v_current:		; points to data field of the word for the vocabulary
	.long	0	; that new words are linked into.
v_compiler:		; Pointer to most recent word in compiler vocabulary
	.long	0
v_kernel:		; Pointer to most recnet word in kernel vocabulary
	.long	0	; data field of { kernel }
v_infile:		; Flag.	 If true, reading from an input file.
	.byte	c_false	; If false, reading from terminal.  Set by { load }
v_filelinenum:		; number of lines read from input file
	.long	0	; used in error reporting
v_state:		; Flag.	 True if compiletime word found
	.byte	c_false ; in compile mode (then set to false by ?execute),
			; otherwise false.
v_mode:			; Flag.	 True if in compile mode, false if execute mode.
	.byte	c_false ; true => compile word, false => execute word
v_radix:
	.long	10	; base for number conversion on input and output
v_hld:
	.long	0	; pointer to number output conversion buffer

	newpage <Kernel Built-ins>
	.psect	vtilcode,exe,nowrt
;******************************************************************************
;
; Kernel Built-Ins -- Original vocabulary of words.  All other vocabularies
;	link into this one, except the compiler (compiletime word) vocabulary.
;
;******************************************************************************
_kernel_begin:


;+++t
;k> ! (store) -- ( n a -- ) store longword `n?' at `a'.
;---
	header	i_store,<!>
	movl	4(r11),@(r11)		; store item at what's pointed to by
					; top of stack
	addl2	#8,r11			; pop arguments
	rsb				; end of !


;+++
;k> # -- ( n1 -- n2 ) generate next output character in number conversion.
;	used between { <# } and { #> }.
;---
	header	i_sharp,<#>
	movl	v_radix,-(r11)	; put radix on stack
	jsb	i_div_mod	; get next digit
	jsb	tochar		; make it appropriate ascii char
	jsb	hold		; put in output string
	rsb			; end of #


;+++
;k> #> -- ( n1 -- a n2 ) End numeric output.  Leaves length and address of
;	numeric text on stack for { write }.
;---
	header	i_sharp_greater,^\#>\
	movl	v_hld,(r11)		; drop number, put address of output
					; on stack
	addl3	r9,#c_pad_moat,r0	; get address of pad
	subl3	v_hld,r0,-(r11)		; put count on stack
					; count = pad - hld
	rsb				; end of #>


;+++
;k> #s -- ( n1 -- n2 ) Convert all all digits of n1 to output string.  Leaves 0.
;	Used between { <# } and { #> }.
;---
	header	i_sharp_s,<#s>
	jsb	i_sharp			; output at least one character
	tstl	(r11)			; is top not = 0?
	bneq	i_sharp_s		; yes, do it again
	rsb				; no, exit
					; end of #s


;+++
;k> (# -- ( -- ) Start count of items on the stack.  Used with { #) }.
;	Uses the loop stack!
;---
	header	i_count_begin,<(#>
	movl	r11,-(r10)		; save address of top of stack
	rsb				; end of (#


;+++
;k> (and) -- ( n1 n2 -- n3 ) bitwise and of n1 and n2.
;---
	header	i_bit_and,<(and)>
	mcoml	(r11),(r11)		; make ones comp because blc ones
					; comps mask
	bicl2	(r11)+,(r11)		; and it
	rsb				; end of (and)


;+++
;k> (not) -- ( n1 n2 -- n3 ) bitwise not of n1 and n2.
;---
	header	i_bit_not,<(not)>
	mcoml	(r11),(r11)		; not it
	rsb				; end of (not)


;+++
;k> (or) -- ( n1 n2 -- n3 ) bitwise or of n1 and n2.
;---
	header	i_bit_or,<(or)>
	bisl2	(r11)+,(r11)		; or it
	rsb				; end of (or)


;+++
;k> (xor) -- ( n1 n2 -- n3) bitwise xor of n1 and n2.
;---
	header	i_bit_xor,<(xor)>
	xorl2	(r11)+,(r11)		; xor it
	rsb				; end of (xor)


;+++t
;k> * -- ( n1 n2 -- n3) multiply top two stack items, leave result on stack.
;---
	header	i_multiply,<*>
	mull2	(r11)+,(r11)		; multiply them
	rsb				; end of *


;+++
;k> #) -- ( -- n ) Return number of items on stack since last { (# }.
;	uses the loop stack!
;---
	header	i_count_end,<#)>
	subl3	r11,(r10)+,-(r11)	; number of bytes difference in
					; top of stack then and now.
	divl2	#4,(r11)		; divide to get number of stack
					; items (longwords)
	rsb				; end of #)


;+++t
;k> + -- ( n1 n2 -- n3 ) add the top two stack items, leave result on stack.~~~ Why i_add and not i_plus???
;---
	header	i_add,<+>
	addl2	(r11)+,(r11)		; add them and leave the result on stack
	rsb				; end of +


;+++
;k> +! -- ( n a -- ) Adds `n' to contents of `a'.
;---
	header	i_plus_store,<+!>
; Add top of stack to cents of address that is top of stack.
	addl2	   4(r11),@(r11)	;
	addl2	   #8,r11		; pop arguments
	rsb				; end of +!


;+++
;k> +rot - (n1 n2 n3 -- n3 n1 n2 ) rotate top 3 items on the stack up,
;	bringing the second to the top.
;---
	header	i_plus_rot,<+rot>
	movl	(r11),r0		; t1 = n3
	movl	4(r11),(r11)		; n3 = n2
	movl	8(r11),4(r11)		; n2 = n1
	movl	r0,8(r11)		; n1 = t1 (old n3)
	rsb				; end of +rot


;+++
;k> , -- ( n -- ) Compile a longword `n' into the dictionary.
;---
	header	i_comma,<,>
	movl	(r11)+,(r9)+		; store longword in dictionary
	rsb				; end of ,


;+++t
;k> - -- ( n1 n2 -- n3 ) subtract the top stack item from the next stack item.
;---
	header	i_subtract,<->
	subl2	(r11)+,(r11)		; subract and leave result on stack.
	rsb				; end of -


;+++
;k> -rot -- ( n1 n2 n3 -- n2 n3 n1 ) rotate top 3 items on the stack down,
;	bringing the third to the top.
;---
	header	i_minus_rot,<-rot>
	movl	8(r11),r0		; t1 = n1
	movl	4(r11),8(r11)		; n1 = n2
	movl	(r11),4(r11)		; n2 = n3
	movl	r0,(r11)		; n3 = n1
	rsb				; end of -rot


;+++
;k> . -- ( n -- ) output the top of the stack as a signed number and pop it.
;---
	header	i_dot,<.>
	movl	(r11),-(r10)		; dup ds>ls
	jsb	abs			; abs
	jsb	i_less_sharp		; <#
	jsb	i_sharp_s		; #s
	movl	(r10)+,-(r11)		; ls>ds
	jsb	sign			; sign
	jsb	i_sharp_greater		; #>
	jsb	write			; output it
	movl	#c_blank,-(r11)		; put space on stack
	jsb	putc			; output it
	rsb				; end of .


;+++
;k> .( -- ( -- ) write the text following until the next `)' to the screen.
;	This word should only be used *OUTSIDE* a definition (i.e.,
;	in execute mode).
;---
	header	i_dot_lparen,<.(>
	movl	#^a\)\,-(r11)		; set up for `)' delimited token.
	jsb	token			; get the token
	addl3	#1,r9,-(r11)		; address of string
	movzbl	(r9),-(r11)		; get count of string on stack
	jsb	write			; put it on the screen
	rsb				; end of .(


;---
;k> .sb -- ( -- ) output the stack from the bottom up without consuming it.
;	The last item printed is the top of the stack.
;---
	header	i_dot_sb,<.sb>
	movl	#c_ds_start,-(r10)	; save end of stack.
10$:
	cmpl	r11,(r10)		; at top of stack yet?
	bgeq	100$			; yes, leave
	subl2	#4,(r10)		; move to item
	movl	@(r10),-(r11)		; put item on top of stack
	jsb	i_dot			; print it
	brb	10$			; do it again
100$:
	addl2	#4,r10			; pop off stack pointer from loop stack
	rsb				; end of .sb


;+++
;k> .st -- ( -- ) output stack from the top down without consuming it.
;	The last item printed is the bottom of the stack.
;---
	header	i_dot_st,<.st>
	movl	r11,-(r10)		; save sp on top of loop stack
10$:
	cmpl	(r10),#c_ds_start	; Is stack empty?
	bgeq	20$			; yes
	movl	@(r10),-(r11)		; put item on top
	jsb	i_dot			; print it
	addl2	#4,(r10)		; move down stack
	brb	10$			; do it again
20$:
	addl2	#4,r10			; pop off stack pointer from loop stack
	rsb				; end of .st


;+++t
;k> / -- ( n1 n2 -- n3 ) divides second stack item by top stack item, leaves
;	result on stack.  n3 = n1 / n2.
;---
	header	i_divide,</>
	divl2	(r11)+,(r11)
	rsb				; end of /


;+++
;k> /mod -- ( n1 n2 -- n3 n4 ) divides second stack item by top stack item,
;	leaves ( quotient remainder ) on the stack.  n3 = n1 / n2, n4 = n1 - (n3 * n2).
;---
	header	i_div_mod,</mod>
	divl3	(r11),4(r11),r0		; r0 = n1 / n2 = n3
	mull3	r0,(r11)+,r1		; tmp = n2 * n3
	subl3	r1,(r11)+,r1		; r1 = n1 - (n2 * n3) = n4
	movl	r0,-(r11)		; push n3, quotient
	movl	r1,-(r11)		; push n4, remainder
	rsb				; end of /mod


;+++
;k> 1+ -- ( n -- n+1 ) Add one to the top of the stack.
;---
	header	i_one_plus,<1+>
	incl	(r11)			; dd one to the top of the stack.
	rsb				; end of 1+


;+++
;k> 1- -- ( n -- n-1 ) Subtract one from the top of the stack.
;---
	header	i_one_minus,<1->
	decl	(r11)			; subtract one from top of stack
	rsb				; end of 1-


;+++
;k> : -- ( -- ) (colon) defining word that starts a word definition.
;	sets { mode } to true
;	Note that { : } is a compiling word an so is in compiler vocab.
;---
	header	i_colon,<:>
	movl	v_current,v_context	; search same vocab we are defining into
	jsb	create			; create header for new word
;??? Should I now set the high bit in the length byte (To prevent word from
; being found during its own definition)?
	jsb	smudge			; set smudge bit in name length so word isn't found
	movb	#c_true,v_mode		; set compiler v_mode
	rsb				; end of :


;+++t
;k> < -- ( n1 n2 -- f ) true if n1 < n2, false otherwise.
;---
	header	i_less,^\<\
	cmpl	(r11)+,(r11)+		; reverse order, so n2 > n1
	bgtr	10$			; yes
	movl	#c_false,-(r11)		; no, leave with false
	rsb				; return
10$:
	movl	#c_true,-(r11)		; yes, leave with true
	rsb				; end of <


;+++
;k> <# -- ( -- ) start numeric output conversion.
;---
	header	i_less_sharp,^\<#\
	addl3	r9,#c_pad_moat,v_hld	; pad hld !
	rsb				; end of <#


;+++t
;k> <= -- ( n1 n2 -- f ) true if n1 <= n2, false otherwise.
;---
	header	i_less_equal,^\<=\
	cmpl	(r11)+,(r11)+		; reverse order, so n2 >= n1
	bgeq	10$			; yes
	movl	#c_false,-(r11)		; no, leave with false
	rsb				; return
10$:
	movl	#c_true,-(r11)		; yes, leave with true
	rsb				; end of <


;+++t
;k> = -- ( n1 n2 -- f ) true if n1 = n2, false otherwise
;---
	header	i_equal,<=>
	cmpl	(r11)+,(r11)+		; n2 = n1?
	beql	10$			; yes
	movl	#c_false,-(r11)		; no, leave with false
	rsb				; return
10$:
	movl	#c_true,-(r11)		; yes, leave with true
	rsb				; end of =


;+++
;K> =text -- ( a1 a2 n -- f ) compare strings of length `n' at `a1' and `a2',
;	return true if they are equal, false otherwise.
;---
	header	i_equal_text,<=text>
	cmpc3	(r11),@4(r11),@8(r11)	; Are they equal>
	bneq	10$			; no
	addl2	#12,r11			; pop arguments
	movl	#c_true,-(r11)		; yes, leave true
	rsb				; return
10$:
	addl2	#12,r11			; pop arguments
	movl	#c_false,-(r11)		; no, they aren't equal, leave false.
	rsb				; end of =text


;+++t
;k> > -- ( n1 n2 -- f ) true if n1 > n2, false otherwise.
;---
	header	i_greter,^\>\
	cmpl	(r11)+,(r11)+		; reverse order, so n2 < n1
	blss	10$			; yes
	movl	#c_false,-(r11)		; no, leave with false
	rsb				; return
10$:
	movl	#c_true,-(r11)		; yes, leave with true
	rsb				; end of >


;+++t
;k> >= -- ( n1 n2 -- f ) true if n1 >= n2; false otherwise.
;---
	header	i_greater_equal,^\>=\
	cmpl	(r11)+,(r11)+		; reverse order, so n2 <= n1
	bleq	10$			; yes
	movl	#c_false,-(r11)		; no, leave with false
	rsb				; return
10$:
	movl	#c_true,-(r11)		; yes, leave with false
	rsb				; end of >=


;+++
;k> ? -- ( a -- ) Output contents of `a' as a long in current radix.
;---
; Remark on the internal name of this word: { header q_,<?> } is aesthetically
; displeasing, so make it i_question by analogoy with i_dot for { . }.
	header	i_question,<?>
	movl	@(r11),(r11)		; get contents of `a'.
	jsb	i_dot			; print contents
	rsb				; end of ?


;+++
;k> ?cr -- ( -- ) start a new line unless already at beginning of line.
;---
	header	q_cr,<?cr>
	tstw	v_outlen		; At beginning of line?
	beql	10$			; yes, exit
	jsb	cr			; no, start new line
10$:
	rsb				; end of ?cr


;+++
;k> ?dup -- ( f -- f ? f ) Duplicate top of stack only if it is true (non-zero).
;	Used so don't always have to drop 0 in else.
;---
	header	q_dup,<?dup>
	tstl	(r11)			; is it zero?
	beql	10$			; yes, don't duplicate it.
	movl	(r11),-(r11)		; no, duplicate it.
10$:
	rsb				; end of ?dup


;+++
;k> ?n-cr -- ( n -- ) starts new line on terminal if < n chars left on line.
;---
	header	q_n_cr,<?n-cr>
	movzwl	v_outlen,r0		; get current length of line.
	subl3	r0,#c_screen_len,r0	; get current length of line
	cmpl	(r11)+,r0		; enough characers left?
	blss	10$			; yes, go to return
; no, not enough characters left on line.
	jsb	cr			; start a new line
10$:
	rsb				; end of ?n-cr


;+++t
;k> ?number -- ( -- n ? f ) Convert token at eodp to a number, and if compiling
;	enclose it as a literal in the current word.  If executing, push on
;	the  stack.  If not a number, leave false on stack.  If a number leave
;	a true on stack.
;---
	header	q_number,<?number>
	jsb	number			; try to make it a number
	tstl	(r11)			; is it a number?
	beql	10$			; no, exit leaving false on the stack
	addl2	#4,r11			; yes.	pop flag
	tstb	v_mode			; are we compiling?
	beql	20$			; no, leaving it on stack
	jsb	literal			; yes, include in dictionary as
					; a literal
20$:
	movl	#c_true,-(r11)		; leave with true on stack
10$:
	rsb				; end of ?number


;+++t
;k> ?search -- ( -- a ? f )  search context vocabulary for most recent token,
;	return false if not found, or ( addr true ) if found.  If compiling,
;	search compiler vocab if not found in context and set { state }
;	true.  Compare byte-counted string at eodp to find.
;---
	header	q_search,<?search>
;??? this next perhaps should have been
;	movl	@v_context,(r11)
;	tstb	v_mode
;	beql	5$
;	movl	@(r11),(r11)
;5$:
; which would (during compilation of new words)
; start the search at the word before the one currently being compiled;
; this would allow use of older definition of word `x' in new definition
; of word `x'.	However, as it stands it allows easy recursion.
;??? changed to eliminate recusion by default, as that is probably more
; useful, since RECURSE is a simple way to get recusion.
;??? The problem with this is that if you switch vocabularies while defining
; a word, the new vocab (which you want to search from the first) also is
; searched from the second word.  Perhaps I should set the smudge bit (gasp!
; Horrors!).
; get pointer to pointer to start of vocab
	movl @v_context,-(r11)		; get address of current word
;??? took out to test smudge bit
;	tstb  v_mode			; Are we compiling?
;	beql  5$			; no, go on.
; yes, so skip address of word we are defining, so we can use
; previous definitions of this word.
;	movl	@(r11),(r11)		; get address of previous word
5$:
	jsb	search			; search it
	tstl	(r11)			; Was it found?
	bneq	10$			; yes, exit with ( addr true ) on dstack
	tstb	v_mode			; no. Are we compiling?
	beql	10$			; no, exit leaving false on dstack
	movl	v_compiler,(r11)	; yes, get adddress of compiler vocab
	jsb	search			; search it
	tstl	(r11)			; Was it found?
	beql	10$			; no, exit with false on dstack
	movb	#c_true,v_state		; yes, set v_state flag
					; exit with ( addr true ) on dstack
10$:
	rsb				; end of ?search
;??? Should the compiler vocabulary be searched *before* the context vocabulary
; when we are compiling?  This would allow defining new versions in compiler
; of words in context that would be more efficient during compilation (or
; have a different effect, or allow immediate and noimmediate words that
; should do the same thing, like { % }).



;+++t
;k> @ -- (fetch) ( a -- l ) Fetches contents of longword at `a'.
;---
	header	i_fetch,<@>
	movl	@(r11),(r11)		; get contents of address at top-of-ds
	rsb				; end of @


;+++
;k> abort -- ( -- ) clear data stack and restart VTIL.
;---
	header	abort
	brw	r_warm_start		; end of abort


;+++
;k> abs -- ( n1 -- n2 ) Takes the absolute value of top of stack.
;---
	header	abs
	tstl	(r11)			; is top of stack < 0?
	bgeq	10$			; no, go on
	mnegl	(r11),(r11)		; yes, negate it
10$:
	rsb				; end of abs


;+++t
;k> ac: -- ( b -- ) assembler constant (makes opcode & operand defintions).
;	ac: creates a word that compiles the byte on the top of the stack at
;	definition into the dictionary.
;---
	header	i_ac_colon,<ac:>
	jsb	create			; enclose name in dictionary
	movb	#op_movb,(r9)+		; `movb'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#2,(r9)+		; (pc+2)
	movb	#adm_ainc_r9,(r9)+	; (r9)+
	movb	#op_rsb,(r9)+		; `rsb'
	movb	(r11),(r9)+		; enclose byte value in dictionary
	addl	#4,r11			; pop argument
; Make it an compiletime word so it will compile the machine language into the
; dictionary when defining a new word and will not be found otherwise.
	jsb	compiletime
	rsb				; end of ac:


;+++t
;k> and -- ( f1 f2 -- f ) logical and f1 and f2
;---
	header	and
	tstl	(r11)+			; is first false?
	beql	10$			; yes
	tstl	(r11)+			; no, is second false?
	beql	20$			; yes
	movl	#c_true,-(r11)		; no, both true, leave with true
	rsb				; return
10$:
	addl2	#4,(r11)		; pop second item off, don't need
					; to check
20$:
	movl	#c_false,-(r11)		; leave with false
	rsb				; end of and


;+++
;k> array -- ( n -- ) create word that pushes addres of `n' bytes
;	which are saved in the dictionary.
;---
	header	array
	jsb	create			; enclose next token in dictinary
	movb	#op_movab,(r9)+		; `moval'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#2,(r9)+		; (pc+2)
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_rsb,(r9)+		; `rsb'
	addl2	(r11)+,r9		; save `n' bytes in dictionary
	rsb				; end of array


;+++
;k> ascii -- ( -- n ) put ascii value of first character of next token on stack.
;	Note that this cannot be used in colon definitions!  (See { [ascii] }.)
;---
	header	ascii
	movl	#c_blank,-(r11)		; set up for blank separated token
	jsb	token			; get it
	movzbl	1(r9),-(r11)		; put ascii value of token on stack
	rsb				; end of ascii


;+++
;k> b! -- ( b a -- ) store 8 bits of `b' at address `a'.
;---
	header	i_b_store,<b!>
	movb	4(r11),@(r11)		; store byte at what's pointed to by
					; top of stack
	addl2	#8,r11			; pop arguments
	rsb				; end of b!


;+++
;k> b, -- ( b -- ) store low byte of top stack entry into dictionary.
;---
	header	i_b_comma,<b,>
	movb	(r11),(r9)+		; store in dictinary
	addl2	#4,r11			; pop argument
	rsb				; end of b,


;+++
;k> b@ -- ( a -- b ) Fetch byte from address `a'.
;---
	header	i_b_fetch,<b@>
	movzbl	@(r11),(r11)
	rsb				; end of b@


;+++
;k> bcount -- ( a -- a n ) Given the address of a byte-counted
;	string, leave address of first character in string and the
;	count of the string on the stack.
;---
	header	bcount
	movzbl	@(r11),r0		; get length of string
	incl	(r11)			; move over byte-count
	movl	r0,-(r11)		; put count on stack
	rsb				; end of bcount


;+++
;k> binary -- ( -- ) Set the base to binary
;---
	header	binary
	movl	#2,v_radix		; switch to base 2
	rsb				; end of binary


;+++
;k> (bl) -- ( -- c ) Pushes ascii value of a blank on the stack.
;---
	header	i_bl,<(bl)>
	movl	#c_blank,-(r11)		; put on stack
	rsb				; end of (bl)


;+++
;k> blank --- ( a w -- ) fill `w' bytes from `a' with blanks.
;---
	header	blank
	movc5	#0,(r9),-		; srclen,src  use (r9) to be safe
		#c_blank,-		; fill with blanks
		(r11),@4(r11)		; destlen, dest
	addl2	#8,r11			; pop arguments
	rsb				; end of blank


;+++
;k> block -- ( l -- a ) Get block `l' into buffer at address `a'.
;---
	header	block
; Is the block already in memory?
	clrl   r0			; start with buffer 0
10$:
	cmpl	(r11),-			; does this buffer contain the
		v_buf_blk_nums[r0]	;   block we are looking for?
	beql	100$			; yes, go on
	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
;
; not in memory, so we have to get it in
;
; Are there any unused buffers?
	clrl	r0			; start with buffer 0
20$:
	tstb	v_buf_inuse[r0]		; is it in use?
	beql	90$			; no, read block into it
	aoblss	#c_max_blocks,r0,20$	; move to next buffer, if any
; Are there any unmodified buffers?
	clrl	r0
30$:
	cmpb	#c_modified,-		; Has this buffer
		v_buf_inuse[r0]		;   been modified?
	bneq	90$			; no, read block into it
	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
; all buffers are modified, so we must write out out and use it.
	clrl	r0			; for now, always use the zero'th one
	movl	r0,-(r10)		; save buffer number
	movl	r0,-(r11)		; set up for buffer-write
	jsb	i_buffer_write		; write the buffer
	movl	(r10)+,r0		; get the buffer number back
; read block into buffer
90$:
	movl	(r11),-			; Save the new block number in
		v_buf_blk_nums[r0]	;   buffer
	movb	#c_inuse,-		; flag that buffer is in use
		v_buf_inuse[r0]
	movl	r0,(r11)		; set up for buffer-read
	jsb	i_buffer_read		; read block into buffer
	rsb				; return
;
; block already in memory
;
100$:
; Comes here if block already in memory, with buffers in r0, block# on stack
	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
	addl2	#v_blkbuff,(r11)	; calcualte addressof `r0'th buffer
	movl	r0,v_current_buff	; mark this as most current block
	rsb				; end of block



;+++
;k> block-close -- ( -- ) Close the block file
;---
	header	i_block_close,<block-close>
	tstb	v_blockio		; is the block file open?
	beql	100$			; no, return
	$close	fab=v_blkfab		; Yes, close block file
	blbs	r0,10$			; go on if no error
	brw	_error_exit		; exit with error message
10$:
	movb	#c_false,v_blockio	; we're not using block file
100$:
	rsb				; end of block-close


;+++
;k> block-open -- ( -- ) Open the block file.
;---
	header	i_block_open,<block-open>
	tstb	v_blockio		; Is block file open?
	bneq	100$			; Yes, don't open again
; no, open it
	$open	fab=v_blkfab		; open block file
	blbs	r0,10$			; no error, go on
	brw	_error_exit		; quit on error
10$:
	$connect rab=v_blkrab		; connect to block file
	blbs	 r0,20$			; no error, go on
	brw	 _error_exit		; quit on error
20$:
	movb	#c_true,v_blockio	; yes, we are using the block file
100$:
	rsb				; end of block-open


;+++
;k> block-read -- ( l a -- ) Read block `l' from buffer at address `a'.
;---
	header	i_block_read,<block-read>
	movl	(r11)+,-		; get address of buffer
		v_blkrab+rab$l_ubf	;   into  rab
	movl	(r11)+,-		; get VTIL block (rms record) number
		v_blkkey		;   into rab's key
	$get	rab=v_blkrab		; read the block
	blbs	r0,100$			; no errors, go on
	brw	_error_exit		; exit and signal error
100$:
	rsb				; end of block-read


;+++
;k> block-write -- ( l a -- ) Write block `l' from buffer at address `a'.
;---
	header	i_block_write,<block-write>
	movl	(r11)+,-		; get buffer address
		v_blkrab+rab$l_rbf	;   into rab
	movl	(r11)+,-		; get VTIL block (rms record) number
		v_blkkey		;   into key buffer
	movw	#c_block_size,-		; get proper VTIL block (rms record)
		v_blkrab+rab$w_rsz	;   size into fab
	$find	rab=v_blkrab		; find the correct block
	$update	rab=v_blkrab		; write the block
	blbs	r0,100$			; no errors, go on
	brw	_error_exit		; exit and signal error
100$:
	rsb				; end of block-write


;+++
;k> break -- ( -- ) Breakpoint!	 For use in debugging kernel and compiler.
;	This word should only be executed when running in the VAX/VMS Debugger.~~~ Usually you do something in the debugger then "GO _INTERPRETER" to resume execution.
;---
	header	break
	bpt				; breakpoint
	rsb				; end of break


;+++
;k> bs@ -- ( a -- l ) Fetch byte at `a' and sign extend it to longword on stack.
;---
	header	i_bs_fetch,<bs@>
	cvtbl	@(r11),(r11)		; sign extend it
	rsb				; end of bs@


;+++
;k> buffer -- ( l -- a ) Get buffer at `a' that will be written to block `l'.
;---
	header	buffer
; Is the block already in memory?
	clrl   r0			; start with buffer 0
10$:
	cmpl	(r11),-			; does this buffer contain the
		v_buf_blk_nums[r0]	;   block we are looking for?
	beql	100$			; yes, go on
	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
;
; not in memory, so we have to get it in
;
; Are there unused buffers?
	clrl	r0			; start with buffer 0
20$:
	tstb	v_buf_inuse[r0]		; Is it in use?
	beql	90$			; no, read block into it
	aoblss	#c_max_blocks,r0,20$	; move to the next buffer, if any
; Are there any unmodified buffers?
	clrl	r0
30$:
	cmpb	#c_modified,-		; Has this buffer
		v_buf_inuse[r0]		;   been modified?
	bneq	90$			; no, read block into it
	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
; all buffers are modified, so we must write one out and use it.
	clrl	r0			; for now, always use zero'th one
	movl	r0,-(r10)		; save buffer number
	movl	r0,-(r11)		; set up for buffer-write
	jsb	i_buffer_write		; write the buffer
	movl	(r10)+,r0		; get the buffer number back
;
; come here with bloc## on stack and buffer# in r0.
;
90$:
; save block info
	movl	(r11),-			; Save the new block number in
		v_buf_blk_nums[r0]	;   buffer
	movb	#c_inuse,-		; Flag that buffer is in use
		v_buf_inuse[r0]

100$:
; leave address of buffer on stack
	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
	addl2	#v_blkbuff,(r11)	; calculate address of `r0'th buffer
	movl	r0,v_current_buff	; mark this as most current block
	rsb				; end of buffer


;+++
;k> buffer-read -- ( n -- a ) read into a block into buffer `n'.  The block
;	number is already in the buffer.  Leave `a', the address of the
;	block buffer.  This word assumes that buffer is correctly set up
;	(block number, etc).
;---
	header	i_buffer_read,<buffer-read>
	movl	(r11)+,r0		; get buffer number
	movl	r0,v_current_buff	; save buffer number as most current
	mull3	r0,#c_block_size,r1	; offset to `r0'th buffer
	addl3	r1,#v_blkbuff,-(r11)	; put address of buffer on stack
					; this is left after exit
	movl	v_buf_blk_nums[r0],-	; number of block
		-(r11)			;   to read
	movl	4(r11),-(r11)		; get another copy of the buffer address
	jsb	i_block_read		; read the block
	rsb				; end of buffer-read


;+++
;k> buffer-write -- ( n -- ) write block in buffer number n to file.
;	Note that the block number is in the buffer already.
;---
	header	i_buffer_write,<buffer-write>
	movl	(r11)+,r0		; get buffer number
	movl	v_buf_blk_nums[r0],-	; number of block
		-(r11)			;   to write
	mull3	r0,#c_block_size,r1	; offset into the buffer buffer
	addl3	r1,#v_blkbuff,-(r11)	; address of buffer to write
					; this is left after exit
	jsb	i_block_write		; write the block
	rsb				; end of buffer-write


;+++
;k> byte -- ( n -- ) Creates word that pushes address of byte on stack and initializes the byte to `n'.
;---
	header	byte,<byte>
	jsb	create			; enclose next token in dictionary
	movb	#op_movab,(r9)+		; `movab'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#2,(r9)+		; (pc+2)
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_rsb,(r9)+		; `rsb'
	movb	(r11),(r9)+		; move top of stack into dictionary
	addl2	#4,r11			; pop argument
	rsb				; end of byte


;+++t
;k> cfa -- ( a -- a ) given the address of the header of a word, return the address of
;	the code for that word (i.e., the Code Field Address).
;---
;??? the smudge bit makes this one a little harder.
	header	cfa
	addl2	#4,(r11)		; skip over link field
	movzbl	@(r11),r0		; get unsigned length of name
	bicb2	#^b10000000,r0		; clear smudge bit of length of name
	incl	(r11)			; skip over count byte
	addl2	r0,(r11)		; skip over name field
	rsb				; end of cfa


;+++
;k> clist -- ( -- ) list compiler vocabulary.
;---
	header	clist
	movl	v_compiler,-(r11)	; get address of most recent word
					;   in compiler vocabulary
10$:
	tstl	(r11)			; nil pointer?
	beql	100$			; yes, exit loop
	addl3	(r11),#4,-(r11)		; get address of name field
	jsb	bcount			; set up for write
	movl	(r11),-(r11)		; set up for ?cr
	jsb	q_n_cr			; start new line if word is too long
	jsb	write			; tell user
	movl	#c_blank,-(r1)		; blank to separate words
	jsb	putc			; output it
	movl	@(r11),(r11)		; get previous word's lfa
	brb	10$			; try it again
100$:
	addl2	#4,r11			; pop pointer off stack
	rsb				; end of clist


;+++t
;k> compile-jsb ( a -- ) compile a jump to subroutine to location `a'.
;---
;??? At the moment this uses absolute mode.  Should it use displacment
; off a register so that it can be ?relocatable (like stoic)?  Or should it
; use a brw (which I'm not sure would work in { defer< ... >defer }.
	header	   i_compile_jsb,<compile-jsb>
	movb	   #op_jsb,(r9)+	; `jsb'
	movb	   #adm_absolute,(r9)+	; absolute mode
	movl	   (r11)+,(r9)+		; save place to jump to in dictionary
	rsb				; end of compile-jsb


;+++
;k> compiletime -- ( -- ) move word defined to the compiler vocabulary.
;	This word unlinks the last word in the current vocabulary and
;	links it to the compiler vocabulary.  Compiiler words are *never*
;	executed during execute mode.
;---
	header	compiletime
	movl	@v_current,r0		; save pointer to word we a unlinking
	movl	(r0),@v_current		; make current previous word in vocab
	movl	v_compiler,(r0)		; link word to prev in compiler vocab
	movl	r0,v_compiler		; make v_compiler point to new word
	rsb				; end of compiletime
;??? Should I also have immediate words, that execute in *both* compile
; mode and execute mode?  This would require some sort of attribute flag,
; which would have to be checked during compilation.  It would allow
; considerably more flexibility (remember how % started out a word and ended
; up part of _interpreter because it was either compiletime or runtime?).
;??? Much beter idea.  Have a compile buffer like STOIC and have only
; compiletime and runtime words, both of which are in the same vocabulary.
; If not inside a { : ... ; }, do a jsb at the end of the line? if in colon
; definition, copy it to the dictionary and update dictionary links.
; Have to think about this.


;+++
;k> context -- ( -- a ) Leaves address of the vocabulary pointer of the
;	vocabulary in which we currently search for words (the `context').
;---
	header	context
	moval	v_context,-(r11)	; move address of pointer to vocab
					; that is searched when defining
					; to stack
	rsb				; end of context


;+++
;k> count -- ( a1 -- a2 n ) Given word-counted string at `a' returns
;	address of characters in string and string's length on top of stack.
;---
	header	count
	movzwl	@(r11),r0		; get length of string
	addl2	#2,(r11)		; move pointer to first character
	movl	r0,-(r11)		; put count on top of stack
	rsb				; end of count


;+++
;k> cr -- ( -- )  Start new output line (C_arriage R_eturn).
;---
	header	cr
	movab	v_outbuf,-(r11)		; move address of output buffer on stack
	movzwl	v_outlen,-(r11)		; put count on stack
	movw	v_static_dsc,2(r11)	; put middle of descriptor on ~~~ Is this correct?
	pushl	r11			; push address of output descriptor
	calls	#1,g^lib$put_output	; output it~~~ Really should check the return value!!!
	addl2	#8,r11			; pop descriptor off stack
	clrw	v_outlen		; clear output length
	rsb				; end of cr


;+++t
;k> create -- ( -- ) Enclose next token in input stream in the dictionary,
;	truncating it if it is too long.
;---
	header	create
	movl	@v_current,(r9)		; make link field
	movl	r9,@v_current		; make vocab point to here, newest word
	addl2	#4,r9			; move eodp over link field
	movl	#c_blank,-(r11)		; set up to get blank separated token
	jsb	token			; get token
	cmpl	#c_max_name_len,(r9)	; is the name over the maximum length?
	bneq	10$			; no, go on
	movab	v_nametoolong,-(r11)	; address of error message on stack
	jsb	bcount			; get ( addr count )
	jsb	write			; write out message
	addl3	#1,r9,-(r11)		; address of name
	movab	(r9),-(r11)		; count of name
	jsb	write			; write out untruncated name
	jsb	cr			; start new line
	movl	#c_max_name_len,(r9)	; truncate name
	movab	v_nametrunc,-(r11)	; get address of stack
	jsb	bcount			; get ( addr count )
	jsb	write			; write out message
	addl3	#1,r9,-(r11)		; address of name
	movzbl	(r9),-(r11)		; count of name
	jsb	write			; write out truncated name
10$:
	movzbl	(r9)+,r0		; get byte length and move over it
	addl2	r0,r9			; move over string
	movb	#op_rsb,(r9)		; stick a `rsb' in just in case
	rsb				; end of create


;+++
;k> current -- ( -- a ) Leaves address of the vocabulary pointer of the
;	vocabulary we link new words into.
;---
	header	current
	moval	v_current,-(r11)	; move address (of pointer to vocab
					; that new words are linked to when
					; defining) to stack
	rsb				; end of current


;+++
;k> decimal -- ( -- ) Set base to decimal.
;---
	header	decimal
	movl	#10,v_radix		; switch to base 10
	rsb				; end of decimal


;+++
;k> definitions -- ( -- )  Sets curren to context. { <name> definitions }
;	makes all new words link into vocabulary { <name> }
;	(i.e., new operators will be linked dictionary currently being searched).
;---
	header	definitions
	movl	v_context, v_current
	rsb				; end of definitions


;+++
;k> drop -- ( n -- ) Drop the top stack item.
;---
	header	drop
	addl2	#4,r11			; pop argument, dropping top item
	rsb				; end of drop


;+++
;k> ds>ls -- ( n -- ) move `n' to loop stack.
;---
	header	i_ds_to_ls,^/ds>ls/
	movl	(r11)+,-(r10)		; pop from dstack, move to lstack.
	rsb				; end of ds>ls


;+++
;k> dup -- ( n -- n n ) Duplicated the top stack entry.
;---
	header	dup
	movl	(r11),-(r11)
	rsb				; end of dup


;+++
;k> empty-buffers -- ( -- ) Mark all buffers unmodified without writing.
;---
	header	i_empty_buffers,<empty-buffers>
	clrl	r0			; buffer number
10$:
	movb	#c_false,-		; mark with c_false to show
		v_buf_inuse[r0]		;   emptied, not in use
	movl	#c_false,-		; mark with c_false to show
		v_buf_blk_nums[r0]	;  holds no block number
	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
		#1,r0,10$		; move to next buffer number, if any
	rsb				; end of empty buffers


;
;??? Note: the `eodp' words are supplied so that the user can work with the
;	dictionary without having to know if eodp is a register or a variable.
;


;+++
;k> eodp -- ( -- a ) Return address of next free byte in dictionary.
;	Means "end of dictinary pointer".
;---
	header	eodp
	movl	r9,-(r11)		; get
	rsb				; end of eodp


;+++
;k> eodp! -- ( a -- ) Make `a' new value of end of dictionary  pointer.
;---
	header	i_eod_store,<eodp!>
	movl	(r11)+,r9		; make eodp = top of stack
	rsb				; end of edop!


;+++
;k> eodp+! -- ( n -- ) Add `n' to end of dictionary pointer.
;---
	header	i_eodp_plus_store,<eodp+!>
	addl2	(r11)+,r9		; add top of stack to eodp
	rsb				; end of eodp+!


;+++
;k> eve -- call up eve editor.	Format: { eve filename }.
;---
	header	eve
	movl	#c_blank,-(r11)		; set up for blank delimited token
	jsb	token			; get the token
	movzbl	(r9),r6			; save length
	addl3	#1,r9,r7		; start of string
	movc3	r6,(r7),v_tpu_com2	; move string into buffer
	addw3	#c_tpu_com_len,r6,-	; put length in descriptor
		v_tpu_dsc
	pushaq	v_tpu_dsc		; push address of command
	calls	#1,g^tpu$tpu		; call tpu
	blbc	r0,10$			; ?error
	rsb				; no, exit
10$:					; yes, signal and patch
	pushl	r0			; set up for signal
	calls	#1,g^lib$signal		; signal it
	brw	r_warm_start		; patch VTIL to run
					; end of eve


;+++
;k> exit -- ( -- ) Exit VTIL.  Never returns.
;---
	header	i_exit,<exit>
	brw	_exit			; exit silently


;+++
;k> fill -- ( a w c -- l ) Fill `w' bytes from `a' with character `c'.
;---
	header	fill
	movc5	#0,(r9),-		; srclen,src (use eodp just to be safe)
		(r11),-			; fill character
		4(r11),@8(r11)		; destlen, dest
	addl2	#12,r11			; pop arguments
	rsb				; end of fill


;+++
;k> flush-buffers -- ( -- ) write all modified buffers and mark them unmodified.
;---
	header	i_flush_buffers,<flush-buffers>
	clrl	r0			; bufffer number
10$:
	cmpb	#c_modified,-		; Has the buffer
		v_buf_inuse[r0]		;   been modified?
	bneq	20$			; no, skip it
	movl	r0,-(r10)		; save the buffer name
	movl	r0,-(r11)		; set up for buffer-write
	jsb	i_buffer_write		; write the buffer
	movl	(r10)+,r0		; get the buffer number back
	movb	#c_false,-		; mark the buffer as
		v_buf_inuse[r0]		;   flushed, not in use
20$:
	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
		#1,r0,10$		; move to next buffer number, if any
	rsb				; end of flush-buffers


;+++
;k> forget -- ( -- ) reset content vocab back to word before word forgotten.
;	Note that while this makes the forgotten word and any words
;	defined after it unavailale, it does not reclaim an space,
;	since the other vocabularies can be threaded through in the
;	dictionary between words of this vocabulary.
;---
;??? Should I make { forget } = { forget/erase }?  Why did I make both
; in the first place?
	header	forget
	movl	#c_blank,-(r11)		; set up for blank delimited token
	jsb	token			; get token
	movl	@v_context,-(r11)	; start search at context
	jsb	search			; search it
	tstl	(r11)+			; Was it found?
	beql	100$			; No, tell user
; make vocab point to word before the forgotten one.
	movl	@(r11),@v_context	;
	addl2	#4,r11			; pop address of found word
	rsb				; exit
100$:
	movab	v_wordnotfound,-(r11)	; put address of error message on stack
	jsb	bcount			; get address of text and length
	jsb	write			; write error message
	movl	r9,-(r11)		; address of token not found in search
	jsb	bcount			; get address of text and length
	jsb	write			; write the name of the word
	brw	r_warm_start		; end of forget


;+++
;k> forget/erase -- ( -- ) rset context vocab to word before word forgotten
;	and move the dictinary back to header address of word forgotten.
;	In other words, dictinary is truncated BEFORE the word forgotten. ~~~Add warning
;---
	header	i_forget_erase,<forget/erase>
	movl	#c_blank,-(r11)		; set up for blank delimited token
	jsb	token			; get token
	movl	@v_context,-(r11)	; start search at contxt
	jsb	search			; search it
	tstl	(r11)+			; Was it found?
	beql	100$			; No, tell user
; make vocab point to word before the forgotten one.
	movl	@(r11),@v_context
	movl	(r11),r9		; truncate dictionary
	addl2	#4,(r11)		; pop address of found word
	rsb				; return
100$:
	movab	v_wordnotfound,-(r11)	;
	jsb	bcount			; get address of text and length
	jsb	write			; write error message
	movl	r9,-(r11)		; address of token not found in search
	jsb	bcount			; get addres of text and length
	jsb	write			; write the name of the word ~~ not found
	brw	r_warm_start		; end of forget/erase


;+++
;k> freemem -- ( -- l ) print amount of memory left in dictionary
;--- ~~~ does it really leave a longword on the stack?
	header	freemem
	subl3	r9,#c_dict_end,-(r11)	; put free space on stack
	jsb	i_dot			; print it
	rsb				; end of freemem


;+++
;k> halt -- ( l -- ) halt VTIL, use `l' as returned value.  Never returns. ~~~ Change "returned value" to "exit status?
;---
	header	i_halt,<halt>
	movl	(r11)+,r0		; put error number in right place
	brw	_error_exit		; go to error exit routine
					; end of halt


;+++
;k> hex -- ( -- ) Set the base to hexidecimal.
;---
	header	hex
	movl	#16,v_radix		; switch to base 16 (hexadecimal)
	rsb				; end of hex


;+++
;k> hld -- ( -- a ) Variable hld, return address of hld.
;---
	header	hld
	moval	v_hld,-(r11)		; leave address on stack
	rsb				; end of hld


;+++
;k> hold -- ( c -- ) Insert `c' in current numeric output string.
;---
	header	hold
	decl	v_hld			; move pointer down one char
	movb	(r11),@v_hld		; fill new char w/top of stack
	addl2	#4,r11			; pop char off stack
	rsb				; end of hold


;+++
;k> i> -- ( -- ) Copy the top of the loop stack to the data stack.
;	This word is used inside of { do ... loop }'s to get the index
;	of the innermost loop onto the top of the stack.
;---
	header	i_i_to,^\i>\
	movl	(r10),-(r11)		; copy w/o consuming ~~~ from loop stack.
	rsb				; end of i>


;+++
;k> kernel -- ( -- ) Set context to kernel vocabulary.
;---
	header	kernel
	moval	v_kernel,v_context
	rsb				; end of kernel


;+++
;k> leave -- ( -- ) Leave a { do } loop at end of this iteration.
;---
	header	leave
	movl	(r10),4(r10)		; make limit = index so loop will exit
	rsb				; end of leave


;+++
;k> load -- ( -- ) Take input from file instead of the terminal.
;	Format: { load filename }
;---
	header	load
	movl	#c_blank,-(r11)		; set up for blank terminated file name
	jsb	token			; get v_fname
	movzbl	(r9),r6			; get count of v_fname
	movc3	r6,1(r9),v_fname	; move to name buffer
	movb	r6,v_fnamelen		; save length
	moval	v_fname,-
		v_infab+fab$l_fna	; tell it where filespec is
	movb	v_fnamelen,-
		v_infab+fab$b_fns	; tell it what size filespec is
	$open	fab=v_infab		; open input file
	blbc	r0,10$			; Quit on error
	$connect rab=v_inrab		; connect to input
	blbc	r0,20$			; Quit on error
	brb	40$			; branch to read loop
10$:
	cmpl	r0,#rms$_fnf		; is it file not found?
	bneq	15$			; no
	pushaq	v_filenotfound		;
	calls	#1,g^lib$put_output	; Tell user file not found
	rsb				; return
15$:
	moval	v_infab,r6		; error: keep fab address
	brw	_f_err			; signal file error
20$:
	moval	v_inrab,r6		; keep rab address
	brw	_r_err			; signal record error
40$:
	movb	#c_true,v_infile	; set input from file flag
	movl	#0,v_filelinenum	; reinitialize number of lines read
	rsb				; end of load


;+++t
;k> long -- ( n -- ) Create a word that pushed address of longword on stack,
;	save space in dictionary, and initialize to `n'.
;---
	header	i_long,<long>
	jsb	create			; enclose next token in dictionary
	movb	#op_moval,(r9)+		; `moval'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#2,(r9)+		; (pc+2)
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_rsb,(r9)+		; `rsb'
	movl	(r11)+,(r9)+		; move top of stack into dictionary
	rsb				; end of long


;+++t
;k> longconst -- ( n -- ) Create a word that pushed a `n' to the stack.
;---
	header	longconst
	jsb	create			; enclose next token in dictionary
	jsb	literal			; enclose code in dictionary
	movb	#op_rsb,(r9)+		; stick `rsb' into dictionary to
					;   end constant word
	rsb				; end of longconst


;+++
;k> ls>ds -- ( -- n ) Remove `n' from loop stack.
;---
	header	i_ls_to_ds,^/ls>ds/
	movl	(r10)+,-(r11)		; pop from loop stack, move to dstack
	rsb				; end of ls>ds


;+++
;k> match -- ( a1 n1 a2 n2 -- a3 ? f ) Search for string of length `n2' at
;	`a2' in string of length `n' at `a'.
;---
	header	i_match,<match>
	matchc	(r11),@4(r11),-		; object string (one we're looking for)
		8(r11),@12(r11)		; source string (one we're looking in)
	bneq	100$			; no match found
; match found, calcualte its address.  matchc leaves in r3 the address of the
; byte after last byte matched in the source string, so address of matched
; string is r3 - objectlen.
	subl3  (r1),r3,r0		; calculate address of matched string
	addl2  #16,r11			; pop arguments
	movl   r0,-(r11)		; put address of matched string on stack
	movl   #c_true,-(r11)		; leave true on top of stack
	rsb				; return
100$:
; no match found
	addl2	#16,r11			; pop arguments
	movl	#c_false,-(r11)		; leave a false ~~~ on top of stack
	rsb				; end of match


;+++
;k> max -- ( n1 n2 -- n2 ) Leave larger of n1 and n2 on stack.
;---
	header	max
	cmpl	(r11),4(r11)		; compare top two stack items
	bleq	10$			; Top less than under item?
; no, top greater
	movl	(r11),4(r11)		; move greater down stack
10$:
	addl2	#4,r11			; pop first argument, since
					;   great is in second item now
	rsb				; end of max


;+++
;k> message -- ( a -- ) writes word-counted string at `a' to terminal.
;---
	header	message
	jsb	count			; set up for write
	jsb	write			; write it out
	rsb				; end of message


;+++
;k> min -- ( n1 n2 -- n2 ) Leaves small or n1 and n2 on stack.
;---
	header	min
	cmpl	(r11),4(r11)		; compare top two stack items
	bgeq	10$			; Top is greater than under item
	movl	(r11),4(r11)		;
10$:
	addl2	#4,r11			; pop top stack item since lesser is
					;   in second line.
	rsb				; end of min


;+++
;k> mod -- ( n1 n2 -- n3 ) Leave remainder of n1 / n2 on stack.
;---
	header	mod
	divl3	(r11),4(r11),r0		; r0 = n1 / n2
	mull3	r0,(r11)+,r1		; temp = n2 * n3
	subl2	r1,(r11)		; n3 = n1 - quotient
	rsb				; end of mod


;+++
;k> move -- ( a1 a2 w -- ) Copies `w' bytes from `a1' to `a2'.
;---
	header	move
	movc3	(r11),@8(r11),@4(r11)	;
	addl2	#12,r11			; pop arguments
	rsb				; end of move


;+++
;k> move&fill -- ( a1 w1 a2 w2 c -- ) copies bytes from `a1' to `a2'.
;	If `w2' > `wl', fill with c.  If `w2' < `w1', truncate.
;---
	header	i_move_fill,<move&fill>
	movc5	12(r11),@16(r11),-	; sourcelen, source
		(r11),-			; fill character
		4(r11),@8(r11)		; destlen, destination
	addl2	#20,r11			; pop arguments
	rsb				; end of move/fill


;+++
;k> negate -- ( n -- -n )  Leave two's complement of top stack item on stack.
;---
	header	negage
	mnegl	(r11),(r11)		; negate it
	rsb				; end of negate


;+++
;k> not -- ( f1 -- f2 ) Logical not of top  of stack; not f1.
;---
	header	not
	tstl	(r11)+			; Is it false?
	beql	10$			; yes
	movl	#c_false,-(r11)		; no, leave with false on stack
	rsb				; return
10$:
	movl	#c_true,-(r11)		; it is false, leave with true on stack
	rsb				; end of not


;+++t
;k> number -- ( -- n ? f ) Try to turn token at eodp into a number.  If
;	it is a number, leave ( number true ) on stack.  If it is not a number
;	leave ( false ) on stack.
;---
	header	number
	clrl	r0			; clear result
	clrl	r1			; clear sign
	movl	r9, r6			; get pointer to token
	movzbl	(r6)+,r7		; get byte count
	cmpb	#^a/-/,(r6)		; does it have a leading minus sign?
	bneq	_number_top		; no, go on
	movl	#1,r1			; yes, set flag
	incl	r6			; advance over sign
	decl	r7			; length = length - 1
_number_top:
	movzbl	(r6),r2			; get byte
	subl2	#^x30,r2			; check in range 0...9
	tstl	r2			; Is it negative?
	blss	_invalid_number		; yes, leave with false
	cmpl	r2,#9			; r2 <= 9
	bleq	_check_base		; yes, continue
	cmpl	r2,#^x11		; Is it A or greater?
	blss	_invalid_number		; no, leave with false
	cmpl	r2,#^x2a		; is it Z or less
	bgtr	_check_lowercase	; no, go check if lower case
	subl2	#7,r2			; convert to ^xA...^xZ
	brb	_check_base		; now check if it is valid in current
					; base
_check_lowercase:
	cmpl	r2,#^x31		; Is it a or greater?
	blss	_invalid_number		; no, leave with false
	cmpl	r2,#^x4a		; Is it z or less?
	bgtr	_invalid_number		; no, leave with false.
	subl2	#^x27,r2		; convert to ^xA...^xZ
_check_base:
	cmpl	r2,v_radix		; is it in set 0... base-1?
	bgeq	_invalid_number		; no, leave w/false
	mull2	v_radix,r0		; result = result * base
	addl2	r2,r0			; result = result + num
	decl	r7			; count = count - 1
	incl	r6			; move to next byte in number
	tstl	r7			; count = 0?
	bgtr	_number_top		; no, do it again
	tstl	r1			; negative?
	beql	20$			; no
	mnegl	r0,r0			; yes, negate it.
20$:
	movl	r0,-(r11)		; put result on stack
	movl	#c_true,-(r11)		; put true on stack
	rsb				; exit with ( number true ) on dstack
_invalid_number:
	movl	#c_false,-(r11)		; exit with ( false ) on dstack
	rsb				; end of number


;+++
;,> octal -- ( -- ) Set the base to octal.
;---
	header	octal
	movl	#8,v_radix		; Switch to base 8
	rsb				; end of octal


;+++t
;k> or -- ( f1 f2 -- f ) Logical or, f1 or f2.
;---
	header	or
	tstl	(r11)+			; is first true?
	bneq	10$			; Yes
	tstl	(r11)+			; Is seconed true?
	bneq	20$			; Yes
	movl	#c_false,-(r11)		; Both false, leave with false on stack
	rsb				; return
10$:
	addl2	#4,r11			; pop second item off, don't need
					;   to check
20$:
	movl	#c_true,-(r11)		; Yes, one or both true.  Leave with
					;   true on stack.
	rsb				; end of or


;+++
;k> over -- ( n1 n2 -- n1 n2 n1 ) Leave a copy of the second item on the stack.
;+++
	header	over			; push copy of n1 on top of stack
	movl	4(r11),-(r11)
	rsb				; end of over


;+++
;k> pad -- ( -- a ) Leave address of (edop + c_pad_moat) on stack.
;	This is a good area to use for temporary storage of such things
;	as strings.
;---
	header	pad
	addl3	r9,#c_pad_moat,-(r11)	;
	rsb				; end of pad


;+++
;k> putc -- ( c -- ) Output character `c'.
;---
	header	putc
	cmpw	v_outlen,#c_max_len	; is output buffer full?
	blss	10$			; no, go on
	jsb	cr			; yes output it
10$:
	movab	v_outbuf,r0		; pointer to start of buffer
	movzwl	v_outlen,r1		; index into buffer
	addl2	r1,r0			; pointer to next available char
	movb	(r11),(r0)		; move char into buffer
	addl2	#4,r11			; pop char off stack
	incw	v_outlen		; increment index (or length)
	rsb				; end of putc


;+++
;k> radix ( -- a ) leave address of system radix longword on stack.
;---
	header	radix
	moval	v_radix,-(r11)		; leave address on dstack
	rsb				; end of radix


;+++
;k> read ( a -- ) return a byte-counted string from terminal at `a'
;---
	header	read
	movl	(r11),v_readaddr	; v_readaddr = address to write to
	incl	v_readaddr		; allow for byte count before string
	pushaw	v_readlen		; where to put returned length
; Is there any outstanding output?
	tstw   v_outlen			;
	bneq   10$			; yes~~~, branch to output prompt
	pushl  #0			; omit prompt since no output
	brb    20$			; skip over prompting
10$:					; yes, construct a descriptor on stack
	movab	v_outbuf,-(r11)		; put address of buffer on stack
	movzwl	v_outlen,-(r11)		; move count on stack
	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
	pushl	r11			; put address of descriptor on rstack
	addl2	#8,r11			; move stack ptr back over descriptor
20$:
	pushaq	v_readdsc		; push address of descriptor
	calls	#3,g^lib$get_input	; get a line from terminal
	isstrerr
30$:
	clrw	v_outlen		; clean output length, since any
					;   outstanding was just output
	cvtwb	v_readlen,@(r11)	; save byte-count at address on stack
	addl2	#4,r11			; pop address off stack
	rsb				; end of read


;+++t
;k> readstr ( a n -- ) Read line from terminal into word-counted string.
;	`a' is address of word-counted string.
;	'n' is maximum length.
;---
	header	readstr
	pushl	4(r11)			; where to put returned length
	addl2	#2,4(r11)		; move pointer over length word
	movw	v_static_dsc,2(r11)	; move middle of descriptor on dstack
	tstw	v_outlen		; Is there any outstanding output?
	bneq	10$			; yes
	pushl	#0			; omit prompt since no output
	brb	20$			; skip over prompting
10$:					; yes, construct a descriptor on stack
	movab	v_outbuf,-(r11)		; put address of buffer on stack
	movzwl	v_outlen,-(r11)		; move count on stack
	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
	clrw	v_outlen		; clear output length, since any
					;   outstanding will be saved.
	pushl	r11			; put addrss of descriptor on rstack
	addl2	#8,r11			; move stack ptr back over descriptor
20$:
	pushl	r11			; push address of descriptor
	calls	#3,g^lib$get_input	; get a line from terminal
	isstrerr
	addl2	#8,r11			; pop arguments
	rsb				; end of readstr


;+++
;k> restart -- ( -- ) Restart VTIL, patching it to run again.
;	Used in cases of error.  Never RETURNs.
;---
	header	restart
	brw	r_warm_start		; patch it
					; end of restart


;+++
;k> s! -- ( n a -- ) Store a short integer (first 16 bits of `n' at `a'.~~~ `n' should be a `s'.
;---
	header	i_word_store,<s!>
	movw	4(r11),@(r11)		; store the first 16 bits
	addl2	#8,r11			; pop arguments
	rsb				; end of s!


;+++
;k> s, -- ( s -- ) Store low word of `s' in dictinary.
;---
	header	i_w_comma,<s,>
	movw	(r11),(r9)+		; store short in dictinary
	addl2	#8,r11			; pop arguments
	rsb				; end of s,


;+++
;k> s@ -- ( a -- n ) Fetch 16 bits from `a' and zero-extend to longword.
;---
	header	i_word_fetch,<s@>
	movzwl	@(r11),(r11)		; get contents
	rsb				; end of s@


;+++
;k> ss@ -- ( a -- n ) Fetch short at `a' and sign extend it to longword.
;---
	header	i_ws_fetch,<ss@>
	cvtwl	@(r11),(r11)		; get contents, sign extend it
	rsb				; end of ss@


;+++
;k> save-buffers -- ( -- ) Write all modified buffers and mark them unmodified.
;---
	header	i_save_buffers,<save-buffers>
	clrl	r0			; buffer number
10$:
	cmpb	#c_modified,-		; Has the buffer
		v_buf_inuse(r0)		;   been modified? ~~~ Why not [r0]?
	bneq	20$			; no, skip it
	movl	r0,-(r10)		; save the buffer number
	movl	r0,-(r11)		; set up for buffer-write
	jsb	i_buffer_write		; write the buffer
	movl	(r10)+,r0		; get the buffer number back
	movb	#c_inuse,-		; mark the buffer as
		v_buf_inuse(r0)		;   in use, but not modified.
20$:
	acbl	#c_max_blocks-1,-	; buffer # is in [0 .. c_max_blocks-1]
		#1,r0,10$		; move to next buffer number, if any
	rsb				; end of save-buffers


;+++t
;k> search -- ( a1 -- a2 ? f )  Search vocabulary at `a1' for a match with
;	byte-counted string at eodp.  Return  ( false ) if not found, or
;	( addr true ) if found.
;---
	header	search
	tstl	(r11)			; Is it nil pointer on top of stack?
	beql	10$			; yes, stop search, leave false on stack
	addl3	#4,(r11),r6		; r6 = Address of byte-count
	cmpb	(r6),(r9)		; no, ?equal length
	bneq	20$			; no
	cvtbw	(r9),r6			; yes, get string length
	addl3	#5,(r11),r7		; get address of word name
	addl3	#1,r9,r8		; get address of token
	cmpc3	r6,(r7),(r8)		; compare strings
	bneq	20$			; strings don't match
; string match
	movl	#c_true,-(r11)		; move true to top of stack
	brb	10$			; exit leaving ( addr true ) on dstack.
20$:
	movl	@(r11),(r11)		; get address of next word
	brb	search			; try it again
10$:
	rsb				; end of search


;+++
;k> short -- ( n -- ) Create a word that pushed the address of two bytes
;	(a VAX memory `word') on the stack, reserves space in the dictionary
;	for those two bytes, and initializes it to the value of `n'.
;---
	header	i_short,<short>
	jsb	create			; enclose next token in dictionary
	movb	#op_movaw,(r9)+		; `movaw'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#2,(r9)+		; (pc+2)
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_rsb,(r9)+		; `rsb'
	movw	(r11),(r9)+		; move top of stack into dictionary
	addl2	#4,r11			; pop aruments
	rsb				; end of short


;+++
;k> sign -- ( n -- ) Output minus in pictured numeric if top of stack is < 0.
;---
	header	sign
	tstl	(r11)+			; tos < 0?
	bgeq	10$			; no, exit
	movl	#^a\-\,-(r11)		; put ascii for minus sign on stack
	jsb	hold			; put it in output string
10$:
	rsb				; end of sign


;+++
;k> smudge -- ( -- ) Sets the smudge (high) bit in the length byte as the word
;	that is currently being defined won't be found in itself.
;---
	header	smudge
	movl	@v_current,r0		; address of word being defined
	addl2	#4,r0			; move over link field
	bisb2	#^b10000000,(r0)	; set smudge bit in length of name
	rsb				; end of smudge


;+++
;k> sp@ -- ( -- l ) Returns the address of the top fo the data stack before
;	{ sp@ } is executed.
;---
	header	i_sp_fetch,<sp@>
	movl	r11,-(r11)		; put address of top of stack on stack
	rsb				; end of sp@


;+++
;k> sp0 -- ( -- l ) Returns the address of the bottom of the data stack.
;	Note that the stack grows downward, so this is actually the
;	top in memory of the data-stack structure's space.
;___
	header	i_sp_0,<sp0>
	moval	c_ds_start,-(r11)	; put address on stack
	rsb				; end of sp0


;+++
;k> space -- ( -- ) Output a space to terminal.
;---
	header	space
	cmpw	v_outlen,#c_max_len	; Is output buffer full?
	blss	10$			; no, go on
	jsb	cr			; yes, output it
10$:
	movab	v_outbuf,r0		; pointer to start of buffer
	movzwl	v_outlen,r1		; index into buffer
	addl2	r1,40			; pointer to next available buffer
	movb	#c_blank,(r0)		; move char into buffer
	incw	v_outlen		; increment index (or length)
	rsb				; end of space


;+++
;,> spaces -- ( n -- ) Output `n' spaces to terminal
;---
	header	spaces
	tstl	(r11)			; Is it less than or equal to zero?
	bleq	100$			; yes, exit
	movl	#1,-(r11)		; no, save space on stack for index
10$:
	jsb	space			; output one space
	aoblss	4(r11),(r11),10$	; (r11) += 1, repeat if (r11) < 4(r11)
	addl2	#4,r11			; pop index
100$:
	addl2	#4,r11			; pop argument
	rsb				; end of spaces


;+++t
;k> sread ( -- ) Read a line from terminal or file into input stream,
;	depending on value of { infile }.  if { infile } is true, read
;	from file; otherwise, read from terminal.
;---
	header	sread
	tstw	v_outlen		; Is there any outstanding output?
	beql	5$			; no
	jsb	cr			; yes, output it
5$:
	moval	v_inbuf,v_inptr		; start at beginning of line
	tstb	v_infile		; getting input from file?
	bneq	10$			; yes, go do it
; no, get from terminal
	pushaw	v_inlen			; save returned length
	pushaq	v_vtilprompt		; use vtil prompt
	pushaq	v_in_dsc		; address of input descriptor
	calls	#3,g^lib$get_input	; get a line from terminal
	blbs	r0,8$			; no error, go on
	cmpl	#rms$_eof,r0		; Is it eof from terminal?
	bneq	7$			; no, go die messily
	brw	_exit			; yes, exit silently
7$:
	brw	_error_exit		; die messily
8$:
	movw	v_inlen,v_org_inlen	; save original length
	rsb				; success read from terminal, return
10$:
	$get	rab=v_inrab		; get a record
	blbs	r0,20$			; write the record
	cmpl	r0,#rms$_eof		; was error end-of-file
	beql	30$			; successful completion
; error otherwize
	moval	v_inrab,r6		; keep rab address
	brw	_r_err			; signal record error
20$:
	movw	v_inrab+rab$w_rsz,-	; input rab set record size
		v_inlen
	movw	v_inrab+rab$w_rsz,-
		v_org_inlen
	incl	v_filelinenum		; increment line number in file
	rsb				; success read from file, return
30$:
	$close	fab=v_infab		; close input
	movb	#c_false,v_infile	; set v_infile flag false
	movl	#0,v_filelinenum	; zero file line as well
	rsb				; end of sread


;+++
;k> strcat -- ( a1 a2 -- ) Catenate string at `a`' to string at `a2'.
;	Works only with strings defined by { string } or { string" }
;	since it uses maxlen of string at `a2'.
;---
	header	strcat
	movzwl	@4(r11),r0		; length of src
	movzwl	@(r11),r7		; length of dest
	addl3	#2,4(r11),r3		; address of src characters
	movl	(r11),r2		; address of dest
	subl3	#2,r2,r4		; address of maxlen of dest
	addl3	#2,r2,r2		; address of dest char
	movzwl	(r4),r5			; maxlen of dest
	subl3	r7,r5,r6		; space available in dest
	cmpl	r6,r0			; less space available than to copy
	bleq	10$			; yes, use space available in dest as len
	movl	r0,r6			; no, move all characters in src
10$:
	addl2	r7,r2			; start at end of dest chars
	movc3	r6,(r3),(r2)		; copy the string
	addw2	r6,@(r11)		; store the new length
	addl2	#8,r11			; pop arguments
	rsb				; end of strcat


;+++
;k> strcmp -- ( a1 a2 -- n ) Compare word-counted strings.
;	Return 0 if string at `a`' = string at `a2'.
;	Return >0 if string at `a`' > string at `a2'.
;	Return <0 if string at `a1' < string at `a2'.
;---
	header	strcmp
	movzwl	@4(r11),r0		; length of str1
	addl3	#2,4(r11),r1		; address of chars in str1
	movzwl	@(r11),r2		; length of str2
	addl3	#2,(r11),r3		; address of chars in str2
	addl2	#8,r11			; pop top two stack items
	cmpc5	r0,(r1),#0,r2,(r3)	; compare chars with 0 fill
	beql	10$			; str1 = str2
	bgtr	20$			; str1 > str2
	movl	#-1,-(r11)		; str1 < str2
	rsb				; exit
10$:
	movl	#0,-(r11)		; str1 = str2
	rsb				; exit
20$:
	movl	#1,-(r11)		; str1 > str2
	rsb				; end of strcmp


;+++
;k> strcpy -- ( a1 a2 -- ) copy word counted string at `a1' to w-string at `a2'.
;	Both must be word-counted, and string at `a2' must have maxlen 2bytes
;	(i.e., defined by { string } or { string" }).
;---
	header	strcpy
	movl	(r11),r0		; get address of destination
	movl	4(r11),r1		; get address of source
	movzwl	(r1),r6			; length of source
	subl3	#2,r0,r2		; address of destination max len
	movzwl	(r2),r2			; dest max len
	cmpl	r2,r6			; max len < source len?
	bgeq	10$			; no
	movl	r2,r6			; yes, use max len for src len
10$:
	movc3	r6,2(r11),2(r0)		; move the strings
	movw	r6,@(r11)		; save the new length of dest
	addl2	#8,r11			; pop arguments
	rsb				; end of strcpy


;+++
;k> string -- ( n -- ) Create a string variable with maximum length of `n'.
;	The first 2 bytes of the string contains its length.
;	The 2 bytes previous to the string contains its maximum length.
;---
	header	string,<string>
	jsb	create			; make the header
	movb	#op_movaw,(r9)+		; `movaw'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#4,(r9)+		; (pc+4)
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_rsb,(r9)+		; rsb
	movw	(r11),(r9)+		; maximum length
	movw	#0,(r9)+		; make high byte of current count
	addl2	(r11)+,r9		; save space for characters
	rsb				; end of string


;+++
;k> string" -- ( n -- ) Create a string variable with maximum length of `n',
;	and initialize with string from input stream up until next `"'.
;	The first 2 bytes of the string contain its length.
;	The 2 bytes previous to the string contains its maximum length.
;---
	header	i_string_quote,<string">
	jsb	create			; make the header
	movb	#op_movaw,(r9)+		; `movaw'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#4,(r9)+		; (pc+4)
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_rsb,(r9)+		; `rsb'
	movw	(r11),(r9)+		; maximum length
	movl	r9,-(r10)		; save address of current length on lstack
	movb	#0,(r9)+		; make high byte of current count
					;   zero since token returns a b-counted
					;   string
	movl	#^a\"\,-(r11)		; set up for quote terminated token
	jsb	token			; get the token
	movzbl	(r9)+,r0		; get count and move over to first char
	cmpw	(r11),r0		; is max length < token length
	bgeq	10$			; no
	movl	(r11),r0		; yes, only allow maxlen chars from
					;   token
10$:
	movw	r0,@(r10)		; save current length
	addl2	#4,r10			; pop temp storage from loop stack.
	addl2	(r11)+,r9		; save space for characters
	rsb				; end of string"


;+++
;k> strmax -- ( -- ) Return maximum length of string at `a'.
;---
	header	strmax
	subl2	#2,(r11)		; get address of max len
	movzwl	@(r11),(r11)		; get maximum length
	rsb				; end of strmax


;+++
;k> strpos -- ( a1 n1 a2 n2 -- a3 n3 ? f ) Find pos and len of substring in str.
;	Searches string whose text is at `a2' and length is `n2' for substring
;	whose text is at `a`' and whose length is `n1'.  Returns true on top of
;	stack if found and under that { a3 n3 }, address and length of located
;	substring.  Otherwise returns false.
;---
	header	strpos
	matchc	8(r11),-		; length of object string (to find)
		@12(r11),-		; address of object string
		(r11),-			; length of source string (to search in)
		@4(r11)			; address of source string
	bneq	10$			; match not found
	movl	8(r11),r0		; save length of object string
	subl3	r0,r3,r1		; calculate start addr of found string
	addl2	#16,r11			; pop arguments
	movl	r1,-(r11)		; put address of found string on stack
	movl	r0,-(r11)		; put length of found string on stack
	movl	#c_true,-(r11)		; put true on stack
	rsb				; rturn
10$:
	addl2	#16,r11			; pop arguments
	movl	#c_false,-(r11)
	rsb				; end of strpos


;+++
;k> swap -- ( n1 n2 -- n2 n1 ) exchange the top two items on the stack.
;---
	header	swap
	movl	(r11),r0		; temp = n2
	movl	4(r11),(r11)		; n2 = n1
	movl	r0,4(r11)		; n1 = saved n2
	rsb				; end of swap


;+++
;k> tochar -- convert top fo stack from 0..9, A..Z to '0'..'9','A'..'Z'
;	( n -- c ) where n is a number and c is a char.
;	If not in rnage leave alow.
;---
	header	tochar
; with 10 numbers and 26 letters, largest base is 36.
; didgits go from 0 to 35.
	tstl	(r11)			; n < 0?
	blss	100$			; yes, exit
	cmpl	(r11),#35		; n > 35
	bgtr	100$			; yes, exit
	cmpl	(r11),#9		; n > 9 (not a `number') ~~~base 10 digit
	bgtr	10$			; yes, make it 'A' .. 'Z'
	addl2	#48,(r11)		; no, make it a '1' .. '9'
	brb	100$			; exit
10$:
	addl2	#55,(r11)		; make it 'A' .. 'Z'
100$:
	rsb				; end of tochar.


;+++t
;k> token -- ( c -- ) Get next token from input stream and put it in dictionary.
;	Note that this dos NOT increment the dictionary pointer!
;---
	header	token
	cmpb	#c_blank,(r11)		; ?c = ' '~~~, an ascii blank
	bneq	_gettoken		; if anything but space, don't skip
_skipwhitespace:
	skpc	(r11),v_inlen,@v_inptr	; skip whitespace
	bneq	_startfound		; if something other than whitespace
					; found
	jsb     sread                   ; get a new line, only whitespace found
	brb	_skipwhitespace		; do it over
_startfound:
	movl	r1,v_inptr		; where non-whitespcae found
	movw	r0,v_inlen		; bytes remaining in string
_gettoken:
	clrl	r6
	clrl	r7
	locc	(r11),v_inlen,@v_inptr	; locate character
	subw3	r0,v_inlen,r6		; (v_inlen = r0) = number of chars
					;   to copy
	movw    r0,v_inlen              ; these are only bytes left (including one
					; located~~~close paren?
	movl	r1,r7			; save address of found char
	cvtwb	r6,(r9)			; store byte length
	addl3	#1,r9,r8		; where to put in dictinary
	movc3	r6,@v_inptr,(r8)	; move string to dictinary
	movl	r7,v_inptr		; v_inptr points into string
	tstw	v_inlen			; Are any more char?  (including
					;   located one)
	beql	10$			; no, exit
	subw2	#1,v_inlen		; yes, move over terminator
					;   (located char)
	addl2	#1,v_inptr
10$:
	addl2	#4,r11			; pop terminator off stack
	rsb				; end of token


;+++t
;k> unlink -- ( -- ) Unlink the most current word from the current vocab.  Used
;	when a definition is aborted by an unknown token.
;---
	header	unlink
	movl	@v_current,r8		; reclaim directory space
	movl	(r9),@v_current		; get pointer to last word in current
					; vocab from link field of word
					; we just deleted
	rsb				; end of unlink


;+++
;k> unsmudge -- clear the smudge (high) bit in the word being defined, so
;	that it can be found again.
;---
	header	unsmudge
	movl	@v_current,r0		; address of word being defined
	addl2	#4,r0			; move over link field
	bicb2	#^b10000000,(r0)	; clear smudge bit of length of name
	rsb				; end of unsmudge


;+++
;k> update -- ( -- ) Mark the most recent block as updated.
;---
	header	update
	movl	v_current_buff,r0	; get buffer number of current block
	movb	#c_modified,-		;
		v_buf_inuse(r0)		; mark buffer as updated
	rsb				; end of update


;+++
;k> variable -- ( -- ) Create a word that pushed its PFA on the stack.
;	Doesn't reserve any space.  Use for making initialized arrays.
;	PF = parameter field address = address of data following end
;	of code body of work.
;---
;??? This concept is fuzzy.  Work on it.
	header	  variable
	jsb	  create		; enclose next token in dictionary
	movb	  #op_movab,(r9)+	; `movb'
	movb	  #adm_b_rel,(r9)+	; byte relative
	movb	  #2,(r9)+		; (pc+2)
	movb	  #adm_adec_r11,(r9)+	; -(r11)
	movb	  #op_rsb,(r9)+		; `rsb'
	rsb				; end of variable


;+++
;k> vlist -- ( -- ) List context vocabulary
;---
	header	vlist
	movl	@v_context,r0		; get address of context vocabulary
	movl	r0,-(r11)		; get address of most recent word
10$:
	tstl	(r11)			; nil pointer?
	beql	100$			; yes, exit
	addl3	(r11),#4,-(r11)		; get address of name field
	jsb	bcount			; set up for write
	movl	(r11),-(r11)		; set up for ?cr
	jsb	q_n_cr			; start new line if word too long
	jsb	write			; tell user
	movl	#c_blank,-(r11)		; blank to separate words
	jsb	putc			; output it
	movl	@(r11),(r11)		; get previous word's LFA
	brb	10$			; try it again
100$:
	addl2	#4,r10			; pop pointer off stack
	rsb				; end of vlist


;+++
;k> vocabulary -- ( -- ) Defining word.  Creates a new vocabulary. When the word
;	defined by this is executed, context is set to the new vocabulary.
;---
	header	vocabulary
	movl	@v_context,-(r10)	; save LFA of word to link to
	jsb	create			;   make header for new vocab~~~ word
	movb	#op_moval,(r9)+		; `moval'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#6,(r9)+		; (pc+2) ~~~ isn't this (pc+6)?
	movb	adm_absolute,(r9)+	; absolute mode (address in next lword)
	moval	v_context,(r9)+		; context
	movab	#op_rsb,(r9)+		; rsb
	movl	(r10)+,(r9)+		; initialize link
	rsb				; end of vocabulary


;+++t
;k> write -- ( a w -- ) Write string of length `w' at address `a' out to  terminal.
;---
	header	write
	cmpw	v_outlen,#c_max_len	; Is output buffer full?
	blss	10$			; no, go get some
; yes, output it
	moval	v_outbuf,-(r11)		; put address on stack
	movzwl	v_outlen,-(r11)		; put length on stack
	movw	v_static_dsc,2(r11)	; put rest of descriptor in
	pushl	r11			; address of descriptor
	calls	#1,g^lib$put_output	; output it
	addl2	#8,r11			; pop top two entries (descriptor)
	clrw	v_outlen		; nothing left in buffer
10$:
	movzwl	v_outlen,r6		; get length
	subl3	r6,#c_max_len,r7	; space available in output buffer
	movab	v_outbuf,r0		; pointer into buffer
	addl2	r6,r0			; next available byte
	cmpl	(r11),r7		; chars to output <= available
	bgtr	20$			; no, do a part
	movc3	(r11),@4(r11),(r0)	; move the string into the output buffer
	addw2	(r11),v_outlen		; save the new # of chars in buffer
	addl2	#8,r11			; pop top two entries off stack
	rsb				; return
20$:					; more chars to output than buffer space
	movc3	r7,@4(r11),(r0)		; move some into buffer
	subl2	r7,(r11)		; new length to output
	addl2	r7,4(r11)		; new place to start in chars to output
	addw2	r7,v_outlen		; new # of chars in buffer
	movab	v_outbuf,-(r11)		; address of buffer on stack
	movzbl	v_outlen,-(r11)		; count on stack
	movw	v_static_dsc,2(r11)	; put middle of descriptor in
	pushl	r11			; address of descriptor
	calls	#1,g^lib$put_output	; display it
	clrw	v_outlen		; nothing in buffer now
	addl2	#8,r11			; pop descriptor off stack
	tstl	(r11)			; Are there any remaining characters?
	bgtr	10$			; yes, try it again
	addl2	#8,r11			; pop arguments
	rsb				; end of write


;+++
;k> xor -- ( f1 f2 -- f ) logical xor; f1 xor f2.
;---
	header	xor
	tstl	(r11)+			; is the first one false?
	beql	10$			; yes
	tstl	(r11)+			; no, is the second one false?
	beql	30$			; yes, leave with true
	brb	20$			; no leave with false
10$:					; first one false
	tstl	(r11)+			; Is the second one true?
	bneq	30$			; yes, leave with true
20$:					; leave with false
	movl	#c_false,-(r11)		; leave with false
	rsb				; return
30$:
	movl	#c_true,-(r11)		; leave with true
	rsb				; end of xor


;+++
;k> ] -- ( -- ) enter compile mode.  Used with { [ } in definitions.
;---
	header i_right_back,<]>
	movb   #c_true,v_mode		; enter compile mode
	rsb				; end of l


_kernel_end:
	newpage <Compiler Built-ins>
;*******************************************************************************
;
; Compiler Built-ins -- a new word is unlinked from the current vocabulary
;	and linked into the compilier vocabulary by the word { compiletime }.
;	Computer (or compiletime} words are only search for during the
;	definition of new words, which prevents them from mucking about with
;	the stacks and the dictionary when we are interpreting the user's
;	commands.
;
;*******************************************************************************
compiler_begin:


;+++
;c> (variable) - ( -- ) compiles the code body of a word that pushes the
;	address of its parameter field on the stack.  Must be the last word
;	in the word...
;---
;??? This concept is fuzzy.  Work on it.
     header	  i_variable,<(variable)>,vl_compiler
     movb	  #op_movab,(r9)+	; `movab'
     movb	  #adm_b_rel,(r9)+	; byte relative
     movb	  #2,(r9)+		; (pc+2)
     movb	  #adm_adec_r11,(r9)+	; -(r11)
     movb	  #op_rsb,(r9)+		; `rsb'
     rsb				; end of (variable)


;+++
;c> +loop -- ( n -- ) where n is an increment.  Edns { do .. +loop }.  Adds top
;	of stack to loop index and branches to { do } if ((index > 0) and
;	(index < limit)), or if ((index < 0) and (index > limit)).~~~ WTF: and should be or???
;	In other words, { +loop } with a positive argument is like Pascal's
;	{ for index := start to finish do ... } and with a negative argument
;	it is like { for index := start downto finish do }.
;---
	header	i_plus_loop,<+loop>,vl_compiler
	movb	#op_acbl,(r9)+		; `acbl'
	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
	movb	#4,(r9)+		; 4 byte displacement for previous adm
	movb	#adm_ainc_r11,(r9)+	; (r11)+
	movb	#adm_def_r10,(r9)+	; (r10)
	movl	r9,r0			; save address of branch word
	movw	#0,(r9)+		; save space for branch displacement
	subl3	r9,(r10)+,r1		; calculate displacement
	movw	r1,(r0)			; save displacement
	movw	#op_addl2,(r9)+		; `addl2'	pop index&limit from ls
	movb	#^x08,(r9)+		; s^#8
	movb	#adm_r10,(r9)+		; r10
	rsb				; end of +loop


;+++
;c> ." -- ( -- ) compile text until next `"' into dictinary to be printed when
;	the current word is executed.
;---
	header	i_dot_quote,<.">,vl_compiler
	movb	#op_movab,(r9)+		; `movab'
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#5,(r9)+		; (pc+5)	skip length byte too
	movb	#adm_adec_r11,(r9)+	; -(r11)
	movb	#op_brw,(r9)+		; `brw'
	movl	r9,-(r10)		; save address of displacement
	movw	#0,(r9)+		; save space for displacement
	movl	#^a\"\,-(r11)		; set up for `"' delimited tokens
	jsb	token			; get token
	movzbl	(r9),r0			; get length of token
	addl3	#1,r0,r1		; calc displacement (count length too)
	movw	r1,@(r10)		; fill in displacement
	addl2	#4,r10			; pop item off loop stack
	addl2	r1,r9			; save string in dictionary
	movb	#op_movl,(r9)+		; `movl'
	movb	#adm_immediate,(r9)+	; immeidate mode
	movl	r0,(r9)+		; length of string
	movb	#adm_adec_r11,(r9)+	; -(r11)
; we now have ( address count ) on stack (when new word executed)
	movb	#op_jsb,(r9)+		; `jsb'
	movb	#adm_absolute,(r9)+	; absolute mode
	moval	write,(r9)+		; address of subroutine to jsb to
	rsb				; end of ."


;+++
;c> ; (semicolon) -- ( -- ) Terminate a definition started by { : }.
;	Sets { mode } to false and adds an rsb to the definition.
;---
	header	i_semicolon,<;>,vl_compiler
	movb	#op_rsb,(r9)+		; put an rsb in to end word
	movb	#c_false,v_mode		; switch off compiler v_mode
;??? might need to unset high bit in count of name (smudge) bit
	jsb	unsmudge      	     	; clear smudge bit so word is found
	rsb				; end of ;


;+++
;c> >defer -- ( -- ) ends a section of code that is to copied to the
;	dictionary whenever this word is executed (i.e., { >defer } ends code
;	to be executed by all words defined by the word we are now compiling).
;	{ >defer } is used to define words that define words.
;---
;???  This concept is fuzzy.  Work on it.  May be fuzzy, but it works...
	header	   i_defer_end,^\>defer\,vl_compiler
	subl3	   (r10)+,r9,r0		; calculate length and displacement
	movw	   r0,@(r10)+		; store displacement
	movw	   r0,@(r10)+		; store length
; make new word advance dictionary pointer over just added code
	movb	#op_addl2,(r9)+		; `addl2'
	movb	#adm_immediate,(r9)+	; i^#
	movl	r0,(r0)+		; amount to advance
	movb	#adm_r9,(r9)+		; r9
	rsb				; end of >defer


;+++
;c> again -- ( -- ) Terminate a { repeat ... if ... again } loop.  { agin }
;	unconditionally branches back to the { repeat }.
;---
	header	again,,vl_compiler
; save values for calculating displacement in if.
	movl  (r10)+,r0			; save address to displace from if
	movl  (r10)+,r1			; save address for displacement
; construct negative branch from { again } to { repeat }
	movb	#op_brw,(r9)+		; `brw'
	movl	r9,r2			; save address for negative displacement
	movw	#0,(r9)+		; save space for displacement
	subl3	r9,(r10)+,r3		; calculate negative displacment
	movw	r3,(r2)			; save negative displacement
; construct forward branch from { if } to after { again }
	subl3	r0,r9,r4		; calculate { if }'s displacment
	movw	r4,(r1)			; save displacement
	rsb				; end of again


;+++
;c> b^ -- ( -- ) Convert next token to number and enclose low byte in dictionary.~~~ byte immediate???
;---
	header	i_b_up,<b^>,vl_compiler
	movl	#c_blank,-(r11)		; set up for blank delimeted token
	jsb	token			; get it
	jsb	number			; try to make it a number
	tstl	(r11)+			; is it a number?
	bneq	10$			; yes
	rsb				; no, for now just exit~~~??? FIXME!
10$:
	movb	(r11),(r9)+		; save byte in dictionary
	addl2	#4,r11			; pop value from dstack
	rsb				; end of b^


;+++
;c> defer< -- ( -- ) start a section of code that is to be copied to dictionary
;	whenever this word is executed (i.e., { defer< } starts code to be
;	executed by all words defined by the word we are now compiling).
;	Used in defining words that are to define words.
;---
;??? This concept is fuzzy.  Work on it.
	header	i_defer_begin,^\defer<\,vl_compiler
	movb	#op_movc3,(r9)+		; `movc3'
	movb	#adm_immediate,(r9)+	; I^x immediate mode
	movl	r9,-(r10)		; save address to put length in on
					;   the loop stack
	movw	#0,(r9)+		; save space for length
	movb	#adm_b_rel,(r9)+	; byte relative
	movb	#4,(r9)+		; (pc+4)
	movb	#adm_def_r9,(r9)+	; (r9)
	movb	#op_brw,(r9)+		; `brw'
	movl	r9,-(r10)		; save address to put branch
					;   displacement at on loop stack
	movw	#0,(r9)+		; save space for the displacement
	movl	r9,-(r10)		; save address of data start on loop
					;   stack to calculate data length
	rsb				; end of defer<


;+++
;c> do -- ( n1 n2 -- ) Program control structure; starts { do ... +loop },
;	{ do ... downloop }, and { do ... loop }.  Note that all do
;	loops execute at least once.  `n1' is the limit and `n2' is the
;	number to start the index at.
;---
	header	i_do,<do>,vl_compiler	; VAX/VMS debug thinks do is a command
	movb	#op_movl,(r9)+		; `movl'	save index
	movb	#adm_ainc_r11,(r9)+	; (r11)+
	movb	#adm_r0,(r9)+		; r0
	movb	#op_movl,(r9)+		; `movl'	put limit on lstack
	movb	#adm_ainc_r11,(r9)+	; (r11)+
	movb	#adm_adec_r10,(r9)+	; -(r10)
	movb	#op_movl,(r9)+		; `movl'	put index on lstack
	movb	#adm_r0,(r9)+		; r0
	movb	#adm_adec_r10,(r9)+	; -(r10)
	movl	r9,-(r10)		; save address to branch to
	rsb				; end of do


;+++
;c> downloop -- ( -- ) Ends a { do ... downloop }.  Adds -1 to the loop index
;	and branches to { do } if ((index < 0) and (index > limit)).~~~ inverted?
;	In other words, { downloop } is like Pascal's
;	{ for index := start downto finish do }.
;---
	header	downloop,,vl_compiler
	movb	#op_acbl,(r9)+		; `acbl'
	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
	movb	#4,(r9)+		; 4 byte displacement for previous adm
	movb	#adm_immediate,(r9)+	; immediate mode
	movl	#-1,(r9)+		; -1 is addend
	movb	#adm_def_r10,(r9)+	; (r10)
	movl	r9,r0			; save address of branch word
	movw	#0,(r9)+		; save space for branch displacement
	subl3	r9,(r10)+,r1		; calculate displacement
	movw	r1,(r0)			; save displacement
	movb	#op_addl2,(r9)+		; `addl2'	pop index&limit from lstack
	movb	#^x08,(r9)+		; s^#8
	movb	#adm_r10,(r9)+		; r10
	rsb				; end of downloop


;+++
;c> else -- ( -- ) In control structure { if ... else ... endif } { else }
;	else ends the true branch and starts the false branch.
;---
	header	else,,vl_compiler
	movb	#op_brw,(r9)+		; branch over false part
	movl	r9,r0			; save address of displacement
	movw	#0,(r9)+		; save space for displacement
	movl	r9,r1			; save address to calculate
					;   displacement from
; make branch to false part (fill in displacement in if)
	subl3	(r10)+,r9,r2		; calculate displacement
	movw	r2,@(r10)		; save displacment
	addl2	#4,r10			; pop address of displacement off lstack
	movl	r0,-(r10)		; save address of displacement
	movl	r1,-(r10)		; save address to displace from
	rsb				; end of else


;+++
;c> endif -- ( -- ) { endif } ends either of { if } or { else } branches.
;	{ if ... else ... endif } and { if ... endif } are both legal.
;---
	header	endif,,vl_compiler
	subl3	(r10)+,r9,r0		; calculate displacement
	movw	r0,@(r10)		; save displacement
	addl2	#4,r10			; pop address of displacement off lstack
	rsb				; end of endif


;+++
;c> endwhile -- ( -- ) ends a { while ... endwhile }.  Unconditionally branches
;	back to { while }.
;---
	header	endwhile,,vl_compiler
	movb	#op_brw,(r9)+		; brw back to test
	movl	r9,r0			; address to put displacement in
	movw	#0,(r9)+		; save space for displacement
	subl3	(r10)+,r9,r1		; displacement to after loop
	movw	r1,@(r10)		; fill in displacement to after loop
	addl2	#4,r10			; pop off address of displacement
	subl3	r9,(r10)+,r1		; displacement back to beginning
	movw	r1,(r0)			; save displacement
	rsb				; end of endwhile


;+++
;c> if -- ( n -- ) In { if ... else ... endif } or { if ... endif },
;	if the top of the stack is true, execute the code following
;	the { if } until an { endif } or an { else }.  At an { else } skip to
;	the code after the { endif }.  If the top of the stack
;	is false, skip to the { endif } or { else }.
;	In the { repeat ... if ... again } if the top fo the stack is true the
;	code up to the { again } is executed and then a branch back to
;	{ repeat } is done.  If the top of the stack is false, execution jumps
;	to the code after the { again }.
;---
	header	if,,vl_compiler
	movb	#op_tstl,(r9)+		; `tstl'
	movb	#adm_ainc_r11,(r9)+	; (r11)+
	movb	#op_bneq,(r9)+		; `bneq'
	movb	#^x03,(r9)+		; to (pc+3)
	movb	#op_brw,(r9)+		; `brw'
	movl	r9,-(r10)		; save address of displacement
	movw	#0,(r9)+		; save space for displacmnent
	movl	r9,-(r10)		; save address to calculate
					;   displacement from
	rsb				; end of if


;+++
;c> l^ -- ( -- ) Convert next token to number and enclose in dictionary.
;---
	header	i_l_up,<l^>,vl_compiler
	movl	#c_blank,-(r11)		; set up for blank delimited token
	jsb	token			; get it
	jsb	number			; try to make it a number
	tstl	(r11)+			; Is it a number>
	bneq	10$			; yes
	rsb				; no, for now just exit~~~ WTF, no error?
10$:
	movl	(r11)+,(r9)+		; save long in dictionary
	rsb				; end of l^


;+++
;c> literal -- ( n -- ) convert top of stack to a literal in current word.
;---
	header	literal,,vl_compiler
	movb	#op_movl,(r9)+		; `movl'
	movb	#adm_immediate,(r9)+	; immediate mode
	movl	(r11)+,(r9)+		; move top of stack into dictionary
	movb	#adm_adec_r11,(r9)+	; -(r11)
	rsb				; end of literal


;+++
;c> loop -- ( -- ) Ends a { do ... loop }.  Adds 1 to loop index and branches
;	to { do } if ((index >= 0) and (index < limit)).  In other words,
;	{ loop } is like Pascal's { for index := start to finish do ... }.
;---
	header	i_loop,<loop>,vl_compiler ; VAX/VMS debuffer thinks loop is a a command
	movb	#op_acbl,(r9)+		  ; `acbl'
	movb	#adm_b_dis_r10,(r9)+	  ; b^(r10)
	movb	#4,(r9)+		  ; 4 byte displacement for previous adm
	movb	#^x01,(r9)+		  ; s^#1
	movb	#adm_def_r10,(r9)+	  ; (r10)
	movl	r9,r0			  ; save address of branch word
	movw	#0,(r9)+		  ; save space for branch displacement
	subl3	r9,(r10)+,r1		  ; calculate displacement
	movw	r1,(r0)			  ; save displacement
	movb	#op_addl2,(r9)+		  ; `addl2'	pop index&limit from lstack
	movb	#^x08,(r9)+		  ; s^#8
	movb	#adm_r10,(r9)+		  ; r10
	rsb				  ; end of loop


;+++
;c> recurse -- ( -- ) Compile a jsb to the word that is currently being defined,
;	allowing recursion.
;---
	header	recurse,,vl_compiler
	movl	@v_context,-(r11)	; get address of current word
	jsb	cfa			; get the code field address
	jsb	i_compile_jsb		; compile it into current word
	rsb				; end of recurse


;+++
;c> repeat -- ( -- ) Start { repeat ... until } and { repeat ... if ... again }
;	loops.
;---
	header	repeat,,vl_compiler
	movl	r9,-(r10)		; save address to branch to
	rsb				; end of repeat


;+++
;c> w^ -- ( -- ) Convert next token to number, enclose low 16 bits in dictionary.
;	This is used with the assembler, mainly, which is why it is w^ instead
;	of  s^.
;---
	header	i_s_up,<w^>,vl_compiler
	movl	#c_blank,-(r11)		; set up for blank delimited token
	jsb	token			; get it
	jsb	number			; try to make it a number
	tstl	(r11)+			; Is it a number?
	bneq	10$			; yes
	rsb				; no, for now just exit~~~ WTF, no error?
10$:
	movw	(r11),(r9)+		; save word in dictionary
	addl2	#4,r11			; pop value from dstack
	rsb				; end of w^


;+++
;c> until -- ( f -- ) End a { repeat ... until } loop.  If top of stack is
;	false, branch back to the { repeat }, else fall out of loop.
;---
	header	until,,v1_compiler
	movb	#op_tstl,(r9)+		; `tstl'
	movb	#adm_ainc_r11,(r9)+	; (r11)+
	movb	#op_bneq,(r9)+		; `bneq'
	movb	#3,(r9)+		; (pc+3)
	movb	#op_brw,(r9)+		; `brw'
	movl	r9,r0			; save address of displacement
	movw	#0,(r9)+		; save space for displacement
	subl3	r9,(r10)+,r1		; calcualte negative displacement
	movw	r1,(r10)		; save negative displacement
	rsb				; end of until


;+++
;c> while -- ( f -- ) Start a { while ... endwhile } loop.  If top of stack
;	is true, execute code to { endwhile }, which loops back to { while }.
;	If false, skip to after the { endwhile }.
;---
	header	while,,vl_compiler
	movl	r9,-(r10)		; save address to branch to at endwhile
	movb	#op_tstl,(r9)+		; `tstl'
	movb	#adm_ainc_r11,(r9)+	; (r11)+
	movb	#op_bneq,(r9)+		; `bneq'
	movb	#3,(r9)+		; over brw false_part
	movb	#op_brw,(r9)+		; `brw'
	movl	r9,-(r10)		; save address of displacement to
					;   statements after loop
	movw	#0,(r9)+		; save space for displacement
	movl	r9,-(r10)		; address to make diplacement to
					;   after loop from~~~ awkward phrasing
	rsb				; end of while


;+++
;c> [ -- ( -- ) leave compile mode without terminating definition.
;	Must be followed by { ] }.
;---
	header	i_left_brack,<[>,vl_compiler
	movb	#c_false,v_mode
	rsb				; end of [


;+++
;c> [ascii] -- ( -- ) compile ascii value of 1st char of next token into word.
;---
	header	i_compile_ascii,<[ascii]>,vl_compiler
	movl	#c_blank,-(r11)		; set up for blank separated token
	jsb	token			; get it
	movzbl	1(r9),-(r11)		; put ascii value of 1st char of token on stack
	jsb	literal			; compile it into the dictionary
	rsb				; end of ascii


_compiler_end:
	newpage <Enter VTIL>
;*******************************************************************************
;
; Enter VTIL -- Set up condition handler and call main program.
;
;*******************************************************************************


;+++
;s> vtil -- entry procedure of vtil
;---
	.entry	vtil,^m<r6,r7,r8,r9,r10,r11>
    .if defined ca_trapping
        .print ; Trapping is enabled
	moval	s_trap,(fp)		; set up condition handler
    .if_false
        .print ; Trapping is not enabled
    .endc
    .if defined ca_controlc
        .print ; Control/C Trapping is enabled
; If a terminal, set up control/c trap
	$assign_s chan=v_input_chan,-	; connect to sys$command
		devnam=v_input_name
	blbs	r0,1$			; exit on error~~~Success, so branch over error exit
	brw	vtil_exit		; exit vtil
1$:
	$getchn_s chan=v_input_chan,-	; find out if it is a terminal
		prilen=v_getchn_ret_len,- ; where to put length
		pribuf=v_getchn_in_buf  ; where to find input buffer

	cmpb	#dc$_term,v_getchn_buf+4 ; is it a terminal?
	bneq	5$			; not a terminal, so don't enable ctr-c
; enable control-c trapping
	.show	   meb,me
	$qio_s	chan=v_input_chan,-
		func=#IO$_SETMODE!IO$M_CTRLCAST,-
		p1=enable_ctrlc,-
		p3=#3
	blbs	r0,6$			; no error, go on, don't deassign channel
	brw	vtil_exit
5$:
;	$dassign_s chan=v_input_chan    ; channel not a terminal, deassign it.
6$:
    .if_false
        .print ; Control/c trapping not enabled
    .endc

	calls	#0,s_cold_start		; call subroutine to start from scratch
; If we have returned from cold start there was an error caught by the
; trap subroutine and we want to a warm start.
10$:
	calls	#0,s_warm_start		; call subroutine to do warm start.
; If we have returned from warm start there was an error caught by the
; trap subroutine and we want to do another warm start.
	brb	10$

;+++
;r> vtil_exit -- exit if errors in setting up control-c ast or traps
;---
vtil_exit:
	pushl	r0
	calls	#1,g^lib$signal
	ret				; this is return from main program.


;+++
;s> enable_ctrlc -- enable controlc trapping.
;---
	.entry	enable_ctrlc,^m<>
; reenable ctrlc handler...
	$qio_s	chan=v_input_chan,-
		func=#IO$_SETMODE!IO$M_CTRLCAST,-
		p1=enable_ctrlc,-
		p3=#3
	pushl	#vtil_ctrlc
	calls	#1,g^lib$signal		; this should NOT return!
	rsb				; end of enable_ctrlc


;+++
;s> trap --  trap routine.  Don't exit VTIL unless maximum number of errors
;	has been exceeded.
;---
	.entry	s_trap,^m<>
; output some sort of error message
	movl	chf$l_sigarglst(ap),r1
	pushl	#1
	pushl	chf$l_sig_name(r1)
	$putmsg_s msgvec=(r1)
; somewhere we need to figure out how to message this as well
	incl	v_errors		; increment number of errors
	cmpl	v_errors,#c_max_errs	; the max number of errors exceeded?
	bgtr	10$			; yes, go exit
	movl	chf$l_mcharglst(ap),r0	; get address of mechanism array
	movl	chf$l_mch_depth(r0),-	; get depth, so we will unwind to
		v_trap_depth		;   the main program
	$unwind_s depadr=v_trap_depth	; unwind stack
	ret				; return to main progam
10$:
	pushl	#0			; number of fao parameters
	pushl	#vtil_maxerrors		; message number
	pushl	#2			; number of longs in message vecor,
					; not including this one.
	movl	sp,r0			; save address of buffer
	$putmsg_s msgvec=(r0)		; write message
	$exit_s				; exit
					; end of trap

	newpage <Initialization>
;*******************************************************************************
;
; Initialization
;
;*******************************************************************************

;+++
;s> cold_start -- do all initial setup
;+++
	.entry	s_cold_start,^m<>
	movl	sp,v_returnstack	; save original return stack pointer
	movl	#c_dict_begin,r9	; initialize dictionary pointer
; vl_compiler and vl_kernel are symbols that contain location of last word in
; these vocabularies, which are built-in.
	movl	#vl_compiler,v_compiler	; Initialize compiler vocabulary
	movl	#vl_kernel,v_kernel	; Initialize kernel vocabulary
; greet user
	pushaq	v_greeting
	calls	#1,g^lib$put_output	; greet user
	moval	v_kernel,v_context	; Initialize context
	moval	v_kernel,v_current	; Initialize current
	brw	_initialize		; skip patching stuff


;+++
;s> warm_start -- do a warm start.  Called from main program.  Branched to
;	internally.
;---
	.entry	s_warm_start,^m<>
; only greet user if entered from main program.  Otherwise we are recovering
; from an internal error and are only patching, not recovering from a trap.
	pushaq	v_greeting
	calls	#1,g^lib$put_output	; greet user
	moval	v_kernel,v_context	; Initialize context
	moval	v_kernel,v_current	; Initialize current
;+++
;r> warm_start -- so we can brw to it as well as call it
;---
r_warm_start:

; The following patches system variables and delivers error messages to the user
; about the cause of the boom.
	tstb	v_mode		        ; were we compiling before error?
	beql	10$			; no
	jsb	unlink			; yes, unlink unfinished word
10$:
	movb	#c_false,v_mode		; put in execute mode
	movb	#c_false,v_state	;   just in case
	movw	#0,v_inlen		; so start with new line
	movw	#0,v_org_inlen		;   just in case
	tstb	v_infile		; Are we getting from file?
	beql	20$			; no
	$close	fab=v_infab		; yes, close file
	movb	#c_false,v_infile	; set infile flag false
	movl	#0,v_filelinenum	; zero file line as well
	movab	v_infilemess,-(r11)	; put address of 'In file:' on stack
	jsb 	bcount			; convert from ascic to write format ( address count )
	jsb	write			; put in output
	moval	v_fname,-(r11)		; put address of filename on stack
	movzbl	v_fnamelen,-(r11)	; put count of filename on stack
	jsb	write			; write filename out to terminal
20$:
	jsb	q_cr			; finish off outstanding input, if any
	movl	v_returnstack,sp	; restore original return stack pointer

;
; The following is also done during a cold start.
;
_initialize:
	; Initialize stacks.
	moval	c_ds_start,r11 		; move address of data stack to ds pointer
	moval	c_ls_start,r10		; move address of loop stack to ls pointer


	newpage <Interpreter>
;*******************************************************************************
;
; Interpreter -- Take commands from the user (or a file) and execute them.
;
;*******************************************************************************
_interpreter:
	movl	#c_blank,-(r11)		; set up for space delimeted token
	jsb	token			; get the next token
; is it a comment?
	cmpb	#1,(r9)			; token only one byte long?
	bneq	10$			; no
	cmpb	#c_com1_begin,1(r9)	; is it a \
	beql	_strip_comment		; yes, strip comment
	cmpb	#c_com2_begin,1(r9)	; Is it a (
	beql	_strip_comment2		; yes, strip second type of comment
10$:
	jsb	q_search		; search for the word
	tstl	(r11)+			; was it found?
	beql	30$			; no, go see if number
	brb	_q_execute		; yes, go see if execute or compile
30$:
	jsb	q_number		; see if it is a number
	tstl	(r11)+			; was it valid?
	bneq	_interpreter		; yes, leave with number on the stack
	brw	_unknowntoken		; no, tell user bad token


_strip_comment:
	movl	#c_com1_end,-(r11)	; end of first type of comment
	jsb	token			; get the token
	brw	_interpreter		; end of strip comment


_strip_comment2:
	movl	#c_com2_end,-(r11)	; end of second type of comment
	jsb	token			; get the token
	brw	_interpreter		; end of strip comment2


_q_execute:
	jsb	cfa			; get the code field address of
					;   the word
	cmpb	v_mode,v_state		; v_mode = v_state?~~~ what does this tell us???
	bneq	10$			; no, go compile it
	movb	#c_false,v_state	; set v_state false~~~ Why???
	jsb	@(r11)+			; yes, execute it
	cmpl	r10,#c_ds_end		; stack overflow?
	blss	_overflow		; yes, go announce it
	cmpl	r11,#c_ds_start		; stack underflow?
	bgtr	_underflow		; yes, go announce it
	brw	_interpreter		; everything ok, do it again
10$:
	movb	#c_false,v_state	; set v_state false~~~ what does this tell us???
	jsb	i_compile_jsb		; compile a jump to the word whose
					;   cfa addressis at the top of stack
	brw	_interpreter		; everthing ok, do it again


_underflow:
	jsb	cr			; make sure everything is output
	pushaq	v_undermess		; push address of underflow message
	calls	#1,g^lib$put_output	; tell user
	brw	r_warm_start			; clean up VTIL


_overflow:
	jsb	cr			; make sure everything is output
	pushaq	v_overmess		; make sure everything is output
	calls	#1,g^lib$put_output	; tell user
	brw	r_warm_start			; clean up VTIL


_unknowntoken:
	movab	v_unknown,-(r11)	; push address of unknown token message
	jsb	bcount			; convert it to ( address count )
	jsb	write			; tell user
	movl	r9,-(r11)		; get address of token
	incl	(r11)			; move address over byte-count
	movzbl	(r9),-(r11)		; get byte count of string on stack
	jsb	write			; show user bad token
	movab	v_unknown2,-(r11)	; Put address of 'In line:' on stack
	jsb	bcount			; convert it to ( address count )
	jsb	write			; tell user
	tstb	v_infile		; In a file?
	beql	10$			; no
	movl	v_filelinenum,-(r11)	; yes, print line number
	jsb	i_dot			; put number in output buffer
10$:
	jsb	cr			; end line
	moval	v_inbuf,-(r11)		; get address of original line
	cvtwl	v_org_inlen,-(r11)	; length of original line
	jsb	write			; show user
	jsb	cr			; end line
	brw	r_warm_start		; go clean up VTIL


	newpage <Exit Routines>
;*******************************************************************************
;
; Exit Routines -- Routines to handle successful and unsuccessful  exits
;
;*******************************************************************************
_error_exit:				; die messily
	pushl	r0			; put error message number on stack
	calls	#1,g^lib$signal		; signal error
	ret				; return


_f_err:	pushl	fab$l_stv(r6)		; push stv and sts of fab
	pushl	fab$l_sts(r6)		; on the stack
	calls	#2,g^lib$signal		; signal error
	brb	_exit


_r_err:	pushl	rab$l_stv(r6)		; push stv and sts of rab
	pushl	rab$l_sts(r6)		; on the stack
	calls	#2,g^lib$signal		; signal error


_done:	$close	fab=v_infile		; close input


_exit:
	movl	#1,r0			; successful completion
	$exit_s	r0			; exit with status


	newpage <Dictionary Space>
;*******************************************************************************
;
; Dictionary
;
;*******************************************************************************
	.psect	vtildict
c_dict_begin:
	. = .+<16 * 1024>		; reserve space for dictinary~~~ why not a constant???
c_dict_end:


;
; Block i/o buffers -- Here because that is the safest place for them.
;
v_blkbuff:
	.blkb	c_max_blocks * c_block_size ; buffers for block i/o


;*******************************************************************************
;
; End of VTIL, and transfer address
;
;*******************************************************************************
	.end	vtil
