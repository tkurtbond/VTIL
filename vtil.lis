VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   0
Table of contents

    (1)       58        External Symbols
    (1)       77        General Notes
    (1)      137        Implementation Notes
    (1)      202        Constants
    (1)      284        Macros
    (1)      334        Data Section
    (1)      551        Kernel Built-ins
    (1)     2873        Compiler Built-ins
    (1)     3304        Enter VTIL
    (1)     3412        Initialization
    (1)     3487        Interpreter
    (1)     3584        Exit Routines
    (1)     3615        Dictionary Space
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   1
V1.01                                                                     7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000     1 ;
                                     0000     2 	.title	VTIL -- VAX Threaded Interpretive Language
                                     0000     3 	.ident	/v1.01/			; version number
                                     0000     4 ;******************************************************************************
                                     0000     5 ;
                                     0000     6 ; VTIL -- VAX Threaded Interpretive Language
                                     0000     7 ;
                                     0000     8 ;	Program:	V T I L . MAR
                                     0000     9 ;	Written By:	Thomas Kurt Bond
                                     0000    10 ;	Version:	v1.01
                                     0000    11 ;	Date:		7 February 1988
                                     0000    12 ;
                                     0000    13 ; Description:
                                     0000    14 ;     This program was written for my Senior Seminar Project at West Virginia
                                     0000    15 ; Wesleyan College in the spring of 1988.
                                     0000    16 ;
                                     0000    17 ;     This program implements a Threaded Interpretive Language (TIL) in
                                     0000    18 ; VAX Macro, using subroutine threading.  Essentially, it is an interactive
                                     0000    19 ; compiler.
                                     0000    20 ;
                                     0000    21 ; History
                                     0000    22 ; Ver	  When	   Who	What
                                     0000    23 ; 1.00	  020788   tkb	Initial version.
                                     0000    24 ; 1.01	  021288   tkb	Uses a smudge bit to prevent word being defined from
                                     0000    25 ;			being found while defining it.	({ recurse } allows
                                     0000    26 ;			recursion.)  Also limits length of names to 80 characters
                                     0000    27 ;			allowing the name-length byte to have the smudge bit
                                     0000    28 ;			in it.
                                     0000    29 ;******************************************************************************
                                     0000    30 ;!> VTIL.MAR -- VAX Threaded Interpretive Langague, an interactive compiler.
                                     0000    31 
                                     0000    32 ;
                                     0000    33 ; Set up source code formatting macros.
                                     0000    34 ;
                                     0000    35 
                                     0000    36 ;+++
                                     0000    37 ;m> newpage -- change the subtitle and move to a new page.
                                     0000    38 ;---
                                     0000    39 	.macro	newpage subtitle
                                     0000    40 	.page
                                     0000    41 	.sbttl	subtitle
                                     0000    42 	.endm
                                     0000    43 
                                     0000    44 ;******************************************************************************
                                     0000    45 ;
                                     0000    46 ; Conditional Assembly Control Symbols
                                     0000    47 ;
                                     0000    48 ;******************************************************************************
                                     0000    49 ;ca_trapping = 0		; If this is defined, code for a condition handler
                                     0000    50 			; is assembled.	 We don't always want the condition
                                     0000    51 			; handler because it also catched breakpoints in the
                                     0000    52 			; debugger.
                                     0000    53 ;ca_controlc = 0		; If this is defined, code to trap control/c and
                                     0000    54 			; return to the VTIL interpreter is assembled.
                                     0000    55 			; Note that this uses the trapping so it is useless
                                     0000    56 			; if `ca_trapping' is not defined.
                                     0000    57 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   2
V1.01                                                                     7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000    58 	newpage <External Symbols>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   3
V1.01                           External Symbols                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000    59 ;******************************************************************************
                                     0000    60 ;
                                     0000    61 ; External Symbols
                                     0000    62 ;
                                     0000    63 ;******************************************************************************
                                     0000    64 	.dsabl	global
                                     0000    65 	.extrn	dc$_term
                                     0000    66 	.extrn	dsc$k_dtype_t, dsc$k_class_s
                                     0000    67 	.extrn	io$_setmode, io$m_ctrlcast
                                     0000    68 	.extrn	lib$_inpstrtru
                                     0000    69 	.extrn	lib$get_input, lib$put_output, lib$signal
                                     0000    70 	.extrn	ots$cvt_l_ti
                                     0000    71 	.extrn	rms$_eof, rms$_fnf
                                     0000    72 	.extrn	tpu$tpu
                                     0000    73 	.extrn	vtil_ctrlc, vtil_maxerrors
                                     0000    74 	$chfdef				; condition handling facility
                                     0000    75 
                                     0000    76 
                                     0000    77 newpage <General Notes>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   4
V1.01                           General Notes                             7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000    78 ;******************************************************************************
                                     0000    79 ;
                                     0000    80 ; General Notes
                                     0000    81 ;
                                     0000    82 ;******************************************************************************
                                     0000    83 ;
                                     0000    84 ; Word -- A VTIL word is the equivalent of the procedure and/or function of
                                     0000    85 ; Pascal or other langauges.  (Context will have to determine whethere we
                                     0000    86 ; are talking about VTIL words or memory 2-byte words.)	   A word finds any
                                     0000    87 ; parameters it needs on the data stack, and leaves any result on the stack
                                     0000    88 ; also.	 VTIL words (or sequences of words) will be singled out from normal text
                                     0000    89 ; by enclosing them in { } pairs, since many of them include punctuation marks
                                     0000    90 ; that might be otherwise confusing.  Also, the string `...' inside a { }
                                     0000    91 ; pair will indicate a sequence of VTIL words omitted as irrelevent to the
                                     0000    92 ; explaination.
                                     0000    93 ;
                                     0000    94 ; Stack Comments.  A stack comment shows what a word expects to find on the
                                     0000    95 ; stack and what results it leaves on the stack after execution.
                                     0000    96 ; A stack comment looks like the following: ( n1 n2 -- n1 ).  The rightmost
                                     0000    97 ; item on each side of the `--' is the top of the stack, so the items in the
                                     0000    98 ; stack comment are in the same order as they would be if you entered them from
                                     0000    99 ; the terminal.	 The `--' separates the items that word expects to find on
                                     0000   100 ; the stack from the items that it leaves on the stack.	 Ex: After you enter
                                     0000   101 ; { 1 2 3 }, 3 is on the top of the stack.  In ( n1 n2 n3 -- x1 x2 ) n3 is
                                     0000   102 ; on top of the stack before the word executes, and x2 is on top of
                                     0000   103 ; the stack after that word executes.
                                     0000   104 ;
                                     0000   105 ; Items in stack comments:
                                     0000   106 ;	?	-- `?' is not an item on the stack itself.  Instead, it
                                     0000   107 ;		   indicates that items to the left of the `?' (further
                                     0000   108 ;		   down on the stack) may or may not be present, depending
                                     0000   109 ;		   on the value of items to the right of the `?' (which
                                     0000   110 ;		   are on top of the stack).  For instance, a stack comment
                                     0000   111 ;		   of ( a -- a ? f ) indicates that the word leaves a
                                     0000   112 ;		   flag on the top of the stack, and depending on the value
                                     0000   113 ;		   of the flag will also leave an address on the stack.
                                     0000   114 ;	a	-- address
                                     0000   115 ;	b	-- unsigned byte (integer, 1 byte)
                                     0000   116 ;	c	-- unsigned characcter (1 byte)
                                     0000   117 ;	f	-- boolean flag; 0 = false, true <> 0 (usually 1)
                                     0000   118 ;	l	-- long (integer, 4 bytes)
                                     0000   119 ;	n	-- integer (usually meaning number.  A longword)
                                     0000   120 ;	s	-- short (integer, 2 bytes)
                                     0000   121 ;
                                     0000   122 ;	Note that *all* stack items are at least a longword in width.
                                     0000   123 ;	a ( b ) stack item merely says that the programmer should consider
                                     0000   124 ;	the stack as containing a value that will fit in an unsigned
                                     0000   125 ;	byte.  Words that use data types that are smaller than a longword
                                     0000   126 ;	will only use th first part of the longword in their calculations,
                                     0000   127 ;	but will still pop the whole longword containing the smaller data
                                     0000   128 ;	type from the stack, not just the smaller data type.  In other words,
                                     0000   129 ;	the stack pointer can only be manipulated in 4 byte increments or
                                     0000   130 ;	decrements.
                                     0000   131 ;
                                     0000   132 ; Starting Vocabularies -- At the moment, there are only two starting
                                     0000   133 ; vocabularies `compiler' and `kernel', which are independent of each other.
                                     0000   134 ; All later vocabularies should be linked into one of thse.  But See v1_*.
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   5
V1.01                           General Notes                             7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000   135 ;
                                     0000   136 ;******************************************************************************
                                     0000   137 	newpage <Implementation Notes>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   6
V1.01                           Implementation Notes                      7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000   138 ;******************************************************************************
                                     0000   139 ;
                                     0000   140 ; Implementation Notes
                                     0000   141 ;
                                     0000   142 ;******************************************************************************
                                     0000   143 ;
                                     0000   144 ; r11, ds	-- data stack pointer
                                     0000   145 ; r10, ls	-- loop stack pointer
                                     0000   146 ; r9, eodp	-- end of dictionary pointer
                                     0000   147 ; r8-r4 are used for temporary storage when using character instructions.
                                     0000   148 ;
                                     0000   149 ; header format for a word
                                     0000   150 ;	long	-- back link to next word in dictionary (hfa, lfa)
                                     0000   151 ;	byte	-- count of name byes (nfa)
                                     0000   152 ;	byte(s) -- bytes of name
                                     0000   153 ;	code	-- executable code for this word (cfa)
                                     0000   154 ;	data	-- optional data for this word (pfa)
                                     0000   155 ;
                                     0000   156 ; Names
                                     0000   157 ; Since none of the VTIL kernel and compiler words contain underscores,
                                     0000   158 ; the following conventions were followed so there would be no conflict
                                     0000   159 ; between names in the MACRO-32 source and in the VTIL.	 For instance,
                                     0000   160 ; { context } is the name of a word in the kernel that pushes the address
                                     0000   161 ; of the current vocabulary variable on the stack.  However, the definition
                                     0000   162 ; of context in the MACRO source makes `context' a label wich jsb'ing to
                                     0000   163 ; executes the word, so `context' can't be used in MACRO as a label for
                                     0000   164 ; the variable as well.
                                     0000   165 ;
                                     0000   166 ;	<name>	   -- label of start of a VTIL word called <name>
                                     0000   167 ;	_<name>	   -- internal branch points
                                     0000   168 ;	adm_<name> -- addressing mode constant value
                                     0000   169 ;	c_<name>   -- constant value
                                     0000   170 ;	ca_<name>  -- conditional assembly control symbols
                                     0000   171 ;	i_<name>   -- label of start of a VTIL word whose <name> doesn't
                                     0000   172 ;		      otherwise fit this naming convention, du to the
                                     0000   173 ;		      character limitations in VAX MACRO symbols.
                                     0000   174 ;		      For eample, i_plus = { + }, i_plus_store = { +! }
                                     0000   175 ;	op_<name>  -- opcode constant value
                                     0000   176 ;	r_<name>   -- internal routine <name> that is readed by branching and
                                     0000   177 ;		      not by jumping to subroutine.
                                     0000   178 ;	s_<name>   --  internal subroutine that is reached by a call.
                                     0000   179 ;	q_<name>   -- label of start of a VTIL word with name `?<name>'.
                                     0000   180 ;	v_<name>   -- internal variable name.
                                     0000   181 ;	vl_<name>  -- internal vocabulary link symbol used by the header macro
                                     0000   182 ;		      to link built-in vocabularies together.
                                     0000   183 ;
                                     0000   184 ;	Names of words other than looping words or branching words that should
                                     0000   185 ;	occur in pairs generally have VTIL names like { name( } and
                                     0000   186 ;	{ )name } or { name< } and { >name } and internal names like
                                     0000   187 ;	i_name_begin and i_name_end.
                                     0000   188 ;
                                     0000   189 ; To make finding words easie, all the words have a header comment
                                     0000   190 ; like this:
                                     0000   191 ;	;+++
                                     0000   192 ;	;s> name -- explanation
                                     0000   193 ;	;---
                                     0000   194 ; where `s' is `c' for the compiler words, `k' for the kernel words,
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   7
V1.01                           Implementation Notes                      7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000   195 ; `m' for macros, `r' for routines, and `s' for subroutines.
                                     0000   196 ;
                                     0000   197 ; The string `;??? starts an internal note to the programmer.  These notes
                                     0000   198 ; generally comment about an alternate method of doing something or suggest
                                     0000   199 ; areas that should be improved.  ~~~ indicates a note made while typing this back in.
                                     0000   200 ;
                                     0000   201 ;******************************************************************************
                                     0000   202 	newpage <Constants>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   8
V1.01                           Constants                                 7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000   203 ;******************************************************************************
                                     0000   204 ;
                                     0000   205 ; Constants -- Symbol definitions for constant values
                                     0000   206 ;
                                     0000   207 ;******************************************************************************
                                     0000   208 ;
                                     0000   209 ; General constants
                                     0000   210 ;
                           FFFFFFFF  0000   211 c_true		= -1			; true value, actually anything
                                     0000   212 					;  but 0 is true
                           00000000  0000   213 c_false		= 0			; false value
                           00000014  0000   214 c_max_errs	= 20			; Maximum number of fatal errors allowed
                           00000050  0000   215 c_max_name_len	= 80			; Maximum length of word names
                           00000020  0000   216 c_blank		= 32			; ascii blank
                           0000005C  0000   217 c_com1_begin	= ^a/\/			; start first type of comment with `\'
                           00000000  0000   218 c_com1_end	= 0			; end w/something not in a line of text
                                     0000   219 					; so it will skip the whole line
                           00000028  0000   220 c_com2_begin	= ^a/(/			; start second type of comment with `('
                           00000029  0000   221 c_com2_end	= ^a/)/			; end with `)'
                           00000001  0000   222 c_inuse		= 1			; buffer in use flag
                           00000002  0000   223 c_modified	= 2			; bufffer updated flag
                           00000003  0000   224 c_max_blocks	= 3			; number of block i/o buffers
                           00000400  0000   225 c_block_size	= 1024			; size for block i/o buffer
                           00000004  0000   226 c_keysize	= 4			; size of key (longword record number)
                           00000002  0000   227 c_d_blks_in_blk = c_block_size / 512	; number of disk blocks in VTIL block
                           000000A0  0000   228 c_max_len	= 160			; maximum length of input line
                           00000050  0000   229 c_screen_len	= 80			; screen is 80 chars wide
                           00000109  0000   230 c_pad_moat	= 265			; distance of pad from eodp
                           00001000  0000   231 c_ds_size	= 1024 * 4		; data stack size: 1024 items of
                                     0000   232 					; 4 bytes each
                           00000800  0000   233 c_ls_size	= 512 * 4		; loop stack size: 512 items of
                                     0000   234 					; 4 bytes each
                                     0000   235 ;
                                     0000   236 ; opcodes == constants for compiling opcodes into dictionary
                                     0000   237 ;
                           000000F1  0000   238 op_acbl		= ^xf1
                           000000C0  0000   239 op_addl2	= ^xc0
                           00000012  0000   240 op_bneq		= ^x12
                           00000031  0000   241 op_brw		= ^x31
                           00000016  0000   242 op_jsb		= ^x16
                           0000009E  0000   243 op_movab	= ^x9e
                           000000DE  0000   244 op_moval	= ^xde
                           0000003E  0000   245 op_movaw	= ^x3e
                           00000090  0000   246 op_movb		= ^x90
                           00000028  0000   247 op_movc3	= ^x28
                           000000D0  0000   248 op_movl		= ^xd0
                           00000005  0000   249 op_rsb		= ^x05
                           000000D5  0000   250 op_tstl		= ^xd5
                                     0000   251 ;
                                     0000   252 ; addressing modes -- constants for compiling addressing modes into dictionary.
                                     0000   253 ;	In order by register and addressing mode.
                                     0000   254 ;
                           00000050  0000   255 adm_r0		= ^x50			; r0
                           00000059  0000   256 adm_r9		= ^x59			; r9
                           00000069  0000   257 adm_def_r9	= ^x69			; (r9)
                           00000089  0000   258 adm_ainc_r9	= ^x89			; (r9)+
                           0000005A  0000   259 adm_r10		= ^x5a			; r10
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page   9
V1.01                           Constants                                 7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                           0000006A  0000   260 adm_def_r10	= ^x6a			; (r10)
                           0000007A  0000   261 adm_adec_r10	= ^x7a			; -(r10)
                           0000008A  0000   262 adm_ainc_r10	= ^x8a			; (r10)+
                           000000AA  0000   263 adm_b_dis_r10	= ^xaa			; b^(r10)
                           0000006B  0000   264 adm_def_r11	= ^x6b			; (r11)
                           0000007B  0000   265 adm_adec_r11	= ^x7b			; -(r11)
                           0000008B  0000   266 adm_ainc_r11	= ^x8b			; (r11)+
                           0000008F  0000   267 adm_immediate	= ^x8f			; immediate mode
                           0000009F  0000   268 adm_absolute	= ^x9f			; absolute mode
                           000000AF  0000   269 adm_b_rel	= ^xaf			; byte relative
                                     0000   270 
                                     0000   271 ;
                                     0000   272 ; Assembly-time vocabulary links -- symbols used during assembly to link
                                     0000   273 ;	the starting vocabularies together.   These start out at 0 so that
                                     0000   274 ;	all vocabularies will end with a null pointer.	During assembly,
                                     0000   275 ;	each link holds the address of the link fields of the most recently
                                     0000   276 ;	defined.  When a word is defined with the `header' macro then
                                     0000   277 ;	link field of the new word is initialized to the valu of the
                                     0000   278 ;	link and the link is changed to the address of the link field of the
                                     0000   279 ;	new word.
                                     0000   280 ;
                           00000000  0000   281 vl_compiler = 0		   ; Links the compiler vocabulary together
                           00000000  0000   282 vl_kernel = 0		   ; Links the kernel vocabulary together
                                     0000   283 ;******************************************************************************
                                     0000   284 	newpage <Macros>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  10
V1.01                           Macros                                    7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000   285 ;******************************************************************************
                                     0000   286 ;
                                     0000   287 ; Macros -- Macro Definitions
                                     0000   288 ;
                                     0000   289 ;******************************************************************************
                                     0000   290 ;!+++t
                                     0000   291 ;m> header -- macro to start all words in code
                                     0000   292 ;	This macro sets up the header for the VTIL words, and inserts it
                                     0000   293 ;	into the linked vocabulary list.  Because it uses backslash delimited
                                     0000   294 ;	strings, none of the words in the starting vocabularies built in
                                     0000   295 ;	the macro source code should have backslashes in their names.
                                     0000   296 ;
                                     0000   297 ;!---
                                     0000   298 	.macro	header	macname,name=<>,branch=vl_kernel
                                     0000   299 	.long	branch		; back link to the previous word in this branch
                                     0000   300 	branch = . - 4		; where to link the next word to in this branch
                                     0000   301 	.nchr  nchr, ^\name\	; nchr = length( name )
                                     0000   302 	.if    le, nchr		; nchr <= 0
                                     0000   303 	   .ascic \macname\	; no auxillary name, use principle one
                                     0000   304 	.if_false		; else
                                     0000   305 	  .ascic \name\		; use auxillary name
                                     0000   306 	.endc			; end if
                                     0000   307 macname:			; use name of word as branch label
                                     0000   308 	.endm			; end of macro header
                                     0000   309 
                                     0000   310 
                                     0000   311 ;!+++
                                     0000   312 ;m> iserror -- simplistic error checking routine.  If error code in r0,
                                     0000   313 ;	die messily.
                                     0000   314 ;!---
                                     0000   315 	.macro	iserror badwhere=_error_exit,?goodwhere
                                     0000   316 	blbs	r0,goodwhere	; no error, go on
                                     0000   317 	brw	badwhere	; error, branch to error handler
                                     0000   318 goodwhere:
                                     0000   319 	.endm	iserror
                                     0000   320 
                                     0000   321 
                                     0000   322 ;!+++
                                     0000   323 ;m> isstrerr -- simplistic error checking routine.  If error code in r0,
                                     0000   324 ;	unless lib$_inpstrtru, die messily
                                     0000   325 ;!---
                                     0000   326 	.macro	isstrerr badwhere=_error_exit,?goodwhere
                                     0000   327 	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                                     0000   328 	beql	goodwhere		; yes, ignore and go on
                                     0000   329 	blbs	r0,goodwhere		; no error, go on
                                     0000   330 	brw	badwhere		; error, branch to error handler
                                     0000   331 goodwhere:
                                     0000   332 	.endm	isstrerr
                                     0000   333 
                                     0000   334 	newpage <Data Section>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  11
V1.01                           Data Section                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0000   335 ;******************************************************************************
                                     0000   336 ;
                                     0000   337 ; Data Section -- Contains the stacks, i/o buffers, misc buffers,
                                     0000   338 ;	and the system variables.
                                     0000   339 ;
                                     0000   340 ;******************************************************************************
                                 00000000   341 	.psect	vtildata,long,noexe
                                     0000   342 ;
                                     0000   343 ; data stack allocation
                                     0000   344 ;
                                     0000   345 c_ds_end:
                           00001000  0000   346 	.blkb	c_ds_size	; reserve c_ds_size bytes for data stack
                                     1000   347 c_ds_start:
                                     1000   348 ;
                                     1000   349 ; Loop stack allocation
                                     1000   350 ;
                                     1000   351 c_ls_end:
                           00001800  1000   352 	.blkb	c_ls_size	; reserve c_ls_size bytes for loop stack
                                     1800   353 c_ls_start:
                                     1800   354 
                                     1800   355 
                                     1800   356 ;
                                     1800   357 ; message string variables
                                     1800   358 ;	.ascid strings are used by lib$get_input and lib$put_output
                                     1800   359 ;	.ascic strings are used by { write }
                                     1800   360 ;
                                     1800   361 v_greeting:
76 20 4C 49 54 56 00001808'010E0000' 1800   362 	.ascid	/VTIL v1.01 -- Welcome to TIL-land!/	; Greet the user
63 6C 65 57 20 2D 2D 20 31 30 2E 31  180E       
6C 2D 4C 49 54 20 6F 74 20 65 6D 6F  181A       
                        21 64 6E 61  1826       
                                     182A   363 v_vtilprompt:
20 3E 4C 49 54 56 00001832'010E0000' 182A   364 	.ascid	/VTIL> /	; prompt for system input
                                     1838   365 v_usrprompt:
            20 3F 00001840'010E0000' 1838   366 	.ascid	/? /		; prompt for programmer input
                                     1842   367 v_undermess:
20 6B 63 61 74 53 0000184A'010E0000' 1842   368 	.ascid	/Stack Underflow!/
      21 77 6F 6C 66 72 65 64 6E 55  1850       
                                     185A   369 v_overmess:
20 6B 63 61 74 53 00001862'010E0000' 185A   370 	.ascid	/Stack Overflow!/
         21 77 6F 6C 66 72 65 76 4F  1868       
                                     1871   371 v_unknown:
6B 6F 74 20 6E 77 6F 6E 6B 6E 55 00' 1871   372 	.ascic	/Unknown token: { /
                  20 7B 20 3A 6E 65  187D       
                                 11  1871       
                                     1883   373 v_unknown2:
3A 65 6E 69 6C 20 6E 69 20 7D 20 00' 1883   374 	.ascic	/ } in line: /
                                 20  188F       
                                 0C  1883       
                                     1890   375 v_infilemess:
      20 3A 65 6C 69 66 20 6E 49 00' 1890   376 	.ascic	/In file: /
                                 09  1890       
                                     189A   377 v_filenotfound:
6E 20 65 6C 69 46 000018A2'010E0000' 189A   378 	.ascid	/File not found!/
         21 64 6E 75 6F 66 20 74 6F  18A8       
                                     18B1   379 v_unkn_blk_mess:
63 6F 6C 42 20 6E 77 6F 6E 6B 55 00' 18B1   380 	.ascic	/Uknown Block Number: /
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  12
V1.01                           Data Section                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

      20 3A 72 65 62 6D 75 4E 20 6B  18BD       
                                 15  18B1       
                                     18C7   381 v_wordnotfound:
6F 46 20 74 6F 4E 20 64 72 6F 57 00' 18C7   382 	.ascic	/Word Not Found: /
                     20 3A 64 6E 75  18D3       
                                 10  18C7       
                                     18D8   383 v_nametoolong:
6F 6C 20 6F 6F 74 20 65 6D 61 4E 00' 18D8   384 	.ascic	/Name too long: /
                        20 3A 67 6E  18E4       
                                 0F  18D8       
                                     18E8   385 v_nametrunc:
74 20 64 65 74 61 63 6E 75 72 54 00' 18E8   386 	.ascic	/Truncated to: /
                           20 3A 6F  18F4       
                                 0E  18E8       
                                     18F7   387 
                                     18F7   388 
                                     18F7   389 ;
                                     18F7   390 ; variables for system input
                                     18F7   391 ;
                                     18F7   392 v_inbuf:
                           00001997  18F7   393 	.blkb	c_max_len	; buffer for system input
                                     1997   394 v_org_inlen:
                               0000  1997   395 	.word	0		; original length of line
                                     1999   396 v_inlen:			; word to hold length of remaining unprocessed
                               0000  1999   397 	.word	0		; characters
                                     199B   398 v_inptr:
                           000018F7' 199B   399 	.long	v_inbuf		; pointer to current location in string
                                     199F   400 v_in_dsc:
                               00A0  199F   401 	.word	c_max_len	; maximum length for system input
                                 00' 19A1   402 	.byte	dsc$k_dtype_t	; data type text
                                 00' 19A2   403 	.byte	dsc$k_class_s	; descriptor class
                           000018F7' 19A3   404 	.long	v_inbuf		; pointer to input buffer
                                     19A7   405 
                                     19A7   406 
                                     19A7   407 ;
                                     19A7   408 ; rms buffers for loading source from a file instead of keyboard
                                     19A7   409 ;
                                     19A7   410 	.align	long			; so rms macros won't complain
                                     19A8   411 v_infab:
                                     19A8   412 	$fab
                                     19F8   413 ;		fnm=<infile>,-		; primary input file name
                                     19F8   414 ;		dnm=<vtil.vtil>		; default input file extension
                                     19F8   415 v_inrab:
                                     19F8   416 	$rab	fab=v_infab,-		; pointer to fab
                                     19F8   417 		rop=rah,-		; read-ahead option
                                     19F8   418 		ubf=v_inbuf,-		; record buffer
                                     19F8   419 		usz=c_max_len		; and size
                                     1A3C   420 v_fnamelen:
                                 00  1A3C   421 	.byte	0		; length of file name for { load }
                                     1A3D   422 v_fname:
                           00001ADD  1A3D   423 	.blkb	c_max_len	; buffer for file name for { load }
                                     1ADD   424 
                                     1ADD   425 
                                     1ADD   426 ;
                                     1ADD   427 ; rms buffers for VTIL block i/o (which is actually rms record i/o)
                                     1ADD   428 ;
                                     1ADD   429 	.align long
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  13
V1.01                           Data Section                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1AE0   430 v_blkfab:
                                     1AE0   431 	$fab	dnm=<vtilblocks.dat>,-	; default input file name
                                     1AE0   432 		fac=<get,upd>,-		; block i/o operations
                                     1AE0   433 		fnm=<vtilblocks>,-	; input file name
                                     1AE0   434 		mrs=c_block_size,-	; maximum record size
                                     1AE0   435 		rfm=<fix>		; fixed length records
                                     1B30   436 v_blkrab:
                                     1B30   437 	$rab	fab=v_blkfab,-		; pointer to fab
                                     1B30   438 		kfb=v_blkkey,-		; pointer to key
                                     1B30   439 		ksz=c_keysize,-		; size of key
                                     1B30   440 		rac=<key>,-		; random access by record number
                                     1B30   441 		ubf=v_blkbuff,-		; address of user buffer
                                     1B30   442 		usz=c_block_size	; and the record size
                                     1B74   443 v_blkkey:
                           00000000  1B74   444 	.long				; buffer for key (longword pos rec #)
                                     1B78   445 v_blockio:
                                 00  1B78   446 	.byte	c_false			; true when block file is open
                                     1B79   447 v_current_buff:				; Buffer # of most recently accessed
                           00000000  1B79   448 	.long	0			; block
                                     1B7D   449 
                                     1B7D   450 v_buf_inuse:
                           00001B80  1B7D   451 	.blkb	c_max_blocks		; flags for inuse and modified
                                     1B80   452 v_buf_blk_nums:
                           00001B8C  1B80   453 	.blkl	c_max_blocks		; block numbers in buffers
                                     1B8C   454 
                                     1B8C   455 ;
                                     1B8C   456 ; Moved the Block i/o buffers away from the rest of the block i/o stuff
                                     1B8C   457 ; to the end of the dictionary because that is safer.  They are away from
                                     1B8C   458 ; other variables that might get overwritten if someone tries to write
                                     1B8C   459 ; too long a string to the buffers, for instance.
                                     1B8C   460 ;
                                     1B8C   461 
                                     1B8C   462 
                                     1B8C   463 ;
                                     1B8C   464 ; variables for terminal input
                                     1B8C   465 ;
                                     1B8C   466 v_readlen:
                               0000  1B8C   467 	.word			; length of returned input
                                     1B8E   468 v_readdsc:
                               00A0  1B8E   469 	.word	c_max_len	; maximum length
                                 00' 1B90   470 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1B91   471 	.byte	dsc$k_class_s	; descriptor class
                                     1B92   472 v_readaddr:
                           00000000  1B92   473 	.long	0		; pointer to the input buffer
                                     1B96   474 ; v_static_dsc is the middle of a descriptor so it can be copied onto ds
                                     1B96   475 ; to make full desciptor when top fo stack is ( addr count )
                                     1B96   476 v_static_dsc:
                                 00' 1B96   477 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1B97   478 	.byte	dsc$k_class_s	; descriptor class
                                     1B98   479 v_outlen:
                               0000  1B98   480 	.word	0		; length of output
                                     1B9A   481 v_outbuf:
                           00001C3A  1B9A   482 	.blkb	c_max_len	; output bufer
                                     1C3A   483 
                                     1C3A   484 
                                     1C3A   485 ;
                                     1C3A   486 ; Variables for calling the EVE editor using its callable interface.
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  14
V1.01                           Data Section                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1C3A   487 ;
                                     1C3A   488 v_tpu_com:			; buffer for constant section of command
                        20 75 70 74  1C3A   489 	.ascii	\tpu \          ; Don't specify a specific section file, instead of \tpu/section=eve$dir:eve_edt \ ; use my version of eve
                           00000004  1C3E   490 c_tpu_com_len = . - v_tpu_com	; length of command is a constant
                                     1C3E   491 v_tpu_com2:			; buffer for user section of command
                           00001CDE  1C3E   492 	.blkb	c_max_len
                                     1CDE   493 v_tpu_dsc:
                               0000  1CDE   494 	.word	0		; descriptor for command to pass to tpu$tpu
                                 00' 1CE0   495 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1CE1   496 	.byte	dsc$k_class_s	; descriptor class
                           00001C3A' 1CE2   497 	.long	 v_tpu_com	; pointer to tpu command buffer
                                     1CE6   498 ;
                                     1CE6   499 ; Buffers for $ASSIGN, $DASSIGN, and $QIO
                                     1CE6   500 ;
                                     1CE6   501 v_input_name:
6F 63 24 73 79 73 00001CEE'010E0000' 1CE6   502 	.ascid	/sys$command/
                     64 6E 61 6D 6D  1CF4       
                                     1CF9   503 v_input_chan:
                           00001CFB  1CF9   504 	.blkw	1
                                     1CFB   505 ;
                                     1CFB   506 ; Buffers for $GETCHN_S
                                     1CFB   507 ;
                                     1CFB   508 v_getchn_ret_len:		; returned length of buffer info
                           00000000  1CFB   509 	.long	0
                                     1CFF   510 v_getchn_in_buf:		; input buffer for getchn, tells about output
                                     1CFF   511 				; buffer
                           00000008  1CFF   512 	.long	8		; length of output buffer
                                     1D03   513 v_getchn_buf_adr:
                           00001D07' 1D03   514 	.long	v_getchn_buf	; address of output buffer
                                     1D07   515 v_getchn_buf:			; output buffer
                  00000000 00000000  1D07   516 	.quad	0		; cleared to begin
                                     1D0F   517 
                                     1D0F   518 ;
                                     1D0F   519 ; System Variables
                                     1D0F   520 ;
                                     1D0F   521 v_trap_depth:		; depth to unwind stack in trap handler
                           00000001  1D0F   522 	.long	1	; unwind to establisher, i.e, main body, 1 deep
                                     1D13   523 v_ctrlc_depth:		; depth to unwind stack in control/c handler
                           00000002  1D13   524 	.long	2	; unwind to main program, 2 deep (ctrlc and a_start)
                                     1D17   525 v_errors:
                           00000000  1D17   526 	.long	0	; Number of errors caught by condition handler so far
                                     1D1B   527 v_returnstack:		; original return stack pointer.  Save it when we
                           00000000  1D1B   528 	.long	0	; abort out of jsb's we return from the right spot
                                     1D1F   529 v_context:		; points to data field of the word for the vocabulary
                           00000000  1D1F   530 	.long	0	; in which words are searched for.
                                     1D23   531 v_current:		; points to data field of the word for the vocabulary
                           00000000  1D23   532 	.long	0	; that new words are linked into.
                                     1D27   533 v_compiler:		; Pointer to most recent word in compiler vocabulary
                           00000000  1D27   534 	.long	0
                                     1D2B   535 v_kernel:		; Pointer to most recnet word in kernel vocabulary
                           00000000  1D2B   536 	.long	0	; data field of { kernel }
                                     1D2F   537 v_infile:		; Flag.	 If true, reading from an input file.
                                 00  1D2F   538 	.byte	c_false	; If false, reading from terminal.  Set by { load }
                                     1D30   539 v_filelinenum:		; number of lines read from input file
                           00000000  1D30   540 	.long	0	; used in error reporting
                                     1D34   541 v_state:		; Flag.	 True if compiletime word found
                                 00  1D34   542 	.byte	c_false ; in compile mode (then set to false by ?execute),
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  15
V1.01                           Data Section                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1D35   543 			; otherwise false.
                                     1D35   544 v_mode:			; Flag.	 True if in compile mode, false if execute mode.
                                 00  1D35   545 	.byte	c_false ; true => compile word, false => execute word
                                     1D36   546 v_radix:
                           0000000A  1D36   547 	.long	10	; base for number conversion on input and output
                                     1D3A   548 v_hld:
                           00000000  1D3A   549 	.long	0	; pointer to number output conversion buffer
                                     1D3E   550 
                                     1D3E   551 	newpage <Kernel Built-ins>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  16
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 00000000   552 	.psect	vtilcode,exe,nowrt
                                     0000   553 ;******************************************************************************
                                     0000   554 ;
                                     0000   555 ; Kernel Built-Ins -- Original vocabulary of words.  All other vocabularies
                                     0000   556 ;	link into this one, except the compiler (compiletime word) vocabulary.
                                     0000   557 ;
                                     0000   558 ;******************************************************************************
                                     0000   559 _kernel_begin:
                                     0000   560 
                                     0000   561 
                                     0000   562 ;+++t
                                     0000   563 ;k> ! (store) -- ( n a -- ) store longword `n?' at `a'.
                                     0000   564 ;---
                                     0000   565 	header	i_store,<!>
                 00 BB   04 AB   D0  0006   566 	movl	4(r11),@(r11)		; store item at what's pointed to by
                                     000B   567 					; top of stack
                       5B   08   C0  000B   568 	addl2	#8,r11			; pop arguments
                                 05  000E   569 	rsb				; end of !
                                     000F   570 
                                     000F   571 
                                     000F   572 ;+++
                                     000F   573 ;k> # -- ( n1 -- n2 ) generate next output character in number conversion.
                                     000F   574 ;	used between { <# } and { #> }.
                                     000F   575 ;---
                                     000F   576 	header	i_sharp,<#>
              7B   00001D36'EF   D0  0015   577 	movl	v_radix,-(r11)	; put radix on stack
                   000001CD'EF   16  001C   578 	jsb	i_div_mod	; get next digit
                   000012C5'EF   16  0022   579 	jsb	tochar		; make it appropriate ascii char
                   00000B17'EF   16  0028   580 	jsb	hold		; put in output string
                                 05  002E   581 	rsb			; end of #
                                     002F   582 
                                     002F   583 
                                     002F   584 ;+++
                                     002F   585 ;k> #> -- ( n1 -- a n2 ) End numeric output.  Leaves length and address of
                                     002F   586 ;	numeric text on stack for { write }.
                                     002F   587 ;---
                                     002F   588 	header	i_sharp_greater,^\#>\
              6B   00001D3A'EF   D0  0036   589 	movl	v_hld,(r11)		; drop number, put address of output
                                     003D   590 					; on stack
         50   00000109 8F   59   C1  003D   591 	addl3	r9,#c_pad_moat,r0	; get address of pad
         7B   50   00001D3A'EF   C3  0045   592 	subl3	v_hld,r0,-(r11)		; put count on stack
                                     004D   593 					; count = pad - hld
                                 05  004D   594 	rsb				; end of #>
                                     004E   595 
                                     004E   596 
                                     004E   597 ;+++
                                     004E   598 ;k> #s -- ( n1 -- n2 ) Convert all all digits of n1 to output string.  Leaves 0.
                                     004E   599 ;	Used between { <# } and { #> }.
                                     004E   600 ;---
                                     004E   601 	header	i_sharp_s,<#s>
                         BD AF   16  0055   602 	jsb	i_sharp			; output at least one character
                            6B   D5  0058   603 	tstl	(r11)			; is top not = 0?
                            F9   12  005A   604 	bneq	i_sharp_s		; yes, do it again
                                 05  005C   605 	rsb				; no, exit
                                     005D   606 					; end of #s
                                     005D   607 
                                     005D   608 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  17
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     005D   609 ;+++
                                     005D   610 ;k> (# -- ( -- ) Start count of items on the stack.  Used with { #) }.
                                     005D   611 ;	Uses the loop stack!
                                     005D   612 ;---
                                     005D   613 	header	i_count_begin,<(#>
                       7A   5B   D0  0064   614 	movl	r11,-(r10)		; save address of top of stack
                                 05  0067   615 	rsb				; end of (#
                                     0068   616 
                                     0068   617 
                                     0068   618 ;+++
                                     0068   619 ;k> (and) -- ( n1 n2 -- n3 ) bitwise and of n1 and n2.
                                     0068   620 ;---
                                     0068   621 	header	i_bit_and,<(and)>
                       6B   6B   D2  0072   622 	mcoml	(r11),(r11)		; make ones comp because blc ones
                                     0075   623 					; comps mask
                       6B   8B   CA  0075   624 	bicl2	(r11)+,(r11)		; and it
                                 05  0078   625 	rsb				; end of (and)
                                     0079   626 
                                     0079   627 
                                     0079   628 ;+++
                                     0079   629 ;k> (not) -- ( n1 n2 -- n3 ) bitwise not of n1 and n2.
                                     0079   630 ;---
                                     0079   631 	header	i_bit_not,<(not)>
                       6B   6B   D2  0083   632 	mcoml	(r11),(r11)		; not it
                                 05  0086   633 	rsb				; end of (not)
                                     0087   634 
                                     0087   635 
                                     0087   636 ;+++
                                     0087   637 ;k> (or) -- ( n1 n2 -- n3 ) bitwise or of n1 and n2.
                                     0087   638 ;---
                                     0087   639 	header	i_bit_or,<(or)>
                       6B   8B   C8  0090   640 	bisl2	(r11)+,(r11)		; or it
                                 05  0093   641 	rsb				; end of (or)
                                     0094   642 
                                     0094   643 
                                     0094   644 ;+++
                                     0094   645 ;k> (xor) -- ( n1 n2 -- n3) bitwise xor of n1 and n2.
                                     0094   646 ;---
                                     0094   647 	header	i_bit_xor,<(xor)>
                       6B   8B   CC  009E   648 	xorl2	(r11)+,(r11)		; xor it
                                 05  00A1   649 	rsb				; end of (xor)
                                     00A2   650 
                                     00A2   651 
                                     00A2   652 ;+++t
                                     00A2   653 ;k> * -- ( n1 n2 -- n3) multiply top two stack items, leave result on stack.
                                     00A2   654 ;---
                                     00A2   655 	header	i_multiply,<*>
                       6B   8B   C4  00A8   656 	mull2	(r11)+,(r11)		; multiply them
                                 05  00AB   657 	rsb				; end of *
                                     00AC   658 
                                     00AC   659 
                                     00AC   660 ;+++
                                     00AC   661 ;k> #) -- ( -- n ) Return number of items on stack since last { (# }.
                                     00AC   662 ;	uses the loop stack!
                                     00AC   663 ;---
                                     00AC   664 	header	i_count_end,<#)>
                  7B   8A   5B   C3  00B3   665 	subl3	r11,(r10)+,-(r11)	; number of bytes difference in
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  18
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     00B7   666 					; top of stack then and now.
                       6B   04   C6  00B7   667 	divl2	#4,(r11)		; divide to get number of stack
                                     00BA   668 					; items (longwords)
                                 05  00BA   669 	rsb				; end of #)
                                     00BB   670 
                                     00BB   671 
                                     00BB   672 ;+++t
                                     00BB   673 ;k> + -- ( n1 n2 -- n3 ) add the top two stack items, leave result on stack.~~~ Why i_add and not i_plus???
                                     00BB   674 ;---
                                     00BB   675 	header	i_add,<+>
                       6B   8B   C0  00C1   676 	addl2	(r11)+,(r11)		; add them and leave the result on stack
                                 05  00C4   677 	rsb				; end of +
                                     00C5   678 
                                     00C5   679 
                                     00C5   680 ;+++
                                     00C5   681 ;k> +! -- ( n a -- ) Adds `n' to contents of `a'.
                                     00C5   682 ;---
                                     00C5   683 	header	i_plus_store,<+!>
                                     00CC   684 ; Add top of stack to cents of address that is top of stack.
                 00 BB   04 AB   C0  00CC   685 	addl2	   4(r11),@(r11)	;
                       5B   08   C0  00D1   686 	addl2	   #8,r11		; pop arguments
                                 05  00D4   687 	rsb				; end of +!
                                     00D5   688 
                                     00D5   689 
                                     00D5   690 ;+++
                                     00D5   691 ;k> +rot - (n1 n2 n3 -- n3 n1 n2 ) rotate top 3 items on the stack up,
                                     00D5   692 ;	bringing the second to the top.
                                     00D5   693 ;---
                                     00D5   694 	header	i_plus_rot,<+rot>
                       50   6B   D0  00DE   695 	movl	(r11),r0		; t1 = n3
                    6B   04 AB   D0  00E1   696 	movl	4(r11),(r11)		; n3 = n2
                 04 AB   08 AB   D0  00E5   697 	movl	8(r11),4(r11)		; n2 = n1
                    08 AB   50   D0  00EA   698 	movl	r0,8(r11)		; n1 = t1 (old n3)
                                 05  00EE   699 	rsb				; end of +rot
                                     00EF   700 
                                     00EF   701 
                                     00EF   702 ;+++
                                     00EF   703 ;k> , -- ( n -- ) Compile a longword `n' into the dictionary.
                                     00EF   704 ;---
                                     00EF   705 	header	i_comma,<,>
                       89   8B   D0  00F5   706 	movl	(r11)+,(r9)+		; store longword in dictionary
                                 05  00F8   707 	rsb				; end of ,
                                     00F9   708 
                                     00F9   709 
                                     00F9   710 ;+++t
                                     00F9   711 ;k> - -- ( n1 n2 -- n3 ) subtract the top stack item from the next stack item.
                                     00F9   712 ;---
                                     00F9   713 	header	i_subtract,<->
                       6B   8B   C2  00FF   714 	subl2	(r11)+,(r11)		; subract and leave result on stack.
                                 05  0102   715 	rsb				; end of -
                                     0103   716 
                                     0103   717 
                                     0103   718 ;+++
                                     0103   719 ;k> -rot -- ( n1 n2 n3 -- n2 n3 n1 ) rotate top 3 items on the stack down,
                                     0103   720 ;	bringing the third to the top.
                                     0103   721 ;---
                                     0103   722 	header	i_minus_rot,<-rot>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  19
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                    50   08 AB   D0  010C   723 	movl	8(r11),r0		; t1 = n1
                 08 AB   04 AB   D0  0110   724 	movl	4(r11),8(r11)		; n1 = n2
                    04 AB   6B   D0  0115   725 	movl	(r11),4(r11)		; n2 = n3
                       6B   50   D0  0119   726 	movl	r0,(r11)		; n3 = n1
                                 05  011C   727 	rsb				; end of -rot
                                     011D   728 
                                     011D   729 
                                     011D   730 ;+++
                                     011D   731 ;k> . -- ( n -- ) output the top of the stack as a signed number and pop it.
                                     011D   732 ;---
                                     011D   733 	header	i_dot,<.>
                       7A   6B   D0  0123   734 	movl	(r11),-(r10)		; dup ds>ls
                   000003B2'EF   16  0126   735 	jsb	abs			; abs
                   00000239'EF   16  012C   736 	jsb	i_less_sharp		; <#
                       FF1F CF   16  0132   737 	jsb	i_sharp_s		; #s
                       7B   8A   D0  0136   738 	movl	(r10)+,-(r11)		; ls>ds
                   00000FE7'EF   16  0139   739 	jsb	sign			; sign
                       FEF3 CF   16  013F   740 	jsb	i_sharp_greater		; #>
                   00001454'EF   16  0143   741 	jsb	write			; output it
                       7B   20   D0  0149   742 	movl	#c_blank,-(r11)		; put space on stack
                   00000DF2'EF   16  014C   743 	jsb	putc			; output it
                                 05  0152   744 	rsb				; end of .
                                     0153   745 
                                     0153   746 
                                     0153   747 ;+++
                                     0153   748 ;k> .( -- ( -- ) write the text following until the next `)' to the screen.
                                     0153   749 ;	This word should only be used *OUTSIDE* a definition (i.e.,
                                     0153   750 ;	in execute mode).
                                     0153   751 ;---
                                     0153   752 	header	i_dot_lparen,<.(>
                       7B   29   D0  015A   753 	movl	#^a\)\,-(r11)		; set up for `)' delimited token.
                   000012E6'EF   16  015D   754 	jsb	token			; get the token
                  7B   59   01   C1  0163   755 	addl3	#1,r9,-(r11)		; address of string
                       7B   69   9A  0167   756 	movzbl	(r9),-(r11)		; get count of string on stack
                   00001454'EF   16  016A   757 	jsb	write			; put it on the screen
                                 05  0170   758 	rsb				; end of .(
                                     0171   759 
                                     0171   760 
                                     0171   761 ;---
                                     0171   762 ;k> .sb -- ( -- ) output the stack from the bottom up without consuming it.
                                     0171   763 ;	The last item printed is the top of the stack.
                                     0171   764 ;---
                                     0171   765 	header	i_dot_sb,<.sb>
              7A   00001000'8F   D0  0179   766 	movl	#c_ds_start,-(r10)	; save end of stack.
                                     0180   767 10$:
                       6A   5B   D1  0180   768 	cmpl	r11,(r10)		; at top of stack yet?
                            0C   18  0183   769 	bgeq	100$			; yes, leave
                       6A   04   C2  0185   770 	subl2	#4,(r10)		; move to item
                    7B   00 BA   D0  0188   771 	movl	@(r10),-(r11)		; put item on top of stack
                         94 AF   16  018C   772 	jsb	i_dot			; print it
                            EF   11  018F   773 	brb	10$			; do it again
                                     0191   774 100$:
                       5A   04   C0  0191   775 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  0194   776 	rsb				; end of .sb
                                     0195   777 
                                     0195   778 
                                     0195   779 ;+++
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  20
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0195   780 ;k> .st -- ( -- ) output stack from the top down without consuming it.
                                     0195   781 ;	The last item printed is the bottom of the stack.
                                     0195   782 ;---
                                     0195   783 	header	i_dot_st,<.st>
                       7A   5B   D0  019D   784 	movl	r11,-(r10)		; save sp on top of loop stack
                                     01A0   785 10$:
              00001000'8F   6A   D1  01A0   786 	cmpl	(r10),#c_ds_start	; Is stack empty?
                            0D   18  01A7   787 	bgeq	20$			; yes
                    7B   00 BA   D0  01A9   788 	movl	@(r10),-(r11)		; put item on top
                       FF72 CF   16  01AD   789 	jsb	i_dot			; print it
                       6A   04   C0  01B1   790 	addl2	#4,(r10)		; move down stack
                            EA   11  01B4   791 	brb	10$			; do it again
                                     01B6   792 20$:
                       5A   04   C0  01B6   793 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  01B9   794 	rsb				; end of .st
                                     01BA   795 
                                     01BA   796 
                                     01BA   797 ;+++t
                                     01BA   798 ;k> / -- ( n1 n2 -- n3 ) divides second stack item by top stack item, leaves
                                     01BA   799 ;	result on stack.  n3 = n1 / n2.
                                     01BA   800 ;---
                                     01BA   801 	header	i_divide,</>
                       6B   8B   C6  01C0   802 	divl2	(r11)+,(r11)
                                 05  01C3   803 	rsb				; end of /
                                     01C4   804 
                                     01C4   805 
                                     01C4   806 ;+++
                                     01C4   807 ;k> /mod -- ( n1 n2 -- n3 n4 ) divides second stack item by top stack item,
                                     01C4   808 ;	leaves ( quotient remainder ) on the stack.  n3 = n1 / n2, n4 = n1 - (n3 * n2).
                                     01C4   809 ;---
                                     01C4   810 	header	i_div_mod,</mod>
               50   04 AB   6B   C7  01CD   811 	divl3	(r11),4(r11),r0		; r0 = n1 / n2 = n3
                  51   8B   50   C5  01D2   812 	mull3	r0,(r11)+,r1		; tmp = n2 * n3
                  51   8B   51   C3  01D6   813 	subl3	r1,(r11)+,r1		; r1 = n1 - (n2 * n3) = n4
                       7B   50   D0  01DA   814 	movl	r0,-(r11)		; push n3, quotient
                       7B   51   D0  01DD   815 	movl	r1,-(r11)		; push n4, remainder
                                 05  01E0   816 	rsb				; end of /mod
                                     01E1   817 
                                     01E1   818 
                                     01E1   819 ;+++
                                     01E1   820 ;k> 1+ -- ( n -- n+1 ) Add one to the top of the stack.
                                     01E1   821 ;---
                                     01E1   822 	header	i_one_plus,<1+>
                            6B   D6  01E8   823 	incl	(r11)			; dd one to the top of the stack.
                                 05  01EA   824 	rsb				; end of 1+
                                     01EB   825 
                                     01EB   826 
                                     01EB   827 ;+++
                                     01EB   828 ;k> 1- -- ( n -- n-1 ) Subtract one from the top of the stack.
                                     01EB   829 ;---
                                     01EB   830 	header	i_one_minus,<1->
                            6B   D7  01F2   831 	decl	(r11)			; subtract one from top of stack
                                 05  01F4   832 	rsb				; end of 1-
                                     01F5   833 
                                     01F5   834 
                                     01F5   835 ;+++
                                     01F5   836 ;k> : -- ( -- ) (colon) defining word that starts a word definition.
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  21
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     01F5   837 ;	sets { mode } to true
                                     01F5   838 ;	Note that { : } is a compiling word an so is in compiler vocab.
                                     01F5   839 ;---
                                     01F5   840 	header	i_colon,<:>
     00001D1F'EF   00001D23'EF   D0  01FB   841 	movl	v_current,v_context	; search same vocab we are defining into
                   00000846'EF   16  0206   842 	jsb	create			; create header for new word
                                     020C   843 ;??? Should I now set the high bit in the length byte (To prevent word from
                                     020C   844 ; being found during its own definition)?
                   00000FFE'EF   16  020C   845 	jsb	smudge			; set smudge bit in name length so word isn't found
           00001D35'EF   FF 8F   90  0212   846 	movb	#c_true,v_mode		; set compiler v_mode
                                 05  021A   847 	rsb				; end of :
                                     021B   848 
                                     021B   849 
                                     021B   850 ;+++t
                                     021B   851 ;k> < -- ( n1 n2 -- f ) true if n1 < n2, false otherwise.
                                     021B   852 ;---
                                     021B   853 	header	i_less,^\<\
                       8B   8B   D1  0221   854 	cmpl	(r11)+,(r11)+		; reverse order, so n2 > n1
                            04   14  0224   855 	bgtr	10$			; yes
                       7B   00   D0  0226   856 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0229   857 	rsb				; return
                                     022A   858 10$:
              7B   FFFFFFFF 8F   D0  022A   859 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0231   860 	rsb				; end of <
                                     0232   861 
                                     0232   862 
                                     0232   863 ;+++
                                     0232   864 ;k> <# -- ( -- ) start numeric output conversion.
                                     0232   865 ;---
                                     0232   866 	header	i_less_sharp,^\<#\
00001D3A'EF   00000109 8F   59   C1  0239   867 	addl3	r9,#c_pad_moat,v_hld	; pad hld !
                                 05  0245   868 	rsb				; end of <#
                                     0246   869 
                                     0246   870 
                                     0246   871 ;+++t
                                     0246   872 ;k> <= -- ( n1 n2 -- f ) true if n1 <= n2, false otherwise.
                                     0246   873 ;---
                                     0246   874 	header	i_less_equal,^\<=\
                       8B   8B   D1  024D   875 	cmpl	(r11)+,(r11)+		; reverse order, so n2 >= n1
                            04   18  0250   876 	bgeq	10$			; yes
                       7B   00   D0  0252   877 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0255   878 	rsb				; return
                                     0256   879 10$:
              7B   FFFFFFFF 8F   D0  0256   880 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  025D   881 	rsb				; end of <
                                     025E   882 
                                     025E   883 
                                     025E   884 ;+++t
                                     025E   885 ;k> = -- ( n1 n2 -- f ) true if n1 = n2, false otherwise
                                     025E   886 ;---
                                     025E   887 	header	i_equal,<=>
                       8B   8B   D1  0264   888 	cmpl	(r11)+,(r11)+		; n2 = n1?
                            04   13  0267   889 	beql	10$			; yes
                       7B   00   D0  0269   890 	movl	#c_false,-(r11)		; no, leave with false
                                 05  026C   891 	rsb				; return
                                     026D   892 10$:
              7B   FFFFFFFF 8F   D0  026D   893 	movl	#c_true,-(r11)		; yes, leave with true
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  22
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  0274   894 	rsb				; end of =
                                     0275   895 
                                     0275   896 
                                     0275   897 ;+++
                                     0275   898 ;K> =text -- ( a1 a2 n -- f ) compare strings of length `n' at `a1' and `a2',
                                     0275   899 ;	return true if they are equal, false otherwise.
                                     0275   900 ;---
                                     0275   901 	header	i_equal_text,<=text>
            08 BB   04 BB   6B   29  027F   902 	cmpc3	(r11),@4(r11),@8(r11)	; Are they equal>
                            0B   12  0285   903 	bneq	10$			; no
                       5B   0C   C0  0287   904 	addl2	#12,r11			; pop arguments
              7B   FFFFFFFF 8F   D0  028A   905 	movl	#c_true,-(r11)		; yes, leave true
                                 05  0291   906 	rsb				; return
                                     0292   907 10$:
                       5B   0C   C0  0292   908 	addl2	#12,r11			; pop arguments
                       7B   00   D0  0295   909 	movl	#c_false,-(r11)		; no, they aren't equal, leave false.
                                 05  0298   910 	rsb				; end of =text
                                     0299   911 
                                     0299   912 
                                     0299   913 ;+++t
                                     0299   914 ;k> > -- ( n1 n2 -- f ) true if n1 > n2, false otherwise.
                                     0299   915 ;---
                                     0299   916 	header	i_greter,^\>\
                       8B   8B   D1  029F   917 	cmpl	(r11)+,(r11)+		; reverse order, so n2 < n1
                            04   19  02A2   918 	blss	10$			; yes
                       7B   00   D0  02A4   919 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02A7   920 	rsb				; return
                                     02A8   921 10$:
              7B   FFFFFFFF 8F   D0  02A8   922 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  02AF   923 	rsb				; end of >
                                     02B0   924 
                                     02B0   925 
                                     02B0   926 ;+++t
                                     02B0   927 ;k> >= -- ( n1 n2 -- f ) true if n1 >= n2; false otherwise.
                                     02B0   928 ;---
                                     02B0   929 	header	i_greater_equal,^\>=\
                       8B   8B   D1  02B7   930 	cmpl	(r11)+,(r11)+		; reverse order, so n2 <= n1
                            04   15  02BA   931 	bleq	10$			; yes
                       7B   00   D0  02BC   932 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02BF   933 	rsb				; return
                                     02C0   934 10$:
              7B   FFFFFFFF 8F   D0  02C0   935 	movl	#c_true,-(r11)		; yes, leave with false
                                 05  02C7   936 	rsb				; end of >=
                                     02C8   937 
                                     02C8   938 
                                     02C8   939 ;+++
                                     02C8   940 ;k> ? -- ( a -- ) Output contents of `a' as a long in current radix.
                                     02C8   941 ;---
                                     02C8   942 ; Remark on the internal name of this word: { header q_,<?> } is aesthetically
                                     02C8   943 ; displeasing, so make it i_question by analogoy with i_dot for { . }.
                                     02C8   944 	header	i_question,<?>
                    6B   00 BB   D0  02CE   945 	movl	@(r11),(r11)		; get contents of `a'.
                       FE4D CF   16  02D2   946 	jsb	i_dot			; print contents
                                 05  02D6   947 	rsb				; end of ?
                                     02D7   948 
                                     02D7   949 
                                     02D7   950 ;+++
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  23
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     02D7   951 ;k> ?cr -- ( -- ) start a new line unless already at beginning of line.
                                     02D7   952 ;---
                                     02D7   953 	header	q_cr,<?cr>
                   00001B98'EF   B5  02DF   954 	tstw	v_outlen		; At beginning of line?
                            06   13  02E5   955 	beql	10$			; yes, exit
                   00000812'EF   16  02E7   956 	jsb	cr			; no, start new line
                                     02ED   957 10$:
                                 05  02ED   958 	rsb				; end of ?cr
                                     02EE   959 
                                     02EE   960 
                                     02EE   961 ;+++
                                     02EE   962 ;k> ?dup -- ( f -- f ? f ) Duplicate top of stack only if it is true (non-zero).
                                     02EE   963 ;	Used so don't always have to drop 0 in else.
                                     02EE   964 ;---
                                     02EE   965 	header	q_dup,<?dup>
                            6B   D5  02F7   966 	tstl	(r11)			; is it zero?
                            03   13  02F9   967 	beql	10$			; yes, don't duplicate it.
                       7B   6B   D0  02FB   968 	movl	(r11),-(r11)		; no, duplicate it.
                                     02FE   969 10$:
                                 05  02FE   970 	rsb				; end of ?dup
                                     02FF   971 
                                     02FF   972 
                                     02FF   973 ;+++
                                     02FF   974 ;k> ?n-cr -- ( n -- ) starts new line on terminal if < n chars left on line.
                                     02FF   975 ;---
                                     02FF   976 	header	q_n_cr,<?n-cr>
              50   00001B98'EF   3C  0309   977 	movzwl	v_outlen,r0		; get current length of line.
         50   00000050 8F   50   C3  0310   978 	subl3	r0,#c_screen_len,r0	; get current length of line
                       50   8B   D1  0318   979 	cmpl	(r11)+,r0		; enough characers left?
                            06   19  031B   980 	blss	10$			; yes, go to return
                                     031D   981 ; no, not enough characters left on line.
                   00000812'EF   16  031D   982 	jsb	cr			; start a new line
                                     0323   983 10$:
                                 05  0323   984 	rsb				; end of ?n-cr
                                     0324   985 
                                     0324   986 
                                     0324   987 ;+++t
                                     0324   988 ;k> ?number -- ( -- n ? f ) Convert token at eodp to a number, and if compiling
                                     0324   989 ;	enclose it as a literal in the current word.  If executing, push on
                                     0324   990 ;	the  stack.  If not a number, leave false on stack.  If a number leave
                                     0324   991 ;	a true on stack.
                                     0324   992 ;---
                                     0324   993 	header	q_number,<?number>
                   00000D24'EF   16  0330   994 	jsb	number			; try to make it a number
                            6B   D5  0336   995 	tstl	(r11)			; is it a number?
                            18   13  0338   996 	beql	10$			; no, exit leaving false on the stack
                       5B   04   C0  033A   997 	addl2	#4,r11			; yes.	pop flag
                   00001D35'EF   95  033D   998 	tstb	v_mode			; are we compiling?
                            06   13  0343   999 	beql	20$			; no, leaving it on stack
                   000017A3'EF   16  0345  1000 	jsb	literal			; yes, include in dictionary as
                                     034B  1001 					; a literal
                                     034B  1002 20$:
              7B   FFFFFFFF 8F   D0  034B  1003 	movl	#c_true,-(r11)		; leave with true on stack
                                     0352  1004 10$:
                                 05  0352  1005 	rsb				; end of ?number
                                     0353  1006 
                                     0353  1007 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  24
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0353  1008 ;+++t
                                     0353  1009 ;k> ?search -- ( -- a ? f )  search context vocabulary for most recent token,
                                     0353  1010 ;	return false if not found, or ( addr true ) if found.  If compiling,
                                     0353  1011 ;	search compiler vocab if not found in context and set { state }
                                     0353  1012 ;	true.  Compare byte-counted string at eodp to find.
                                     0353  1013 ;---
                                     0353  1014 	header	q_search,<?search>
                                     035F  1015 ;??? this next perhaps should have been
                                     035F  1016 ;	movl	@v_context,(r11)
                                     035F  1017 ;	tstb	v_mode
                                     035F  1018 ;	beql	5$
                                     035F  1019 ;	movl	@(r11),(r11)
                                     035F  1020 ;5$:
                                     035F  1021 ; which would (during compilation of new words)
                                     035F  1022 ; start the search at the word before the one currently being compiled;
                                     035F  1023 ; this would allow use of older definition of word `x' in new definition
                                     035F  1024 ; of word `x'.	However, as it stands it allows easy recursion.
                                     035F  1025 ;??? changed to eliminate recusion by default, as that is probably more
                                     035F  1026 ; useful, since RECURSE is a simple way to get recusion.
                                     035F  1027 ;??? The problem with this is that if you switch vocabularies while defining
                                     035F  1028 ; a word, the new vocab (which you want to search from the first) also is
                                     035F  1029 ; searched from the second word.  Perhaps I should set the smudge bit (gasp!
                                     035F  1030 ; Horrors!).
                                     035F  1031 ; get pointer to pointer to start of vocab
              7B   00001D1F'FF   D0  035F  1032 	movl @v_context,-(r11)		; get address of current word
                                     0366  1033 ;??? took out to test smudge bit
                                     0366  1034 ;	tstb  v_mode			; Are we compiling?
                                     0366  1035 ;	beql  5$			; no, go on.
                                     0366  1036 ; yes, so skip address of word we are defining, so we can use
                                     0366  1037 ; previous definitions of this word.
                                     0366  1038 ;	movl	@(r11),(r11)		; get address of previous word
                                     0366  1039 5$:
                   00000F8A'EF   16  0366  1040 	jsb	search			; search it
                            6B   D5  036C  1041 	tstl	(r11)			; Was it found?
                            21   12  036E  1042 	bneq	10$			; yes, exit with ( addr true ) on dstack
                   00001D35'EF   95  0370  1043 	tstb	v_mode			; no. Are we compiling?
                            19   13  0376  1044 	beql	10$			; no, exit leaving false on dstack
              6B   00001D27'EF   D0  0378  1045 	movl	v_compiler,(r11)	; yes, get adddress of compiler vocab
                   00000F8A'EF   16  037F  1046 	jsb	search			; search it
                            6B   D5  0385  1047 	tstl	(r11)			; Was it found?
                            08   13  0387  1048 	beql	10$			; no, exit with false on dstack
           00001D34'EF   FF 8F   90  0389  1049 	movb	#c_true,v_state		; yes, set v_state flag
                                     0391  1050 					; exit with ( addr true ) on dstack
                                     0391  1051 10$:
                                 05  0391  1052 	rsb				; end of ?search
                                     0392  1053 ;??? Should the compiler vocabulary be searched *before* the context vocabulary
                                     0392  1054 ; when we are compiling?  This would allow defining new versions in compiler
                                     0392  1055 ; of words in context that would be more efficient during compilation (or
                                     0392  1056 ; have a different effect, or allow immediate and noimmediate words that
                                     0392  1057 ; should do the same thing, like { % }).
                                     0392  1058 
                                     0392  1059 
                                     0392  1060 
                                     0392  1061 ;+++t
                                     0392  1062 ;k> @ -- (fetch) ( a -- l ) Fetches contents of longword at `a'.
                                     0392  1063 ;---
                                     0392  1064 	header	i_fetch,<@>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  25
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                    6B   00 BB   D0  0398  1065 	movl	@(r11),(r11)		; get contents of address at top-of-ds
                                 05  039C  1066 	rsb				; end of @
                                     039D  1067 
                                     039D  1068 
                                     039D  1069 ;+++
                                     039D  1070 ;k> abort -- ( -- ) clear data stack and restart VTIL.
                                     039D  1071 ;---
                                     039D  1072 	header	abort
                          162C   31  03A7  1073 	brw	r_warm_start		; end of abort
                                     03AA  1074 
                                     03AA  1075 
                                     03AA  1076 ;+++
                                     03AA  1077 ;k> abs -- ( n1 -- n2 ) Takes the absolute value of top of stack.
                                     03AA  1078 ;---
                                     03AA  1079 	header	abs
                            6B   D5  03B2  1080 	tstl	(r11)			; is top of stack < 0?
                            03   18  03B4  1081 	bgeq	10$			; no, go on
                       6B   6B   CE  03B6  1082 	mnegl	(r11),(r11)		; yes, negate it
                                     03B9  1083 10$:
                                 05  03B9  1084 	rsb				; end of abs
                                     03BA  1085 
                                     03BA  1086 
                                     03BA  1087 ;+++t
                                     03BA  1088 ;k> ac: -- ( b -- ) assembler constant (makes opcode & operand defintions).
                                     03BA  1089 ;	ac: creates a word that compiles the byte on the top of the stack at
                                     03BA  1090 ;	definition into the dictionary.
                                     03BA  1091 ;---
                                     03BA  1092 	header	i_ac_colon,<ac:>
                   00000846'EF   16  03C2  1093 	jsb	create			; enclose name in dictionary
                    89   90 8F   90  03C8  1094 	movb	#op_movb,(r9)+		; `movb'
                    89   AF 8F   90  03CC  1095 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  03D0  1096 	movb	#2,(r9)+		; (pc+2)
                    89   89 8F   90  03D3  1097 	movb	#adm_ainc_r9,(r9)+	; (r9)+
                       89   05   90  03D7  1098 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  03DA  1099 	movb	(r11),(r9)+		; enclose byte value in dictionary
                       5B   04   C0  03DD  1100 	addl	#4,r11			; pop argument
                                     03E0  1101 ; Make it an compiletime word so it will compile the machine language into the
                                     03E0  1102 ; dictionary when defining a new word and will not be found otherwise.
                   000007C5'EF   16  03E0  1103 	jsb	compiletime
                                 05  03E6  1104 	rsb				; end of ac:
                                     03E7  1105 
                                     03E7  1106 
                                     03E7  1107 ;+++t
                                     03E7  1108 ;k> and -- ( f1 f2 -- f ) logical and f1 and f2
                                     03E7  1109 ;---
                                     03E7  1110 	header	and
                            8B   D5  03EF  1111 	tstl	(r11)+			; is first false?
                            0C   13  03F1  1112 	beql	10$			; yes
                            8B   D5  03F3  1113 	tstl	(r11)+			; no, is second false?
                            0B   13  03F5  1114 	beql	20$			; yes
              7B   FFFFFFFF 8F   D0  03F7  1115 	movl	#c_true,-(r11)		; no, both true, leave with true
                                 05  03FE  1116 	rsb				; return
                                     03FF  1117 10$:
                       6B   04   C0  03FF  1118 	addl2	#4,(r11)		; pop second item off, don't need
                                     0402  1119 					; to check
                                     0402  1120 20$:
                       7B   00   D0  0402  1121 	movl	#c_false,-(r11)		; leave with false
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  26
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  0405  1122 	rsb				; end of and
                                     0406  1123 
                                     0406  1124 
                                     0406  1125 ;+++
                                     0406  1126 ;k> array -- ( n -- ) create word that pushes addres of `n' bytes
                                     0406  1127 ;	which are saved in the dictionary.
                                     0406  1128 ;---
                                     0406  1129 	header	array
                   00000846'EF   16  0410  1130 	jsb	create			; enclose next token in dictinary
                    89   9E 8F   90  0416  1131 	movb	#op_movab,(r9)+		; `moval'
                    89   AF 8F   90  041A  1132 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  041E  1133 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0421  1134 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0425  1135 	movb	#op_rsb,(r9)+		; `rsb'
                       59   8B   C0  0428  1136 	addl2	(r11)+,r9		; save `n' bytes in dictionary
                                 05  042B  1137 	rsb				; end of array
                                     042C  1138 
                                     042C  1139 
                                     042C  1140 ;+++
                                     042C  1141 ;k> ascii -- ( -- n ) put ascii value of first character of next token on stack.
                                     042C  1142 ;	Note that this cannot be used in colon definitions!  (See { [ascii] }.)
                                     042C  1143 ;---
                                     042C  1144 	header	ascii
                       7B   20   D0  0436  1145 	movl	#c_blank,-(r11)		; set up for blank separated token
                   000012E6'EF   16  0439  1146 	jsb	token			; get it
                    7B   01 A9   9A  043F  1147 	movzbl	1(r9),-(r11)		; put ascii value of token on stack
                                 05  0443  1148 	rsb				; end of ascii
                                     0444  1149 
                                     0444  1150 
                                     0444  1151 ;+++
                                     0444  1152 ;k> b! -- ( b a -- ) store 8 bits of `b' at address `a'.
                                     0444  1153 ;---
                                     0444  1154 	header	i_b_store,<b!>
                 00 BB   04 AB   90  044B  1155 	movb	4(r11),@(r11)		; store byte at what's pointed to by
                                     0450  1156 					; top of stack
                       5B   08   C0  0450  1157 	addl2	#8,r11			; pop arguments
                                 05  0453  1158 	rsb				; end of b!
                                     0454  1159 
                                     0454  1160 
                                     0454  1161 ;+++
                                     0454  1162 ;k> b, -- ( b -- ) store low byte of top stack entry into dictionary.
                                     0454  1163 ;---
                                     0454  1164 	header	i_b_comma,<b,>
                       89   6B   90  045B  1165 	movb	(r11),(r9)+		; store in dictinary
                       5B   04   C0  045E  1166 	addl2	#4,r11			; pop argument
                                 05  0461  1167 	rsb				; end of b,
                                     0462  1168 
                                     0462  1169 
                                     0462  1170 ;+++
                                     0462  1171 ;k> b@ -- ( a -- b ) Fetch byte from address `a'.
                                     0462  1172 ;---
                                     0462  1173 	header	i_b_fetch,<b@>
                    6B   00 BB   9A  0469  1174 	movzbl	@(r11),(r11)
                                 05  046D  1175 	rsb				; end of b@
                                     046E  1176 
                                     046E  1177 
                                     046E  1178 ;+++
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  27
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     046E  1179 ;k> bcount -- ( a -- a n ) Given the address of a byte-counted
                                     046E  1180 ;	string, leave address of first character in string and the
                                     046E  1181 ;	count of the string on the stack.
                                     046E  1182 ;---
                                     046E  1183 	header	bcount
                    50   00 BB   9A  0479  1184 	movzbl	@(r11),r0		; get length of string
                            6B   D6  047D  1185 	incl	(r11)			; move over byte-count
                       7B   50   D0  047F  1186 	movl	r0,-(r11)		; put count on stack
                                 05  0482  1187 	rsb				; end of bcount
                                     0483  1188 
                                     0483  1189 
                                     0483  1190 ;+++
                                     0483  1191 ;k> binary -- ( -- ) Set the base to binary
                                     0483  1192 ;---
                                     0483  1193 	header	binary
              00001D36'EF   02   D0  048E  1194 	movl	#2,v_radix		; switch to base 2
                                 05  0495  1195 	rsb				; end of binary
                                     0496  1196 
                                     0496  1197 
                                     0496  1198 ;+++
                                     0496  1199 ;k> (bl) -- ( -- c ) Pushes ascii value of a blank on the stack.
                                     0496  1200 ;---
                                     0496  1201 	header	i_bl,<(bl)>
                       7B   20   D0  049F  1202 	movl	#c_blank,-(r11)		; put on stack
                                 05  04A2  1203 	rsb				; end of (bl)
                                     04A3  1204 
                                     04A3  1205 
                                     04A3  1206 ;+++
                                     04A3  1207 ;k> blank --- ( a w -- ) fill `w' bytes from `a' with blanks.
                                     04A3  1208 ;---
                                     04A3  1209 	header	blank
                       69   00   2C  04AD  1210 	movc5	#0,(r9),-		; srclen,src  use (r9) to be safe
                            20       04B0  1211 		#c_blank,-		; fill with blanks
                    04 BB   6B       04B1  1212 		(r11),@4(r11)		; destlen, dest
                       5B   08   C0  04B4  1213 	addl2	#8,r11			; pop arguments
                                 05  04B7  1214 	rsb				; end of blank
                                     04B8  1215 
                                     04B8  1216 
                                     04B8  1217 ;+++
                                     04B8  1218 ;k> block -- ( l -- a ) Get block `l' into buffer at address `a'.
                                     04B8  1219 ;---
                                     04B8  1220 	header	block
                                     04C2  1221 ; Is the block already in memory?
                            50   D4  04C2  1222 	clrl   r0			; start with buffer 0
                                     04C4  1223 10$:
                            6B   D1  04C4  1224 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       04C6  1225 		v_buf_blk_nums[r0]	;   block we are looking for?
                            4E   13  04CC  1226 	beql	100$			; yes, go on
                    F2 50   03   F2  04CE  1227 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     04D2  1228 ;
                                     04D2  1229 ; not in memory, so we have to get it in
                                     04D2  1230 ;
                                     04D2  1231 ; Are there any unused buffers?
                            50   D4  04D2  1232 	clrl	r0			; start with buffer 0
                                     04D4  1233 20$:
                 00001B7D'EF40   95  04D4  1234 	tstb	v_buf_inuse[r0]		; is it in use?
                            25   13  04DB  1235 	beql	90$			; no, read block into it
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  28
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                    F3 50   03   F2  04DD  1236 	aoblss	#c_max_blocks,r0,20$	; move to next buffer, if any
                                     04E1  1237 ; Are there any unmodified buffers?
                            50   D4  04E1  1238 	clrl	r0
                                     04E3  1239 30$:
                            02   91  04E3  1240 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       04E5  1241 		v_buf_inuse[r0]		;   been modified?
                            15   12  04EB  1242 	bneq	90$			; no, read block into it
                    F2 50   03   F2  04ED  1243 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     04F1  1244 ; all buffers are modified, so we must write out out and use it.
                            50   D4  04F1  1245 	clrl	r0			; for now, always use the zero'th one
                       7A   50   D0  04F3  1246 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  04F6  1247 	movl	r0,-(r11)		; set up for buffer-write
                   000006FC'EF   16  04F9  1248 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  04FF  1249 	movl	(r10)+,r0		; get the buffer number back
                                     0502  1250 ; read block into buffer
                                     0502  1251 90$:
                            6B   D0  0502  1252 	movl	(r11),-			; Save the new block number in
                 00001B80'EF40       0504  1253 		v_buf_blk_nums[r0]	;   buffer
                            01   90  050A  1254 	movb	#c_inuse,-		; flag that buffer is in use
                 00001B7D'EF40       050C  1255 		v_buf_inuse[r0]
                       6B   50   D0  0512  1256 	movl	r0,(r11)		; set up for buffer-read
                   000006C0'EF   16  0515  1257 	jsb	i_buffer_read		; read block into buffer
                                 05  051B  1258 	rsb				; return
                                     051C  1259 ;
                                     051C  1260 ; block already in memory
                                     051C  1261 ;
                                     051C  1262 100$:
                                     051C  1263 ; Comes here if block already in memory, with buffers in r0, block# on stack
         6B   00000400 8F   50   C5  051C  1264 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  0524  1265 	addl2	#v_blkbuff,(r11)	; calcualte addressof `r0'th buffer
              00001B79'EF   50   D0  052B  1266 	movl	r0,v_current_buff	; mark this as most current block
                                 05  0532  1267 	rsb				; end of block
                                     0533  1268 
                                     0533  1269 
                                     0533  1270 
                                     0533  1271 ;+++
                                     0533  1272 ;k> block-close -- ( -- ) Close the block file
                                     0533  1273 ;---
                                     0533  1274 	header	i_block_close,<block-close>
                   00001B78'EF   95  0543  1275 	tstb	v_blockio		; is the block file open?
                            1A   13  0549  1276 	beql	100$			; no, return
                                     054B  1277 	$close	fab=v_blkfab		; Yes, close block file
                         03 50   E8  0558  1278 	blbs	r0,10$			; go on if no error
                          15FE   31  055B  1279 	brw	_error_exit		; exit with error message
                                     055E  1280 10$:
              00001B78'EF   00   90  055E  1281 	movb	#c_false,v_blockio	; we're not using block file
                                     0565  1282 100$:
                                 05  0565  1283 	rsb				; end of block-close
                                     0566  1284 
                                     0566  1285 
                                     0566  1286 ;+++
                                     0566  1287 ;k> block-open -- ( -- ) Open the block file.
                                     0566  1288 ;---
                                     0566  1289 	header	i_block_open,<block-open>
                   00001B78'EF   95  0575  1290 	tstb	v_blockio		; Is block file open?
                            2E   12  057B  1291 	bneq	100$			; Yes, don't open again
                                     057D  1292 ; no, open it
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  29
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     057D  1293 	$open	fab=v_blkfab		; open block file
                         03 50   E8  058A  1294 	blbs	r0,10$			; no error, go on
                          15CC   31  058D  1295 	brw	_error_exit		; quit on error
                                     0590  1296 10$:
                                     0590  1297 	$connect rab=v_blkrab		; connect to block file
                         03 50   E8  059D  1298 	blbs	 r0,20$			; no error, go on
                          15B9   31  05A0  1299 	brw	 _error_exit		; quit on error
                                     05A3  1300 20$:
           00001B78'EF   FF 8F   90  05A3  1301 	movb	#c_true,v_blockio	; yes, we are using the block file
                                     05AB  1302 100$:
                                 05  05AB  1303 	rsb				; end of block-open
                                     05AC  1304 
                                     05AC  1305 
                                     05AC  1306 ;+++
                                     05AC  1307 ;k> block-read -- ( l a -- ) Read block `l' from buffer at address `a'.
                                     05AC  1308 ;---
                                     05AC  1309 	header	i_block_read,<block-read>
                            8B   D0  05BB  1310 	movl	(r11)+,-		; get address of buffer
                   00001B54'EF       05BD  1311 		v_blkrab+rab$l_ubf	;   into  rab
                            8B   D0  05C2  1312 	movl	(r11)+,-		; get VTIL block (rms record) number
                   00001B74'EF       05C4  1313 		v_blkkey		;   into rab's key
                                     05C9  1314 	$get	rab=v_blkrab		; read the block
                         03 50   E8  05D6  1315 	blbs	r0,100$			; no errors, go on
                          1580   31  05D9  1316 	brw	_error_exit		; exit and signal error
                                     05DC  1317 100$:
                                 05  05DC  1318 	rsb				; end of block-read
                                     05DD  1319 
                                     05DD  1320 
                                     05DD  1321 ;+++
                                     05DD  1322 ;k> block-write -- ( l a -- ) Write block `l' from buffer at address `a'.
                                     05DD  1323 ;---
                                     05DD  1324 	header	i_block_write,<block-write>
                            8B   D0  05ED  1325 	movl	(r11)+,-		; get buffer address
                   00001B58'EF       05EF  1326 		v_blkrab+rab$l_rbf	;   into rab
                            8B   D0  05F4  1327 	movl	(r11)+,-		; get VTIL block (rms record) number
                   00001B74'EF       05F6  1328 		v_blkkey		;   into key buffer
                       0400 8F   B0  05FB  1329 	movw	#c_block_size,-		; get proper VTIL block (rms record)
                   00001B52'EF       05FF  1330 		v_blkrab+rab$w_rsz	;   size into fab
                                     0604  1331 	$find	rab=v_blkrab		; find the correct block
                                     0611  1332 	$update	rab=v_blkrab		; write the block
                         03 50   E8  061E  1333 	blbs	r0,100$			; no errors, go on
                          1538   31  0621  1334 	brw	_error_exit		; exit and signal error
                                     0624  1335 100$:
                                 05  0624  1336 	rsb				; end of block-write
                                     0625  1337 
                                     0625  1338 
                                     0625  1339 ;+++
                                     0625  1340 ;k> break -- ( -- ) Breakpoint!	 For use in debugging kernel and compiler.
                                     0625  1341 ;	This word should only be executed when running in the VAX/VMS Debugger.
                                     0625  1342 ;---
                                     0625  1343 	header	break
                                 03  062F  1344 	bpt				; breakpoint
                                 05  0630  1345 	rsb				; end of break
                                     0631  1346 
                                     0631  1347 
                                     0631  1348 ;+++
                                     0631  1349 ;k> bs@ -- ( a -- l ) Fetch byte at `a' and sign extend it to longword on stack.
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  30
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0631  1350 ;---
                                     0631  1351 	header	i_bs_fetch,<bs@>
                    6B   00 BB   98  0639  1352 	cvtbl	@(r11),(r11)		; sign extend it
                                 05  063D  1353 	rsb				; end of bs@
                                     063E  1354 
                                     063E  1355 
                                     063E  1356 ;+++
                                     063E  1357 ;k> buffer -- ( l -- a ) Get buffer at `a' that will be written to block `l'.
                                     063E  1358 ;---
                                     063E  1359 	header	buffer
                                     0649  1360 ; Is the block already in memory?
                            50   D4  0649  1361 	clrl   r0			; start with buffer 0
                                     064B  1362 10$:
                            6B   D1  064B  1363 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       064D  1364 		v_buf_blk_nums[r0]	;   block we are looking for?
                            44   13  0653  1365 	beql	100$			; yes, go on
                    F2 50   03   F2  0655  1366 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     0659  1367 ;
                                     0659  1368 ; not in memory, so we have to get it in
                                     0659  1369 ;
                                     0659  1370 ; Are there unused buffers?
                            50   D4  0659  1371 	clrl	r0			; start with buffer 0
                                     065B  1372 20$:
                 00001B7D'EF40   95  065B  1373 	tstb	v_buf_inuse[r0]		; Is it in use?
                            25   13  0662  1374 	beql	90$			; no, read block into it
                    F3 50   03   F2  0664  1375 	aoblss	#c_max_blocks,r0,20$	; move to the next buffer, if any
                                     0668  1376 ; Are there any unmodified buffers?
                            50   D4  0668  1377 	clrl	r0
                                     066A  1378 30$:
                            02   91  066A  1379 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       066C  1380 		v_buf_inuse[r0]		;   been modified?
                            15   12  0672  1381 	bneq	90$			; no, read block into it
                    F2 50   03   F2  0674  1382 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     0678  1383 ; all buffers are modified, so we must write one out and use it.
                            50   D4  0678  1384 	clrl	r0			; for now, always use zero'th one
                       7A   50   D0  067A  1385 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  067D  1386 	movl	r0,-(r11)		; set up for buffer-write
                   000006FC'EF   16  0680  1387 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0686  1388 	movl	(r10)+,r0		; get the buffer number back
                                     0689  1389 ;
                                     0689  1390 ; come here with bloc## on stack and buffer# in r0.
                                     0689  1391 ;
                                     0689  1392 90$:
                                     0689  1393 ; save block info
                            6B   D0  0689  1394 	movl	(r11),-			; Save the new block number in
                 00001B80'EF40       068B  1395 		v_buf_blk_nums[r0]	;   buffer
                            01   90  0691  1396 	movb	#c_inuse,-		; Flag that buffer is in use
                 00001B7D'EF40       0693  1397 		v_buf_inuse[r0]
                                     0699  1398 
                                     0699  1399 100$:
                                     0699  1400 ; leave address of buffer on stack
         6B   00000400 8F   50   C5  0699  1401 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  06A1  1402 	addl2	#v_blkbuff,(r11)	; calculate address of `r0'th buffer
              00001B79'EF   50   D0  06A8  1403 	movl	r0,v_current_buff	; mark this as most current block
                                 05  06AF  1404 	rsb				; end of buffer
                                     06B0  1405 
                                     06B0  1406 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  31
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     06B0  1407 ;+++
                                     06B0  1408 ;k> buffer-read -- ( n -- a ) read into a block into buffer `n'.  The block
                                     06B0  1409 ;	number is already in the buffer.  Leave `a', the address of the
                                     06B0  1410 ;	block buffer.  This word assumes that buffer is correctly set up
                                     06B0  1411 ;	(block number, etc).
                                     06B0  1412 ;---
                                     06B0  1413 	header	i_buffer_read,<buffer-read>
                       50   8B   D0  06C0  1414 	movl	(r11)+,r0		; get buffer number
              00001B79'EF   50   D0  06C3  1415 	movl	r0,v_current_buff	; save buffer number as most current
         51   00000400 8F   50   C5  06CA  1416 	mull3	r0,#c_block_size,r1	; offset to `r0'th buffer
         7B   00004000'8F   51   C1  06D2  1417 	addl3	r1,#v_blkbuff,-(r11)	; put address of buffer on stack
                                     06DA  1418 					; this is left after exit
            7B   00001B80'EF40   D0  06DA  1419 	movl	v_buf_blk_nums[r0],-	; number of block
                                     06E2  1420 		-(r11)			;   to read
                    7B   04 AB   D0  06E2  1421 	movl	4(r11),-(r11)		; get another copy of the buffer address
                       FED1 CF   16  06E6  1422 	jsb	i_block_read		; read the block
                                 05  06EA  1423 	rsb				; end of buffer-read
                                     06EB  1424 
                                     06EB  1425 
                                     06EB  1426 ;+++
                                     06EB  1427 ;k> buffer-write -- ( n -- ) write block in buffer number n to file.
                                     06EB  1428 ;	Note that the block number is in the buffer already.
                                     06EB  1429 ;---
                                     06EB  1430 	header	i_buffer_write,<buffer-write>
                       50   8B   D0  06FC  1431 	movl	(r11)+,r0		; get buffer number
            7B   00001B80'EF40   D0  06FF  1432 	movl	v_buf_blk_nums[r0],-	; number of block
                                     0707  1433 		-(r11)			;   to write
         51   00000400 8F   50   C5  0707  1434 	mull3	r0,#c_block_size,r1	; offset into the buffer buffer
         7B   00004000'8F   51   C1  070F  1435 	addl3	r1,#v_blkbuff,-(r11)	; address of buffer to write
                                     0717  1436 					; this is left after exit
                       FED2 CF   16  0717  1437 	jsb	i_block_write		; write the block
                                 05  071B  1438 	rsb				; end of buffer-write
                                     071C  1439 
                                     071C  1440 
                                     071C  1441 ;+++
                                     071C  1442 ;k> byte -- ( n -- ) Creates word that pushes address of byte on stack and initializes the byte to `n'.
                                     071C  1443 ;---
                                     071C  1444 	header	byte,<byte>
                   00000846'EF   16  0725  1445 	jsb	create			; enclose next token in dictionary
                    89   9E 8F   90  072B  1446 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  072F  1447 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0733  1448 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0736  1449 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  073A  1450 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  073D  1451 	movb	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  0740  1452 	addl2	#4,r11			; pop argument
                                 05  0743  1453 	rsb				; end of byte
                                     0744  1454 
                                     0744  1455 
                                     0744  1456 ;+++t
                                     0744  1457 ;k> cfa -- ( a -- a ) given the address of the header of a word, return the address of
                                     0744  1458 ;	the code for that word (i.e., the Code Field Address).
                                     0744  1459 ;---
                                     0744  1460 ;??? the smudge bit makes this one a little harder.
                                     0744  1461 	header	cfa
                       6B   04   C0  074C  1462 	addl2	#4,(r11)		; skip over link field
                    50   00 BB   9A  074F  1463 	movzbl	@(r11),r0		; get unsigned length of name
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  32
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                    50   80 8F   8A  0753  1464 	bicb2	#^b10000000,r0		; clear smudge bit of length of name
                            6B   D6  0757  1465 	incl	(r11)			; skip over count byte
                       6B   50   C0  0759  1466 	addl2	r0,(r11)		; skip over name field
                                 05  075C  1467 	rsb				; end of cfa
                                     075D  1468 
                                     075D  1469 
                                     075D  1470 ;+++
                                     075D  1471 ;k> clist -- ( -- ) list compiler vocabulary.
                                     075D  1472 ;---
                                     075D  1473 	header	clist
              7B   00001D27'EF   D0  0767  1474 	movl	v_compiler,-(r11)	; get address of most recent word
                                     076E  1475 					;   in compiler vocabulary
                                     076E  1476 10$:
                            6B   D5  076E  1477 	tstl	(r11)			; nil pointer?
                            24   13  0770  1478 	beql	100$			; yes, exit loop
                  7B   04   6B   C1  0772  1479 	addl3	(r11),#4,-(r11)		; get address of name field
                       FCFF CF   16  0776  1480 	jsb	bcount			; set up for write
                       7B   6B   D0  077A  1481 	movl	(r11),-(r11)		; set up for ?cr
                       FB88 CF   16  077D  1482 	jsb	q_n_cr			; start new line if word is too long
                   00001454'EF   16  0781  1483 	jsb	write			; tell user
                       71   20   D0  0787  1484 	movl	#c_blank,-(r1)		; blank to separate words
                   00000DF2'EF   16  078A  1485 	jsb	putc			; output it
                    6B   00 BB   D0  0790  1486 	movl	@(r11),(r11)		; get previous word's lfa
                            D8   11  0794  1487 	brb	10$			; try it again
                                     0796  1488 100$:
                       5B   04   C0  0796  1489 	addl2	#4,r11			; pop pointer off stack
                                 05  0799  1490 	rsb				; end of clist
                                     079A  1491 
                                     079A  1492 
                                     079A  1493 ;+++t
                                     079A  1494 ;k> compile-jsb ( a -- ) compile a jump to subroutine to location `a'.
                                     079A  1495 ;---
                                     079A  1496 ;??? At the moment this uses absolute mode.  Should it use displacment
                                     079A  1497 ; off a register so that it can be ?relocatable (like stoic)?  Or should it
                                     079A  1498 ; use a brw (which I'm not sure would work in { defer< ... >defer }.
                                     079A  1499 	header	   i_compile_jsb,<compile-jsb>
                       89   16   90  07AA  1500 	movb	   #op_jsb,(r9)+	; `jsb'
                    89   9F 8F   90  07AD  1501 	movb	   #adm_absolute,(r9)+	; absolute mode
                       89   8B   D0  07B1  1502 	movl	   (r11)+,(r9)+		; save place to jump to in dictionary
                                 05  07B4  1503 	rsb				; end of compile-jsb
                                     07B5  1504 
                                     07B5  1505 
                                     07B5  1506 ;+++
                                     07B5  1507 ;k> compiletime -- ( -- ) move word defined to the compiler vocabulary.
                                     07B5  1508 ;	This word unlinks the last word in the current vocabulary and
                                     07B5  1509 ;	links it to the compiler vocabulary.  Compiiler words are *never*
                                     07B5  1510 ;	executed during execute mode.
                                     07B5  1511 ;---
                                     07B5  1512 	header	compiletime
              50   00001D23'FF   D0  07C5  1513 	movl	@v_current,r0		; save pointer to word we a unlinking
              00001D23'FF   60   D0  07CC  1514 	movl	(r0),@v_current		; make current previous word in vocab
              60   00001D27'EF   D0  07D3  1515 	movl	v_compiler,(r0)		; link word to prev in compiler vocab
              00001D27'EF   50   D0  07DA  1516 	movl	r0,v_compiler		; make v_compiler point to new word
                                 05  07E1  1517 	rsb				; end of compiletime
                                     07E2  1518 ;??? Should I also have immediate words, that execute in *both* compile
                                     07E2  1519 ; mode and execute mode?  This would require some sort of attribute flag,
                                     07E2  1520 ; which would have to be checked during compilation.  It would allow
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  33
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     07E2  1521 ; considerably more flexibility (remember how % started out a word and ended
                                     07E2  1522 ; up part of _interpreter because it was either compiletime or runtime?).
                                     07E2  1523 ;??? Much beter idea.  Have a compile buffer like STOIC and have only
                                     07E2  1524 ; compiletime and runtime words, both of which are in the same vocabulary.
                                     07E2  1525 ; If not inside a { : ... ; }, do a jsb at the end of the line? if in colon
                                     07E2  1526 ; definition, copy it to the dictionary and update dictionary links.
                                     07E2  1527 ; Have to think about this.
                                     07E2  1528 
                                     07E2  1529 
                                     07E2  1530 ;+++
                                     07E2  1531 ;k> context -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     07E2  1532 ;	vocabulary in which we currently search for words (the `context').
                                     07E2  1533 ;---
                                     07E2  1534 	header	context
              7B   00001D1F'EF   DE  07EE  1535 	moval	v_context,-(r11)	; move address of pointer to vocab
                                     07F5  1536 					; that is searched when defining
                                     07F5  1537 					; to stack
                                 05  07F5  1538 	rsb				; end of context
                                     07F6  1539 
                                     07F6  1540 
                                     07F6  1541 ;+++
                                     07F6  1542 ;k> count -- ( a1 -- a2 n ) Given word-counted string at `a' returns
                                     07F6  1543 ;	address of characters in string and string's length on top of stack.
                                     07F6  1544 ;---
                                     07F6  1545 	header	count
                    50   00 BB   3C  0800  1546 	movzwl	@(r11),r0		; get length of string
                       6B   02   C0  0804  1547 	addl2	#2,(r11)		; move pointer to first character
                       7B   50   D0  0807  1548 	movl	r0,-(r11)		; put count on top of stack
                                 05  080A  1549 	rsb				; end of count
                                     080B  1550 
                                     080B  1551 
                                     080B  1552 ;+++
                                     080B  1553 ;k> cr -- ( -- )  Start new output line (C_arriage R_eturn).
                                     080B  1554 ;---
                                     080B  1555 	header	cr
              7B   00001B9A'EF   9E  0812  1556 	movab	v_outbuf,-(r11)		; move address of output buffer on stack
              7B   00001B98'EF   3C  0819  1557 	movzwl	v_outlen,-(r11)		; put count on stack
           02 AB   00001B96'EF   B0  0820  1558 	movw	v_static_dsc,2(r11)	; put middle of descriptor on ~~~ Is this correct?
                            5B   DD  0828  1559 	pushl	r11			; push address of output descriptor
              00000000'GF   01   FB  082A  1560 	calls	#1,g^lib$put_output	; output it~~~ Really should check the return value!!!
                       5B   08   C0  0831  1561 	addl2	#8,r11			; pop descriptor off stack
                   00001B98'EF   B4  0834  1562 	clrw	v_outlen		; clear output length
                                 05  083A  1563 	rsb				; end of cr
                                     083B  1564 
                                     083B  1565 
                                     083B  1566 ;+++t
                                     083B  1567 ;k> create -- ( -- ) Enclose next token in input stream in the dictionary,
                                     083B  1568 ;	truncating it if it is too long.
                                     083B  1569 ;---
                                     083B  1570 	header	create
              69   00001D23'FF   D0  0846  1571 	movl	@v_current,(r9)		; make link field
              00001D23'FF   59   D0  084D  1572 	movl	r9,@v_current		; make vocab point to here, newest word
                       59   04   C0  0854  1573 	addl2	#4,r9			; move eodp over link field
                       7B   20   D0  0857  1574 	movl	#c_blank,-(r11)		; set up to get blank separated token
                   000012E6'EF   16  085A  1575 	jsb	token			; get token
              69   00000050 8F   D1  0860  1576 	cmpl	#c_max_name_len,(r9)	; is the name over the maximum length?
                            46   12  0867  1577 	bneq	10$			; no, go on
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  34
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

              7B   000018D8'EF   9E  0869  1578 	movab	v_nametoolong,-(r11)	; address of error message on stack
                       FC05 CF   16  0870  1579 	jsb	bcount			; get ( addr count )
                   00001454'EF   16  0874  1580 	jsb	write			; write out message
                  7B   59   01   C1  087A  1581 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9E  087E  1582 	movab	(r9),-(r11)		; count of name
                   00001454'EF   16  0881  1583 	jsb	write			; write out untruncated name
                         88 AF   16  0887  1584 	jsb	cr			; start new line
              69   00000050 8F   D0  088A  1585 	movl	#c_max_name_len,(r9)	; truncate name
              7B   000018E8'EF   9E  0891  1586 	movab	v_nametrunc,-(r11)	; get address of stack
                       FBDD CF   16  0898  1587 	jsb	bcount			; get ( addr count )
                   00001454'EF   16  089C  1588 	jsb	write			; write out message
                  7B   59   01   C1  08A2  1589 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9A  08A6  1590 	movzbl	(r9),-(r11)		; count of name
                   00001454'EF   16  08A9  1591 	jsb	write			; write out truncated name
                                     08AF  1592 10$:
                       50   89   9A  08AF  1593 	movzbl	(r9)+,r0		; get byte length and move over it
                       59   50   C0  08B2  1594 	addl2	r0,r9			; move over string
                       69   05   90  08B5  1595 	movb	#op_rsb,(r9)		; stick a `rsb' in just in case
                                 05  08B8  1596 	rsb				; end of create
                                     08B9  1597 
                                     08B9  1598 
                                     08B9  1599 ;+++
                                     08B9  1600 ;k> current -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     08B9  1601 ;	vocabulary we link new words into.
                                     08B9  1602 ;---
                                     08B9  1603 	header	current
              7B   00001D23'EF   DE  08C5  1604 	moval	v_current,-(r11)	; move address (of pointer to vocab
                                     08CC  1605 					; that new words are linked to when
                                     08CC  1606 					; defining) to stack
                                 05  08CC  1607 	rsb				; end of current
                                     08CD  1608 
                                     08CD  1609 
                                     08CD  1610 ;+++
                                     08CD  1611 ;k> decimal -- ( -- ) Set base to decimal.
                                     08CD  1612 ;---
                                     08CD  1613 	header	decimal
              00001D36'EF   0A   D0  08D9  1614 	movl	#10,v_radix		; switch to base 10
                                 05  08E0  1615 	rsb				; end of decimal
                                     08E1  1616 
                                     08E1  1617 
                                     08E1  1618 ;+++
                                     08E1  1619 ;k> definitions -- ( -- )  Sets curren to context. { <name> definitions }
                                     08E1  1620 ;	makes all new words link into vocabulary { <name> }
                                     08E1  1621 ;	(i.e., new operators will be linked dictionary currently being searched).
                                     08E1  1622 ;---
                                     08E1  1623 	header	definitions
     00001D23'EF   00001D1F'EF   D0  08F1  1624 	movl	v_context, v_current
                                 05  08FC  1625 	rsb				; end of definitions
                                     08FD  1626 
                                     08FD  1627 
                                     08FD  1628 ;+++
                                     08FD  1629 ;k> drop -- ( n -- ) Drop the top stack item.
                                     08FD  1630 ;---
                                     08FD  1631 	header	drop
                       5B   04   C0  0906  1632 	addl2	#4,r11			; pop argument, dropping top item
                                 05  0909  1633 	rsb				; end of drop
                                     090A  1634 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  35
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     090A  1635 
                                     090A  1636 ;+++
                                     090A  1637 ;k> ds>ls -- ( n -- ) move `n' to loop stack.
                                     090A  1638 ;---
                                     090A  1639 	header	i_ds_to_ls,^/ds>ls/
                       7A   8B   D0  0914  1640 	movl	(r11)+,-(r10)		; pop from dstack, move to lstack.
                                 05  0917  1641 	rsb				; end of ds>ls
                                     0918  1642 
                                     0918  1643 
                                     0918  1644 ;+++
                                     0918  1645 ;k> dup -- ( n -- n n ) Duplicated the top stack entry.
                                     0918  1646 ;---
                                     0918  1647 	header	dup
                       7B   6B   D0  0920  1648 	movl	(r11),-(r11)
                                 05  0923  1649 	rsb				; end of dup
                                     0924  1650 
                                     0924  1651 
                                     0924  1652 ;+++
                                     0924  1653 ;k> empty-buffers -- ( -- ) Mark all buffers unmodified without writing.
                                     0924  1654 ;---
                                     0924  1655 	header	i_empty_buffers,<empty-buffers>
                            50   D4  0936  1656 	clrl	r0			; buffer number
                                     0938  1657 10$:
                            00   90  0938  1658 	movb	#c_false,-		; mark with c_false to show
                 00001B7D'EF40       093A  1659 		v_buf_inuse[r0]		;   emptied, not in use
                            00   D0  0940  1660 	movl	#c_false,-		; mark with c_false to show
                 00001B80'EF40       0942  1661 		v_buf_blk_nums[r0]	;  holds no block number
                            02   F1  0948  1662 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFEA 50   01       094A  1663 		#1,r0,10$		; move to next buffer number, if any
                                 05  094E  1664 	rsb				; end of empty buffers
                                     094F  1665 
                                     094F  1666 
                                     094F  1667 ;
                                     094F  1668 ;??? Note: the `eodp' words are supplied so that the user can work with the
                                     094F  1669 ;	dictionary without having to know if eodp is a register or a variable.
                                     094F  1670 ;
                                     094F  1671 
                                     094F  1672 
                                     094F  1673 ;+++
                                     094F  1674 ;k> eodp -- ( -- a ) Return address of next free byte in dictionary.
                                     094F  1675 ;	Means "end of dictinary pointer".
                                     094F  1676 ;---
                                     094F  1677 	header	eodp
                       7B   59   D0  0958  1678 	movl	r9,-(r11)		; get
                                 05  095B  1679 	rsb				; end of eodp
                                     095C  1680 
                                     095C  1681 
                                     095C  1682 ;+++
                                     095C  1683 ;k> eodp! -- ( a -- ) Make `a' new value of end of dictionary  pointer.
                                     095C  1684 ;---
                                     095C  1685 	header	i_eod_store,<eodp!>
                       59   8B   D0  0966  1686 	movl	(r11)+,r9		; make eodp = top of stack
                                 05  0969  1687 	rsb				; end of edop!
                                     096A  1688 
                                     096A  1689 
                                     096A  1690 ;+++
                                     096A  1691 ;k> eodp+! -- ( n -- ) Add `n' to end of dictionary pointer.
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  36
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     096A  1692 ;---
                                     096A  1693 	header	i_eodp_plus_store,<eodp+!>
                       59   8B   C0  0975  1694 	addl2	(r11)+,r9		; add top of stack to eodp
                                 05  0978  1695 	rsb				; end of eodp+!
                                     0979  1696 
                                     0979  1697 
                                     0979  1698 ;+++
                                     0979  1699 ;k> eve -- call up eve editor.	Format: { eve filename }.
                                     0979  1700 ;---
                                     0979  1701 	header	eve
                       7B   20   D0  0981  1702 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012E6'EF   16  0984  1703 	jsb	token			; get the token
                       56   69   9A  098A  1704 	movzbl	(r9),r6			; save length
                  57   59   01   C1  098D  1705 	addl3	#1,r9,r7		; start of string
         00001C3E'EF   67   56   28  0991  1706 	movc3	r6,(r7),v_tpu_com2	; move string into buffer
         00001CDE'EF   56   04   A1  0999  1707 	addw3	#c_tpu_com_len,r6,-	; put length in descriptor
                                     09A1  1708 		v_tpu_dsc
                   00001CDE'EF   7F  09A1  1709 	pushaq	v_tpu_dsc		; push address of command
              00000000'GF   01   FB  09A7  1710 	calls	#1,g^tpu$tpu		; call tpu
                         01 50   E9  09AE  1711 	blbc	r0,10$			; ?error
                                 05  09B1  1712 	rsb				; no, exit
                                     09B2  1713 10$:					; yes, signal and patch
                            50   DD  09B2  1714 	pushl	r0			; set up for signal
              00000000'GF   01   FB  09B4  1715 	calls	#1,g^lib$signal		; signal it
                          1018   31  09BB  1716 	brw	r_warm_start		; patch VTIL to run
                                     09BE  1717 					; end of eve
                                     09BE  1718 
                                     09BE  1719 
                                     09BE  1720 ;+++
                                     09BE  1721 ;k> exit -- ( -- ) Exit VTIL.  Never returns.
                                     09BE  1722 ;---
                                     09BE  1723 	header	i_exit,<exit>
                          11C5   31  09C7  1724 	brw	_exit			; exit silently
                                     09CA  1725 
                                     09CA  1726 
                                     09CA  1727 ;+++
                                     09CA  1728 ;k> fill -- ( a w c -- l ) Fill `w' bytes from `a' with character `c'.
                                     09CA  1729 ;---
                                     09CA  1730 	header	fill
                       69   00   2C  09D3  1731 	movc5	#0,(r9),-		; srclen,src (use eodp just to be safe)
                            6B       09D6  1732 		(r11),-			; fill character
                 08 BB   04 AB       09D7  1733 		4(r11),@8(r11)		; destlen, dest
                       5B   0C   C0  09DB  1734 	addl2	#12,r11			; pop arguments
                                 05  09DE  1735 	rsb				; end of fill
                                     09DF  1736 
                                     09DF  1737 
                                     09DF  1738 ;+++
                                     09DF  1739 ;k> flush-buffers -- ( -- ) wite all modified buffers and mark them unmodified.
                                     09DF  1740 ;---
                                     09DF  1741 	header	i_flush_buffers,<flush-buffers>
                            50   D4  09F1  1742 	clrl	r0			; bufffer number
                                     09F3  1743 10$:
                            02   91  09F3  1744 	cmpb	#c_modified,-		; Has the buffer
                 00001B7D'EF40       09F5  1745 		v_buf_inuse[r0]		;   been modified?
                            15   12  09FB  1746 	bneq	20$			; no, skip it
                       7A   50   D0  09FD  1747 	movl	r0,-(r10)		; save the buffer name
                       7B   50   D0  0A00  1748 	movl	r0,-(r11)		; set up for buffer-write
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  37
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                       FCF5 CF   16  0A03  1749 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0A07  1750 	movl	(r10)+,r0		; get the buffer number back
                            00   90  0A0A  1751 	movb	#c_false,-		; mark the buffer as
                 00001B7D'EF40       0A0C  1752 		v_buf_inuse[r0]		;   flushed, not in use
                                     0A12  1753 20$:
                            02   F1  0A12  1754 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFDB 50   01       0A14  1755 		#1,r0,10$		; move to next buffer number, if any
                                 05  0A18  1756 	rsb				; end of flush-buffers
                                     0A19  1757 
                                     0A19  1758 
                                     0A19  1759 ;+++
                                     0A19  1760 ;k> forget -- ( -- ) reset content vocab back to word before word forgotten.
                                     0A19  1761 ;	Note that while this makes the forgotten word and any words
                                     0A19  1762 ;	defined after it unavailale, it does not reclaim an space,
                                     0A19  1763 ;	since the other vocabularies can be threaded through in the
                                     0A19  1764 ;	dictionary between words of this vocabulary.
                                     0A19  1765 ;---
                                     0A19  1766 ;??? Should I make { forget } = { forget/erase }?  Why did I make both
                                     0A19  1767 ; in the first place?
                                     0A19  1768 	header	forget
                       7B   20   D0  0A24  1769 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012E6'EF   16  0A27  1770 	jsb	token			; get token
              7B   00001D1F'FF   D0  0A2D  1771 	movl	@v_context,-(r11)	; start search at context
                   00000F8A'EF   16  0A34  1772 	jsb	search			; search it
                            8B   D5  0A3A  1773 	tstl	(r11)+			; Was it found?
                            0C   13  0A3C  1774 	beql	100$			; No, tell user
                                     0A3E  1775 ; make vocab point to word before the forgotten one.
           00001D1F'FF   00 BB   D0  0A3E  1776 	movl	@(r11),@v_context	;
                       5B   04   C0  0A46  1777 	addl2	#4,r11			; pop address of found word
                                 05  0A49  1778 	rsb				; exit
                                     0A4A  1779 100$:
              7B   000018C7'EF   9E  0A4A  1780 	movab	v_wordnotfound,-(r11)	; put address of error message on stack
                       FA24 CF   16  0A51  1781 	jsb	bcount			; get address of text and length
                   00001454'EF   16  0A55  1782 	jsb	write			; write error message
                       7B   59   D0  0A5B  1783 	movl	r9,-(r11)		; address of token not found in search
                       FA17 CF   16  0A5E  1784 	jsb	bcount			; get address of text and length
                   00001454'EF   16  0A62  1785 	jsb	write			; write the name of the word
                          0F6B   31  0A68  1786 	brw	r_warm_start		; end of forget
                                     0A6B  1787 
                                     0A6B  1788 
                                     0A6B  1789 ;+++
                                     0A6B  1790 ;k> forget/erase -- ( -- ) rset context vocab to word before word forgotten
                                     0A6B  1791 ;	and move the dictinary back to header address of word forgotten.
                                     0A6B  1792 ;	In other words, dictinary is truncated BEFORE the word forgotten. ~~~Add warning
                                     0A6B  1793 ;---
                                     0A6B  1794 	header	i_forget_erase,<forget/erase>
                       7B   20   D0  0A7C  1795 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012E6'EF   16  0A7F  1796 	jsb	token			; get token
              7B   00001D1F'FF   D0  0A85  1797 	movl	@v_context,-(r11)	; start search at contxt
                   00000F8A'EF   16  0A8C  1798 	jsb	search			; search it
                            8B   D5  0A92  1799 	tstl	(r11)+			; Was it found?
                            0F   13  0A94  1800 	beql	100$			; No, tell user
                                     0A96  1801 ; make vocab point to word before the forgotten one.
           00001D1F'FF   00 BB   D0  0A96  1802 	movl	@(r11),@v_context
                       59   6B   D0  0A9E  1803 	movl	(r11),r9		; truncate dictionary
                       6B   04   C0  0AA1  1804 	addl2	#4,(r11)		; pop address of found word
                                 05  0AA4  1805 	rsb				; return
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  38
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0AA5  1806 100$:
              7B   000018C7'EF   9E  0AA5  1807 	movab	v_wordnotfound,-(r11)	;
                       F9C9 CF   16  0AAC  1808 	jsb	bcount			; get address of text and length
                   00001454'EF   16  0AB0  1809 	jsb	write			; write error message
                       7B   59   D0  0AB6  1810 	movl	r9,-(r11)		; address of token not found in search
                       F9BC CF   16  0AB9  1811 	jsb	bcount			; get addres of text and length
                   00001454'EF   16  0ABD  1812 	jsb	write			; write the name of the word ~~ not found
                          0F10   31  0AC3  1813 	brw	r_warm_start		; end of forget/erase
                                     0AC6  1814 
                                     0AC6  1815 
                                     0AC6  1816 ;+++
                                     0AC6  1817 ;k> freemem -- ( -- l ) print amount of memory left in dictionary
                                     0AC6  1818 ;--- ~~~ does it really leave a longword on the stack?
                                     0AC6  1819 	header	freemem
         7B   00004000'8F   59   C3  0AD2  1820 	subl3	r9,#c_dict_end,-(r11)	; put free space on stack
                       F645 CF   16  0ADA  1821 	jsb	i_dot			; print it
                                 05  0ADE  1822 	rsb				; end of freemem
                                     0ADF  1823 
                                     0ADF  1824 
                                     0ADF  1825 ;+++
                                     0ADF  1826 ;k> halt -- ( l -- ) halt VTIL, use `l' as returned value.  Never returns. ~~~ Change "returned value" to "exit status?
                                     0ADF  1827 ;---
                                     0ADF  1828 	header	i_halt,<halt>
                       50   8B   D0  0AE8  1829 	movl	(r11)+,r0		; put error number in right place
                          106E   31  0AEB  1830 	brw	_error_exit		; go to error exit routine
                                     0AEE  1831 					; end of halt
                                     0AEE  1832 
                                     0AEE  1833 
                                     0AEE  1834 ;+++
                                     0AEE  1835 ;k> hex -- ( -- ) Set the base to hexidecimal.
                                     0AEE  1836 ;---
                                     0AEE  1837 	header	hex
              00001D36'EF   10   D0  0AF6  1838 	movl	#16,v_radix		; switch to base 16 (hexadecimal)
                                 05  0AFD  1839 	rsb				; end of hex
                                     0AFE  1840 
                                     0AFE  1841 
                                     0AFE  1842 ;+++
                                     0AFE  1843 ;k> hld -- ( -- a ) Variable hld, return address of hld.
                                     0AFE  1844 ;---
                                     0AFE  1845 	header	hld
              7B   00001D3A'EF   DE  0B06  1846 	moval	v_hld,-(r11)		; leave address on stack
                                 05  0B0D  1847 	rsb				; end of hld
                                     0B0E  1848 
                                     0B0E  1849 
                                     0B0E  1850 ;+++
                                     0B0E  1851 ;k> hold -- ( c -- ) Insert `c' in current numeric output string.
                                     0B0E  1852 ;---
                                     0B0E  1853 	header	hold
                   00001D3A'EF   D7  0B17  1854 	decl	v_hld			; move pointer down one char
              00001D3A'FF   6B   90  0B1D  1855 	movb	(r11),@v_hld		; fill new char w/top of stack
                       5B   04   C0  0B24  1856 	addl2	#4,r11			; pop char off stack
                                 05  0B27  1857 	rsb				; end of hold
                                     0B28  1858 
                                     0B28  1859 
                                     0B28  1860 ;+++
                                     0B28  1861 ;k> i> -- ( -- ) Copy the top of the loop stack to the data stack.
                                     0B28  1862 ;	This word is used inside of { do ... loop }'s to get the index
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  39
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0B28  1863 ;	of the innermost loop onto the top of the stack.
                                     0B28  1864 ;---
                                     0B28  1865 	header	i_i_to,^\i>\
                       7B   6A   D0  0B2F  1866 	movl	(r10),-(r11)		; copy w/o consuming ~~~ from loop stack.
                                 05  0B32  1867 	rsb				; end of i>
                                     0B33  1868 
                                     0B33  1869 
                                     0B33  1870 ;+++
                                     0B33  1871 ;k> kernel -- ( -- ) Set context to kernel vocabulary.
                                     0B33  1872 ;---
                                     0B33  1873 	header	kernel
     00001D1F'EF   00001D2B'EF   DE  0B3E  1874 	moval	v_kernel,v_context
                                 05  0B49  1875 	rsb				; end of kernel
                                     0B4A  1876 
                                     0B4A  1877 
                                     0B4A  1878 ;+++
                                     0B4A  1879 ;k> leave -- ( -- ) Leave a { do } loop at end of this iteration.
                                     0B4A  1880 ;---
                                     0B4A  1881 	header	leave
                    04 AA   6A   D0  0B54  1882 	movl	(r10),4(r10)		; make limit = index so loop will exit
                                 05  0B58  1883 	rsb				; end of leave
                                     0B59  1884 
                                     0B59  1885 
                                     0B59  1886 ;+++
                                     0B59  1887 ;k> load -- ( -- ) Take input from file instead of the terminal.
                                     0B59  1888 ;	Format: { load filename }
                                     0B59  1889 ;---
                                     0B59  1890 	header	load
                       7B   20   D0  0B62  1891 	movl	#c_blank,-(r11)		; set up for blank terminated file name
                   000012E6'EF   16  0B65  1892 	jsb	token			; get v_fname
                       56   69   9A  0B6B  1893 	movzbl	(r9),r6			; get count of v_fname
      00001A3D'EF   01 A9   56   28  0B6E  1894 	movc3	r6,1(r9),v_fname	; move to name buffer
              00001A3C'EF   56   90  0B77  1895 	movb	r6,v_fnamelen		; save length
                   00001A3D'EF   DE  0B7E  1896 	moval	v_fname,-
                   000019D4'EF       0B84  1897 		v_infab+fab$l_fna	; tell it where filespec is
                   00001A3C'EF   90  0B89  1898 	movb	v_fnamelen,-
                   000019DC'EF       0B8F  1899 		v_infab+fab$b_fns	; tell it what size filespec is
                                     0B94  1900 	$open	fab=v_infab		; open input file
                         12 50   E9  0BA1  1901 	blbc	r0,10$			; Quit on error
                                     0BA4  1902 	$connect rab=v_inrab		; connect to input
                         23 50   E9  0BB1  1903 	blbc	r0,20$			; Quit on error
                            2B   11  0BB4  1904 	brb	40$			; branch to read loop
                                     0BB6  1905 10$:
              00000000'8F   50   D1  0BB6  1906 	cmpl	r0,#rms$_fnf		; is it file not found?
                            0E   12  0BBD  1907 	bneq	15$			; no
                   0000189A'EF   7F  0BBF  1908 	pushaq	v_filenotfound		;
              00000000'GF   01   FB  0BC5  1909 	calls	#1,g^lib$put_output	; Tell user file not found
                                 05  0BCC  1910 	rsb				; return
                                     0BCD  1911 15$:
              56   000019A8'EF   DE  0BCD  1912 	moval	v_infab,r6		; error: keep fab address
                          0F8F   31  0BD4  1913 	brw	_f_err			; signal file error
                                     0BD7  1914 20$:
              56   000019F8'EF   DE  0BD7  1915 	moval	v_inrab,r6		; keep rab address
                          0F94   31  0BDE  1916 	brw	_r_err			; signal record error
                                     0BE1  1917 40$:
           00001D2F'EF   FF 8F   90  0BE1  1918 	movb	#c_true,v_infile	; set input from file flag
              00001D30'EF   00   D0  0BE9  1919 	movl	#0,v_filelinenum	; reinitialize number of lines read
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  40
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  0BF0  1920 	rsb				; end of load
                                     0BF1  1921 
                                     0BF1  1922 
                                     0BF1  1923 ;+++t
                                     0BF1  1924 ;k> long -- ( n -- ) Create a word that pushed address of longword on stack,
                                     0BF1  1925 ;	save space in dictionary, and initialize to `n'.
                                     0BF1  1926 ;---
                                     0BF1  1927 	header	i_long,<long>
                       FC48 CF   16  0BFA  1928 	jsb	create			; enclose next token in dictionary
                    89   DE 8F   90  0BFE  1929 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  0C02  1930 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0C06  1931 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0C09  1932 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0C0D  1933 	movb	#op_rsb,(r9)+		; `rsb'
                       89   8B   D0  0C10  1934 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                                 05  0C13  1935 	rsb				; end of long
                                     0C14  1936 
                                     0C14  1937 
                                     0C14  1938 ;+++t
                                     0C14  1939 ;k> longconst -- ( n -- ) Create a word that pushed a `n' to the stack.
                                     0C14  1940 ;---
                                     0C14  1941 	header	longconst
                       FC20 CF   16  0C22  1942 	jsb	create			; enclose next token in dictionary
                   000017A3'EF   16  0C26  1943 	jsb	literal			; enclose code in dictionary
                       89   05   90  0C2C  1944 	movb	#op_rsb,(r9)+		; stick `rsb' into dictionary to
                                     0C2F  1945 					;   end constant word
                                 05  0C2F  1946 	rsb				; end of longconst
                                     0C30  1947 
                                     0C30  1948 
                                     0C30  1949 ;+++
                                     0C30  1950 ;k> ls>ds -- ( -- n ) Remove `n' from loop stack.
                                     0C30  1951 ;---
                                     0C30  1952 	header	i_ls_to_ds,^/ls>ds/
                       7B   8A   D0  0C3A  1953 	movl	(r10)+,-(r11)		; pop from loop stack, move to dstack
                                 05  0C3D  1954 	rsb				; end of ls>ds
                                     0C3E  1955 
                                     0C3E  1956 
                                     0C3E  1957 ;+++
                                     0C3E  1958 ;k> match -- ( a1 n1 a2 n2 -- a3 ? f ) Search for string of length `n2' at
                                     0C3E  1959 ;	`a2' in string of length `n' at `a'.
                                     0C3E  1960 ;---
                                     0C3E  1961 	header	i_match,<match>
                    04 BB   6B   39  0C48  1962 	matchc	(r11),@4(r11),-		; object string (one we're looking for)
                 0C BB   08 AB       0C4C  1963 		8(r11),@12(r11)		; source string (one we're looking in)
                            12   12  0C50  1964 	bneq	100$			; no match found
                                     0C52  1965 ; match found, calcualte its address.  matchc leaves in r3 the address of the
                                     0C52  1966 ; byte after last byte matched in the source string, so address of matched
                                     0C52  1967 ; string is r3 - objectlen.
                  50   53   61   C3  0C52  1968 	subl3  (r1),r3,r0		; calculate address of matched string
                       5B   10   C0  0C56  1969 	addl2  #16,r11			; pop arguments
                       7B   50   D0  0C59  1970 	movl   r0,-(r11)		; put address of matched string on stack
              7B   FFFFFFFF 8F   D0  0C5C  1971 	movl   #c_true,-(r11)		; leave true on top of stack
                                 05  0C63  1972 	rsb				; return
                                     0C64  1973 100$:
                                     0C64  1974 ; no match found
                       5B   10   C0  0C64  1975 	addl2	#16,r11			; pop arguments
                       7B   00   D0  0C67  1976 	movl	#c_false,-(r11)		; leave a false ~~~ on top of stack
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  41
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  0C6A  1977 	rsb				; end of match
                                     0C6B  1978 
                                     0C6B  1979 
                                     0C6B  1980 ;+++
                                     0C6B  1981 ;k> max -- ( n1 n2 -- n2 ) Leave larger of n1 and n2 on stack.
                                     0C6B  1982 ;---
                                     0C6B  1983 	header	max
                    04 AB   6B   D1  0C73  1984 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   15  0C77  1985 	bleq	10$			; Top less than under item?
                                     0C79  1986 ; no, top greater
                    04 AB   6B   D0  0C79  1987 	movl	(r11),4(r11)		; move greater down stack
                                     0C7D  1988 10$:
                       5B   04   C0  0C7D  1989 	addl2	#4,r11			; pop first argument, since
                                     0C80  1990 					;   great is in second item now
                                 05  0C80  1991 	rsb				; end of max
                                     0C81  1992 
                                     0C81  1993 
                                     0C81  1994 ;+++
                                     0C81  1995 ;k> message -- ( a -- ) writes word-counted string at `a' to terminal.
                                     0C81  1996 ;---
                                     0C81  1997 	header	message
                       FB6F CF   16  0C8D  1998 	jsb	count			; set up for write
                   00001454'EF   16  0C91  1999 	jsb	write			; write it out
                                 05  0C97  2000 	rsb				; end of message
                                     0C98  2001 
                                     0C98  2002 
                                     0C98  2003 ;+++
                                     0C98  2004 ;k> min -- ( n1 n2 -- n2 ) Leaves small or n1 and n2 on stack.
                                     0C98  2005 ;---
                                     0C98  2006 	header	min
                    04 AB   6B   D1  0CA0  2007 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   18  0CA4  2008 	bgeq	10$			; Top is greater than under item
                    04 AB   6B   D0  0CA6  2009 	movl	(r11),4(r11)		;
                                     0CAA  2010 10$:
                       5B   04   C0  0CAA  2011 	addl2	#4,r11			; pop top stack item since lesser is
                                     0CAD  2012 					;   in second line.
                                 05  0CAD  2013 	rsb				; end of min
                                     0CAE  2014 
                                     0CAE  2015 
                                     0CAE  2016 ;+++
                                     0CAE  2017 ;k> mod -- ( n1 n2 -- n3 ) Leave remainder of n1 / n2 on stack.
                                     0CAE  2018 ;---
                                     0CAE  2019 	header	mod
               50   04 AB   6B   C7  0CB6  2020 	divl3	(r11),4(r11),r0		; r0 = n1 / n2
                  51   8B   50   C5  0CBB  2021 	mull3	r0,(r11)+,r1		; temp = n2 * n3
                       6B   51   C2  0CBF  2022 	subl2	r1,(r11)		; n3 = n1 - quotient
                                 05  0CC2  2023 	rsb				; end of mod
                                     0CC3  2024 
                                     0CC3  2025 
                                     0CC3  2026 ;+++
                                     0CC3  2027 ;k> move -- ( a1 a2 w -- ) Copies `w' bytes from `a1' to `a2'.
                                     0CC3  2028 ;---
                                     0CC3  2029 	header	move
            04 BB   08 BB   6B   28  0CCC  2030 	movc3	(r11),@8(r11),@4(r11)	;
                       5B   0C   C0  0CD2  2031 	addl2	#12,r11			; pop arguments
                                 05  0CD5  2032 	rsb				; end of move
                                     0CD6  2033 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  42
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0CD6  2034 
                                     0CD6  2035 ;+++
                                     0CD6  2036 ;k> move&fill -- ( a1 w1 a2 w2 c -- ) copies bytes from `a1' to `a2'.
                                     0CD6  2037 ;	If `w2' > `wl', fill with c.  If `w2' < `w1', truncate.
                                     0CD6  2038 ;---
                                     0CD6  2039 	header	i_move_fill,<move&fill>
                 10 BB   0C AB   2C  0CE4  2040 	movc5	12(r11),@16(r11),-	; sourcelen, source
                            6B       0CE9  2041 		(r11),-			; fill character
                 08 BB   04 AB       0CEA  2042 		4(r11),@8(r11)		; destlen, destination
                       5B   14   C0  0CEE  2043 	addl2	#20,r11			; pop arguments
                                 05  0CF1  2044 	rsb				; end of move/fill
                                     0CF2  2045 
                                     0CF2  2046 
                                     0CF2  2047 ;+++
                                     0CF2  2048 ;k> negate -- ( n -- -n )  Leave two's complement of top stack item on stack.
                                     0CF2  2049 ;---
                                     0CF2  2050 	header	negage
                       6B   6B   CE  0CFD  2051 	mnegl	(r11),(r11)		; negate it
                                 05  0D00  2052 	rsb				; end of negate
                                     0D01  2053 
                                     0D01  2054 
                                     0D01  2055 ;+++
                                     0D01  2056 ;k> not -- ( f1 -- f2 ) Logical not of top  of stack; not f1.
                                     0D01  2057 ;---
                                     0D01  2058 	header	not
                            8B   D5  0D09  2059 	tstl	(r11)+			; Is it false?
                            04   13  0D0B  2060 	beql	10$			; yes
                       7B   00   D0  0D0D  2061 	movl	#c_false,-(r11)		; no, leave with false on stack
                                 05  0D10  2062 	rsb				; return
                                     0D11  2063 10$:
              7B   FFFFFFFF 8F   D0  0D11  2064 	movl	#c_true,-(r11)		; it is false, leave with true on stack
                                 05  0D18  2065 	rsb				; end of not
                                     0D19  2066 
                                     0D19  2067 
                                     0D19  2068 ;+++t
                                     0D19  2069 ;k> number -- ( -- n ? f ) Try to turn token at eodp into a number.  If
                                     0D19  2070 ;	it is a number, leave ( number true ) on stack.  If it is not a number
                                     0D19  2071 ;	leave ( false ) on stack.
                                     0D19  2072 ;---
                                     0D19  2073 	header	number
                            50   D4  0D24  2074 	clrl	r0			; clear result
                            51   D4  0D26  2075 	clrl	r1			; clear sign
                       56   59   D0  0D28  2076 	movl	r9, r6			; get pointer to token
                       57   86   9A  0D2B  2077 	movzbl	(r6)+,r7		; get byte count
                       66   2D   91  0D2E  2078 	cmpb	#^a/-/,(r6)		; does it have a leading minus sign?
                            07   12  0D31  2079 	bneq	_number_top		; no, go on
                       51   01   D0  0D33  2080 	movl	#1,r1			; yes, set flag
                            56   D6  0D36  2081 	incl	r6			; advance over sign
                            57   D7  0D38  2082 	decl	r7			; length = length - 1
                                     0D3A  2083 _number_top:
                       52   66   9A  0D3A  2084 	movzbl	(r6),r2			; get byte
                       52   30   C2  0D3D  2085 	subl2	#^x30,r2			; check in range 0...9
                            52   D5  0D40  2086 	tstl	r2			; Is it negative?
                            52   19  0D42  2087 	blss	_invalid_number		; yes, leave with false
                       09   52   D1  0D44  2088 	cmpl	r2,#9			; r2 <= 9
                            20   15  0D47  2089 	bleq	_check_base		; yes, continue
                       11   52   D1  0D49  2090 	cmpl	r2,#^x11		; Is it A or greater?
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  43
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                            48   19  0D4C  2091 	blss	_invalid_number		; no, leave with false
                       2A   52   D1  0D4E  2092 	cmpl	r2,#^x2a		; is it Z or less
                            05   14  0D51  2093 	bgtr	_check_lowercase	; no, go check if lower case
                       52   07   C2  0D53  2094 	subl2	#7,r2			; convert to ^xA...^xZ
                            11   11  0D56  2095 	brb	_check_base		; now check if it is valid in current
                                     0D58  2096 					; base
                                     0D58  2097 _check_lowercase:
                       31   52   D1  0D58  2098 	cmpl	r2,#^x31		; Is it a or greater?
                            39   19  0D5B  2099 	blss	_invalid_number		; no, leave with false
              0000004A 8F   52   D1  0D5D  2100 	cmpl	r2,#^x4a		; Is it z or less?
                            30   14  0D64  2101 	bgtr	_invalid_number		; no, leave with false.
                       52   27   C2  0D66  2102 	subl2	#^x27,r2		; convert to ^xA...^xZ
                                     0D69  2103 _check_base:
              00001D36'EF   52   D1  0D69  2104 	cmpl	r2,v_radix		; is it in set 0... base-1?
                            24   18  0D70  2105 	bgeq	_invalid_number		; no, leave w/false
              50   00001D36'EF   C4  0D72  2106 	mull2	v_radix,r0		; result = result * base
                       50   52   C0  0D79  2107 	addl2	r2,r0			; result = result + num
                            57   D7  0D7C  2108 	decl	r7			; count = count - 1
                            56   D6  0D7E  2109 	incl	r6			; move to next byte in number
                            57   D5  0D80  2110 	tstl	r7			; count = 0?
                            B6   14  0D82  2111 	bgtr	_number_top		; no, do it again
                            51   D5  0D84  2112 	tstl	r1			; negative?
                            03   13  0D86  2113 	beql	20$			; no
                       50   50   CE  0D88  2114 	mnegl	r0,r0			; yes, negate it.
                                     0D8B  2115 20$:
                       7B   50   D0  0D8B  2116 	movl	r0,-(r11)		; put result on stack
              7B   FFFFFFFF 8F   D0  0D8E  2117 	movl	#c_true,-(r11)		; put true on stack
                                 05  0D95  2118 	rsb				; exit with ( number true ) on dstack
                                     0D96  2119 _invalid_number:
                       7B   00   D0  0D96  2120 	movl	#c_false,-(r11)		; exit with ( false ) on dstack
                                 05  0D99  2121 	rsb				; end of number
                                     0D9A  2122 
                                     0D9A  2123 
                                     0D9A  2124 ;+++
                                     0D9A  2125 ;,> octal -- ( -- ) Set the base to octal.
                                     0D9A  2126 ;---
                                     0D9A  2127 	header	octal
              00001D36'EF   08   D0  0DA4  2128 	movl	#8,v_radix		; Switch to base 8
                                 05  0DAB  2129 	rsb				; end of octal
                                     0DAC  2130 
                                     0DAC  2131 
                                     0DAC  2132 ;+++t
                                     0DAC  2133 ;k> or -- ( f1 f2 -- f ) Logical or, f1 or f2.
                                     0DAC  2134 ;---
                                     0DAC  2135 	header	or
                            8B   D5  0DB3  2136 	tstl	(r11)+			; is first true?
                            08   12  0DB5  2137 	bneq	10$			; Yes
                            8B   D5  0DB7  2138 	tstl	(r11)+			; Is seconed true?
                            07   12  0DB9  2139 	bneq	20$			; Yes
                       7B   00   D0  0DBB  2140 	movl	#c_false,-(r11)		; Both false, leave with false on stack
                                 05  0DBE  2141 	rsb				; return
                                     0DBF  2142 10$:
                       5B   04   C0  0DBF  2143 	addl2	#4,r11			; pop second item off, don't need
                                     0DC2  2144 					;   to check
                                     0DC2  2145 20$:
              7B   FFFFFFFF 8F   D0  0DC2  2146 	movl	#c_true,-(r11)		; Yes, one or both true.  Leave with
                                     0DC9  2147 					;   true on stack.
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  44
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  0DC9  2148 	rsb				; end of or
                                     0DCA  2149 
                                     0DCA  2150 
                                     0DCA  2151 ;+++
                                     0DCA  2152 ;k> over -- ( n1 n2 -- n1 n2 n1 ) Leave a copy of the second item on the stack.
                                     0DCA  2153 ;+++
                                     0DCA  2154 	header	over			; push copy of n1 on top of stack
                    7B   04 AB   D0  0DD3  2155 	movl	4(r11),-(r11)
                                 05  0DD7  2156 	rsb				; end of over
                                     0DD8  2157 
                                     0DD8  2158 
                                     0DD8  2159 ;+++
                                     0DD8  2160 ;k> pad -- ( -- a ) Leave address of (edop + c_pad_moat) on stack.
                                     0DD8  2161 ;	This is a good area to use for temporary storage of such things
                                     0DD8  2162 ;	as strings.
                                     0DD8  2163 ;---
                                     0DD8  2164 	header	pad
         7B   00000109 8F   59   C1  0DE0  2165 	addl3	r9,#c_pad_moat,-(r11)	;
                                 05  0DE8  2166 	rsb				; end of pad
                                     0DE9  2167 
                                     0DE9  2168 
                                     0DE9  2169 ;+++
                                     0DE9  2170 ;k> putc -- ( c -- ) Output character `c'.
                                     0DE9  2171 ;---
                                     0DE9  2172 	header	putc
         00A0 8F   00001B98'EF   B1  0DF2  2173 	cmpw	v_outlen,#c_max_len	; is output buffer full?
                            04   19  0DFB  2174 	blss	10$			; no, go on
                       FA11 CF   16  0DFD  2175 	jsb	cr			; yes output it
                                     0E01  2176 10$:
              50   00001B9A'EF   9E  0E01  2177 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  0E08  2178 	movzwl	v_outlen,r1		; index into buffer
                       50   51   C0  0E0F  2179 	addl2	r1,r0			; pointer to next available char
                       60   6B   90  0E12  2180 	movb	(r11),(r0)		; move char into buffer
                       5B   04   C0  0E15  2181 	addl2	#4,r11			; pop char off stack
                   00001B98'EF   B6  0E18  2182 	incw	v_outlen		; increment index (or length)
                                 05  0E1E  2183 	rsb				; end of putc
                                     0E1F  2184 
                                     0E1F  2185 
                                     0E1F  2186 ;+++
                                     0E1F  2187 ;k> radix ( -- a ) leave address of system radix longword on stack.
                                     0E1F  2188 ;---
                                     0E1F  2189 	header	radix
              7B   00001D36'EF   DE  0E29  2190 	moval	v_radix,-(r11)		; leave address on dstack
                                 05  0E30  2191 	rsb				; end of radix
                                     0E31  2192 
                                     0E31  2193 
                                     0E31  2194 ;+++
                                     0E31  2195 ;k> read ( a -- ) return a byte-counted string from terminal at `a'
                                     0E31  2196 ;---
                                     0E31  2197 	header	read
              00001B92'EF   6B   D0  0E3A  2198 	movl	(r11),v_readaddr	; v_readaddr = address to write to
                   00001B92'EF   D6  0E41  2199 	incl	v_readaddr		; allow for byte count before string
                   00001B8C'EF   3F  0E47  2200 	pushaw	v_readlen		; where to put returned length
                                     0E4D  2201 ; Is there any outstanding output?
                   00001B98'EF   B5  0E4D  2202 	tstw   v_outlen			;
                            04   12  0E53  2203 	bneq   10$			; yes~~~, branch to output prompt
                            00   DD  0E55  2204 	pushl  #0			; omit prompt since no output
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  45
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                            1B   11  0E57  2205 	brb    20$			; skip over prompting
                                     0E59  2206 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0E59  2207 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0E60  2208 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0E67  2209 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                            5B   DD  0E6F  2210 	pushl	r11			; put address of descriptor on rstack
                       5B   08   C0  0E71  2211 	addl2	#8,r11			; move stack ptr back over descriptor
                                     0E74  2212 20$:
                   00001B8E'EF   7F  0E74  2213 	pushaq	v_readdsc		; push address of descriptor
              00000000'GF   03   FB  0E7A  2214 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0E81  2215 	isstrerr
                                     0E90  2216 30$:
                   00001B98'EF   B4  0E90  2217 	clrw	v_outlen		; clean output length, since any
                                     0E96  2218 					;   outstanding was just output
           00 BB   00001B8C'EF   33  0E96  2219 	cvtwb	v_readlen,@(r11)	; save byte-count at address on stack
                       5B   04   C0  0E9E  2220 	addl2	#4,r11			; pop address off stack
                                 05  0EA1  2221 	rsb				; end of read
                                     0EA2  2222 
                                     0EA2  2223 
                                     0EA2  2224 ;+++t
                                     0EA2  2225 ;k> readstr ( a n -- ) Read line from terminal into word-counted string.
                                     0EA2  2226 ;	`a' is address of word-counted string.
                                     0EA2  2227 ;	'n' is maximum length.
                                     0EA2  2228 ;---
                                     0EA2  2229 	header	readstr
                         04 AB   DD  0EAE  2230 	pushl	4(r11)			; where to put returned length
                    04 AB   02   C0  0EB1  2231 	addl2	#2,4(r11)		; move pointer over length word
           02 AB   00001B96'EF   B0  0EB5  2232 	movw	v_static_dsc,2(r11)	; move middle of descriptor on dstack
                   00001B98'EF   B5  0EBD  2233 	tstw	v_outlen		; Is there any outstanding output?
                            04   12  0EC3  2234 	bneq	10$			; yes
                            00   DD  0EC5  2235 	pushl	#0			; omit prompt since no output
                            21   11  0EC7  2236 	brb	20$			; skip over prompting
                                     0EC9  2237 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0EC9  2238 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0ED0  2239 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0ED7  2240 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                   00001B98'EF   B4  0EDF  2241 	clrw	v_outlen		; clear output length, since any
                                     0EE5  2242 					;   outstanding will be saved.
                            5B   DD  0EE5  2243 	pushl	r11			; put addrss of descriptor on rstack
                       5B   08   C0  0EE7  2244 	addl2	#8,r11			; move stack ptr back over descriptor
                                     0EEA  2245 20$:
                            5B   DD  0EEA  2246 	pushl	r11			; push address of descriptor
              00000000'GF   03   FB  0EEC  2247 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0EF3  2248 	isstrerr
                       5B   08   C0  0F02  2249 	addl2	#8,r11			; pop arguments
                                 05  0F05  2250 	rsb				; end of readstr
                                     0F06  2251 
                                     0F06  2252 
                                     0F06  2253 ;+++
                                     0F06  2254 ;k> restart -- ( -- ) Restart VTIL, patching it to run again.
                                     0F06  2255 ;	Used in cases of error.  Never RETURNs.
                                     0F06  2256 ;---
                                     0F06  2257 	header	restart
                          0AC1   31  0F12  2258 	brw	r_warm_start		; patch it
                                     0F15  2259 					; end of restart
                                     0F15  2260 
                                     0F15  2261 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  46
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0F15  2262 ;+++
                                     0F15  2263 ;k> s! -- ( n a -- ) Store a short integer (first 16 bits of `n' at `a'.~~~ `n' should be a `s'.
                                     0F15  2264 ;---
                                     0F15  2265 	header	i_word_store,<s!>
                 00 BB   04 AB   B0  0F1C  2266 	movw	4(r11),@(r11)		; store the first 16 bits
                       5B   08   C0  0F21  2267 	addl2	#8,r11			; pop arguments
                                 05  0F24  2268 	rsb				; end of s!
                                     0F25  2269 
                                     0F25  2270 
                                     0F25  2271 ;+++
                                     0F25  2272 ;k> s, -- ( s -- ) Store low word of `s' in dictinary.
                                     0F25  2273 ;---
                                     0F25  2274 	header	i_w_comma,<s,>
                       89   6B   B0  0F2C  2275 	movw	(r11),(r9)+		; store short in dictinary
                       5B   08   C0  0F2F  2276 	addl2	#8,r11			; pop arguments
                                 05  0F32  2277 	rsb				; end of s,
                                     0F33  2278 
                                     0F33  2279 
                                     0F33  2280 ;+++
                                     0F33  2281 ;k> s@ -- ( a -- n ) Fetch 16 bits from `a' and zero-extend to longword.
                                     0F33  2282 ;---
                                     0F33  2283 	header	i_word_fetch,<s@>
                    6B   00 BB   3C  0F3A  2284 	movzwl	@(r11),(r11)		; get contents
                                 05  0F3E  2285 	rsb				; end of s@
                                     0F3F  2286 
                                     0F3F  2287 
                                     0F3F  2288 ;+++
                                     0F3F  2289 ;k> ss@ -- ( a -- n ) Fetch short at `a' and sign extend it to longword.
                                     0F3F  2290 ;---
                                     0F3F  2291 	header	i_ws_fetch,<ss@>
                    6B   00 BB   32  0F47  2292 	cvtwl	@(r11),(r11)		; get contents, sign extend it
                                 05  0F4B  2293 	rsb				; end of ss@
                                     0F4C  2294 
                                     0F4C  2295 
                                     0F4C  2296 ;+++
                                     0F4C  2297 ;k> save-buffers -- ( -- ) Write all modified buffers and mark them unmodified.
                                     0F4C  2298 ;---
                                     0F4C  2299 	header	i_save_buffers,<save-buffers>
                            50   D4  0F5D  2300 	clrl	r0			; buffer number
                                     0F5F  2301 10$:
                            02   91  0F5F  2302 	cmpb	#c_modified,-		; Has the buffer
                       1B7D'C0       0F61  2303 		v_buf_inuse(r0)		;   been modified? ~~~ Why not [r0]?
                            12   12  0F64  2304 	bneq	20$			; no, skip it
                       7A   50   D0  0F66  2305 	movl	r0,-(r10)		; save the buffer number
                       7B   50   D0  0F69  2306 	movl	r0,-(r11)		; set up for buffer-write
                       F78C CF   16  0F6C  2307 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0F70  2308 	movl	(r10)+,r0		; get the buffer number back
                            01   90  0F73  2309 	movb	#c_inuse,-		; mark the buffer as
                       1B7D'C0       0F75  2310 		v_buf_inuse(r0)		;   in use, but not modified.
                                     0F78  2311 20$:
                            02   F1  0F78  2312 	acbl	#c_max_blocks-1,-	; buffer # is in [0 .. c_max_blocks-1]
                  FFE1 50   01       0F7A  2313 		#1,r0,10$		; move to next buffer number, if any
                                 05  0F7E  2314 	rsb				; end of save-buffers
                                     0F7F  2315 
                                     0F7F  2316 
                                     0F7F  2317 ;+++t
                                     0F7F  2318 ;k> search -- ( a1 -- a2 ? f )  Search vocabulary at `a1' for a match with
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  47
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0F7F  2319 ;	byte-counted string at eodp.  Return  ( false ) if not found, or
                                     0F7F  2320 ;	( addr true ) if found.
                                     0F7F  2321 ;---
                                     0F7F  2322 	header	search
                            6B   D5  0F8A  2323 	tstl	(r11)			; Is it nil pointer on top of stack?
                            29   13  0F8C  2324 	beql	10$			; yes, stop search, leave false on stack
                  56   6B   04   C1  0F8E  2325 	addl3	#4,(r11),r6		; r6 = Address of byte-count
                       69   66   91  0F92  2326 	cmpb	(r6),(r9)		; no, ?equal length
                            1A   12  0F95  2327 	bneq	20$			; no
                       56   69   99  0F97  2328 	cvtbw	(r9),r6			; yes, get string length
                  57   6B   05   C1  0F9A  2329 	addl3	#5,(r11),r7		; get address of word name
                  58   59   01   C1  0F9E  2330 	addl3	#1,r9,r8		; get address of token
                  68   67   56   29  0FA2  2331 	cmpc3	r6,(r7),(r8)		; compare strings
                            09   12  0FA6  2332 	bneq	20$			; strings don't match
                                     0FA8  2333 ; string match
              7B   FFFFFFFF 8F   D0  0FA8  2334 	movl	#c_true,-(r11)		; move true to top of stack
                            06   11  0FAF  2335 	brb	10$			; exit leaving ( addr true ) on dstack.
                                     0FB1  2336 20$:
                    6B   00 BB   D0  0FB1  2337 	movl	@(r11),(r11)		; get address of next word
                            D3   11  0FB5  2338 	brb	search			; try it again
                                     0FB7  2339 10$:
                                 05  0FB7  2340 	rsb				; end of search
                                     0FB8  2341 
                                     0FB8  2342 
                                     0FB8  2343 ;+++
                                     0FB8  2344 ;k> short -- ( n -- ) Create a word that pushed the address of two bytes
                                     0FB8  2345 ;	(a VAX memory `word') on the stack, reserves space in the dictionary
                                     0FB8  2346 ;	for those two bytes, and initializes it to the value of `n'.
                                     0FB8  2347 ;---
                                     0FB8  2348 	header	i_short,<short>
                       F880 CF   16  0FC2  2349 	jsb	create			; enclose next token in dictionary
                       89   3E   90  0FC6  2350 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  0FC9  2351 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0FCD  2352 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0FD0  2353 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0FD4  2354 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  0FD7  2355 	movw	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  0FDA  2356 	addl2	#4,r11			; pop aruments
                                 05  0FDD  2357 	rsb				; end of short
                                     0FDE  2358 
                                     0FDE  2359 
                                     0FDE  2360 ;+++
                                     0FDE  2361 ;k> sign -- ( n -- ) Output minus in pictured numeric if top of stack is < 0.
                                     0FDE  2362 ;---
                                     0FDE  2363 	header	sign
                            8B   D5  0FE7  2364 	tstl	(r11)+			; tos < 0?
                            07   18  0FE9  2365 	bgeq	10$			; no, exit
                       7B   2D   D0  0FEB  2366 	movl	#^a\-\,-(r11)		; put ascii for minus sign on stack
                       FB25 CF   16  0FEE  2367 	jsb	hold			; put it in output string
                                     0FF2  2368 10$:
                                 05  0FF2  2369 	rsb				; end of sign
                                     0FF3  2370 
                                     0FF3  2371 
                                     0FF3  2372 ;+++
                                     0FF3  2373 ;k> smudge -- ( -- ) Sets the smudge (high) bit in the length byte as the word
                                     0FF3  2374 ;	that is currently being defined won't be found in itself.
                                     0FF3  2375 ;---
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  48
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     0FF3  2376 	header	smudge
              50   00001D23'FF   D0  0FFE  2377 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  1005  2378 	addl2	#4,r0			; move over link field
                    60   80 8F   88  1008  2379 	bisb2	#^b10000000,(r0)	; set smudge bit in length of name
                                 05  100C  2380 	rsb				; end of smudge
                                     100D  2381 
                                     100D  2382 
                                     100D  2383 ;+++
                                     100D  2384 ;k> sp@ -- ( -- l ) Returns the address of the top fo the data stack before
                                     100D  2385 ;	{ sp@ } is executed.
                                     100D  2386 ;---
                                     100D  2387 	header	i_sp_fetch,<sp@>
                       7B   5B   D0  1015  2388 	movl	r11,-(r11)		; put address of top of stack on stack
                                 05  1018  2389 	rsb				; end of sp@
                                     1019  2390 
                                     1019  2391 
                                     1019  2392 ;+++
                                     1019  2393 ;k> sp0 -- ( -- l ) Returns the address of the bottom of the data stack.
                                     1019  2394 ;	Note that the stack grows downward, so this is actually the
                                     1019  2395 ;	top in memory of the data-stack structure's space.
                                     1019  2396 ;___
                                     1019  2397 	header	i_sp_0,<sp0>
              7B   00001000'EF   DE  1021  2398 	moval	c_ds_start,-(r11)	; put address on stack
                                 05  1028  2399 	rsb				; end of sp0
                                     1029  2400 
                                     1029  2401 
                                     1029  2402 ;+++
                                     1029  2403 ;k> space -- ( -- ) Output a space to terminal.
                                     1029  2404 ;---
                                     1029  2405 	header	space
         00A0 8F   00001B98'EF   B1  1033  2406 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            04   19  103C  2407 	blss	10$			; no, go on
                       F7D0 CF   16  103E  2408 	jsb	cr			; yes, output it
                                     1042  2409 10$:
              50   00001B9A'EF   9E  1042  2410 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  1049  2411 	movzwl	v_outlen,r1		; index into buffer
              00000028'EF   51   C0  1050  2412 	addl2	r1,40			; pointer to next available buffer
                       60   20   90  1057  2413 	movb	#c_blank,(r0)		; move char into buffer
                   00001B98'EF   B6  105A  2414 	incw	v_outlen		; increment index (or length)
                                 05  1060  2415 	rsb				; end of space
                                     1061  2416 
                                     1061  2417 
                                     1061  2418 ;+++
                                     1061  2419 ;,> spaces -- ( n -- ) Output `n' spaces to terminal
                                     1061  2420 ;---
                                     1061  2421 	header	spaces
                            6B   D5  106C  2422 	tstl	(r11)			; Is it less than or equal to zero?
                            0E   15  106E  2423 	bleq	100$			; yes, exit
                       7B   01   D0  1070  2424 	movl	#1,-(r11)		; no, save space on stack for index
                                     1073  2425 10$:
                         BD AF   16  1073  2426 	jsb	space			; output one space
                 F8 6B   04 AB   F2  1076  2427 	aoblss	4(r11),(r11),10$	; (r11) += 1, repeat if (r11) < 4(r11)
                       5B   04   C0  107B  2428 	addl2	#4,r11			; pop index
                                     107E  2429 100$:
                       5B   04   C0  107E  2430 	addl2	#4,r11			; pop argument
                                 05  1081  2431 	rsb				; end of spaces
                                     1082  2432 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  49
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1082  2433 
                                     1082  2434 ;+++t
                                     1082  2435 ;k> sread ( -- ) Read a line from terminal or file into input stream,
                                     1082  2436 ;	depending on value of { infile }.  if { infile } is true, read
                                     1082  2437 ;	from file; otherwise, read from terminal.
                                     1082  2438 ;---
                                     1082  2439 	header	sread
                   00001B98'EF   B5  108C  2440 	tstw	v_outlen		; Is there any outstanding output?
                            04   13  1092  2441 	beql	5$			; no
                       F77A CF   16  1094  2442 	jsb	cr			; yes, output it
                                     1098  2443 5$:
     0000199B'EF   000018F7'EF   DE  1098  2444 	moval	v_inbuf,v_inptr		; start at beginning of line
                   00001D2F'EF   95  10A3  2445 	tstb	v_infile		; getting input from file?
                            37   12  10A9  2446 	bneq	10$			; yes, go do it
                                     10AB  2447 ; no, get from terminal
                   00001999'EF   3F  10AB  2448 	pushaw	v_inlen			; save returned length
                   0000182A'EF   7F  10B1  2449 	pushaq	v_vtilprompt		; use vtil prompt
                   0000199F'EF   7F  10B7  2450 	pushaq	v_in_dsc		; address of input descriptor
              00000000'GF   03   FB  10BD  2451 	calls	#3,g^lib$get_input	; get a line from terminal
                         0F 50   E8  10C4  2452 	blbs	r0,8$			; no error, go on
              50   00000000'8F   D1  10C7  2453 	cmpl	#rms$_eof,r0		; Is it eof from terminal?
                            03   12  10CE  2454 	bneq	7$			; no, go die messily
                          0ABC   31  10D0  2455 	brw	_exit			; yes, exit silently
                                     10D3  2456 7$:
                          0A86   31  10D3  2457 	brw	_error_exit		; die messily
                                     10D6  2458 8$:
     00001997'EF   00001999'EF   B0  10D6  2459 	movw	v_inlen,v_org_inlen	; save original length
                                 05  10E1  2460 	rsb				; success read from terminal, return
                                     10E2  2461 10$:
                                     10E2  2462 	$get	rab=v_inrab		; get a record
                         13 50   E8  10EF  2463 	blbs	r0,20$			; write the record
              00000000'8F   50   D1  10F2  2464 	cmpl	r0,#rms$_eof		; was error end-of-file
                            27   13  10F9  2465 	beql	30$			; successful completion
                                     10FB  2466 ; error otherwize
              56   000019F8'EF   DE  10FB  2467 	moval	v_inrab,r6		; keep rab address
                          0A70   31  1102  2468 	brw	_r_err			; signal record error
                                     1105  2469 20$:
                   00001A1A'EF   B0  1105  2470 	movw	v_inrab+rab$w_rsz,-	; input rab set record size
                   00001999'EF       110B  2471 		v_inlen
                   00001A1A'EF   B0  1110  2472 	movw	v_inrab+rab$w_rsz,-
                   00001997'EF       1116  2473 		v_org_inlen
                   00001D30'EF   D6  111B  2474 	incl	v_filelinenum		; increment line number in file
                                 05  1121  2475 	rsb				; success read from file, return
                                     1122  2476 30$:
                                     1122  2477 	$close	fab=v_infab		; close input
              00001D2F'EF   00   90  112F  2478 	movb	#c_false,v_infile	; set v_infile flag false
              00001D30'EF   00   D0  1136  2479 	movl	#0,v_filelinenum	; zero file line as well
                                 05  113D  2480 	rsb				; end of sread
                                     113E  2481 
                                     113E  2482 
                                     113E  2483 ;+++
                                     113E  2484 ;k> strcat -- ( a1 a2 -- ) Catenate string at `a`' to string at `a2'.
                                     113E  2485 ;	Works only with strings defined by { string } or { string" }
                                     113E  2486 ;	since it uses maxlen of string at `a2'.
                                     113E  2487 ;---
                                     113E  2488 	header	strcat
                    50   04 BB   3C  1149  2489 	movzwl	@4(r11),r0		; length of src
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  50
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                    57   00 BB   3C  114D  2490 	movzwl	@(r11),r7		; length of dest
               53   04 AB   02   C1  1151  2491 	addl3	#2,4(r11),r3		; address of src characters
                       52   6B   D0  1156  2492 	movl	(r11),r2		; address of dest
                  54   52   02   C3  1159  2493 	subl3	#2,r2,r4		; address of maxlen of dest
                  52   52   02   C1  115D  2494 	addl3	#2,r2,r2		; address of dest char
                       55   64   3C  1161  2495 	movzwl	(r4),r5			; maxlen of dest
                  56   55   57   C3  1164  2496 	subl3	r7,r5,r6		; space available in dest
                       50   56   D1  1168  2497 	cmpl	r6,r0			; less space available than to copy
                            03   15  116B  2498 	bleq	10$			; yes, use space available in dest as len
                       56   50   D0  116D  2499 	movl	r0,r6			; no, move all characters in src
                                     1170  2500 10$:
                       52   57   C0  1170  2501 	addl2	r7,r2			; start at end of dest chars
                  62   63   56   28  1173  2502 	movc3	r6,(r3),(r2)		; copy the string
                    00 BB   56   A0  1177  2503 	addw2	r6,@(r11)		; store the new length
                       5B   08   C0  117B  2504 	addl2	#8,r11			; pop arguments
                                 05  117E  2505 	rsb				; end of strcat
                                     117F  2506 
                                     117F  2507 
                                     117F  2508 ;+++
                                     117F  2509 ;k> strcmp -- ( a1 a2 -- n ) Compare word-counted strings.
                                     117F  2510 ;	Return 0 if string at `a`' = string at `a2'.
                                     117F  2511 ;	Return >0 if string at `a`' > string at `a2'.
                                     117F  2512 ;	Return <0 if string at `a1' < string at `a2'.
                                     117F  2513 ;---
                                     117F  2514 	header	strcmp
                    50   04 BB   3C  118A  2515 	movzwl	@4(r11),r0		; length of str1
               51   04 AB   02   C1  118E  2516 	addl3	#2,4(r11),r1		; address of chars in str1
                    52   00 BB   3C  1193  2517 	movzwl	@(r11),r2		; length of str2
                  53   6B   02   C1  1197  2518 	addl3	#2,(r11),r3		; address of chars in str2
                       5B   08   C0  119B  2519 	addl2	#8,r11			; pop top two stack items
        63   52   00   61   50   2D  119E  2520 	cmpc5	r0,(r1),#0,r2,(r3)	; compare chars with 0 fill
                            0A   13  11A4  2521 	beql	10$			; str1 = str2
                            0C   14  11A6  2522 	bgtr	20$			; str1 > str2
              7B   FFFFFFFF 8F   D0  11A8  2523 	movl	#-1,-(r11)		; str1 < str2
                                 05  11AF  2524 	rsb				; exit
                                     11B0  2525 10$:
                       7B   00   D0  11B0  2526 	movl	#0,-(r11)		; str1 = str2
                                 05  11B3  2527 	rsb				; exit
                                     11B4  2528 20$:
                       7B   01   D0  11B4  2529 	movl	#1,-(r11)		; str1 > str2
                                 05  11B7  2530 	rsb				; end of strcmp
                                     11B8  2531 
                                     11B8  2532 
                                     11B8  2533 ;+++
                                     11B8  2534 ;k> strcpy -- ( a1 a2 -- ) copy word counted string at `a1' to w-string at `a2'.
                                     11B8  2535 ;	Both must be word-counted, and string at `a2' must have maxlen 2bytes
                                     11B8  2536 ;	(i.e., defined by { string } or { string" }).
                                     11B8  2537 ;---
                                     11B8  2538 	header	strcpy
                       50   6B   D0  11C3  2539 	movl	(r11),r0		; get address of destination
                    51   04 AB   D0  11C6  2540 	movl	4(r11),r1		; get address of source
                       56   61   3C  11CA  2541 	movzwl	(r1),r6			; length of source
                  52   50   02   C3  11CD  2542 	subl3	#2,r0,r2		; address of destination max len
                       52   62   3C  11D1  2543 	movzwl	(r2),r2			; dest max len
                       56   52   D1  11D4  2544 	cmpl	r2,r6			; max len < source len?
                            03   18  11D7  2545 	bgeq	10$			; no
                       56   52   D0  11D9  2546 	movl	r2,r6			; yes, use max len for src len
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  51
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     11DC  2547 10$:
            02 A0   02 AB   56   28  11DC  2548 	movc3	r6,2(r11),2(r0)		; move the strings
                    00 BB   56   B0  11E2  2549 	movw	r6,@(r11)		; save the new length of dest
                       5B   08   C0  11E6  2550 	addl2	#8,r11			; pop arguments
                                 05  11E9  2551 	rsb				; end of strcpy
                                     11EA  2552 
                                     11EA  2553 
                                     11EA  2554 ;+++
                                     11EA  2555 ;k> string -- ( n -- ) Create a string variable with maximum length of `n'.
                                     11EA  2556 ;	The first 2 bytes of the string contains its length.
                                     11EA  2557 ;	The 2 bytes previous to the string contains its maximum length.
                                     11EA  2558 ;---
                                     11EA  2559 	header	string,<string>
                       F64D CF   16  11F5  2560 	jsb	create			; make the header
                       89   3E   90  11F9  2561 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  11FC  2562 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  1200  2563 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  1203  2564 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  1207  2565 	movb	#op_rsb,(r9)+		; rsb
                       89   6B   B0  120A  2566 	movw	(r11),(r9)+		; maximum length
                       89   00   B0  120D  2567 	movw	#0,(r9)+		; make high byte of current count
                       59   8B   C0  1210  2568 	addl2	(r11)+,r9		; save space for characters
                                 05  1213  2569 	rsb				; end of string
                                     1214  2570 
                                     1214  2571 
                                     1214  2572 ;+++
                                     1214  2573 ;k> string" -- ( n -- ) Create a string variable with maximum length of `n',
                                     1214  2574 ;	and initialize with string from input stream up until next `"'.
                                     1214  2575 ;	The first 2 bytes of the string contain its length.
                                     1214  2576 ;	The 2 bytes previous to the string contains its maximum length.
                                     1214  2577 ;---
                                     1214  2578 	header	i_string_quote,<string">
                       F622 CF   16  1220  2579 	jsb	create			; make the header
                       89   3E   90  1224  2580 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  1227  2581 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  122B  2582 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  122E  2583 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  1232  2584 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  1235  2585 	movw	(r11),(r9)+		; maximum length
                       7A   59   D0  1238  2586 	movl	r9,-(r10)		; save address of current length on lstack
                       89   00   90  123B  2587 	movb	#0,(r9)+		; make high byte of current count
                                     123E  2588 					;   zero since token returns a b-counted
                                     123E  2589 					;   string
                       7B   22   D0  123E  2590 	movl	#^a\"\,-(r11)		; set up for quote terminated token
                   000012E6'EF   16  1241  2591 	jsb	token			; get the token
                       50   89   9A  1247  2592 	movzbl	(r9)+,r0		; get count and move over to first char
                       50   6B   B1  124A  2593 	cmpw	(r11),r0		; is max length < token length
                            03   18  124D  2594 	bgeq	10$			; no
                       50   6B   D0  124F  2595 	movl	(r11),r0		; yes, only allow maxlen chars from
                                     1252  2596 					;   token
                                     1252  2597 10$:
                    00 BA   50   B0  1252  2598 	movw	r0,@(r10)		; save current length
                       5A   04   C0  1256  2599 	addl2	#4,r10			; pop temp storage from loop stack.
                       59   8B   C0  1259  2600 	addl2	(r11)+,r9		; save space for characters
                                 05  125C  2601 	rsb				; end of string"
                                     125D  2602 
                                     125D  2603 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  52
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     125D  2604 ;+++
                                     125D  2605 ;k> strmax -- ( -- ) Return maximum length of string at `a'.
                                     125D  2606 ;---
                                     125D  2607 	header	strmax
                       6B   02   C2  1268  2608 	subl2	#2,(r11)		; get address of max len
                    6B   00 BB   3C  126B  2609 	movzwl	@(r11),(r11)		; get maximum length
                                 05  126F  2610 	rsb				; end of strmax
                                     1270  2611 
                                     1270  2612 
                                     1270  2613 ;+++
                                     1270  2614 ;k> strpos -- ( a1 n1 a2 n2 -- a3 n3 ? f ) Find pos and len of substring in str.
                                     1270  2615 ;	Searches string whose text is at `a2' and length is `n2' for substring
                                     1270  2616 ;	whose text is at `a`' and whose length is `n1'.  Returns true on top of
                                     1270  2617 ;	stack if found and under that { a3 n3 }, address and length of located
                                     1270  2618 ;	substring.  Otherwise returns false.
                                     1270  2619 ;---
                                     1270  2620 	header	strpos
                         08 AB   39  127B  2621 	matchc	8(r11),-		; length of object string (to find)
                         0C BB       127E  2622 		@12(r11),-		; address of object string
                            6B       1280  2623 		(r11),-			; length of source string (to search in)
                         04 BB       1281  2624 		@4(r11)			; address of source string
                            19   12  1283  2625 	bneq	10$			; match not found
                    50   08 AB   D0  1285  2626 	movl	8(r11),r0		; save length of object string
                  51   53   50   C3  1289  2627 	subl3	r0,r3,r1		; calculate start addr of found string
                       5B   10   C0  128D  2628 	addl2	#16,r11			; pop arguments
                       7B   51   D0  1290  2629 	movl	r1,-(r11)		; put address of found string on stack
                       7B   50   D0  1293  2630 	movl	r0,-(r11)		; put length of found string on stack
              7B   FFFFFFFF 8F   D0  1296  2631 	movl	#c_true,-(r11)		; put true on stack
                                 05  129D  2632 	rsb				; rturn
                                     129E  2633 10$:
                       5B   10   C0  129E  2634 	addl2	#16,r11			; pop arguments
                       7B   00   D0  12A1  2635 	movl	#c_false,-(r11)
                                 05  12A4  2636 	rsb				; end of strpos
                                     12A5  2637 
                                     12A5  2638 
                                     12A5  2639 ;+++
                                     12A5  2640 ;k> swap -- ( n1 n2 -- n2 n1 ) exchange the top two items on the stack.
                                     12A5  2641 ;---
                                     12A5  2642 	header	swap
                       50   6B   D0  12AE  2643 	movl	(r11),r0		; temp = n2
                    6B   04 AB   D0  12B1  2644 	movl	4(r11),(r11)		; n2 = n1
                    04 AB   50   D0  12B5  2645 	movl	r0,4(r11)		; n1 = saved n2
                                 05  12B9  2646 	rsb				; end of swap
                                     12BA  2647 
                                     12BA  2648 
                                     12BA  2649 ;+++
                                     12BA  2650 ;k> tochar -- convert top fo stack from 0..9, A..Z to '0'..'9','A'..'Z'
                                     12BA  2651 ;	( n -- c ) where n is a number and c is a char.
                                     12BA  2652 ;	If not in rnage leave alow.
                                     12BA  2653 ;---
                                     12BA  2654 	header	tochar
                                     12C5  2655 ; with 10 numbers and 26 letters, largest base is 36.
                                     12C5  2656 ; didgits go from 0 to 35.
                            6B   D5  12C5  2657 	tstl	(r11)			; n < 0?
                            12   19  12C7  2658 	blss	100$			; yes, exit
                       23   6B   D1  12C9  2659 	cmpl	(r11),#35		; n > 35
                            0D   14  12CC  2660 	bgtr	100$			; yes, exit
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  53
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                       09   6B   D1  12CE  2661 	cmpl	(r11),#9		; n > 9 (not a `number') ~~~base 10 digit
                            05   14  12D1  2662 	bgtr	10$			; yes, make it 'A' .. 'Z'
                       6B   30   C0  12D3  2663 	addl2	#48,(r11)		; no, make it a '1' .. '9'
                            03   11  12D6  2664 	brb	100$			; exit
                                     12D8  2665 10$:
                       6B   37   C0  12D8  2666 	addl2	#55,(r11)		; make it 'A' .. 'Z'
                                     12DB  2667 100$:
                                 05  12DB  2668 	rsb				; end of tochar.
                                     12DC  2669 
                                     12DC  2670 
                                     12DC  2671 ;+++t
                                     12DC  2672 ;k> token -- ( c -- ) Get next token from input stream and put it in dictionary.
                                     12DC  2673 ;	Note that this dos NOT increment the dictionary pointer!
                                     12DC  2674 ;---
                                     12DC  2675 	header	token
                       6B   20   91  12E6  2676 	cmpb	#c_blank,(r11)		; ?c = ' '~~~, an ascii blank
                            22   12  12E9  2677 	bneq	_gettoken		; if anything but space, don't skip
                                     12EB  2678 _skipwhitespace:
0000199B'FF   00001999'EF   6B   3B  12EB  2679 	skpc	(r11),v_inlen,@v_inptr	; skip whitespace
                            06   12  12F7  2680 	bneq	_startfound		; if something other than whitespace
                                     12F9  2681 					; found
                       FD8F CF   16  12F9  2682 	jsb     sread                   ; get a new line, only whitespace found
                            EC   11  12FD  2683 	brb	_skipwhitespace		; do it over
                                     12FF  2684 _startfound:
              0000199B'EF   51   D0  12FF  2685 	movl	r1,v_inptr		; where non-whitespcae found
              00001999'EF   50   B0  1306  2686 	movw	r0,v_inlen		; bytes remaining in string
                                     130D  2687 _gettoken:
                            56   D4  130D  2688 	clrl	r6
                            57   D4  130F  2689 	clrl	r7
0000199B'FF   00001999'EF   6B   3A  1311  2690 	locc	(r11),v_inlen,@v_inptr	; locate character
         56   00001999'EF   50   A3  131D  2691 	subw3	r0,v_inlen,r6		; (v_inlen = r0) = number of chars
                                     1325  2692 					;   to copy
              00001999'EF   50   B0  1325  2693 	movw    r0,v_inlen              ; these are only bytes left (including one
                                     132C  2694 					; located~~~close paren?
                       57   51   D0  132C  2695 	movl	r1,r7			; save address of found char
                       69   56   33  132F  2696 	cvtwb	r6,(r9)			; store byte length
                  58   59   01   C1  1332  2697 	addl3	#1,r9,r8		; where to put in dictinary
         68   0000199B'FF   56   28  1336  2698 	movc3	r6,@v_inptr,(r8)	; move string to dictinary
              0000199B'EF   57   D0  133E  2699 	movl	r7,v_inptr		; v_inptr points into string
                   00001999'EF   B5  1345  2700 	tstw	v_inlen			; Are any more char?  (including
                                     134B  2701 					;   located one)
                            0E   13  134B  2702 	beql	10$			; no, exit
              00001999'EF   01   A2  134D  2703 	subw2	#1,v_inlen		; yes, move over terminator
                                     1354  2704 					;   (located char)
              0000199B'EF   01   C0  1354  2705 	addl2	#1,v_inptr
                                     135B  2706 10$:
                       5B   04   C0  135B  2707 	addl2	#4,r11			; pop terminator off stack
                                 05  135E  2708 	rsb				; end of token
                                     135F  2709 
                                     135F  2710 
                                     135F  2711 ;+++t
                                     135F  2712 ;k> unlink -- ( -- ) Unlink the most current word from the current vocab.  Used
                                     135F  2713 ;	when a definition is aborted by an unknown token.
                                     135F  2714 ;---
                                     135F  2715 	header	unlink
              58   00001D23'FF   D0  136A  2716 	movl	@v_current,r8		; reclaim directory space
              00001D23'FF   69   D0  1371  2717 	movl	(r9),@v_current		; get pointer to last word in current
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  54
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1378  2718 					; vocab from link field of word
                                     1378  2719 					; we just deleted
                                 05  1378  2720 	rsb				; end of unlink
                                     1379  2721 
                                     1379  2722 
                                     1379  2723 ;+++
                                     1379  2724 ;k> unsmudge -- clear the smudge (high) bit in the word being defined, so
                                     1379  2725 ;	that it can be found again.
                                     1379  2726 ;---
                                     1379  2727 	header	unsmudge
              50   00001D23'FF   D0  1386  2728 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  138D  2729 	addl2	#4,r0			; move over link field
                    60   80 8F   8A  1390  2730 	bicb2	#^b10000000,(r0)	; clear smudge bit of length of name
                                 05  1394  2731 	rsb				; end of unsmudge
                                     1395  2732 
                                     1395  2733 
                                     1395  2734 ;+++
                                     1395  2735 ;k> update -- ( -- ) Mark the most recent block as updated.
                                     1395  2736 ;---
                                     1395  2737 	header	update
              50   00001B79'EF   D0  13A0  2738 	movl	v_current_buff,r0	; get buffer number of current block
                            02   90  13A7  2739 	movb	#c_modified,-		;
                       1B7D'C0       13A9  2740 		v_buf_inuse(r0)		; mark buffer as updated
                                 05  13AC  2741 	rsb				; end of update
                                     13AD  2742 
                                     13AD  2743 
                                     13AD  2744 ;+++
                                     13AD  2745 ;k> variable -- ( -- ) Create a word that pushed its PFA on the stack.
                                     13AD  2746 ;	Doesn't reserve any space.  Use for making initialized arrays.
                                     13AD  2747 ;	PF = parameter field address = address of data following end
                                     13AD  2748 ;	of code body of work.
                                     13AD  2749 ;---
                                     13AD  2750 ;??? This concept is fuzzy.  Work on it.
                                     13AD  2751 	header	  variable
                       F488 CF   16  13BA  2752 	jsb	  create		; enclose next token in dictionary
                    89   9E 8F   90  13BE  2753 	movb	  #op_movab,(r9)+	; `movb'
                    89   AF 8F   90  13C2  2754 	movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  13C6  2755 	movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  13C9  2756 	movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  13CD  2757 	movb	  #op_rsb,(r9)+		; `rsb'
                                 05  13D0  2758 	rsb				; end of variable
                                     13D1  2759 
                                     13D1  2760 
                                     13D1  2761 ;+++
                                     13D1  2762 ;k> vlist -- ( -- ) List context vocabulary
                                     13D1  2763 ;---
                                     13D1  2764 	header	vlist
              50   00001D1F'FF   D0  13DB  2765 	movl	@v_context,r0		; get address of context vocabulary
                       7B   50   D0  13E2  2766 	movl	r0,-(r11)		; get address of most recent word
                                     13E5  2767 10$:
                            6B   D5  13E5  2768 	tstl	(r11)			; nil pointer?
                            22   13  13E7  2769 	beql	100$			; yes, exit
                  7B   04   6B   C1  13E9  2770 	addl3	(r11),#4,-(r11)		; get address of name field
                       F088 CF   16  13ED  2771 	jsb	bcount			; set up for write
                       7B   6B   D0  13F1  2772 	movl	(r11),-(r11)		; set up for ?cr
                       EF11 CF   16  13F4  2773 	jsb	q_n_cr			; start new line if word too long
                   00001454'EF   16  13F8  2774 	jsb	write			; tell user
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  55
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                       7B   20   D0  13FE  2775 	movl	#c_blank,-(r11)		; blank to separate words
                       F9ED CF   16  1401  2776 	jsb	putc			; output it
                    6B   00 BB   D0  1405  2777 	movl	@(r11),(r11)		; get previous word's LFA
                            DA   11  1409  2778 	brb	10$			; try it again
                                     140B  2779 100$:
                       5A   04   C0  140B  2780 	addl2	#4,r10			; pop pointer off stack
                                 05  140E  2781 	rsb				; end of vlist
                                     140F  2782 
                                     140F  2783 
                                     140F  2784 ;+++
                                     140F  2785 ;k> vocabulary -- ( -- ) Defining word.  Creates a new vocabulary. When the word
                                     140F  2786 ;	defined by this is executed, context is set to the new vocabulary.
                                     140F  2787 ;---
                                     140F  2788 	header	vocabulary
              7A   00001D1F'FF   D0  141E  2789 	movl	@v_context,-(r10)	; save LFA of word to link to
                       F41D CF   16  1425  2790 	jsb	create			;   make header for new vocab~~~ word
                    89   DE 8F   90  1429  2791 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  142D  2792 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   06   90  1431  2793 	movb	#6,(r9)+		; (pc+2) ~~~ isn't this (pc+6)?
              89   0000009F'EF   90  1434  2794 	movb	adm_absolute,(r9)+	; absolute mode (address in next lword)
              89   00001D1F'EF   DE  143B  2795 	moval	v_context,(r9)+		; context
                    89   05 8F   9E  1442  2796 	movab	#op_rsb,(r9)+		; rsb
                       89   8A   D0  1446  2797 	movl	(r10)+,(r9)+		; initialize link
                                 05  1449  2798 	rsb				; end of vocabulary
                                     144A  2799 
                                     144A  2800 
                                     144A  2801 ;+++t
                                     144A  2802 ;k> write -- ( a w -- ) Write string of length `w' at address `a' out to  terminal.
                                     144A  2803 ;---
                                     144A  2804 	header	write
         00A0 8F   00001B98'EF   B1  1454  2805 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            28   19  145D  2806 	blss	10$			; no, go get some
                                     145F  2807 ; yes, output it
              7B   00001B9A'EF   DE  145F  2808 	moval	v_outbuf,-(r11)		; put address on stack
              7B   00001B98'EF   3C  1466  2809 	movzwl	v_outlen,-(r11)		; put length on stack
           02 AB   00001B96'EF   B0  146D  2810 	movw	v_static_dsc,2(r11)	; put rest of descriptor in
                            5B   DD  1475  2811 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  1477  2812 	calls	#1,g^lib$put_output	; output it
                       5B   08   C0  147E  2813 	addl2	#8,r11			; pop top two entries (descriptor)
                   00001B98'EF   B4  1481  2814 	clrw	v_outlen		; nothing left in buffer
                                     1487  2815 10$:
              56   00001B98'EF   3C  1487  2816 	movzwl	v_outlen,r6		; get length
         57   000000A0 8F   56   C3  148E  2817 	subl3	r6,#c_max_len,r7	; space available in output buffer
              50   00001B9A'EF   9E  1496  2818 	movab	v_outbuf,r0		; pointer into buffer
                       50   56   C0  149D  2819 	addl2	r6,r0			; next available byte
                       57   6B   D1  14A0  2820 	cmpl	(r11),r7		; chars to output <= available
                            10   14  14A3  2821 	bgtr	20$			; no, do a part
               60   04 BB   6B   28  14A5  2822 	movc3	(r11),@4(r11),(r0)	; move the string into the output buffer
              00001B98'EF   6B   A0  14AA  2823 	addw2	(r11),v_outlen		; save the new # of chars in buffer
                       5B   08   C0  14B1  2824 	addl2	#8,r11			; pop top two entries off stack
                                 05  14B4  2825 	rsb				; return
                                     14B5  2826 20$:					; more chars to output than buffer space
               60   04 BB   57   28  14B5  2827 	movc3	r7,@4(r11),(r0)		; move some into buffer
                       6B   57   C2  14BA  2828 	subl2	r7,(r11)		; new length to output
                    04 AB   57   C0  14BD  2829 	addl2	r7,4(r11)		; new place to start in chars to output
              00001B98'EF   57   A0  14C1  2830 	addw2	r7,v_outlen		; new # of chars in buffer
              7B   00001B9A'EF   9E  14C8  2831 	movab	v_outbuf,-(r11)		; address of buffer on stack
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  56
V1.01                           Kernel Built-ins                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

              7B   00001B98'EF   9A  14CF  2832 	movzbl	v_outlen,-(r11)		; count on stack
           02 AB   00001B96'EF   B0  14D6  2833 	movw	v_static_dsc,2(r11)	; put middle of descriptor in
                            5B   DD  14DE  2834 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  14E0  2835 	calls	#1,g^lib$put_output	; display it
                   00001B98'EF   B4  14E7  2836 	clrw	v_outlen		; nothing in buffer now
                       5B   08   C0  14ED  2837 	addl2	#8,r11			; pop descriptor off stack
                            6B   D5  14F0  2838 	tstl	(r11)			; Are there any remaining characters?
                            93   14  14F2  2839 	bgtr	10$			; yes, try it again
                       5B   08   C0  14F4  2840 	addl2	#8,r11			; pop arguments
                                 05  14F7  2841 	rsb				; end of write
                                     14F8  2842 
                                     14F8  2843 
                                     14F8  2844 ;+++
                                     14F8  2845 ;k> xor -- ( f1 f2 -- f ) logical xor; f1 xor f2.
                                     14F8  2846 ;---
                                     14F8  2847 	header	xor
                            8B   D5  1500  2848 	tstl	(r11)+			; is the first one false?
                            06   13  1502  2849 	beql	10$			; yes
                            8B   D5  1504  2850 	tstl	(r11)+			; no, is the second one false?
                            0A   13  1506  2851 	beql	30$			; yes, leave with true
                            04   11  1508  2852 	brb	20$			; no leave with false
                                     150A  2853 10$:					; first one false
                            8B   D5  150A  2854 	tstl	(r11)+			; Is the second one true?
                            04   12  150C  2855 	bneq	30$			; yes, leave with true
                                     150E  2856 20$:					; leave with false
                       7B   00   D0  150E  2857 	movl	#c_false,-(r11)		; leave with false
                                 05  1511  2858 	rsb				; return
                                     1512  2859 30$:
              7B   FFFFFFFF 8F   D0  1512  2860 	movl	#c_true,-(r11)		; leave with true
                                 05  1519  2861 	rsb				; end of xor
                                     151A  2862 
                                     151A  2863 
                                     151A  2864 ;+++
                                     151A  2865 ;k> ] -- ( -- ) enter compile mode.  Used with { [ } in definitions.
                                     151A  2866 ;---
                                     151A  2867 	header i_right_back,<]>
           00001D35'EF   FF 8F   90  1520  2868 	movb   #c_true,v_mode		; enter compile mode
                                 05  1528  2869 	rsb				; end of l
                                     1529  2870 
                                     1529  2871 
                                     1529  2872 _kernel_end:
                                     1529  2873 	newpage <Compiler Built-ins>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  57
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1529  2874 ;*******************************************************************************
                                     1529  2875 ;
                                     1529  2876 ; Compiler Built-ins -- a new word is unlinked from the current vocabulary
                                     1529  2877 ;	and linked into the compilier vocabulary by the word { compiletime }.
                                     1529  2878 ;	Computer (or compiletime} words are only search for during the
                                     1529  2879 ;	definition of new words, which prevents them from mucking about with
                                     1529  2880 ;	the stacks and the dictionary when we are interpreting the user's
                                     1529  2881 ;	commands.
                                     1529  2882 ;
                                     1529  2883 ;*******************************************************************************
                                     1529  2884 compiler_begin:
                                     1529  2885 
                                     1529  2886 
                                     1529  2887 ;+++
                                     1529  2888 ;c> (variable) - ( -- ) compiles the code body of a word that pushes the
                                     1529  2889 ;	address of its parameter field on the stack.  Must be the last word
                                     1529  2890 ;	in the word...
                                     1529  2891 ;---
                                     1529  2892 ;??? This concept is fuzzy.  Work on it.
                                     1529  2893      header	  i_variable,<(variable)>,vl_compiler
                    89   9E 8F   90  1538  2894      movb	  #op_movab,(r9)+	; `movab'
                    89   AF 8F   90  153C  2895      movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  1540  2896      movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  1543  2897      movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  1547  2898      movb	  #op_rsb,(r9)+		; `rsb'
                                 05  154A  2899      rsb				; end of (variable)
                                     154B  2900 
                                     154B  2901 
                                     154B  2902 ;+++
                                     154B  2903 ;c> +loop -- ( n -- ) where n is an increment.  Edns { do .. +loop }.  Adds top
                                     154B  2904 ;	of stack to loop index and branches to { do } if ((index > 0) and
                                     154B  2905 ;	(index < limit)), or if ((index < 0) and (index > limit)).~~~ WTF: and should be or???
                                     154B  2906 ;	In other words, { +loop } with a positive argument is like Pascal's
                                     154B  2907 ;	{ for index := start to finish do ... } and with a negative argument
                                     154B  2908 ;	it is like { for index := start downto finish do }.
                                     154B  2909 ;---
                                     154B  2910 	header	i_plus_loop,<+loop>,vl_compiler
                    89   F1 8F   90  1555  2911 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  1559  2912 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  155D  2913 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8B 8F   90  1560  2914 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   6A 8F   90  1564  2915 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  1568  2916 	movl	r9,r0			; save address of branch word
                       89   00   B0  156B  2917 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  156E  2918 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  1572  2919 	movw	r1,(r0)			; save displacement
                  89   00C0 8F   B0  1575  2920 	movw	#op_addl2,(r9)+		; `addl2'	pop index&limit from ls
                       89   08   90  157A  2921 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  157D  2922 	movb	#adm_r10,(r9)+		; r10
                                 05  1581  2923 	rsb				; end of +loop
                                     1582  2924 
                                     1582  2925 
                                     1582  2926 ;+++
                                     1582  2927 ;c> ." -- ( -- ) compile text until next `"' into dictinary to be printed when
                                     1582  2928 ;	the current word is executed.
                                     1582  2929 ;---
                                     1582  2930 	header	i_dot_quote,<.">,vl_compiler
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  58
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                    89   9E 8F   90  1589  2931 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  158D  2932 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   05   90  1591  2933 	movb	#5,(r9)+		; (pc+5)	skip length byte too
                    89   7B 8F   90  1594  2934 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   31   90  1598  2935 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  159B  2936 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  159E  2937 	movw	#0,(r9)+		; save space for displacement
                       7B   22   D0  15A1  2938 	movl	#^a\"\,-(r11)		; set up for `"' delimited tokens
                       FD3E CF   16  15A4  2939 	jsb	token			; get token
                       50   69   9A  15A8  2940 	movzbl	(r9),r0			; get length of token
                  51   50   01   C1  15AB  2941 	addl3	#1,r0,r1		; calc displacement (count length too)
                    00 BA   51   B0  15AF  2942 	movw	r1,@(r10)		; fill in displacement
                       5A   04   C0  15B3  2943 	addl2	#4,r10			; pop item off loop stack
                       59   51   C0  15B6  2944 	addl2	r1,r9			; save string in dictionary
                    89   D0 8F   90  15B9  2945 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  15BD  2946 	movb	#adm_immediate,(r9)+	; immeidate mode
                       89   50   D0  15C1  2947 	movl	r0,(r9)+		; length of string
                    89   7B 8F   90  15C4  2948 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                     15C8  2949 ; we now have ( address count ) on stack (when new word executed)
                       89   16   90  15C8  2950 	movb	#op_jsb,(r9)+		; `jsb'
                    89   9F 8F   90  15CB  2951 	movb	#adm_absolute,(r9)+	; absolute mode
                  89   FE81 CF   DE  15CF  2952 	moval	write,(r9)+		; address of subroutine to jsb to
                                 05  15D4  2953 	rsb				; end of ."
                                     15D5  2954 
                                     15D5  2955 
                                     15D5  2956 ;+++
                                     15D5  2957 ;c> ; (semicolon) -- ( -- ) Terminate a definition started by { : }.
                                     15D5  2958 ;	Sets { mode } to false and adds an rsb to the definition.
                                     15D5  2959 ;---
                                     15D5  2960 	header	i_semicolon,<;>,vl_compiler
                       89   05   90  15DB  2961 	movb	#op_rsb,(r9)+		; put an rsb in to end word
              00001D35'EF   00   90  15DE  2962 	movb	#c_false,v_mode		; switch off compiler v_mode
                                     15E5  2963 ;??? might need to unset high bit in count of name (smudge) bit
                       FD9D CF   16  15E5  2964 	jsb	unsmudge      	     	; clear smudge bit so word is found
                                 05  15E9  2965 	rsb				; end of ;
                                     15EA  2966 
                                     15EA  2967 
                                     15EA  2968 ;+++
                                     15EA  2969 ;c> >defer -- ( -- ) ends a section of code that is to copied to the
                                     15EA  2970 ;	dictionary whenever this word is executed (i.e., { >defer } ends code
                                     15EA  2971 ;	to be executed by all words defined by the word we are now compiling).
                                     15EA  2972 ;	{ >defer } is used to define words that define words.
                                     15EA  2973 ;---
                                     15EA  2974 ;???  This concept is fuzzy.  Work on it.  May be fuzzy, but it works...
                                     15EA  2975 	header	   i_defer_end,^\>defer\,vl_compiler
                  50   59   8A   C3  15F5  2976 	subl3	   (r10)+,r9,r0		; calculate length and displacement
                       9A   50   B0  15F9  2977 	movw	   r0,@(r10)+		; store displacement
                       9A   50   B0  15FC  2978 	movw	   r0,@(r10)+		; store length
                                     15FF  2979 ; make new word advance dictionary pointer over just added code
                    89   C0 8F   90  15FF  2980 	movb	#op_addl2,(r9)+		; `addl2'
                    89   8F 8F   90  1603  2981 	movb	#adm_immediate,(r9)+	; i^#
                       80   50   D0  1607  2982 	movl	r0,(r0)+		; amount to advance
                    89   59 8F   90  160A  2983 	movb	#adm_r9,(r9)+		; r9
                                 05  160E  2984 	rsb				; end of >defer
                                     160F  2985 
                                     160F  2986 
                                     160F  2987 ;+++
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  59
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     160F  2988 ;c> again -- ( -- ) Terminate a { repeat ... if ... again } loop.  { agin }
                                     160F  2989 ;	unconditionally branches back to the { repeat }.
                                     160F  2990 ;---
                                     160F  2991 	header	again,,vl_compiler
                                     1619  2992 ; save values for calculating displacement in if.
                       50   8A   D0  1619  2993 	movl  (r10)+,r0			; save address to displace from if
                       51   8A   D0  161C  2994 	movl  (r10)+,r1			; save address for displacement
                                     161F  2995 ; construct negative branch from { again } to { repeat }
                       89   31   90  161F  2996 	movb	#op_brw,(r9)+		; `brw'
                       52   59   D0  1622  2997 	movl	r9,r2			; save address for negative displacement
                       89   00   B0  1625  2998 	movw	#0,(r9)+		; save space for displacement
                  53   8A   59   C3  1628  2999 	subl3	r9,(r10)+,r3		; calculate negative displacment
                       62   53   B0  162C  3000 	movw	r3,(r2)			; save negative displacement
                                     162F  3001 ; construct forward branch from { if } to after { again }
                  54   59   50   C3  162F  3002 	subl3	r0,r9,r4		; calculate { if }'s displacment
                       61   54   B0  1633  3003 	movw	r4,(r1)			; save displacement
                                 05  1636  3004 	rsb				; end of again
                                     1637  3005 
                                     1637  3006 
                                     1637  3007 ;+++
                                     1637  3008 ;c> b^ -- ( -- ) Convert next token to number and enclose low byte in dictionary.~~~ byte immediate???
                                     1637  3009 ;---
                                     1637  3010 	header	i_b_up,<b^>,vl_compiler
                       7B   20   D0  163E  3011 	movl	#c_blank,-(r11)		; set up for blank delimeted token
                       FCA1 CF   16  1641  3012 	jsb	token			; get it
                       F6DB CF   16  1645  3013 	jsb	number			; try to make it a number
                            8B   D5  1649  3014 	tstl	(r11)+			; is it a number?
                            01   12  164B  3015 	bneq	10$			; yes
                                 05  164D  3016 	rsb				; no, for now just exit~~~??? FIXME!
                                     164E  3017 10$:
                       89   6B   90  164E  3018 	movb	(r11),(r9)+		; save byte in dictionary
                       5B   04   C0  1651  3019 	addl2	#4,r11			; pop value from dstack
                                 05  1654  3020 	rsb				; end of b^
                                     1655  3021 
                                     1655  3022 
                                     1655  3023 ;+++
                                     1655  3024 ;c> defer< -- ( -- ) start a section of code that is to be copied to dictionary
                                     1655  3025 ;	whenever this word is executed (i.e., { defer< } starts code to be
                                     1655  3026 ;	executed by all words defined by the word we are now compiling).
                                     1655  3027 ;	Used in defining words that are to define words.
                                     1655  3028 ;---
                                     1655  3029 ;??? This concept is fuzzy.  Work on it.
                                     1655  3030 	header	i_defer_begin,^\defer<\,vl_compiler
                       89   28   90  1660  3031 	movb	#op_movc3,(r9)+		; `movc3'
                    89   8F 8F   90  1663  3032 	movb	#adm_immediate,(r9)+	; I^x immediate mode
                       7A   59   D0  1667  3033 	movl	r9,-(r10)		; save address to put length in on
                                     166A  3034 					;   the loop stack
                       89   00   B0  166A  3035 	movw	#0,(r9)+		; save space for length
                    89   AF 8F   90  166D  3036 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  1671  3037 	movb	#4,(r9)+		; (pc+4)
                    89   69 8F   90  1674  3038 	movb	#adm_def_r9,(r9)+	; (r9)
                       89   31   90  1678  3039 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  167B  3040 	movl	r9,-(r10)		; save address to put branch
                                     167E  3041 					;   displacement at on loop stack
                       89   00   B0  167E  3042 	movw	#0,(r9)+		; save space for the displacement
                       7A   59   D0  1681  3043 	movl	r9,-(r10)		; save address of data start on loop
                                     1684  3044 					;   stack to calculate data length
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  60
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  1684  3045 	rsb				; end of defer<
                                     1685  3046 
                                     1685  3047 
                                     1685  3048 ;+++
                                     1685  3049 ;c> do -- ( n1 n2 -- ) Program control structure; starts { do ... +loop },
                                     1685  3050 ;	{ do ... downloop }, and { do ... loop }.  Note that all do
                                     1685  3051 ;	loops execute at least once.  `n1' is the limit and `n2' is the
                                     1685  3052 ;	number to start the index at.
                                     1685  3053 ;---
                                     1685  3054 	header	i_do,<do>,vl_compiler	; VAX/VMS debug thinks do is a command
                    89   D0 8F   90  168C  3055 	movb	#op_movl,(r9)+		; `movl'	save index
                    89   8B 8F   90  1690  3056 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   50 8F   90  1694  3057 	movb	#adm_r0,(r9)+		; r0
                    89   D0 8F   90  1698  3058 	movb	#op_movl,(r9)+		; `movl'	put limit on lstack
                    89   8B 8F   90  169C  3059 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   7A 8F   90  16A0  3060 	movb	#adm_adec_r10,(r9)+	; -(r10)
                    89   D0 8F   90  16A4  3061 	movb	#op_movl,(r9)+		; `movl'	put index on lstack
                    89   50 8F   90  16A8  3062 	movb	#adm_r0,(r9)+		; r0
                    89   7A 8F   90  16AC  3063 	movb	#adm_adec_r10,(r9)+	; -(r10)
                       7A   59   D0  16B0  3064 	movl	r9,-(r10)		; save address to branch to
                                 05  16B3  3065 	rsb				; end of do
                                     16B4  3066 
                                     16B4  3067 
                                     16B4  3068 ;+++
                                     16B4  3069 ;c> downloop -- ( -- ) Ends a { do ... downloop }.  Adds -1 to the loop index
                                     16B4  3070 ;	and branches to { do } if ((index < 0) and (index > limit)).~~~ inverted?
                                     16B4  3071 ;	In other words, { downloop } is like Pascal's
                                     16B4  3072 ;	{ for index := start downto finish do }.
                                     16B4  3073 ;---
                                     16B4  3074 	header	downloop,,vl_compiler
                    89   F1 8F   90  16C1  3075 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  16C5  3076 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  16C9  3077 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8F 8F   90  16CC  3078 	movb	#adm_immediate,(r9)+	; immediate mode
              89   FFFFFFFF 8F   D0  16D0  3079 	movl	#-1,(r9)+		; -1 is addend
                    89   6A 8F   90  16D7  3080 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  16DB  3081 	movl	r9,r0			; save address of branch word
                       89   00   B0  16DE  3082 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  16E1  3083 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  16E5  3084 	movw	r1,(r0)			; save displacement
                    89   C0 8F   90  16E8  3085 	movb	#op_addl2,(r9)+		; `addl2'	pop index&limit from lstack
                       89   08   90  16EC  3086 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  16EF  3087 	movb	#adm_r10,(r9)+		; r10
                                 05  16F3  3088 	rsb				; end of downloop
                                     16F4  3089 
                                     16F4  3090 
                                     16F4  3091 ;+++
                                     16F4  3092 ;c> else -- ( -- ) In control structure { if ... else ... endif } { else }
                                     16F4  3093 ;	else ends the true branch and starts the false branch.
                                     16F4  3094 ;---
                                     16F4  3095 	header	else,,vl_compiler
                       89   31   90  16FD  3096 	movb	#op_brw,(r9)+		; branch over false part
                       50   59   D0  1700  3097 	movl	r9,r0			; save address of displacement
                       89   00   B0  1703  3098 	movw	#0,(r9)+		; save space for displacement
                       51   59   D0  1706  3099 	movl	r9,r1			; save address to calculate
                                     1709  3100 					;   displacement from
                                     1709  3101 ; make branch to false part (fill in displacement in if)
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  61
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                  52   59   8A   C3  1709  3102 	subl3	(r10)+,r9,r2		; calculate displacement
                    00 BA   52   B0  170D  3103 	movw	r2,@(r10)		; save displacment
                       5A   04   C0  1711  3104 	addl2	#4,r10			; pop address of displacement off lstack
                       7A   50   D0  1714  3105 	movl	r0,-(r10)		; save address of displacement
                       7A   51   D0  1717  3106 	movl	r1,-(r10)		; save address to displace from
                                 05  171A  3107 	rsb				; end of else
                                     171B  3108 
                                     171B  3109 
                                     171B  3110 ;+++
                                     171B  3111 ;c> endif -- ( -- ) { endif } ends either of { if } or { else } branches.
                                     171B  3112 ;	{ if ... else ... endif } and { if ... endif } are both legal.
                                     171B  3113 ;---
                                     171B  3114 	header	endif,,vl_compiler
                  50   59   8A   C3  1725  3115 	subl3	(r10)+,r9,r0		; calculate displacement
                    00 BA   50   B0  1729  3116 	movw	r0,@(r10)		; save displacement
                       5A   04   C0  172D  3117 	addl2	#4,r10			; pop address of displacement off lstack
                                 05  1730  3118 	rsb				; end of endif
                                     1731  3119 
                                     1731  3120 
                                     1731  3121 ;+++
                                     1731  3122 ;c> endwhile -- ( -- ) ends a { while ... endwhile }.  Unconditionally branches
                                     1731  3123 ;	back to { while }.
                                     1731  3124 ;---
                                     1731  3125 	header	endwhile,,vl_compiler
                       89   31   90  173E  3126 	movb	#op_brw,(r9)+		; brw back to test
                       50   59   D0  1741  3127 	movl	r9,r0			; address to put displacement in
                       89   00   B0  1744  3128 	movw	#0,(r9)+		; save space for displacement
                  51   59   8A   C3  1747  3129 	subl3	(r10)+,r9,r1		; displacement to after loop
                    00 BA   51   B0  174B  3130 	movw	r1,@(r10)		; fill in displacement to after loop
                       5A   04   C0  174F  3131 	addl2	#4,r10			; pop off address of displacement
                  51   8A   59   C3  1752  3132 	subl3	r9,(r10)+,r1		; displacement back to beginning
                       60   51   B0  1756  3133 	movw	r1,(r0)			; save displacement
                                 05  1759  3134 	rsb				; end of endwhile
                                     175A  3135 
                                     175A  3136 
                                     175A  3137 ;+++
                                     175A  3138 ;c> if -- ( n -- ) In { if ... else ... endif } or { if ... endif },
                                     175A  3139 ;	if the top of the stack is true, execute the code following
                                     175A  3140 ;	the { if } until an { endif } or an { else }.  At an { else } skip to
                                     175A  3141 ;	the code after the { endif }.  If the top of the stack
                                     175A  3142 ;	is false, skip to the { endif } or { else }.
                                     175A  3143 ;	In the { repeat ... if ... again } if the top fo the stack is true the
                                     175A  3144 ;	code up to the { again } is executed and then a branch back to
                                     175A  3145 ;	{ repeat } is done.  If the top of the stack is false, execution jumps
                                     175A  3146 ;	to the code after the { again }.
                                     175A  3147 ;---
                                     175A  3148 	header	if,,vl_compiler
                    89   D5 8F   90  1761  3149 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  1765  3150 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  1769  3151 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  176C  3152 	movb	#^x03,(r9)+		; to (pc+3)
                       89   31   90  176F  3153 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1772  3154 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  1775  3155 	movw	#0,(r9)+		; save space for displacmnent
                       7A   59   D0  1778  3156 	movl	r9,-(r10)		; save address to calculate
                                     177B  3157 					;   displacement from
                                 05  177B  3158 	rsb				; end of if
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  62
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     177C  3159 
                                     177C  3160 
                                     177C  3161 ;+++
                                     177C  3162 ;c> l^ -- ( -- ) Convert next token to number and enclose in dictionary.
                                     177C  3163 ;---
                                     177C  3164 	header	i_l_up,<l^>,vl_compiler
                       7B   20   D0  1783  3165 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FB5C CF   16  1786  3166 	jsb	token			; get it
                       F596 CF   16  178A  3167 	jsb	number			; try to make it a number
                            8B   D5  178E  3168 	tstl	(r11)+			; Is it a number>
                            01   12  1790  3169 	bneq	10$			; yes
                                 05  1792  3170 	rsb				; no, for now just exit~~~ WTF, no error?
                                     1793  3171 10$:
                       89   8B   D0  1793  3172 	movl	(r11)+,(r9)+		; save long in dictionary
                                 05  1796  3173 	rsb				; end of l^
                                     1797  3174 
                                     1797  3175 
                                     1797  3176 ;+++
                                     1797  3177 ;c> literal -- ( n -- ) convert top of stack to a literal in current word.
                                     1797  3178 ;---
                                     1797  3179 	header	literal,,vl_compiler
                    89   D0 8F   90  17A3  3180 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  17A7  3181 	movb	#adm_immediate,(r9)+	; immediate mode
                       89   8B   D0  17AB  3182 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                    89   7B 8F   90  17AE  3183 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                 05  17B2  3184 	rsb				; end of literal
                                     17B3  3185 
                                     17B3  3186 
                                     17B3  3187 ;+++
                                     17B3  3188 ;c> loop -- ( -- ) Ends a { do ... loop }.  Adds 1 to loop index and branches
                                     17B3  3189 ;	to { do } if ((index >= 0) and (index < limit)).  In other words,
                                     17B3  3190 ;	{ loop } is like Pascal's { for index := start to finish do ... }.
                                     17B3  3191 ;---
                                     17B3  3192 	header	i_loop,<loop>,vl_compiler ; VAX/VMS debuffer thinks loop is a a command
                    89   F1 8F   90  17BC  3193 	movb	#op_acbl,(r9)+		  ; `acbl'
                    89   AA 8F   90  17C0  3194 	movb	#adm_b_dis_r10,(r9)+	  ; b^(r10)
                       89   04   90  17C4  3195 	movb	#4,(r9)+		  ; 4 byte displacement for previous adm
                       89   01   90  17C7  3196 	movb	#^x01,(r9)+		  ; s^#1
                    89   6A 8F   90  17CA  3197 	movb	#adm_def_r10,(r9)+	  ; (r10)
                       50   59   D0  17CE  3198 	movl	r9,r0			  ; save address of branch word
                       89   00   B0  17D1  3199 	movw	#0,(r9)+		  ; save space for branch displacement
                  51   8A   59   C3  17D4  3200 	subl3	r9,(r10)+,r1		  ; calculate displacement
                       60   51   B0  17D8  3201 	movw	r1,(r0)			  ; save displacement
                    89   C0 8F   90  17DB  3202 	movb	#op_addl2,(r9)+		  ; `addl2'	pop index&limit from lstack
                       89   08   90  17DF  3203 	movb	#^x08,(r9)+		  ; s^#8
                    89   5A 8F   90  17E2  3204 	movb	#adm_r10,(r9)+		  ; r10
                                 05  17E6  3205 	rsb				  ; end of loop
                                     17E7  3206 
                                     17E7  3207 
                                     17E7  3208 ;+++
                                     17E7  3209 ;c> recurse -- ( -- ) Compile a jsb to the word that is currently being defined,
                                     17E7  3210 ;	allowing recursion.
                                     17E7  3211 ;---
                                     17E7  3212 	header	recurse,,vl_compiler
              7B   00001D1F'FF   D0  17F3  3213 	movl	@v_context,-(r11)	; get address of current word
                       EF4E CF   16  17FA  3214 	jsb	cfa			; get the code field address
                       EFA8 CF   16  17FE  3215 	jsb	i_compile_jsb		; compile it into current word
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  63
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                 05  1802  3216 	rsb				; end of recurse
                                     1803  3217 
                                     1803  3218 
                                     1803  3219 ;+++
                                     1803  3220 ;c> repeat -- ( -- ) Start { repeat ... until } and { repeat ... if ... again }
                                     1803  3221 ;	loops.
                                     1803  3222 ;---
                                     1803  3223 	header	repeat,,vl_compiler
                       7A   59   D0  180E  3224 	movl	r9,-(r10)		; save address to branch to
                                 05  1811  3225 	rsb				; end of repeat
                                     1812  3226 
                                     1812  3227 
                                     1812  3228 ;+++
                                     1812  3229 ;c> w^ -- ( -- ) Convert next token to number, enclose low 16 bits in dictionary.
                                     1812  3230 ;	This is used with the assembler, mainly, which is why it is w^ instead
                                     1812  3231 ;	of  s^.
                                     1812  3232 ;---
                                     1812  3233 	header	i_s_up,<w^>,vl_compiler
                       7B   20   D0  1819  3234 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FAC6 CF   16  181C  3235 	jsb	token			; get it
                       F500 CF   16  1820  3236 	jsb	number			; try to make it a number
                            8B   D5  1824  3237 	tstl	(r11)+			; Is it a number?
                            01   12  1826  3238 	bneq	10$			; yes
                                 05  1828  3239 	rsb				; no, for now just exit~~~ WTF, no error?
                                     1829  3240 10$:
                       89   6B   B0  1829  3241 	movw	(r11),(r9)+		; save word in dictionary
                       5B   04   C0  182C  3242 	addl2	#4,r11			; pop value from dstack
                                 05  182F  3243 	rsb				; end of w^
                                     1830  3244 
                                     1830  3245 
                                     1830  3246 ;+++
                                     1830  3247 ;c> until -- ( f -- ) End a { repeat ... until } loop.  If top of stack is
                                     1830  3248 ;	false, branch back to the { repeat }, else fall out of loop.
                                     1830  3249 ;---
                                     1830  3250 	header	until,,v1_compiler
                    89   D5 8F   90  183A  3251 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  183E  3252 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  1842  3253 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  1845  3254 	movb	#3,(r9)+		; (pc+3)
                       89   31   90  1848  3255 	movb	#op_brw,(r9)+		; `brw'
                       50   59   D0  184B  3256 	movl	r9,r0			; save address of displacement
                       89   00   B0  184E  3257 	movw	#0,(r9)+		; save space for displacement
                  51   8A   59   C3  1851  3258 	subl3	r9,(r10)+,r1		; calcualte negative displacement
                       6A   51   B0  1855  3259 	movw	r1,(r10)		; save negative displacement
                                 05  1858  3260 	rsb				; end of until
                                     1859  3261 
                                     1859  3262 
                                     1859  3263 ;+++
                                     1859  3264 ;c> while -- ( f -- ) Start a { while ... endwhile } loop.  If top of stack
                                     1859  3265 ;	is true, execute code to { endwhile }, which loops back to { while }.
                                     1859  3266 ;	If false, skip to after the { endwhile }.
                                     1859  3267 ;---
                                     1859  3268 	header	while,,vl_compiler
                       7A   59   D0  1863  3269 	movl	r9,-(r10)		; save address to branch to at endwhile
                    89   D5 8F   90  1866  3270 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  186A  3271 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  186E  3272 	movb	#op_bneq,(r9)+		; `bneq'
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  64
V1.01                           Compiler Built-ins                        7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                       89   03   90  1871  3273 	movb	#3,(r9)+		; over brw false_part
                       89   31   90  1874  3274 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1877  3275 	movl	r9,-(r10)		; save address of displacement to
                                     187A  3276 					;   statements after loop
                       89   00   B0  187A  3277 	movw	#0,(r9)+		; save space for displacement
                       7A   59   D0  187D  3278 	movl	r9,-(r10)		; address to make diplacement to
                                     1880  3279 					;   after loop from~~~ awkward phrasing
                                 05  1880  3280 	rsb				; end of while
                                     1881  3281 
                                     1881  3282 
                                     1881  3283 ;+++
                                     1881  3284 ;c> [ -- ( -- ) leave compile mode without terminating definition.
                                     1881  3285 ;	Must be followed by { ] }.
                                     1881  3286 ;---
                                     1881  3287 	header	i_left_brack,<[>,vl_compiler
              00001D35'EF   00   90  1887  3288 	movb	#c_false,v_mode
                                 05  188E  3289 	rsb				; end of [
                                     188F  3290 
                                     188F  3291 
                                     188F  3292 ;+++
                                     188F  3293 ;c> [ascii] -- ( -- ) compile ascii value of 1st char of next token into word.
                                     188F  3294 ;---
                                     188F  3295 	header	i_compile_ascii,<[ascii]>,vl_compiler
                       7B   20   D0  189B  3296 	movl	#c_blank,-(r11)		; set up for blank separated token
                       FA44 CF   16  189E  3297 	jsb	token			; get it
                    7B   01 A9   9A  18A2  3298 	movzbl	1(r9),-(r11)		; put ascii value of 1st char of token on stack
                       FEF9 CF   16  18A6  3299 	jsb	literal			; compile it into the dictionary
                                 05  18AA  3300 	rsb				; end of ascii
                                     18AB  3301 
                                     18AB  3302 
                                     18AB  3303 _compiler_end:
                                     18AB  3304 	newpage <Enter VTIL>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  65
V1.01                           Enter VTIL                                7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     18AB  3305 ;*******************************************************************************
                                     18AB  3306 ;
                                     18AB  3307 ; Enter VTIL -- Set up condition handler and call main program.
                                     18AB  3308 ;
                                     18AB  3309 ;*******************************************************************************
                                     18AB  3310 
                                     18AB  3311 
                                     18AB  3312 ;+++
                                     18AB  3313 ;s> vtil -- entry procedure of vtil
                                     18AB  3314 ;---
                               0FC0  18AB  3315 	.entry	vtil,^m<r6,r7,r8,r9,r10,r11>
                                     18AD  3316     .if defined ca_trapping
                                     18AD  3317         .print ; Trapping is enabled
                                     18AD  3318 	moval	s_trap,(fp)		; set up condition handler
                                     18AD  3319     .if_false
                                     18AD  3320         .print ; Trapping is not enabled

                                     18AD  3321     .endc
                                     18AD  3322     .if defined ca_controlc
                                     18AD  3323         .print ; Control/C Trapping is enabled
                                     18AD  3324 ; If a terminal, set up control/c trap
                                     18AD  3325 	$assign_s chan=v_input_chan,-	; connect to sys$command
                                     18AD  3326 		devnam=v_input_name
                                     18AD  3327 	blbs	r0,1$			; exit on error~~~Success, so branch over error exit
                                     18AD  3328 	brw	vtil_exit		; exit vtil
                                     18AD  3329 1$:
                                     18AD  3330 	$getchn_s chan=v_input_chan,-	; find out if it is a terminal
                                     18AD  3331 		prilen=v_getchn_ret_len,- ; where to put length
                                     18AD  3332 		pribuf=v_getchn_in_buf  ; where to find input buffer
                                     18AD  3333 
                                     18AD  3334 	cmpb	#dc$_term,v_getchn_buf+4 ; is it a terminal?
                                     18AD  3335 	bneq	5$			; not a terminal, so don't enable ctr-c
                                     18AD  3336 ; enable control-c trapping
                                     18AD  3337 	.show	   meb,me
                                     18AD  3338 	$qio_s	chan=v_input_chan,-
                                     18AD  3339 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     18AD  3340 		p1=enable_ctrlc,-
                                     18AD  3341 		p3=#3
                                     18AD  3342 	blbs	r0,6$			; no error, go on, don't deassign channel
                                     18AD  3343 	brw	vtil_exit
                                     18AD  3344 5$:
                                     18AD  3345 ;	$dassign_s chan=v_input_chan    ; channel not a terminal, deassign it.
                                     18AD  3346 6$:
                                     18AD  3347     .if_false
                                     18AD  3348         .print ; Control/c trapping not enabled

                                     18AD  3349     .endc
                                     18AD  3350 
              00001965'EF   00   FB  18AD  3351 	calls	#0,s_cold_start		; call subroutine to start from scratch
                                     18B4  3352 ; If we have returned from cold start there was an error caught by the
                                     18B4  3353 ; trap subroutine and we want to a warm start.
                                     18B4  3354 10$:
              000019B1'EF   00   FB  18B4  3355 	calls	#0,s_warm_start		; call subroutine to do warm start.
                                     18BB  3356 ; If we have returned from warm start there was an error caught by the
                                     18BB  3357 ; trap subroutine and we want to do another warm start.
                            F7   11  18BB  3358 	brb	10$
                                     18BD  3359 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  66
V1.01                           Enter VTIL                                7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     18BD  3360 ;+++
                                     18BD  3361 ;r> vtil_exit -- exit if errors in setting up control-c ast or traps
                                     18BD  3362 ;---
                                     18BD  3363 vtil_exit:
                            50   DD  18BD  3364 	pushl	r0
              00000000'GF   01   FB  18BF  3365 	calls	#1,g^lib$signal
                                 04  18C6  3366 	ret				; this is return from main program.
                                     18C7  3367 
                                     18C7  3368 
                                     18C7  3369 ;+++
                                     18C7  3370 ;s> enable_ctrlc -- enable controlc trapping.
                                     18C7  3371 ;---
                               0000  18C7  3372 	.entry	enable_ctrlc,^m<>
                                     18C9  3373 ; reenable ctrlc handler...
                                     18C9  3374 	$qio_s	chan=v_input_chan,-
                                     18C9  3375 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     18C9  3376 		p1=enable_ctrlc,-
                                     18C9  3377 		p3=#3
                   00000000'8F   DD  18ED  3378 	pushl	#vtil_ctrlc
              00000000'GF   01   FB  18F3  3379 	calls	#1,g^lib$signal		; this should NOT return!
                                 05  18FA  3380 	rsb				; end of enable_ctrlc
                                     18FB  3381 
                                     18FB  3382 
                                     18FB  3383 ;+++
                                     18FB  3384 ;s> trap --  trap routine.  Don't exit VTIL unless maximum number of errors
                                     18FB  3385 ;	has been exceeded.
                                     18FB  3386 ;---
                               0000  18FB  3387 	.entry	s_trap,^m<>
                                     18FD  3388 ; output some sort of error message
                    51   04 AC   D0  18FD  3389 	movl	chf$l_sigarglst(ap),r1
                            01   DD  1901  3390 	pushl	#1
                         04 A1   DD  1903  3391 	pushl	chf$l_sig_name(r1)
                                     1906  3392 	$putmsg_s msgvec=(r1)
                                     1915  3393 ; somewhere we need to figure out how to message this as well
                   00001D17'EF   D6  1915  3394 	incl	v_errors		; increment number of errors
              14   00001D17'EF   D1  191B  3395 	cmpl	v_errors,#c_max_errs	; the max number of errors exceeded?
                            1C   14  1922  3396 	bgtr	10$			; yes, go exit
                    50   08 AC   D0  1924  3397 	movl	chf$l_mcharglst(ap),r0	; get address of mechanism array
                         08 A0   D0  1928  3398 	movl	chf$l_mch_depth(r0),-	; get depth, so we will unwind to
                   00001D0F'EF       192B  3399 		v_trap_depth		;   the main program
                                     1930  3400 	$unwind_s depadr=v_trap_depth	; unwind stack
                                 04  193F  3401 	ret				; return to main progam
                                     1940  3402 10$:
                            00   DD  1940  3403 	pushl	#0			; number of fao parameters
                   00000000'8F   DD  1942  3404 	pushl	#vtil_maxerrors		; message number
                            02   DD  1948  3405 	pushl	#2			; number of longs in message vecor,
                                     194A  3406 					; not including this one.
                       50   5E   D0  194A  3407 	movl	sp,r0			; save address of buffer
                                     194D  3408 	$putmsg_s msgvec=(r0)		; write message
                                     195C  3409 	$exit_s				; exit
                                     1965  3410 					; end of trap
                                     1965  3411 
                                     1965  3412 	newpage <Initialization>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  67
V1.01                           Initialization                            7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1965  3413 ;*******************************************************************************
                                     1965  3414 ;
                                     1965  3415 ; Initialization
                                     1965  3416 ;
                                     1965  3417 ;*******************************************************************************
                                     1965  3418 
                                     1965  3419 ;+++
                                     1965  3420 ;s> cold_start -- do all initial setup
                                     1965  3421 ;+++
                               0000  1965  3422 	.entry	s_cold_start,^m<>
              00001D1B'EF   5E   D0  1967  3423 	movl	sp,v_returnstack	; save original return stack pointer
              59   00000000'8F   D0  196E  3424 	movl	#c_dict_begin,r9	; initialize dictionary pointer
                                     1975  3425 ; vl_compiler and vl_kernel are symbols that contain location of last word in
                                     1975  3426 ; these vocabularies, which are built-in.
     00001D27'EF   0000188F'8F   D0  1975  3427 	movl	#vl_compiler,v_compiler	; Initialize compiler vocabulary
     00001D2B'EF   0000151A'8F   D0  1980  3428 	movl	#vl_kernel,v_kernel	; Initialize kernel vocabulary
                                     198B  3429 ; greet user
                   00001800'EF   7F  198B  3430 	pushaq	v_greeting
              00000000'GF   01   FB  1991  3431 	calls	#1,g^lib$put_output	; greet user
     00001D1F'EF   00001D2B'EF   DE  1998  3432 	moval	v_kernel,v_context	; Initialize context
     00001D23'EF   00001D2B'EF   DE  19A3  3433 	moval	v_kernel,v_current	; Initialize current
                          009C   31  19AE  3434 	brw	_initialize		; skip patching stuff
                                     19B1  3435 
                                     19B1  3436 
                                     19B1  3437 ;+++
                                     19B1  3438 ;s> warm_start -- do a warm start.  Called from main program.  Branched to
                                     19B1  3439 ;	internally.
                                     19B1  3440 ;---
                               0000  19B1  3441 	.entry	s_warm_start,^m<>
                                     19B3  3442 ; only greet user if entered from main program.  Otherwise we are recovering
                                     19B3  3443 ; from an internal error and are only patching, not recovering from a trap.
                   00001800'EF   7F  19B3  3444 	pushaq	v_greeting
              00000000'GF   01   FB  19B9  3445 	calls	#1,g^lib$put_output	; greet user
     00001D1F'EF   00001D2B'EF   DE  19C0  3446 	moval	v_kernel,v_context	; Initialize context
     00001D23'EF   00001D2B'EF   DE  19CB  3447 	moval	v_kernel,v_current	; Initialize current
                                     19D6  3448 ;+++
                                     19D6  3449 ;r> warm_start -- so we can brw to it as well as call it
                                     19D6  3450 ;---
                                     19D6  3451 r_warm_start:
                                     19D6  3452 
                                     19D6  3453 ; The following patches system variables and delivers error messages to the user
                                     19D6  3454 ; about the cause of the boom.
                   00001D35'EF   95  19D6  3455 	tstb	v_mode		        ; were we compiling before error?
                            04   13  19DC  3456 	beql	10$			; no
                       F988 CF   16  19DE  3457 	jsb	unlink			; yes, unlink unfinished word
                                     19E2  3458 10$:
              00001D35'EF   00   90  19E2  3459 	movb	#c_false,v_mode		; put in execute mode
              00001D34'EF   00   90  19E9  3460 	movb	#c_false,v_state	;   just in case
              00001999'EF   00   B0  19F0  3461 	movw	#0,v_inlen		; so start with new line
              00001997'EF   00   B0  19F7  3462 	movw	#0,v_org_inlen		;   just in case
                   00001D2F'EF   95  19FE  3463 	tstb	v_infile		; Are we getting from file?
                            3C   13  1A04  3464 	beql	20$			; no
                                     1A06  3465 	$close	fab=v_infab		; yes, close file
              00001D2F'EF   00   90  1A13  3466 	movb	#c_false,v_infile	; set infile flag false
              00001D30'EF   00   D0  1A1A  3467 	movl	#0,v_filelinenum	; zero file line as well
              7B   00001890'EF   9E  1A21  3468 	movab	v_infilemess,-(r11)	; put address of 'In file:' on stack
                       EA4D CF   16  1A28  3469 	jsb 	bcount			; convert from ascic to write format ( address count )
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  68
V1.01                           Initialization                            7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                       FA24 CF   16  1A2C  3470 	jsb	write			; put in output
              7B   00001A3D'EF   DE  1A30  3471 	moval	v_fname,-(r11)		; put address of filename on stack
              7B   00001A3C'EF   9A  1A37  3472 	movzbl	v_fnamelen,-(r11)	; put count of filename on stack
                       FA12 CF   16  1A3E  3473 	jsb	write			; write filename out to terminal
                                     1A42  3474 20$:
                       E899 CF   16  1A42  3475 	jsb	q_cr			; finish off outstanding input, if any
              5E   00001D1B'EF   D0  1A46  3476 	movl	v_returnstack,sp	; restore original return stack pointer
                                     1A4D  3477 
                                     1A4D  3478 ;
                                     1A4D  3479 ; The following is also done during a cold start.
                                     1A4D  3480 ;
                                     1A4D  3481 _initialize:
                                     1A4D  3482 	; Initialize stacks.
              5B   00001000'EF   DE  1A4D  3483 	moval	c_ds_start,r11 		; move address of data stack to ds pointer
              5A   00001800'EF   DE  1A54  3484 	moval	c_ls_start,r10		; move address of loop stack to ls pointer
                                     1A5B  3485 
                                     1A5B  3486 
                                     1A5B  3487 	newpage <Interpreter>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  69
V1.01                           Interpreter                               7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1A5B  3488 ;*******************************************************************************
                                     1A5B  3489 ;
                                     1A5B  3490 ; Interpreter -- Take commands from the user (or a file) and execute them.
                                     1A5B  3491 ;
                                     1A5B  3492 ;*******************************************************************************
                                     1A5B  3493 _interpreter:
                       7B   20   D0  1A5B  3494 	movl	#c_blank,-(r11)		; set up for space delimeted token
                       F884 CF   16  1A5E  3495 	jsb	token			; get the next token
                                     1A62  3496 ; is it a comment?
                       69   01   91  1A62  3497 	cmpb	#1,(r9)			; token only one byte long?
                            0D   12  1A65  3498 	bneq	10$			; no
                 01 A9   5C 8F   91  1A67  3499 	cmpb	#c_com1_begin,1(r9)	; is it a \
                            1B   13  1A6C  3500 	beql	_strip_comment		; yes, strip comment
                    01 A9   28   91  1A6E  3501 	cmpb	#c_com2_begin,1(r9)	; Is it a (
                            1F   13  1A72  3502 	beql	_strip_comment2		; yes, strip second type of comment
                                     1A74  3503 10$:
                       E8E7 CF   16  1A74  3504 	jsb	q_search		; search for the word
                            8B   D5  1A78  3505 	tstl	(r11)+			; was it found?
                            02   13  1A7A  3506 	beql	30$			; no, go see if number
                            1F   11  1A7C  3507 	brb	_q_execute		; yes, go see if execute or compile
                                     1A7E  3508 30$:
                       E8AE CF   16  1A7E  3509 	jsb	q_number		; see if it is a number
                            8B   D5  1A82  3510 	tstl	(r11)+			; was it valid?
                            D5   12  1A84  3511 	bneq	_interpreter		; yes, leave with number on the stack
                          0079   31  1A86  3512 	brw	_unknowntoken		; no, tell user bad token
                                     1A89  3513 
                                     1A89  3514 
                                     1A89  3515 _strip_comment:
                       7B   00   D0  1A89  3516 	movl	#c_com1_end,-(r11)	; end of first type of comment
                       F856 CF   16  1A8C  3517 	jsb	token			; get the token
                          FFC8   31  1A90  3518 	brw	_interpreter		; end of strip comment
                                     1A93  3519 
                                     1A93  3520 
                                     1A93  3521 _strip_comment2:
                       7B   29   D0  1A93  3522 	movl	#c_com2_end,-(r11)	; end of second type of comment
                       F84C CF   16  1A96  3523 	jsb	token			; get the token
                          FFBE   31  1A9A  3524 	brw	_interpreter		; end of strip comment2
                                     1A9D  3525 
                                     1A9D  3526 
                                     1A9D  3527 _q_execute:
                       ECAB CF   16  1A9D  3528 	jsb	cfa			; get the code field address of
                                     1AA1  3529 					;   the word
     00001D34'EF   00001D35'EF   91  1AA1  3530 	cmpb	v_mode,v_state		; v_mode = v_state?~~~ what does this tell us???
                            1E   12  1AAC  3531 	bneq	10$			; no, go compile it
              00001D34'EF   00   90  1AAE  3532 	movb	#c_false,v_state	; set v_state false~~~ Why???
                            9B   16  1AB5  3533 	jsb	@(r11)+			; yes, execute it
              00000000'8F   5A   D1  1AB7  3534 	cmpl	r10,#c_ds_end		; stack overflow?
                            2E   19  1ABE  3535 	blss	_overflow		; yes, go announce it
              00001000'8F   5B   D1  1AC0  3536 	cmpl	r11,#c_ds_start		; stack underflow?
                            11   14  1AC7  3537 	bgtr	_underflow		; yes, go announce it
                          FF8F   31  1AC9  3538 	brw	_interpreter		; everything ok, do it again
                                     1ACC  3539 10$:
              00001D34'EF   00   90  1ACC  3540 	movb	#c_false,v_state	; set v_state false~~~ what does this tell us???
                       ECD3 CF   16  1AD3  3541 	jsb	i_compile_jsb		; compile a jump to the word whose
                                     1AD7  3542 					;   cfa addressis at the top of stack
                          FF81   31  1AD7  3543 	brw	_interpreter		; everthing ok, do it again
                                     1ADA  3544 
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  70
V1.01                           Interpreter                               7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1ADA  3545 
                                     1ADA  3546 _underflow:
                       ED34 CF   16  1ADA  3547 	jsb	cr			; make sure everything is output
                   00001842'EF   7F  1ADE  3548 	pushaq	v_undermess		; push address of underflow message
              00000000'GF   01   FB  1AE4  3549 	calls	#1,g^lib$put_output	; tell user
                          FEE8   31  1AEB  3550 	brw	r_warm_start			; clean up VTIL
                                     1AEE  3551 
                                     1AEE  3552 
                                     1AEE  3553 _overflow:
                       ED20 CF   16  1AEE  3554 	jsb	cr			; make sure everything is output
                   0000185A'EF   7F  1AF2  3555 	pushaq	v_overmess		; make sure everything is output
              00000000'GF   01   FB  1AF8  3556 	calls	#1,g^lib$put_output	; tell user
                          FED4   31  1AFF  3557 	brw	r_warm_start			; clean up VTIL
                                     1B02  3558 
                                     1B02  3559 
                                     1B02  3560 _unknowntoken:
              7B   00001871'EF   9E  1B02  3561 	movab	v_unknown,-(r11)	; push address of unknown token message
                       E96C CF   16  1B09  3562 	jsb	bcount			; convert it to ( address count )
                       F943 CF   16  1B0D  3563 	jsb	write			; tell user
                       7B   59   D0  1B11  3564 	movl	r9,-(r11)		; get address of token
                            6B   D6  1B14  3565 	incl	(r11)			; move address over byte-count
                       7B   69   9A  1B16  3566 	movzbl	(r9),-(r11)		; get byte count of string on stack
                       F937 CF   16  1B19  3567 	jsb	write			; show user bad token
              7B   00001883'EF   9E  1B1D  3568 	movab	v_unknown2,-(r11)	; Put address of 'In line:' on stack
                       E951 CF   16  1B24  3569 	jsb	bcount			; convert it to ( address count )
                       F928 CF   16  1B28  3570 	jsb	write			; tell user
                   00001D2F'EF   95  1B2C  3571 	tstb	v_infile		; In a file?
                            0B   13  1B32  3572 	beql	10$			; no
              7B   00001D30'EF   D0  1B34  3573 	movl	v_filelinenum,-(r11)	; yes, print line number
                       E5E4 CF   16  1B3B  3574 	jsb	i_dot			; put number in output buffer
                                     1B3F  3575 10$:
                       ECCF CF   16  1B3F  3576 	jsb	cr			; end line
              7B   000018F7'EF   DE  1B43  3577 	moval	v_inbuf,-(r11)		; get address of original line
              7B   00001997'EF   32  1B4A  3578 	cvtwl	v_org_inlen,-(r11)	; length of original line
                       F8FF CF   16  1B51  3579 	jsb	write			; show user
                       ECB9 CF   16  1B55  3580 	jsb	cr			; end line
                          FE7A   31  1B59  3581 	brw	r_warm_start		; go clean up VTIL
                                     1B5C  3582 
                                     1B5C  3583 
                                     1B5C  3584 	newpage <Exit Routines>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  71
V1.01                           Exit Routines                             7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1B5C  3585 ;*******************************************************************************
                                     1B5C  3586 ;
                                     1B5C  3587 ; Exit Routines -- Routines to handle successful and unsuccessful  exits
                                     1B5C  3588 ;
                                     1B5C  3589 ;*******************************************************************************
                                     1B5C  3590 _error_exit:				; die messily
                            50   DD  1B5C  3591 	pushl	r0			; put error message number on stack
              00000000'GF   01   FB  1B5E  3592 	calls	#1,g^lib$signal		; signal error
                                 04  1B65  3593 	ret				; return
                                     1B66  3594 
                                     1B66  3595 
                         0C A6   DD  1B66  3596 _f_err:	pushl	fab$l_stv(r6)		; push stv and sts of fab
                         08 A6   DD  1B69  3597 	pushl	fab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1B6C  3598 	calls	#2,g^lib$signal		; signal error
                            1A   11  1B73  3599 	brb	_exit
                                     1B75  3600 
                                     1B75  3601 
                         0C A6   DD  1B75  3602 _r_err:	pushl	rab$l_stv(r6)		; push stv and sts of rab
                         08 A6   DD  1B78  3603 	pushl	rab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1B7B  3604 	calls	#2,g^lib$signal		; signal error
                                     1B82  3605 
                                     1B82  3606 
                                     1B82  3607 _done:	$close	fab=v_infile		; close input
                                     1B8F  3608 
                                     1B8F  3609 
                                     1B8F  3610 _exit:
                       50   01   D0  1B8F  3611 	movl	#1,r0			; successful completion
                                     1B92  3612 	$exit_s	r0			; exit with status
                                     1B9B  3613 
                                     1B9B  3614 
                                     1B9B  3615 	newpage <Dictionary Space>
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  72
V1.01                           Dictionary Space                          7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                     1B9B  3616 ;*******************************************************************************
                                     1B9B  3617 ;
                                     1B9B  3618 ; Dictionary
                                     1B9B  3619 ;
                                     1B9B  3620 ;*******************************************************************************
                                 00000000  3621 	.psect	vtildict
                                     0000  3622 c_dict_begin:
                           00004000  0000  3623 	. = .+<16 * 1024>		; reserve space for dictinary~~~ why not a constant???
                                     4000  3624 c_dict_end:
                                     4000  3625 
                                     4000  3626 
                                     4000  3627 ;
                                     4000  3628 ; Block i/o buffers -- Here because that is the safest place for them.
                                     4000  3629 ;
                                     4000  3630 v_blkbuff:
                           00004C00  4000  3631 	.blkb	c_max_blocks * c_block_size ; buffers for block i/o
                                     4C00  3632 
                                     4C00  3633 
                                     4C00  3634 ;*******************************************************************************
                                     4C00  3635 ;
                                     4C00  3636 ; End of VTIL, and transfer address
                                     4C00  3637 ;
                                     4C00  3638 ;*******************************************************************************
                                     4C00  3639 	.end	vtil
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  73
Symbol table                                                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

$$$ADR                         = 00000060    D            C_DICT_END                       00004000 R  D  05        
$$.TAB                         = 00001B30 R  D  02        C_DS_END                         00000000 R  D  02        
$$.TABEND                      = 00001B74 R  D  02        C_DS_SIZE                      = 00001000    D            
$$.TMP                         = 00000000    D            C_DS_START                       00001000 R  D  02        
$$.TMP1                        = 00000001    D            C_D_BLKS_IN_BLK                = 00000002    D            
$$.TMP2                        = 000000CF                 C_FALSE                        = 00000000    D            
$$.TMPX                        = 0000000A R  D  03        C_INUSE                        = 00000001    D            
$$.TMPX1                       = 0000000E    D            C_KEYSIZE                      = 00000004    D            
$$T1                           = 00000001    D            C_LS_END                         00001000 R  D  02        
ABORT                            000003A7 R  D  04        C_LS_SIZE                      = 00000800    D            
ABS                              000003B2 R  D  04        C_LS_START                       00001800 R  D  02        
ADM_ABSOLUTE                   = 0000009F    D            C_MAX_BLOCKS                   = 00000003    D            
ADM_ADEC_R10                   = 0000007A    D            C_MAX_ERRS                     = 00000014    D            
ADM_ADEC_R11                   = 0000007B    D            C_MAX_LEN                      = 000000A0    D            
ADM_AINC_R10                   = 0000008A    D            C_MAX_NAME_LEN                 = 00000050    D            
ADM_AINC_R11                   = 0000008B    D            C_MODIFIED                     = 00000002    D            
ADM_AINC_R9                    = 00000089    D            C_PAD_MOAT                     = 00000109    D            
ADM_B_DIS_R10                  = 000000AA    D            C_SCREEN_LEN                   = 00000050    D            
ADM_B_REL                      = 000000AF    D            C_TPU_COM_LEN                  = 00000004    D            
ADM_DEF_R10                    = 0000006A    D            C_TRUE                         = FFFFFFFF    D            
ADM_DEF_R11                    = 0000006B    D            DC$_TERM                         ********   X   00        
ADM_DEF_R9                     = 00000069    D            DECIMAL                          000008D9 R  D  04        
ADM_IMMEDIATE                  = 0000008F    D            DEFINITIONS                      000008F1 R  D  04        
ADM_R0                         = 00000050    D            DOWNLOOP                         000016C1 R  D  04        
ADM_R10                        = 0000005A    D            DROP                             00000906 R  D  04        
ADM_R9                         = 00000059    D            DSC$K_CLASS_S                    ********   X   00        
AGAIN                            00001619 R  D  04        DSC$K_DTYPE_T                    ********   X   00        
AND                              000003EF R  D  04        DUP                              00000920 R  D  04        
ARRAY                            00000410 R  D  04        ELSE                             000016FD R  D  04        
ASCII                            00000436 R  D  04        ENABLE_CTRLC                     000018C7 RG D  04        
BCOUNT                           00000479 R  D  04        ENDIF                            00001725 R  D  04        
BINARY                           0000048E R  D  04        ENDWHILE                         0000173E R  D  04        
BLANK                            000004AD R  D  04        EODP                             00000958 R  D  04        
BLOCK                            000004C2 R  D  04        EVE                              00000981 R  D  04        
BREAK                            0000062F R  D  04        FAB$B_DNS                      = 00000035    D            
BUFFER                           00000649 R  D  04        FAB$B_FNS                      = 00000034    D            
BYTE                             00000725 R  D  04        FAB$C_BID                      = 00000003    D            
CFA                              0000074C R  D  04        FAB$C_BLN                      = 00000050    D            
CHF$L_MCHARGLST                = 00000008    D            FAB$C_FIX                      = 00000001    D            
CHF$L_MCH_DEPTH                = 00000008    D            FAB$C_SEQ                      = 00000000    D            
CHF$L_SIGARGLST                = 00000004    D            FAB$C_VAR                      = 00000002    D            
CHF$L_SIG_NAME                 = 00000004    D            FAB$L_ALQ                      = 00000010    D            
CLIST                            00000767 R  D  04        FAB$L_DNA                      = 00000030    D            
COMPILER_BEGIN                   00001529 R  D  04        FAB$L_FNA                      = 0000002C    D            
COMPILETIME                      000007C5 R  D  04        FAB$L_FOP                      = 00000004    D            
CONTEXT                          000007EE R  D  04        FAB$L_STS                      = 00000008    D            
COUNT                            00000800 R  D  04        FAB$L_STV                      = 0000000C    D            
CR                               00000812 R  D  04        FAB$V_CHAN_MODE                = 00000002    D            
CREATE                           00000846 R  D  04        FAB$V_FILE_MODE                = 00000004    D            
CURRENT                          000008C5 R  D  04        FAB$V_GET                      = 00000001    D            
C_BLANK                        = 00000020    D            FAB$V_LNM_MODE                 = 00000000    D            
C_BLOCK_SIZE                   = 00000400    D            FAB$V_UPD                      = 00000003    D            
C_COM1_BEGIN                   = 0000005C    D            FAB$W_GBC                      = 00000048    D            
C_COM1_END                     = 00000000    D            FILL                             000009D3 R  D  04        
C_COM2_BEGIN                   = 00000028    D            FORGET                           00000A24 R  D  04        
C_COM2_END                     = 00000029    D            FREEMEM                          00000AD2 R  D  04        
C_DICT_BEGIN                     00000000 R  D  05        HEX                              00000AF6 R  D  04        
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  74
Symbol table                                                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

HLD                              00000B06 R  D  04        I_LONG                           00000BFA R  D  04        
HOLD                             00000B17 R  D  04        I_LOOP                           000017BC R  D  04        
IF                               00001761 R  D  04        I_LS_TO_DS                       00000C3A R  D  04        
IO$M_CTRLCAST                    ********   X   00        I_L_UP                           00001783 R  D  04        
IO$_SETMODE                      ********   X   00        I_MATCH                          00000C48 R  D  04        
I_AC_COLON                       000003C2 R  D  04        I_MINUS_ROT                      0000010C R  D  04        
I_ADD                            000000C1 R  D  04        I_MOVE_FILL                      00000CE4 R  D  04        
I_BIT_AND                        00000072 R  D  04        I_MULTIPLY                       000000A8 R  D  04        
I_BIT_NOT                        00000083 R  D  04        I_ONE_MINUS                      000001F2 R  D  04        
I_BIT_OR                         00000090 R  D  04        I_ONE_PLUS                       000001E8 R  D  04        
I_BIT_XOR                        0000009E R  D  04        I_PLUS_LOOP                      00001555 R  D  04        
I_BL                             0000049F R  D  04        I_PLUS_ROT                       000000DE R  D  04        
I_BLOCK_CLOSE                    00000543 R  D  04        I_PLUS_STORE                     000000CC R  D  04        
I_BLOCK_OPEN                     00000575 R  D  04        I_QUESTION                       000002CE R  D  04        
I_BLOCK_READ                     000005BB R  D  04        I_RIGHT_BACK                     00001520 R  D  04        
I_BLOCK_WRITE                    000005ED R  D  04        I_SAVE_BUFFERS                   00000F5D R  D  04        
I_BS_FETCH                       00000639 R  D  04        I_SEMICOLON                      000015DB R  D  04        
I_BUFFER_READ                    000006C0 R  D  04        I_SHARP                          00000015 R  D  04        
I_BUFFER_WRITE                   000006FC R  D  04        I_SHARP_GREATER                  00000036 R  D  04        
I_B_COMMA                        0000045B R  D  04        I_SHARP_S                        00000055 R  D  04        
I_B_FETCH                        00000469 R  D  04        I_SHORT                          00000FC2 R  D  04        
I_B_STORE                        0000044B R  D  04        I_SP_0                           00001021 R  D  04        
I_B_UP                           0000163E R  D  04        I_SP_FETCH                       00001015 R  D  04        
I_COLON                          000001FB R  D  04        I_STORE                          00000006 R  D  04        
I_COMMA                          000000F5 R  D  04        I_STRING_QUOTE                   00001220 R  D  04        
I_COMPILE_ASCII                  0000189B R  D  04        I_SUBTRACT                       000000FF R  D  04        
I_COMPILE_JSB                    000007AA R  D  04        I_S_UP                           00001819 R  D  04        
I_COUNT_BEGIN                    00000064 R  D  04        I_VARIABLE                       00001538 R  D  04        
I_COUNT_END                      000000B3 R  D  04        I_WORD_FETCH                     00000F3A R  D  04        
I_DEFER_BEGIN                    00001660 R  D  04        I_WORD_STORE                     00000F1C R  D  04        
I_DEFER_END                      000015F5 R  D  04        I_WS_FETCH                       00000F47 R  D  04        
I_DIVIDE                         000001C0 R  D  04        I_W_COMMA                        00000F2C R  D  04        
I_DIV_MOD                        000001CD R  D  04        KERNEL                           00000B3E R  D  04        
I_DO                             0000168C R  D  04        LEAVE                            00000B54 R  D  04        
I_DOT                            00000123 R  D  04        LIB$GET_INPUT                    ********   X   00        
I_DOT_LPAREN                     0000015A R  D  04        LIB$PUT_OUTPUT                   ********   X   00        
I_DOT_QUOTE                      00001589 R  D  04        LIB$SIGNAL                       ********   X   00        
I_DOT_SB                         00000179 R  D  04        LIB$_INPSTRTRU                   ********   X   00        
I_DOT_ST                         0000019D R  D  04        LITERAL                          000017A3 R  D  04        
I_DS_TO_LS                       00000914 R  D  04        LOAD                             00000B62 R  D  04        
I_EMPTY_BUFFERS                  00000936 R  D  04        LONGCONST                        00000C22 R  D  04        
I_EODP_PLUS_STORE                00000975 R  D  04        MAX                              00000C73 R  D  04        
I_EOD_STORE                      00000966 R  D  04        MESSAGE                          00000C8D R  D  04        
I_EQUAL                          00000264 R  D  04        MIN                              00000CA0 R  D  04        
I_EQUAL_TEXT                     0000027F R  D  04        MOD                              00000CB6 R  D  04        
I_EXIT                           000009C7 R  D  04        MOVE                             00000CCC R  D  04        
I_FETCH                          00000398 R  D  04        NCHR                           = 00000007                 
I_FLUSH_BUFFERS                  000009F1 R  D  04        NEGAGE                           00000CFD R  D  04        
I_FORGET_ERASE                   00000A7C R  D  04        NOT                              00000D09 R  D  04        
I_GREATER_EQUAL                  000002B7 R  D  04        NUMBER                           00000D24 R  D  04        
I_GRETER                         0000029F R  D  04        OCTAL                            00000DA4 R  D  04        
I_HALT                           00000AE8 R  D  04        OP_ACBL                        = 000000F1    D            
I_I_TO                           00000B2F R  D  04        OP_ADDL2                       = 000000C0    D            
I_LEFT_BRACK                     00001887 R  D  04        OP_BNEQ                        = 00000012    D            
I_LESS                           00000221 R  D  04        OP_BRW                         = 00000031    D            
I_LESS_EQUAL                     0000024D R  D  04        OP_JSB                         = 00000016    D            
I_LESS_SHARP                     00000239 R  D  04        OP_MOVAB                       = 0000009E    D            
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  75
Symbol table                                                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

OP_MOVAL                       = 000000DE    D            SYS$OPEN                         ********  G    04        
OP_MOVAW                       = 0000003E    D            SYS$PUTMSG                       ********  G    04        
OP_MOVB                        = 00000090    D            SYS$QIO                          ********  G    04        
OP_MOVC3                       = 00000028    D            SYS$UNWIND                       ********  G    04        
OP_MOVL                        = 000000D0    D            SYS$UPDATE                       ********  G    04        
OP_RSB                         = 00000005    D            S_COLD_START                     00001965 RG D  04        
OP_TSTL                        = 000000D5    D            S_TRAP                           000018FB RG D  04        
OR                               00000DB3 R  D  04        S_WARM_START                     000019B1 RG D  04        
OTS$CVT_L_TI                     ********   X   00        TOCHAR                           000012C5 R  D  04        
OVER                             00000DD3 R  D  04        TOKEN                            000012E6 R  D  04        
PAD                              00000DE0 R  D  04        TPU$TPU                          ********   X   00        
PUTC                             00000DF2 R  D  04        UNLINK                           0000136A R  D  04        
Q_CR                             000002DF R  D  04        UNSMUDGE                         00001386 R  D  04        
Q_DUP                            000002F7 R  D  04        UNTIL                            0000183A R  D  04        
Q_NUMBER                         00000330 R  D  04        UPDATE                           000013A0 R  D  04        
Q_N_CR                           00000309 R  D  04        V1_COMPILER                    = 00001830 R  D  04        
Q_SEARCH                         0000035F R  D  04        VARIABLE                         000013BA R  D  04        
RAB$B_RAC                      = 0000001E    D            VLIST                            000013DB R  D  04        
RAB$C_BID                      = 00000001    D            VL_COMPILER                    = 0000188F R  D  04        
RAB$C_BLN                      = 00000044    D            VL_KERNEL                      = 0000151A R  D  04        
RAB$C_KEY                      = 00000001    D            VOCABULARY                       0000141E R  D  04        
RAB$C_SEQ                      = 00000000    D            VTIL                             000018AB RG D  04        
RAB$L_CTX                      = 00000018    D            VTIL_CTRLC                       ********   X   00        
RAB$L_RBF                      = 00000028    D            VTIL_EXIT                        000018BD R  D  04        
RAB$L_ROP                      = 00000004    D            VTIL_MAXERRORS                   ********   X   00        
RAB$L_STS                      = 00000008    D            V_BLKBUFF                        00004000 R  D  05        
RAB$L_STV                      = 0000000C    D            V_BLKFAB                         00001AE0 R  D  02        
RAB$L_UBF                      = 00000024    D            V_BLKKEY                         00001B74 R  D  02        
RAB$V_RAH                      = 00000009    D            V_BLKRAB                         00001B30 R  D  02        
RAB$W_RSZ                      = 00000022    D            V_BLOCKIO                        00001B78 R  D  02        
RADIX                            00000E29 R  D  04        V_BUF_BLK_NUMS                   00001B80 R  D  02        
READ                             00000E3A R  D  04        V_BUF_INUSE                      00001B7D R  D  02        
READSTR                          00000EAE R  D  04        V_COMPILER                       00001D27 R  D  02        
RECURSE                          000017F3 R  D  04        V_CONTEXT                        00001D1F R  D  02        
REPEAT                           0000180E R  D  04        V_CTRLC_DEPTH                    00001D13 R  D  02        
RESTART                          00000F12 R  D  04        V_CURRENT                        00001D23 R  D  02        
RMS$_EOF                         ********   X   00        V_CURRENT_BUFF                   00001B79 R  D  02        
RMS$_FNF                         ********   X   00        V_ERRORS                         00001D17 R  D  02        
R_WARM_START                     000019D6 R  D  04        V_FILELINENUM                    00001D30 R  D  02        
SEARCH                           00000F8A R  D  04        V_FILENOTFOUND                   0000189A R  D  02        
SIGN                             00000FE7 R  D  04        V_FNAME                          00001A3D R  D  02        
SMUDGE                           00000FFE R  D  04        V_FNAMELEN                       00001A3C R  D  02        
SPACE                            00001033 R  D  04        V_GETCHN_BUF                     00001D07 R  D  02        
SPACES                           0000106C R  D  04        V_GETCHN_BUF_ADR                 00001D03 R  D  02        
SREAD                            0000108C R  D  04        V_GETCHN_IN_BUF                  00001CFF R  D  02        
STRCAT                           00001149 R  D  04        V_GETCHN_RET_LEN                 00001CFB R  D  02        
STRCMP                           0000118A R  D  04        V_GREETING                       00001800 R  D  02        
STRCPY                           000011C3 R  D  04        V_HLD                            00001D3A R  D  02        
STRING                           000011F5 R  D  04        V_INBUF                          000018F7 R  D  02        
STRMAX                           00001268 R  D  04        V_INFAB                          000019A8 R  D  02        
STRPOS                           0000127B R  D  04        V_INFILE                         00001D2F R  D  02        
SWAP                             000012AE R  D  04        V_INFILEMESS                     00001890 R  D  02        
SYS$CLOSE                        ********  G    04        V_INLEN                          00001999 R  D  02        
SYS$CONNECT                      ********  G    04        V_INPTR                          0000199B R  D  02        
SYS$EXIT                         ********  G    04        V_INPUT_CHAN                     00001CF9 R  D  02        
SYS$FIND                         ********  G    04        V_INPUT_NAME                     00001CE6 R  D  02        
SYS$GET                          ********  G    04        V_INRAB                          000019F8 R  D  02        
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  76
Symbol table                                                              7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

V_IN_DSC                         0000199F R  D  02        
V_KERNEL                         00001D2B R  D  02        
V_MODE                           00001D35 R  D  02        
V_NAMETOOLONG                    000018D8 R  D  02        
V_NAMETRUNC                      000018E8 R  D  02        
V_ORG_INLEN                      00001997 R  D  02        
V_OUTBUF                         00001B9A R  D  02        
V_OUTLEN                         00001B98 R  D  02        
V_OVERMESS                       0000185A R  D  02        
V_RADIX                          00001D36 R  D  02        
V_READADDR                       00001B92 R  D  02        
V_READDSC                        00001B8E R  D  02        
V_READLEN                        00001B8C R  D  02        
V_RETURNSTACK                    00001D1B R  D  02        
V_STATE                          00001D34 R  D  02        
V_STATIC_DSC                     00001B96 R  D  02        
V_TPU_COM                        00001C3A R  D  02        
V_TPU_COM2                       00001C3E R  D  02        
V_TPU_DSC                        00001CDE R  D  02        
V_TRAP_DEPTH                     00001D0F R  D  02        
V_UNDERMESS                      00001842 R  D  02        
V_UNKNOWN                        00001871 R  D  02        
V_UNKNOWN2                       00001883 R  D  02        
V_UNKN_BLK_MESS                  000018B1 R  D  02        
V_USRPROMPT                      00001838 R  D  02        
V_VTILPROMPT                     0000182A R  D  02        
V_WORDNOTFOUND                   000018C7 R  D  02        
WHILE                            00001863 R  D  04        
WRITE                            00001454 R  D  04        
XOR                              00001500 R  D  04        
_CHECK_BASE                      00000D69 R  D  04        
_CHECK_LOWERCASE                 00000D58 R  D  04        
_COMPILER_END                    000018AB R  D  04        
_DONE                            00001B82 R  D  04        
_ERROR_EXIT                      00001B5C R  D  04        
_EXIT                            00001B8F R  D  04        
_F_ERR                           00001B66 R  D  04        
_GETTOKEN                        0000130D R  D  04        
_INITIALIZE                      00001A4D R  D  04        
_INTERPRETER                     00001A5B R  D  04        
_INVALID_NUMBER                  00000D96 R  D  04        
_KERNEL_BEGIN                    00000000 R  D  04        
_KERNEL_END                      00001529 R  D  04        
_NUMBER_TOP                      00000D3A R  D  04        
_OVERFLOW                        00001AEE R  D  04        
_Q_EXECUTE                       00001A9D R  D  04        
_R_ERR                           00001B75 R  D  04        
_SKIPWHITESPACE                  000012EB R  D  04        
_STARTFOUND                      000012FF R  D  04        
_STRIP_COMMENT                   00001A89 R  D  04        
_STRIP_COMMENT2                  00001A93 R  D  04        
_UNDERFLOW                       00001ADA R  D  04        
_UNKNOWNTOKEN                    00001B02 R  D  04        
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  77
Psect synopsis                                                            7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)


                                                +----------------+
                                                ! Psect synopsis !
                                                +----------------+

PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          ---------  ----------     
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE  
$ABS$                           00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILDATA                        00001D3E  ( 7486.)  02 (  2.)  NOPIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT NOVEC LONG  
$RMSNAM                         00000018  (   24.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILCODE                        00001B9B  ( 7067.)  04 (  4.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE  
VTILDICT                        00004C00  (19456.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  78
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)


                                             +------------------------+
                                             ! Symbol Cross Reference !
                                             +------------------------+

SYMBOL                          VALUE        DEFINITION      REFERENCES... 
------                          -----        ----------      ------------- 
$$$ADR                         =00000060     3408   (1)      3377   (1)      3392   (1)      3400   (1)      3408   (1)    
$$.TAB                         =00001B30-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TABEND                      =00001B74-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP                         =00000000     442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP1                        =00000001     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMP2                        =000000CF     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMPX                        =0000000A-R   435    (1)      435    (1)    
$$.TMPX1                       =0000000E     435    (1)      435    (1)    
$$T1                           =00000001     3377   (1)      3377   (1)    
ABORT                           000003A7-R   1072   (1)    
ABS                             000003B2-R   1079   (1)      735    (1)    
ADM_ABSOLUTE                   =0000009F     268    (1)    #-1501   (1)    #-2794   (1)    #-2951   (1)    
ADM_ADEC_R10                   =0000007A     261    (1)    #-3060   (1)    #-3063   (1)    
ADM_ADEC_R11                   =0000007B     265    (1)    #-1134   (1)    #-1449   (1)    #-1932   (1)    #-2353   (1)    
                                                           #-2564   (1)    #-2583   (1)    #-2756   (1)    #-2897   (1)    
                                                           #-2934   (1)    #-2948   (1)    #-3183   (1)    
ADM_AINC_R10                   =0000008A     262    (1)    
ADM_AINC_R11                   =0000008B     266    (1)    #-2914   (1)    #-3056   (1)    #-3059   (1)    #-3150   (1)    
                                                           #-3252   (1)    #-3271   (1)    
ADM_AINC_R9                    =00000089     258    (1)    #-1097   (1)    
ADM_B_DIS_R10                  =000000AA     263    (1)    #-2912   (1)    #-3076   (1)    #-3194   (1)    
ADM_B_REL                      =000000AF     269    (1)    #-1095   (1)    #-1132   (1)    #-1447   (1)    #-1930   (1)    
                                                           #-2351   (1)    #-2562   (1)    #-2581   (1)    #-2754   (1)    
                                                           #-2792   (1)    #-2895   (1)    #-2932   (1)    #-3036   (1)    
ADM_DEF_R10                    =0000006A     260    (1)    #-2915   (1)    #-3080   (1)    #-3197   (1)    
ADM_DEF_R11                    =0000006B     264    (1)    
ADM_DEF_R9                     =00000069     257    (1)    #-3038   (1)    
ADM_IMMEDIATE                  =0000008F     267    (1)    #-2946   (1)    #-2981   (1)    #-3032   (1)    #-3078   (1)    
                                                           #-3181   (1)    
ADM_R0                         =00000050     255    (1)    #-3057   (1)    #-3062   (1)    
ADM_R10                        =0000005A     259    (1)    #-2922   (1)    #-3087   (1)    #-3204   (1)    
ADM_R9                         =00000059     256    (1)    #-2983   (1)    
AGAIN                           00001619-R   2991   (1)    
AND                             000003EF-R   1110   (1)    
ARRAY                           00000410-R   1129   (1)    
ASCII                           00000436-R   1144   (1)    
BCOUNT                          00000479-R   1183   (1)      1480   (1)      1579   (1)      1587   (1)      1781   (1)    
                                                             1784   (1)      1808   (1)      1811   (1)      2771   (1)    
                                                             3469   (1)      3562   (1)      3569   (1)    
BINARY                          0000048E-R   1193   (1)    
BLANK                           000004AD-R   1209   (1)    
BLOCK                           000004C2-R   1220   (1)    
BREAK                           0000062F-R   1343   (1)    
BUFFER                          00000649-R   1359   (1)    
BYTE                            00000725-R   1444   (1)    
CFA                             0000074C-R   1461   (1)      3214   (1)      3528   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  79
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

CHF$L_MCHARGLST                =00000008                   #-3397   (1)    
CHF$L_MCH_DEPTH                =00000008                   #-3398   (1)    
CHF$L_SIGARGLST                =00000004                   #-3389   (1)    
CHF$L_SIG_NAME                 =00000004                   #-3391   (1)    
CLIST                           00000767-R   1473   (1)    
COMPILER_BEGIN                  00001529-R   2884   (1)    
COMPILETIME                     000007C5-R   1512   (1)      1103   (1)    
CONTEXT                         000007EE-R   1534   (1)    
COUNT                           00000800-R   1545   (1)      1998   (1)    
CR                              00000812-R   1555   (1)      1584   (1)      2175   (1)      2408   (1)      2442   (1)    
                                                             3547   (1)      3554   (1)      3576   (1)      3580   (1)    
                                                             956    (1)      982    (1)    
CREATE                          00000846-R   1570   (1)      1093   (1)      1130   (1)      1445   (1)      1928   (1)    
                                                             1942   (1)      2349   (1)      2560   (1)      2579   (1)    
                                                             2752   (1)      2790   (1)      842    (1)    
CURRENT                         000008C5-R   1603   (1)    
C_BLANK                        =00000020     216    (1)    #-1145   (1)    #-1202   (1)    #-1211   (1)    #-1484   (1)    
                                                           #-1574   (1)    #-1702   (1)    #-1769   (1)    #-1795   (1)    
                                                           #-1891   (1)    #-2413   (1)    #-2676   (1)    #-2775   (1)    
                                                           #-3011   (1)    #-3165   (1)    #-3234   (1)    #-3296   (1)    
                                                           #-3494   (1)    #-742    (1)    
C_BLOCK_SIZE                   =00000400     225    (1)    #-1264   (1)    #-1329   (1)    #-1401   (1)    #-1416   (1)    
                                                           #-1434   (1)      227    (1)      3631   (1)      435    (1)    
                                                             442    (1)    
C_COM1_BEGIN                   =0000005C     217    (1)    #-3499   (1)    
C_COM1_END                     =00000000     218    (1)    #-3516   (1)    
C_COM2_BEGIN                   =00000028     220    (1)    #-3501   (1)    
C_COM2_END                     =00000029     221    (1)    #-3522   (1)    
C_DICT_BEGIN                    00000000-R   3622   (1)    #-3424   (1)    
C_DICT_END                      00004000-R   3624   (1)    #-1820   (1)    
C_DS_END                        00000000-R   345    (1)    #-3534   (1)    
C_DS_SIZE                      =00001000     231    (1)      346    (1)    
C_DS_START                      00001000-R   347    (1)      2398   (1)      3483   (1)    #-3536   (1)    #-766    (1)    
                                                           #-786    (1)    
C_D_BLKS_IN_BLK                =00000002     227    (1)    
C_FALSE                        =00000000     213    (1)    #-1121   (1)    #-1281   (1)    #-1658   (1)    #-1660   (1)    
                                                           #-1751   (1)    #-1976   (1)    #-2061   (1)    #-2120   (1)    
                                                           #-2140   (1)    #-2478   (1)    #-2635   (1)    #-2857   (1)    
                                                           #-2962   (1)    #-3288   (1)    #-3459   (1)    #-3460   (1)    
                                                           #-3466   (1)    #-3532   (1)    #-3540   (1)      446    (1)    
                                                             538    (1)      542    (1)      545    (1)    #-856    (1)    
                                                           #-877    (1)    #-890    (1)    #-909    (1)    #-919    (1)    
                                                           #-932    (1)    
C_INUSE                        =00000001     222    (1)    #-1254   (1)    #-1396   (1)    #-2309   (1)    
C_KEYSIZE                      =00000004     226    (1)      442    (1)    
C_LS_END                        00001000-R   351    (1)    
C_LS_SIZE                      =00000800     233    (1)      352    (1)    
C_LS_START                      00001800-R   353    (1)      3484   (1)    
C_MAX_BLOCKS                   =00000003     224    (1)    #-1227   (1)    #-1236   (1)    #-1243   (1)    #-1366   (1)    
                                                           #-1375   (1)    #-1382   (1)    #-1662   (1)    #-1754   (1)    
                                                           #-2312   (1)      3631   (1)      451    (1)      453    (1)    
C_MAX_ERRS                     =00000014     214    (1)    #-3395   (1)    
C_MAX_LEN                      =000000A0     228    (1)    #-2173   (1)    #-2406   (1)    #-2805   (1)    #-2817   (1)    
                                                             393    (1)      401    (1)      419    (1)      423    (1)    
                                                             469    (1)      482    (1)      492    (1)    
C_MAX_NAME_LEN                 =00000050     215    (1)    #-1576   (1)    #-1585   (1)    
C_MODIFIED                     =00000002     223    (1)    #-1240   (1)    #-1379   (1)    #-1744   (1)    #-2302   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  80
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                                           #-2739   (1)    
C_PAD_MOAT                     =00000109     230    (1)    #-2165   (1)    #-591    (1)    #-867    (1)    
C_SCREEN_LEN                   =00000050     229    (1)    #-978    (1)    
C_TPU_COM_LEN                  =00000004     490    (1)    #-1707   (1)    
C_TRUE                         =FFFFFFFF     211    (1)    #-1003   (1)    #-1049   (1)    #-1115   (1)    #-1301   (1)    
                                                           #-1918   (1)    #-1971   (1)    #-2064   (1)    #-2117   (1)    
                                                           #-2146   (1)    #-2334   (1)    #-2631   (1)    #-2860   (1)    
                                                           #-2868   (1)    #-846    (1)    #-859    (1)    #-880    (1)    
                                                           #-893    (1)    #-905    (1)    #-922    (1)    #-935    (1)    
DC$_TERM                        00000000-XR                  65     (1)    
DECIMAL                         000008D9-R   1613   (1)    
DEFINITIONS                     000008F1-R   1623   (1)    
DOWNLOOP                        000016C1-R   3074   (1)    
DROP                            00000906-R   1631   (1)    
DSC$K_CLASS_S                   00000000-XR                  403    (1)      471    (1)      478    (1)      496    (1)    
                                                             66     (1)    
DSC$K_DTYPE_T                   00000000-XR                  402    (1)      470    (1)      477    (1)      495    (1)    
                                                             66     (1)    
DUP                             00000920-R   1647   (1)    
ELSE                            000016FD-R   3095   (1)    
ENABLE_CTRLC                    000018C7-R   3372   (1)      3377   (1)    
ENDIF                           00001725-R   3114   (1)    
ENDWHILE                        0000173E-R   3125   (1)    
EODP                            00000958-R   1677   (1)    
EVE                             00000981-R   1701   (1)    
FAB$B_DNS                      =00000035                     435    (1)    
FAB$B_FNS                      =00000034                   #-1899   (1)      435    (1)    
FAB$C_BID                      =00000003                     412    (1)      435    (1)    
FAB$C_BLN                      =00000050                     412    (1)      435    (1)    
FAB$C_FIX                      =00000001                     435    (1)    
FAB$C_SEQ                      =00000000                     412    (1)      435    (1)    
FAB$C_VAR                      =00000002                     412    (1)    
FAB$L_ALQ                      =00000010                     412    (1)      435    (1)    
FAB$L_DNA                      =00000030                     435    (1)    
FAB$L_FNA                      =0000002C                   #-1897   (1)      435    (1)    
FAB$L_FOP                      =00000004                     412    (1)      435    (1)    
FAB$L_STS                      =00000008                   #-3597   (1)    
FAB$L_STV                      =0000000C                   #-3596   (1)    
FAB$V_CHAN_MODE                =00000002                     412    (1)      435    (1)    
FAB$V_FILE_MODE                =00000004                     412    (1)      435    (1)    
FAB$V_GET                      =00000001                     435    (1)    
FAB$V_LNM_MODE                 =00000000                     412    (1)      435    (1)    
FAB$V_UPD                      =00000003                     435    (1)    
FAB$W_GBC                      =00000048                     412    (1)      435    (1)    
FILL                            000009D3-R   1730   (1)    
FORGET                          00000A24-R   1768   (1)    
FREEMEM                         00000AD2-R   1819   (1)    
HEX                             00000AF6-R   1837   (1)    
HLD                             00000B06-R   1845   (1)    
HOLD                            00000B17-R   1853   (1)      2367   (1)      580    (1)    
IF                              00001761-R   3148   (1)    
IO$M_CTRLCAST                   00000000-XR                #-3377   (1)      67     (1)    
IO$_SETMODE                     00000000-XR                #-3377   (1)      67     (1)    
I_AC_COLON                      000003C2-R   1092   (1)    
I_ADD                           000000C1-R   675    (1)    
I_BIT_AND                       00000072-R   621    (1)    
I_BIT_NOT                       00000083-R   631    (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  81
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

I_BIT_OR                        00000090-R   639    (1)    
I_BIT_XOR                       0000009E-R   647    (1)    
I_BL                            0000049F-R   1201   (1)    
I_BLOCK_CLOSE                   00000543-R   1274   (1)    
I_BLOCK_OPEN                    00000575-R   1289   (1)    
I_BLOCK_READ                    000005BB-R   1309   (1)      1422   (1)    
I_BLOCK_WRITE                   000005ED-R   1324   (1)      1437   (1)    
I_BS_FETCH                      00000639-R   1351   (1)    
I_BUFFER_READ                   000006C0-R   1413   (1)      1257   (1)    
I_BUFFER_WRITE                  000006FC-R   1430   (1)      1248   (1)      1387   (1)      1749   (1)      2307   (1)    
I_B_COMMA                       0000045B-R   1164   (1)    
I_B_FETCH                       00000469-R   1173   (1)    
I_B_STORE                       0000044B-R   1154   (1)    
I_B_UP                          0000163E-R   3010   (1)    
I_COLON                         000001FB-R   840    (1)    
I_COMMA                         000000F5-R   705    (1)    
I_COMPILE_ASCII                 0000189B-R   3295   (1)    
I_COMPILE_JSB                   000007AA-R   1499   (1)      3215   (1)      3541   (1)    
I_COUNT_BEGIN                   00000064-R   613    (1)    
I_COUNT_END                     000000B3-R   664    (1)    
I_DEFER_BEGIN                   00001660-R   3030   (1)    
I_DEFER_END                     000015F5-R   2975   (1)    
I_DIVIDE                        000001C0-R   801    (1)    
I_DIV_MOD                       000001CD-R   810    (1)      578    (1)    
I_DO                            0000168C-R   3054   (1)    
I_DOT                           00000123-R   733    (1)      1821   (1)      3574   (1)      772    (1)      789    (1)    
                                                             946    (1)    
I_DOT_LPAREN                    0000015A-R   752    (1)    
I_DOT_QUOTE                     00001589-R   2930   (1)    
I_DOT_SB                        00000179-R   765    (1)    
I_DOT_ST                        0000019D-R   783    (1)    
I_DS_TO_LS                      00000914-R   1639   (1)    
I_EMPTY_BUFFERS                 00000936-R   1655   (1)    
I_EODP_PLUS_STORE               00000975-R   1693   (1)    
I_EOD_STORE                     00000966-R   1685   (1)    
I_EQUAL                         00000264-R   887    (1)    
I_EQUAL_TEXT                    0000027F-R   901    (1)    
I_EXIT                          000009C7-R   1723   (1)    
I_FETCH                         00000398-R   1064   (1)    
I_FLUSH_BUFFERS                 000009F1-R   1741   (1)    
I_FORGET_ERASE                  00000A7C-R   1794   (1)    
I_GREATER_EQUAL                 000002B7-R   929    (1)    
I_GRETER                        0000029F-R   916    (1)    
I_HALT                          00000AE8-R   1828   (1)    
I_I_TO                          00000B2F-R   1865   (1)    
I_LEFT_BRACK                    00001887-R   3287   (1)    
I_LESS                          00000221-R   853    (1)    
I_LESS_EQUAL                    0000024D-R   874    (1)    
I_LESS_SHARP                    00000239-R   866    (1)      736    (1)    
I_LONG                          00000BFA-R   1927   (1)    
I_LOOP                          000017BC-R   3192   (1)    
I_LS_TO_DS                      00000C3A-R   1952   (1)    
I_L_UP                          00001783-R   3164   (1)    
I_MATCH                         00000C48-R   1961   (1)    
I_MINUS_ROT                     0000010C-R   722    (1)    
I_MOVE_FILL                     00000CE4-R   2039   (1)    
I_MULTIPLY                      000000A8-R   655    (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  82
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

I_ONE_MINUS                     000001F2-R   830    (1)    
I_ONE_PLUS                      000001E8-R   822    (1)    
I_PLUS_LOOP                     00001555-R   2910   (1)    
I_PLUS_ROT                      000000DE-R   694    (1)    
I_PLUS_STORE                    000000CC-R   683    (1)    
I_QUESTION                      000002CE-R   944    (1)    
I_RIGHT_BACK                    00001520-R   2867   (1)    
I_SAVE_BUFFERS                  00000F5D-R   2299   (1)    
I_SEMICOLON                     000015DB-R   2960   (1)    
I_SHARP                         00000015-R   576    (1)      602    (1)    
I_SHARP_GREATER                 00000036-R   588    (1)      740    (1)    
I_SHARP_S                       00000055-R   601    (1)    #-604    (1)      737    (1)    
I_SHORT                         00000FC2-R   2348   (1)    
I_SP_0                          00001021-R   2397   (1)    
I_SP_FETCH                      00001015-R   2387   (1)    
I_STORE                         00000006-R   565    (1)    
I_STRING_QUOTE                  00001220-R   2578   (1)    
I_SUBTRACT                      000000FF-R   713    (1)    
I_S_UP                          00001819-R   3233   (1)    
I_VARIABLE                      00001538-R   2893   (1)    
I_WORD_FETCH                    00000F3A-R   2283   (1)    
I_WORD_STORE                    00000F1C-R   2265   (1)    
I_WS_FETCH                      00000F47-R   2291   (1)    
I_W_COMMA                       00000F2C-R   2274   (1)    
KERNEL                          00000B3E-R   1873   (1)    
LEAVE                           00000B54-R   1881   (1)    
LIB$GET_INPUT                   00000000-XR                  2214   (1)      2247   (1)      2451   (1)      69     (1)    
LIB$PUT_OUTPUT                  00000000-XR                  1560   (1)      1909   (1)      2812   (1)      2835   (1)    
                                                             3431   (1)      3445   (1)      3549   (1)      3556   (1)    
                                                             69     (1)    
LIB$SIGNAL                      00000000-XR                  1715   (1)      3365   (1)      3379   (1)      3592   (1)    
                                                             3598   (1)      3604   (1)      69     (1)    
LIB$_INPSTRTRU                  00000000-XR                #-2215   (1)    #-2248   (1)      68     (1)    
LITERAL                         000017A3-R   3179   (1)      1000   (1)      1943   (1)      3299   (1)    
LOAD                            00000B62-R   1890   (1)    
LONGCONST                       00000C22-R   1941   (1)    
MAX                             00000C73-R   1983   (1)    
MESSAGE                         00000C8D-R   1997   (1)    
MIN                             00000CA0-R   2006   (1)    
MOD                             00000CB6-R   2019   (1)    
MOVE                            00000CCC-R   2029   (1)    
NCHR                           =00000007     3295   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1173   (1)      1183   (1)    
                                                             1193   (1)      1201   (1)      1209   (1)      1220   (1)    
                                                             1274   (1)      1289   (1)      1309   (1)      1324   (1)    
                                                             1343   (1)      1351   (1)      1359   (1)      1413   (1)    
                                                             1430   (1)      1444   (1)      1461   (1)      1473   (1)    
                                                             1499   (1)      1512   (1)      1534   (1)      1545   (1)    
                                                             1555   (1)      1570   (1)      1603   (1)      1613   (1)    
                                                             1623   (1)      1631   (1)      1639   (1)      1647   (1)    
                                                             1655   (1)      1677   (1)      1685   (1)      1693   (1)    
                                                             1701   (1)      1723   (1)      1730   (1)      1741   (1)    
                                                             1768   (1)      1794   (1)      1819   (1)      1828   (1)    
                                                             1837   (1)      1845   (1)      1853   (1)      1865   (1)    
                                                             1873   (1)      1881   (1)      1890   (1)      1927   (1)    
                                                             1941   (1)      1952   (1)      1961   (1)      1983   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  83
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                                             1997   (1)      2006   (1)      2019   (1)      2029   (1)    
                                                             2039   (1)      2050   (1)      2058   (1)      2073   (1)    
                                                             2127   (1)      2135   (1)      2154   (1)      2164   (1)    
                                                             2172   (1)      2189   (1)      2197   (1)      2229   (1)    
                                                             2257   (1)      2265   (1)      2274   (1)      2283   (1)    
                                                             2291   (1)      2299   (1)      2322   (1)      2348   (1)    
                                                             2363   (1)      2376   (1)      2387   (1)      2397   (1)    
                                                             2405   (1)      2421   (1)      2439   (1)      2488   (1)    
                                                             2514   (1)      2538   (1)      2559   (1)      2578   (1)    
                                                             2607   (1)      2620   (1)      2642   (1)      2654   (1)    
                                                             2675   (1)      2715   (1)      2727   (1)      2737   (1)    
                                                             2751   (1)      2764   (1)      2788   (1)      2804   (1)    
                                                             2847   (1)      2867   (1)      2893   (1)      2910   (1)    
                                                             2930   (1)      2960   (1)      2975   (1)      2991   (1)    
                                                             3010   (1)      3030   (1)      3054   (1)      3074   (1)    
                                                             3095   (1)      3114   (1)      3125   (1)      3148   (1)    
                                                             3164   (1)      3179   (1)      3192   (1)      3212   (1)    
                                                             3223   (1)      3233   (1)      3250   (1)      3268   (1)    
                                                             3287   (1)      3295   (1)      565    (1)      576    (1)    
                                                             588    (1)      601    (1)      613    (1)      621    (1)    
                                                             631    (1)      639    (1)      647    (1)      655    (1)    
                                                             664    (1)      675    (1)      683    (1)      694    (1)    
                                                             705    (1)      713    (1)      722    (1)      733    (1)    
                                                             752    (1)      765    (1)      783    (1)      801    (1)    
                                                             810    (1)      822    (1)      830    (1)      840    (1)    
                                                             853    (1)      866    (1)      874    (1)      887    (1)    
                                                             901    (1)      916    (1)      929    (1)      944    (1)    
                                                             953    (1)      965    (1)      976    (1)      993    (1)    
NEGAGE                          00000CFD-R   2050   (1)    
NOT                             00000D09-R   2058   (1)    
NUMBER                          00000D24-R   2073   (1)      3013   (1)      3167   (1)      3236   (1)      994    (1)    
OCTAL                           00000DA4-R   2127   (1)    
OP_ACBL                        =000000F1     238    (1)    #-2911   (1)    #-3075   (1)    #-3193   (1)    
OP_ADDL2                       =000000C0     239    (1)    #-2920   (1)    #-2980   (1)    #-3085   (1)    #-3202   (1)    
OP_BNEQ                        =00000012     240    (1)    #-3151   (1)    #-3253   (1)    #-3272   (1)    
OP_BRW                         =00000031     241    (1)    #-2935   (1)    #-2996   (1)    #-3039   (1)    #-3096   (1)    
                                                           #-3126   (1)    #-3153   (1)    #-3255   (1)    #-3274   (1)    
OP_JSB                         =00000016     242    (1)    #-1500   (1)    #-2950   (1)    
OP_MOVAB                       =0000009E     243    (1)    #-1131   (1)    #-1446   (1)    #-2753   (1)    #-2894   (1)    
                                                           #-2931   (1)    
OP_MOVAL                       =000000DE     244    (1)    #-1929   (1)    #-2791   (1)    
OP_MOVAW                       =0000003E     245    (1)    #-2350   (1)    #-2561   (1)    #-2580   (1)    
OP_MOVB                        =00000090     246    (1)    #-1094   (1)    
OP_MOVC3                       =00000028     247    (1)    #-3031   (1)    
OP_MOVL                        =000000D0     248    (1)    #-2945   (1)    #-3055   (1)    #-3058   (1)    #-3061   (1)    
                                                           #-3180   (1)    
OP_RSB                         =00000005     249    (1)    #-1098   (1)    #-1135   (1)    #-1450   (1)    #-1595   (1)    
                                                           #-1933   (1)    #-1944   (1)    #-2354   (1)    #-2565   (1)    
                                                           #-2584   (1)    #-2757   (1)      2796   (1)    #-2898   (1)    
                                                           #-2961   (1)    
OP_TSTL                        =000000D5     250    (1)    #-3149   (1)    #-3251   (1)    #-3270   (1)    
OR                              00000DB3-R   2135   (1)    
OTS$CVT_L_TI                    00000000-XR                  70     (1)    
OVER                            00000DD3-R   2154   (1)    
PAD                             00000DE0-R   2164   (1)    
PUTC                            00000DF2-R   2172   (1)      1485   (1)      2776   (1)      743    (1)    
Q_CR                            000002DF-R   953    (1)      3475   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  84
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

Q_DUP                           000002F7-R   965    (1)    
Q_NUMBER                        00000330-R   993    (1)      3509   (1)    
Q_N_CR                          00000309-R   976    (1)      1482   (1)      2773   (1)    
Q_SEARCH                        0000035F-R   1014   (1)      3504   (1)    
RAB$B_RAC                      =0000001E                     419    (1)      442    (1)    
RAB$C_BID                      =00000001                     419    (1)      442    (1)    
RAB$C_BLN                      =00000044                     419    (1)      442    (1)    
RAB$C_KEY                      =00000001                     442    (1)    
RAB$C_SEQ                      =00000000                     419    (1)    
RAB$L_CTX                      =00000018                     419    (1)      442    (1)    
RAB$L_RBF                      =00000028                   #-1326   (1)    
RAB$L_ROP                      =00000004                     419    (1)      442    (1)    
RAB$L_STS                      =00000008                   #-3603   (1)    
RAB$L_STV                      =0000000C                   #-3602   (1)    
RAB$L_UBF                      =00000024                   #-1311   (1)    
RAB$V_RAH                      =00000009                     419    (1)    
RAB$W_RSZ                      =00000022                   #-1330   (1)    #-2470   (1)    #-2472   (1)    
RADIX                           00000E29-R   2189   (1)    
READ                            00000E3A-R   2197   (1)    
READSTR                         00000EAE-R   2229   (1)    
RECURSE                         000017F3-R   3212   (1)    
REPEAT                          0000180E-R   3223   (1)    
RESTART                         00000F12-R   2257   (1)    
RMS$_EOF                        00000000-XR                #-2453   (1)    #-2464   (1)      71     (1)    
RMS$_FNF                        00000000-XR                #-1906   (1)      71     (1)    
R_WARM_START                    000019D6-R   3451   (1)    #-1073   (1)    #-1716   (1)    #-1786   (1)    #-1813   (1)    
                                                           #-2258   (1)    #-3550   (1)    #-3557   (1)    #-3581   (1)    
SEARCH                          00000F8A-R   2322   (1)      1040   (1)      1046   (1)      1772   (1)      1798   (1)    
                                                           #-2338   (1)    
SIGN                            00000FE7-R   2363   (1)      739    (1)    
SMUDGE                          00000FFE-R   2376   (1)      845    (1)    
SPACE                           00001033-R   2405   (1)      2426   (1)    
SPACES                          0000106C-R   2421   (1)    
SREAD                           0000108C-R   2439   (1)      2682   (1)    
STRCAT                          00001149-R   2488   (1)    
STRCMP                          0000118A-R   2514   (1)    
STRCPY                          000011C3-R   2538   (1)    
STRING                          000011F5-R   2559   (1)    
STRMAX                          00001268-R   2607   (1)    
STRPOS                          0000127B-R   2620   (1)    
SWAP                            000012AE-R   2642   (1)    
SYS$CLOSE                       00000000-XR                  1277   (1)      2477   (1)      3465   (1)      3607   (1)    
SYS$CONNECT                     00000000-XR                  1297   (1)      1902   (1)    
SYS$EXIT                        00000000-XR                  3409   (1)      3612   (1)    
SYS$FIND                        00000000-XR                  1331   (1)    
SYS$GET                         00000000-XR                  1314   (1)      2462   (1)    
SYS$OPEN                        00000000-XR                  1293   (1)      1900   (1)    
SYS$PUTMSG                      00000000-XR                  3392   (1)      3408   (1)    
SYS$QIO                         00000000-XR                  3377   (1)    
SYS$UNWIND                      00000000-XR                  3400   (1)    
SYS$UPDATE                      00000000-XR                  1332   (1)    
S_COLD_START                    00001965-R   3422   (1)      3351   (1)    
S_TRAP                          000018FB-R   3387   (1)    
S_WARM_START                    000019B1-R   3441   (1)      3355   (1)    
TOCHAR                          000012C5-R   2654   (1)      579    (1)    
TOKEN                           000012E6-R   2675   (1)      1146   (1)      1575   (1)      1703   (1)      1770   (1)    
                                                             1796   (1)      1892   (1)      2591   (1)      2939   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  85
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                                             3012   (1)      3166   (1)      3235   (1)      3297   (1)    
                                                             3495   (1)      3517   (1)      3523   (1)      754    (1)    
TPU$TPU                         00000000-XR                  1710   (1)      72     (1)    
UNLINK                          0000136A-R   2715   (1)      3457   (1)    
UNSMUDGE                        00001386-R   2727   (1)      2964   (1)    
UNTIL                           0000183A-R   3250   (1)    
UPDATE                          000013A0-R   2737   (1)    
V1_COMPILER                    =00001830-R   3250   (1)      3250   (1)    
VARIABLE                        000013BA-R   2751   (1)    
VLIST                           000013DB-R   2764   (1)    
VL_COMPILER                    =0000188F-R   3295   (1)      2893   (1)      2910   (1)      2930   (1)      2960   (1)    
                                                             2975   (1)      2991   (1)      3010   (1)      3030   (1)    
                                                             3054   (1)      3074   (1)      3095   (1)      3114   (1)    
                                                             3125   (1)      3148   (1)      3164   (1)      3179   (1)    
                                                             3192   (1)      3212   (1)      3223   (1)      3233   (1)    
                                                             3268   (1)      3287   (1)      3295   (1)    #-3427   (1)    
VL_KERNEL                      =0000151A-R   2867   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1173   (1)      1183   (1)    
                                                             1193   (1)      1201   (1)      1209   (1)      1220   (1)    
                                                             1274   (1)      1289   (1)      1309   (1)      1324   (1)    
                                                             1343   (1)      1351   (1)      1359   (1)      1413   (1)    
                                                             1430   (1)      1444   (1)      1461   (1)      1473   (1)    
                                                             1499   (1)      1512   (1)      1534   (1)      1545   (1)    
                                                             1555   (1)      1570   (1)      1603   (1)      1613   (1)    
                                                             1623   (1)      1631   (1)      1639   (1)      1647   (1)    
                                                             1655   (1)      1677   (1)      1685   (1)      1693   (1)    
                                                             1701   (1)      1723   (1)      1730   (1)      1741   (1)    
                                                             1768   (1)      1794   (1)      1819   (1)      1828   (1)    
                                                             1837   (1)      1845   (1)      1853   (1)      1865   (1)    
                                                             1873   (1)      1881   (1)      1890   (1)      1927   (1)    
                                                             1941   (1)      1952   (1)      1961   (1)      1983   (1)    
                                                             1997   (1)      2006   (1)      2019   (1)      2029   (1)    
                                                             2039   (1)      2050   (1)      2058   (1)      2073   (1)    
                                                             2127   (1)      2135   (1)      2154   (1)      2164   (1)    
                                                             2172   (1)      2189   (1)      2197   (1)      2229   (1)    
                                                             2257   (1)      2265   (1)      2274   (1)      2283   (1)    
                                                             2291   (1)      2299   (1)      2322   (1)      2348   (1)    
                                                             2363   (1)      2376   (1)      2387   (1)      2397   (1)    
                                                             2405   (1)      2421   (1)      2439   (1)      2488   (1)    
                                                             2514   (1)      2538   (1)      2559   (1)      2578   (1)    
                                                             2607   (1)      2620   (1)      2642   (1)      2654   (1)    
                                                             2675   (1)      2715   (1)      2727   (1)      2737   (1)    
                                                             2751   (1)      2764   (1)      2788   (1)      2804   (1)    
                                                             2847   (1)      2867   (1)    #-3428   (1)      565    (1)    
                                                             576    (1)      588    (1)      601    (1)      613    (1)    
                                                             621    (1)      631    (1)      639    (1)      647    (1)    
                                                             655    (1)      664    (1)      675    (1)      683    (1)    
                                                             694    (1)      705    (1)      713    (1)      722    (1)    
                                                             733    (1)      752    (1)      765    (1)      783    (1)    
                                                             801    (1)      810    (1)      822    (1)      830    (1)    
                                                             840    (1)      853    (1)      866    (1)      874    (1)    
                                                             887    (1)      901    (1)      916    (1)      929    (1)    
                                                             944    (1)      953    (1)      965    (1)      976    (1)    
                                                             993    (1)    
VOCABULARY                      0000141E-R   2788   (1)    
VTIL                            000018AB-R   3315   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  86
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

VTIL_CTRLC                      00000000-XR                #-3378   (1)      73     (1)    
VTIL_EXIT                       000018BD-R   3363   (1)    
VTIL_MAXERRORS                  00000000-XR                #-3404   (1)      73     (1)    
V_BLKBUFF                       00004000-R   3630   (1)    #-1265   (1)    #-1402   (1)    #-1417   (1)    #-1435   (1)    
                                                             442    (1)    
V_BLKFAB                        00001AE0-R   430    (1)      1277   (1)      1293   (1)      442    (1)    
V_BLKKEY                        00001B74-R   443    (1)    #-1313   (1)    #-1328   (1)    
V_BLKRAB                        00001B30-R   436    (1)      1297   (1)    #-1311   (1)      1314   (1)    #-1326   (1)    
                                                           #-1330   (1)      1331   (1)      1332   (1)    
V_BLOCKIO                       00001B78-R   445    (1)    #-1275   (1)    #-1281   (1)    #-1290   (1)    #-1301   (1)    
V_BUF_BLK_NUMS                  00001B80-R   452    (1)    #-1225   (1)    #-1253   (1)    #-1364   (1)    #-1395   (1)    
                                                           #-1419   (1)    #-1432   (1)    #-1661   (1)    
V_BUF_INUSE                     00001B7D-R   450    (1)    #-1234   (1)    #-1241   (1)    #-1255   (1)    #-1373   (1)    
                                                           #-1380   (1)    #-1397   (1)    #-1659   (1)    #-1745   (1)    
                                                           #-1752   (1)    #-2303   (1)    #-2310   (1)    #-2740   (1)    
V_COMPILER                      00001D27-R   533    (1)    #-1045   (1)    #-1474   (1)    #-1515   (1)    #-1516   (1)    
                                                           #-3427   (1)    
V_CONTEXT                       00001D1F-R   529    (1)    #-1032   (1)      1535   (1)    #-1624   (1)    #-1771   (1)    
                                                           #-1776   (1)    #-1797   (1)    #-1802   (1)    #-1874   (1)    
                                                           #-2765   (1)    #-2789   (1)      2795   (1)    #-3213   (1)    
                                                           #-3432   (1)    #-3446   (1)    #-841    (1)    
V_CTRLC_DEPTH                   00001D13-R   523    (1)    
V_CURRENT                       00001D23-R   531    (1)    #-1513   (1)    #-1514   (1)    #-1571   (1)    #-1572   (1)    
                                                             1604   (1)    #-1624   (1)    #-2377   (1)    #-2716   (1)    
                                                           #-2717   (1)    #-2728   (1)    #-3433   (1)    #-3447   (1)    
                                                           #-841    (1)    
V_CURRENT_BUFF                  00001B79-R   447    (1)    #-1266   (1)    #-1403   (1)    #-1415   (1)    #-2738   (1)    
V_ERRORS                        00001D17-R   525    (1)    #-3394   (1)    #-3395   (1)    
V_FILELINENUM                   00001D30-R   539    (1)    #-1919   (1)    #-2474   (1)    #-2479   (1)    #-3467   (1)    
                                                           #-3573   (1)    
V_FILENOTFOUND                  0000189A-R   377    (1)      1908   (1)    
V_FNAME                         00001A3D-R   422    (1)      1894   (1)      1896   (1)      3471   (1)    
V_FNAMELEN                      00001A3C-R   420    (1)    #-1895   (1)    #-1898   (1)    #-3472   (1)    
V_GETCHN_BUF                    00001D07-R   515    (1)      514    (1)    
V_GETCHN_BUF_ADR                00001D03-R   513    (1)    
V_GETCHN_IN_BUF                 00001CFF-R   510    (1)    
V_GETCHN_RET_LEN                00001CFB-R   508    (1)    
V_GREETING                      00001800-R   361    (1)      3430   (1)      3444   (1)    
V_HLD                           00001D3A-R   548    (1)      1846   (1)    #-1854   (1)    #-1855   (1)    #-589    (1)    
                                                           #-592    (1)    #-867    (1)    
V_INBUF                         000018F7-R   392    (1)      2444   (1)      3577   (1)      399    (1)      404    (1)    
                                                             419    (1)    
V_INFAB                         000019A8-R   411    (1)    #-1897   (1)    #-1899   (1)      1900   (1)      1912   (1)    
                                                             2477   (1)      3465   (1)      419    (1)    
V_INFILE                        00001D2F-R   537    (1)    #-1918   (1)    #-2445   (1)    #-2478   (1)    #-3463   (1)    
                                                           #-3466   (1)    #-3571   (1)      3607   (1)    
V_INFILEMESS                    00001890-R   375    (1)      3468   (1)    
V_INLEN                         00001999-R   396    (1)      2448   (1)    #-2459   (1)    #-2471   (1)    #-2679   (1)    
                                                           #-2686   (1)    #-2690   (1)    #-2691   (1)    #-2693   (1)    
                                                           #-2700   (1)    #-2703   (1)    #-3461   (1)    
V_INPTR                         0000199B-R   398    (1)    #-2444   (1)      2679   (1)    #-2685   (1)      2690   (1)    
                                                             2698   (1)    #-2699   (1)    #-2705   (1)    
V_INPUT_CHAN                    00001CF9-R   503    (1)    #-3377   (1)    
V_INPUT_NAME                    00001CE6-R   501    (1)    
V_INRAB                         000019F8-R   415    (1)      1902   (1)      1915   (1)      2462   (1)      2467   (1)    
                                                           #-2470   (1)    #-2472   (1)    
V_IN_DSC                        0000199F-R   400    (1)      2450   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  87
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

V_KERNEL                        00001D2B-R   535    (1)      1874   (1)    #-3428   (1)      3432   (1)      3433   (1)    
                                                             3446   (1)      3447   (1)    
V_MODE                          00001D35-R   544    (1)    #-1043   (1)    #-2868   (1)    #-2962   (1)    #-3288   (1)    
                                                           #-3455   (1)    #-3459   (1)    #-3530   (1)    #-846    (1)    
                                                           #-998    (1)    
V_NAMETOOLONG                   000018D8-R   383    (1)      1578   (1)    
V_NAMETRUNC                     000018E8-R   385    (1)      1586   (1)    
V_ORG_INLEN                     00001997-R   394    (1)    #-2459   (1)    #-2473   (1)    #-3462   (1)    #-3578   (1)    
V_OUTBUF                        00001B9A-R   481    (1)      1556   (1)      2177   (1)      2207   (1)      2238   (1)    
                                                             2410   (1)      2808   (1)      2818   (1)      2831   (1)    
V_OUTLEN                        00001B98-R   479    (1)    #-1557   (1)    #-1562   (1)    #-2173   (1)    #-2178   (1)    
                                                           #-2182   (1)    #-2202   (1)    #-2208   (1)    #-2217   (1)    
                                                           #-2233   (1)    #-2239   (1)    #-2241   (1)    #-2406   (1)    
                                                           #-2411   (1)    #-2414   (1)    #-2440   (1)    #-2805   (1)    
                                                           #-2809   (1)    #-2814   (1)    #-2816   (1)    #-2823   (1)    
                                                           #-2830   (1)    #-2832   (1)    #-2836   (1)    #-954    (1)    
                                                           #-977    (1)    
V_OVERMESS                      0000185A-R   369    (1)      3555   (1)    
V_RADIX                         00001D36-R   546    (1)    #-1194   (1)    #-1614   (1)    #-1838   (1)    #-2104   (1)    
                                                           #-2106   (1)    #-2128   (1)      2190   (1)    #-577    (1)    
V_READADDR                      00001B92-R   472    (1)    #-2198   (1)    #-2199   (1)    
V_READDSC                       00001B8E-R   468    (1)      2213   (1)    
V_READLEN                       00001B8C-R   466    (1)      2200   (1)    #-2219   (1)    
V_RETURNSTACK                   00001D1B-R   527    (1)    #-3423   (1)    #-3476   (1)    
V_STATE                         00001D34-R   541    (1)    #-1049   (1)    #-3460   (1)    #-3530   (1)    #-3532   (1)    
                                                           #-3540   (1)    
V_STATIC_DSC                    00001B96-R   476    (1)    #-1558   (1)    #-2209   (1)    #-2232   (1)    #-2240   (1)    
                                                           #-2810   (1)    #-2833   (1)    
V_TPU_COM                       00001C3A-R   488    (1)      490    (1)      497    (1)    
V_TPU_COM2                      00001C3E-R   491    (1)      1706   (1)    
V_TPU_DSC                       00001CDE-R   493    (1)    #-1708   (1)      1709   (1)    
V_TRAP_DEPTH                    00001D0F-R   521    (1)    #-3399   (1)      3400   (1)    
V_UNDERMESS                     00001842-R   367    (1)      3548   (1)    
V_UNKNOWN                       00001871-R   371    (1)      3561   (1)    
V_UNKNOWN2                      00001883-R   373    (1)      3568   (1)    
V_UNKN_BLK_MESS                 000018B1-R   379    (1)    
V_USRPROMPT                     00001838-R   365    (1)    
V_VTILPROMPT                    0000182A-R   363    (1)      2449   (1)    
V_WORDNOTFOUND                  000018C7-R   381    (1)      1780   (1)      1807   (1)    
WHILE                           00001863-R   3268   (1)    
WRITE                           00001454-R   2804   (1)      1483   (1)      1580   (1)      1583   (1)      1588   (1)    
                                                             1591   (1)      1782   (1)      1785   (1)      1809   (1)    
                                                             1812   (1)      1999   (1)      2774   (1)      2952   (1)    
                                                             3470   (1)      3473   (1)      3563   (1)      3567   (1)    
                                                             3570   (1)      3579   (1)      741    (1)      757    (1)    
XOR                             00001500-R   2847   (1)    
_CHECK_BASE                     00000D69-R   2103   (1)    #-2089   (1)    #-2095   (1)    
_CHECK_LOWERCASE                00000D58-R   2097   (1)    #-2093   (1)    
_COMPILER_END                   000018AB-R   3303   (1)    
_DONE                           00001B82-R   3607   (1)    
_ERROR_EXIT                     00001B5C-R   3590   (1)    #-1279   (1)    #-1295   (1)    #-1299   (1)    #-1316   (1)    
                                                           #-1334   (1)    #-1830   (1)    #-2215   (1)    #-2248   (1)    
                                                           #-2457   (1)    
_EXIT                           00001B8F-R   3610   (1)    #-1724   (1)    #-2455   (1)    #-3599   (1)    
_F_ERR                          00001B66-R   3596   (1)    #-1913   (1)    
_GETTOKEN                       0000130D-R   2687   (1)    #-2677   (1)    
_INITIALIZE                     00001A4D-R   3481   (1)    #-3434   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  88
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

_INTERPRETER                    00001A5B-R   3493   (1)    #-3511   (1)    #-3518   (1)    #-3524   (1)    #-3538   (1)    
                                                           #-3543   (1)    
_INVALID_NUMBER                 00000D96-R   2119   (1)    #-2087   (1)    #-2091   (1)    #-2099   (1)    #-2101   (1)    
                                                           #-2105   (1)    
_KERNEL_BEGIN                   00000000-R   559    (1)    
_KERNEL_END                     00001529-R   2872   (1)    
_NUMBER_TOP                     00000D3A-R   2083   (1)    #-2079   (1)    #-2111   (1)    
_OVERFLOW                       00001AEE-R   3553   (1)    #-3535   (1)    
_Q_EXECUTE                      00001A9D-R   3527   (1)    #-3507   (1)    
_R_ERR                          00001B75-R   3602   (1)    #-1916   (1)    #-2468   (1)    
_SKIPWHITESPACE                 000012EB-R   2678   (1)    #-2683   (1)    
_STARTFOUND                     000012FF-R   2684   (1)    #-2680   (1)    
_STRIP_COMMENT                  00001A89-R   3515   (1)    #-3500   (1)    
_STRIP_COMMENT2                 00001A93-R   3521   (1)    #-3502   (1)    
_UNDERFLOW                      00001ADA-R   3546   (1)    #-3537   (1)    
_UNKNOWNTOKEN                   00001B02-R   3560   (1)    #-3512   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  89
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)


                                             +------------------------+
                                             ! Macros Cross Reference !
                                             +------------------------+

MACRO             SIZE          DEFINITION       REFERENCES... 
-----             ----          ----------       ------------- 
$$R_TABINIT       1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$$R_VBFSET        1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$CHFDEF           2             74     (1)       74     (1)    
$CLOSE            1             1277   (1)       1277   (1)       2477   (1)       3465   (1)       3607   (1)    
$CONNECT          1             1297   (1)       1297   (1)       1902   (1)    
$DEFINI           1             74     (1)       412    (1)       419    (1)       74     (1)    
$EXIT_S           1             3409   (1)       3409   (1)       3612   (1)    
$FAB              4             412    (1)       412    (1)       431    (1)    
$FABDEF           1             412    (1)       412    (1)       435    (1)    
$FIND             1             1331   (1)       1331   (1)    
$GET              1             1314   (1)       1314   (1)       2462   (1)    
$OPEN             1             1293   (1)       1293   (1)       1900   (1)    
$PUSHADR          1             3377   (1)       3377   (1)       3392   (1)       3400   (1)       3408   (1)    
$PUSHTWO          1             3377   (1)       3377   (1)    
$PUTMSG_S         1             3392   (1)       3392   (1)       3408   (1)    
$QIOPUSH          1             3377   (1)       3377   (1)    
$QIO_S            1             3374   (1)       3374   (1)    
$RAB              2             416    (1)       416    (1)       437    (1)    
$RABDEF           1             419    (1)       419    (1)       442    (1)    
$RMSCALL          2             1277   (1)       1277   (1)       1293   (1)       1297   (1)       1314   (1)       1331   (1)    
                                                 1332   (1)       1900   (1)       1902   (1)       2462   (1)       2477   (1)    
                                                 3465   (1)       3607   (1)    
$UNWIND_S         1             3400   (1)       3400   (1)    
$UPDATE           1             1332   (1)       1332   (1)    
HEADER            1             298    (1)       1014   (1)       1064   (1)       1072   (1)       1079   (1)       1092   (1)    
                                                 1110   (1)       1129   (1)       1144   (1)       1154   (1)       1164   (1)    
                                                 1173   (1)       1183   (1)       1193   (1)       1201   (1)       1209   (1)    
                                                 1220   (1)       1274   (1)       1289   (1)       1309   (1)       1324   (1)    
                                                 1343   (1)       1351   (1)       1359   (1)       1413   (1)       1430   (1)    
                                                 1444   (1)       1461   (1)       1473   (1)       1499   (1)       1512   (1)    
                                                 1534   (1)       1545   (1)       1555   (1)       1570   (1)       1603   (1)    
                                                 1613   (1)       1623   (1)       1631   (1)       1639   (1)       1647   (1)    
                                                 1655   (1)       1677   (1)       1685   (1)       1693   (1)       1701   (1)    
                                                 1723   (1)       1730   (1)       1741   (1)       1768   (1)       1794   (1)    
                                                 1819   (1)       1828   (1)       1837   (1)       1845   (1)       1853   (1)    
                                                 1865   (1)       1873   (1)       1881   (1)       1890   (1)       1927   (1)    
                                                 1941   (1)       1952   (1)       1961   (1)       1983   (1)       1997   (1)    
                                                 2006   (1)       2019   (1)       2029   (1)       2039   (1)       2050   (1)    
                                                 2058   (1)       2073   (1)       2127   (1)       2135   (1)       2154   (1)    
                                                 2164   (1)       2172   (1)       2189   (1)       2197   (1)       2229   (1)    
                                                 2257   (1)       2265   (1)       2274   (1)       2283   (1)       2291   (1)    
                                                 2299   (1)       2322   (1)       2348   (1)       2363   (1)       2376   (1)    
                                                 2387   (1)       2397   (1)       2405   (1)       2421   (1)       2439   (1)    
                                                 2488   (1)       2514   (1)       2538   (1)       2559   (1)       2578   (1)    
                                                 2607   (1)       2620   (1)       2642   (1)       2654   (1)       2675   (1)    
                                                 2715   (1)       2727   (1)       2737   (1)       2751   (1)       2764   (1)    
                                                 2788   (1)       2804   (1)       2847   (1)       2867   (1)       2893   (1)    
                                                 2910   (1)       2930   (1)       2960   (1)       2975   (1)       2991   (1)    
                                                 3010   (1)       3030   (1)       3054   (1)       3074   (1)       3095   (1)    
                                                 3114   (1)       3125   (1)       3148   (1)       3164   (1)       3179   (1)    
VTIL                            -- VAX Threaded Interpretive Language     7-SEP-2023 16:08:47  VAX MACRO V5.4-3            Page  90
Cross reference                                                           7-SEP-2023 15:57:06  [MPL.TKB.VTIL]VTIL.MAR;167        (1)

                                                 3192   (1)       3212   (1)       3223   (1)       3233   (1)       3250   (1)    
                                                 3268   (1)       3287   (1)       3295   (1)       565    (1)       576    (1)    
                                                 588    (1)       601    (1)       613    (1)       621    (1)       631    (1)    
                                                 639    (1)       647    (1)       655    (1)       664    (1)       675    (1)    
                                                 683    (1)       694    (1)       705    (1)       713    (1)       722    (1)    
                                                 733    (1)       752    (1)       765    (1)       783    (1)       801    (1)    
                                                 810    (1)       822    (1)       830    (1)       840    (1)       853    (1)    
                                                 866    (1)       874    (1)       887    (1)       901    (1)       916    (1)    
                                                 929    (1)       944    (1)       953    (1)       965    (1)       976    (1)    
                                                 993    (1)    
ISERROR           1             315    (1)    
ISSTRERR          1             326    (1)       2215   (1)       2248   (1)    
NEWPAGE           1             39     (1)       137    (1)       202    (1)       284    (1)       2873   (1)       3304   (1)    
                                                 334    (1)       3412   (1)       3487   (1)       3584   (1)       3615   (1)    
                                                 551    (1)       58     (1)       77     (1)    

                                             +------------------------+
                                             ! Performance indicators !
                                             +------------------------+

Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------------   
Initialization                   34     00:00:00.02    00:00:00.02
Command processing              886     00:00:00.02    00:00:00.02
Pass 1                          549     00:00:00.57    00:00:00.62
Symbol table sort                 0     00:00:00.04    00:00:00.04
Pass 2                           34     00:00:00.21    00:00:00.22
Symbol table output               0     00:00:00.00    00:00:00.00
Psect synopsis output             0     00:00:00.00    00:00:00.00
Cross-reference output            7     00:00:00.08    00:00:00.08
Assembler run totals           1514     00:00:00.94    00:00:01.00

The working set limit was 3200 pages.
116954 bytes (229 pages) of virtual memory were used to buffer the intermediate code.
There were 50 pages of symbol table space allocated to hold 715 non-local and 106 local symbols.
3639 source lines were read in Pass 1, producing 96 object records in Pass 2.
46 pages of virtual memory were used to define 31 macros.

                                            +--------------------------+
                                            ! Macro library statistics !
                                            +--------------------------+

Macro library name                           Macros defined      
------------------                           --------------      
SYS$COMMON:[SYSLIB]STARLET.MLB;2                       24        

720 GETS were required to define 24 macros.

There were no errors, warnings or information messages.

MACRO/DEBUG/LIST/CROSS/OBJECT=VTIL.OBJ VTIL.MAR
