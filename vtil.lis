VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   0
Table of contents

    (1)       58        External Symbols
    (1)       77        General Notes
    (1)      137        Implementation Notes
    (1)      202        Constants
    (1)      284        Macros
    (1)      334        Data Section
    (1)      551        Kernel Built-ins
    (1)     2873        cCompiler Built-ins
    (1)     3304        Enter VTIL
    (1)     3412        Initialization
    (1)     3487        Interpreter
    (1)     3584        Exit Routines
    (1)     3615        Dictionary Space
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   1
V1.01                                                                    31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000     1 ;
                                     0000     2 .title	VTIL VAX Threaded Interpretive Language
                                     0000     3 	.ident	/v1.01/			; version number
                                     0000     4 ;******************************************************************************
                                     0000     5 ;
                                     0000     6 ; VTIL -- VAX Threaded Interpretive Language
                                     0000     7 ;
                                     0000     8 ;	Program:	V T I L . MAR
                                     0000     9 ;	Written By:	Thomas Kurt Bond
                                     0000    10 ;	Version:	v1.01
                                     0000    11 ;	Date:		7 February 1988
                                     0000    12 ;
                                     0000    13 ; Description:
                                     0000    14 ;     This program was written for my Senior Seminar Project at West Virginia
                                     0000    15 ; Wesleyan College in the spring of 1988.
                                     0000    16 ;
                                     0000    17 ;     This program implements a Threaded Interpretive Language (TIL) in
                                     0000    18 ; VAX Macro, using subroutine threading.  Essentially, it is an interactive
                                     0000    19 ; compiler.
                                     0000    20 ;
                                     0000    21 ; History
                                     0000    22 ; Ver	  When	   Who	What
                                     0000    23 ; 1.00	  020788   tkb	Initial version.
                                     0000    24 ; 1.01	  021288   tkb	Uses a smudge bit to prevent word being defined from
                                     0000    25 ;			being found while defining it.	({ recurse } allows
                                     0000    26 ;			recursion.)  Also limits length of names to 80 characters
                                     0000    27 ;			allowing the name-length byte to have the smudge bit
                                     0000    28 ;			in it.
                                     0000    29 ;******************************************************************************
                                     0000    30 ;!> VTIL.MAR -- VAX Threaded Interpretive Langague, an interactive compiler.
                                     0000    31 
                                     0000    32 ;
                                     0000    33 ; Set up source code formatting macros.
                                     0000    34 ;
                                     0000    35 
                                     0000    36 ;+++
                                     0000    37 ;m> newpage -- change the subtitle and move to a new page.
                                     0000    38 ;---
                                     0000    39 	.macro	newpage subtitle
                                     0000    40 	.page
                                     0000    41 	.sbttl	subtitle
                                     0000    42 	.endm
                                     0000    43 
                                     0000    44 ;******************************************************************************
                                     0000    45 ;
                                     0000    46 ; Conditional Assembly Control Symbols
                                     0000    47 ;
                                     0000    48 ;******************************************************************************
                                     0000    49 ;ca_trapping = 0		; If this is defined, code for a condition handler
                                     0000    50 			; is assembled.	 We don't always want the condition
                                     0000    51 			; handler because it also catched breakpoints in the
                                     0000    52 			; debugger.
                                     0000    53 ;ca_controlc = 0		; If this is defined, code to trap control/c and
                                     0000    54 			; return to the VTIL interpreter is assembled.
                                     0000    55 			; Note that this uses the trapping so it is useless
                                     0000    56 			; if `ca_trapping' is not defined.
                                     0000    57 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   2
V1.01                                                                    31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000    58 	newpage <External Symbols>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   3
V1.01                           External Symbols                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.sbttl	External Symbols
                                     0000       	
                                     0000    59 ;******************************************************************************
                                     0000    60 ;
                                     0000    61 ; External Symbols
                                     0000    62 ;
                                     0000    63 ;******************************************************************************
                                     0000    64 	.dsabl	global
                                     0000    65 	.extrn	dc$_term
                                     0000    66 	.extrn	dsc$k_dtype_t, dsc$k_class_s
                                     0000    67 	.extrn	io$_setmode, io$m_ctrlcast
                                     0000    68 	.extrn	lib$_inpstrtru
                                     0000    69 	.extrn	lib$get_input, lib$put_output, lib$signal
                                     0000    70 	.extrn	ots$cvt_l_ti
                                     0000    71 	.extrn	rms$_eof, rms$_fnf
                                     0000    72 	.extrn	tpu$tpu
                                     0000    73 	.extrn	vtil_ctrlc, vtil_maxerrors
                                     0000    74 	$chfdef				; condition handling facility
                                     0000       	$DEFINI	CHF,
                                     0000       	.SAVE	LOCAL_BLOCK
                                     0000       	.NOCROSS
                                     0000       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     0000       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   4
V1.01                           External Symbols                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF	12
                           0000000C  0000       	CHF$S_CHFDEF=12
                                     0000       	
                                     0000       $EQU	CHF$L_SIGARGLST	4
                           00000004  0000       	CHF$L_SIGARGLST=4
                                     0000       	
                                     0000       $EQU	CHF$L_MCHARGLST	8
                           00000008  0000       	CHF$L_MCHARGLST=8
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF1	12
                           0000000C  0000       	CHF$S_CHFDEF1=12
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_ARGS	0
                           00000000  0000       	CHF$IS_SIG_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_ARGS	0
                           00000000  0000       	CHF$L_SIG_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_NAME	4
                           00000004  0000       	CHF$IS_SIG_NAME=4
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_NAME	4
                           00000004  0000       	CHF$L_SIG_NAME=4
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_ARG1	8
                           00000008  0000       	CHF$IS_SIG_ARG1=8
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_ARG1	8
                           00000008  0000       	CHF$L_SIG_ARG1=8
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF2	20
                           00000014  0000       	CHF$S_CHFDEF2=20
                                     0000       	
                                     0000       $EQU	CHF$IS_MCH_ARGS	0
                           00000000  0000       	CHF$IS_MCH_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_ARGS	0
                           00000000  0000       	CHF$L_MCH_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$PH_MCH_FRAME	4
                           00000004  0000       	CHF$PH_MCH_FRAME=4
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_FRAME	4
                           00000004  0000       	CHF$L_MCH_FRAME=4
                                     0000       	
                                     0000       $EQU	CHF$IS_MCH_DEPTH	8
                           00000008  0000       	CHF$IS_MCH_DEPTH=8
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_DEPTH	8
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   5
V1.01                           External Symbols                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000008  0000       	CHF$L_MCH_DEPTH=8
                                     0000       	
                                     0000       $EQU	CHF$IH_MCH_SAVR0	12
                           0000000C  0000       	CHF$IH_MCH_SAVR0=12
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_SAVR0	12
                           0000000C  0000       	CHF$L_MCH_SAVR0=12
                                     0000       	
                                     0000       $EQU	CHF$IH_MCH_SAVR1	16
                           00000010  0000       	CHF$IH_MCH_SAVR1=16
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_SAVR1	16
                           00000010  0000       	CHF$L_MCH_SAVR1=16
                                     0000       	
                                     0000       	$DEFEND	CHF,,DEF
                                     0000       	.MACRO	$CHFDEF A
                                     0000       	.ENDM	$CHFDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                     0000       	.RESTORE
                                     0000       	
                                     0000       	
                                     0000    75 
                                     0000    76 
                                     0000    77 newpage <General Notes>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   6
V1.01                           General Notes                            31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.sbttl	General Notes
                                     0000       	
                                     0000    78 ;******************************************************************************
                                     0000    79 ;
                                     0000    80 ; General Notes
                                     0000    81 ;
                                     0000    82 ;******************************************************************************
                                     0000    83 ;
                                     0000    84 ; Word -- A VTIL word is the equivalent of the procedure and/or function of
                                     0000    85 ; Pascal or other langauges.  (Context will have to determine whethere we
                                     0000    86 ; are talking about VTIL words or memory 2-byte words.)	   A word finds any
                                     0000    87 ; parameters it needs on the data stack, and leaves any result on the stack
                                     0000    88 ; also.	 VTIL words (or sequences of words) will be singled out from normal text
                                     0000    89 ; by enclosing them in { } pairs, since many of them include punctuation marks
                                     0000    90 ; that might be otherwise confusing.  Also, the string `...' inside a { }
                                     0000    91 ; pair will indicate a sequence of VTIL words omitted as irrelevent to the
                                     0000    92 ; explaination.
                                     0000    93 ;
                                     0000    94 ; Stack Comments.  A stack comment shows what a word expects to find on the
                                     0000    95 ; stack and what results it leaves on the stack after execution.
                                     0000    96 ; A stack comment looks like the following: ( n1 n2 -- n1 ).  The rightmost
                                     0000    97 ; item on each side of the `--' is the top of the stack, so the items in the
                                     0000    98 ; stack comment are in the same order as they would be if you entered them from
                                     0000    99 ; the terminal.	 The `--' separates the items that word expects to find on
                                     0000   100 ; the stack from the items that it leaves on the stack.	 Ex: After you enter
                                     0000   101 ; { 1 2 3 }, 3 is on the top of the stack.  In ( n1 n2 n3 -- x1 x2 ) n3 is
                                     0000   102 ; on top of the stack before the word executes, and x2 is on top of
                                     0000   103 ; the stack after that word executes.
                                     0000   104 ;
                                     0000   105 ; Items in stack comments:
                                     0000   106 ;	?	-- `?' is not an item on the stack itself.  Instead, it
                                     0000   107 ;		   indicates that items to the left of the `?' (further
                                     0000   108 ;		   down on the stack) may or may not be present, depending
                                     0000   109 ;		   on the value of items to the right of the `?' (which
                                     0000   110 ;		   are on top of the stack).  For instance, a stack comment
                                     0000   111 ;		   of ( a -- a ? f ) indicates that the word leaves a
                                     0000   112 ;		   flag on the top of the stack, and depending on the value
                                     0000   113 ;		   of the flag will also leave an address on the stack.
                                     0000   114 ;	a	-- address
                                     0000   115 ;	b	-- unsigned byte (integer, 1 byte)
                                     0000   116 ;	c	-- unsigned characcter (1 byte)
                                     0000   117 ;	f	-- boolean flag; 0 = false, true <> 0 (usually 1)
                                     0000   118 ;	l	-- long (integer, 4 bytes)
                                     0000   119 ;	n	-- integer (usually meaning number.  A longword)
                                     0000   120 ;	s	-- short (integer, 2 bytes)
                                     0000   121 ;
                                     0000   122 ;	Note that *all* stack items are at least a longword in width.
                                     0000   123 ;	a ( b ) stack item merely says that the programmer should consider
                                     0000   124 ;	the stack as containing a value that will fit in an unsigned
                                     0000   125 ;	byte.  Words that use data types that are smaller than a longword
                                     0000   126 ;	will only use th first part of the longword in their calculations,
                                     0000   127 ;	but will still pop the whole longword containing the smaller data
                                     0000   128 ;	type from the stack, not just the smaller data type.  In other words,
                                     0000   129 ;	the stack pointer can only be manipulated in 4 byte increments or
                                     0000   130 ;	decrements.
                                     0000   131 ;
                                     0000   132 ; Starting Vocabularies -- At the moment, there are only two starting
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   7
V1.01                           General Notes                            31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000   133 ; vocabularies `compiler' and `kernel', which are independent of each other.
                                     0000   134 ; All later vocabularies should be linked into one of thse.  But See v1_*.
                                     0000   135 ;
                                     0000   136 ;******************************************************************************
                                     0000   137 	newpage <Implementation Notes>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   8
V1.01                           Implementation Notes                     31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.sbttl	Implementation Notes
                                     0000       	
                                     0000   138 ;******************************************************************************
                                     0000   139 ;
                                     0000   140 ; Implementation Notes
                                     0000   141 ;
                                     0000   142 ;******************************************************************************
                                     0000   143 ;
                                     0000   144 ; r11, ds	-- data stack pointer
                                     0000   145 ; r10, ls	-- loop stack pointer
                                     0000   146 ; r9, eodp	-- end of dictionary pointer
                                     0000   147 ; r8-r4 are used for temporary storage when using character instructions.
                                     0000   148 ;
                                     0000   149 ; header format for a word
                                     0000   150 ;	long	-- back link to next word in dictionary (hfa, lfa)
                                     0000   151 ;	byte	-- count of name byes (nfa)
                                     0000   152 ;	byte(s) -- bytes of name
                                     0000   153 ;	code	-- executable code for this word (cfa)
                                     0000   154 ;	data	-- optional data for this word (pfa)
                                     0000   155 ;
                                     0000   156 ; Names
                                     0000   157 ; Since none of the VTIL kernel and compiler words contain underscores,
                                     0000   158 ; the following conventions were followed so there would be no conflict
                                     0000   159 ; between names in the MACRO-32 source and in the VTIL.	 For instance,
                                     0000   160 ; { context } is the name of a word in the kernel that pushes the address
                                     0000   161 ; of the current vocabulary variable on the stack.  However, the definition
                                     0000   162 ; of context in the MACRO source makes `context' a label wich jsb'ing to
                                     0000   163 ; executes the word, so `context' can't be used in MACRO as a label for
                                     0000   164 ; the variable as well.
                                     0000   165 ;
                                     0000   166 ;	<name>	   -- label of start of a VTIL word called <name>
                                     0000   167 ;	_<name>	   -- internal branch points
                                     0000   168 ;	adm_<name> -- addressing mode constant value
                                     0000   169 ;	c_<name>   -- constant value
                                     0000   170 ;	ca_<name>  -- conditional assembly control symbols
                                     0000   171 ;	i_<name>   -- label of start of a VTIL word whose <name> doesn't
                                     0000   172 ;		      otherwise fit this naming convention, du to the
                                     0000   173 ;		      character limitations in VAX MACRO symbols.
                                     0000   174 ;		      For eample, i_plus = { + }, i_plus_store = { +! }
                                     0000   175 ;	op_<name>  -- opcode constant value
                                     0000   176 ;	r_<name>   -- internal routine <name> that is readed by branching and
                                     0000   177 ;		      not by jumping to subroutine.
                                     0000   178 ;	s_<name>   --  internal subroutine that is reached by a call.
                                     0000   179 ;	q_<name>   -- label of start of a VTIL word with name `?<name>'.
                                     0000   180 ;	v_<name>   -- internal variable name.
                                     0000   181 ;	vl_<name>  -- internal vocabulary link symbol used by the header macro
                                     0000   182 ;		      to link built-in vocabularies together.
                                     0000   183 ;
                                     0000   184 ;	Names of words other than looping words or branching words that should
                                     0000   185 ;	occur in pairs generally have VTIL names like { name( } and
                                     0000   186 ;	{ )name } or { name< } and { >name } and internal names like
                                     0000   187 ;	i_name_begin and i_name_end.
                                     0000   188 ;
                                     0000   189 ; To make finding words easie, all the words have a header comment
                                     0000   190 ; like this:
                                     0000   191 ;	;+++
                                     0000   192 ;	;s> name -- explanation
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page   9
V1.01                           Implementation Notes                     31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000   193 ;	;---
                                     0000   194 ; where `s' is `c' for the compiler words, `k' for the kernel words,
                                     0000   195 ; `m' for macros, `r' for routines, and `s' for subroutines.
                                     0000   196 ;
                                     0000   197 ; The string `;??? starts an internal note to the programmer.  These notes
                                     0000   198 ; generally comment about an alternate method of doing something or suggest
                                     0000   199 ; areas that should be improved.  ~~~ indicates a note made while typing this back in.
                                     0000   200 ;
                                     0000   201 ;******************************************************************************
                                     0000   202 	newpage <Constants>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  10
V1.01                           Constants                                31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.sbttl	Constants
                                     0000       	
                                     0000   203 ;******************************************************************************
                                     0000   204 ;
                                     0000   205 ; Constants -- Symbol definitions for constant values
                                     0000   206 ;
                                     0000   207 ;******************************************************************************
                                     0000   208 ;
                                     0000   209 ; General constants
                                     0000   210 ;
                           FFFFFFFF  0000   211 c_true		= -1			; true value, actually anything
                                     0000   212 					;  but 0 is true
                           00000000  0000   213 c_false		= 0			; false value
                           00000014  0000   214 c_max_errs	= 20			; Maximum number of fatal errors allowed
                           00000050  0000   215 c_max_name_len	= 80			; Maximum length of word names
                           00000020  0000   216 c_blank		= 32			; ascii blank
                           0000005C  0000   217 c_com1_begin	= ^a/\/			; start first type of comment with `\'
                           00000000  0000   218 c_com1_end	= 0			; end w/something not in a line of text
                                     0000   219 					; so it will skip the whole line
                           00000028  0000   220 c_com2_begin	= ^a/(/			; start second type of comment with `('
                           00000029  0000   221 c_com2_end	= ^a/)/			; end with `)'
                           00000001  0000   222 c_inuse		= 1			; buffer in use flag
                           00000002  0000   223 c_modified	= 2			; bufffer updated flag
                           00000003  0000   224 c_max_blocks	= 3			; number of block i/o buffers
                           00000400  0000   225 c_block_size	= 1024			; size for block i/o buffer
                           00000004  0000   226 c_keysize	= 4			; size of key (longword record number)
                           00000002  0000   227 c_d_blks_in_blk = c_block_size / 512	; number of disk blocks in VTIL block
                           000000A0  0000   228 c_max_len	= 160			; maximum length of input line
                           00000050  0000   229 c_screen_len	= 80			; screen is 80 chars wide
                           00000109  0000   230 c_pad_moat	= 265			; distance of pad from eodp
                           00001000  0000   231 c_ds_size	= 1024 * 4		; data stack size: 1024 items of
                                     0000   232 					; 4 bytes each
                           00000800  0000   233 c_ls_size	= 512 * 4		; loop stack size: 512 items of
                                     0000   234 					; 4 bytes each
                                     0000   235 ;
                                     0000   236 ; opcodes == constants for compiling opcodes into dictionary
                                     0000   237 ;
                           000000F1  0000   238 op_acbl		= ^xf1
                           000000C0  0000   239 op_addl2	= ^xc0
                           00000012  0000   240 op_bneq		= ^x12
                           00000031  0000   241 op_brw		= ^x31
                           00000016  0000   242 op_jsb		= ^x16
                           0000009E  0000   243 op_movab	= ^x9e
                           000000DE  0000   244 op_moval	= ^xde
                           0000003E  0000   245 op_movaw	= ^x3e
                           00000090  0000   246 op_movb		= ^x90
                           00000028  0000   247 op_movc3	= ^x28
                           000000D0  0000   248 op_movl		= ^xd0
                           00000005  0000   249 op_rsb		= ^x05
                           000000D5  0000   250 op_tstl		= ^xd5
                                     0000   251 ;
                                     0000   252 ; addressing modes -- constants for compiling addressing modes into dictionary.
                                     0000   253 ;	In order by register and addressing mode.
                                     0000   254 ;
                           00000050  0000   255 adm_r0		= ^x50			; r0
                           00000059  0000   256 adm_r9		= ^x59			; r9
                           00000069  0000   257 adm_def_r9	= ^x69			; (r9)
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  11
V1.01                           Constants                                31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000089  0000   258 adm_ainc_r9	= ^x89			; (r9)+
                           0000005A  0000   259 adm_r10		= ^x5a			; r10
                           0000006A  0000   260 adm_def_r10	= ^x6a			; (r10)
                           0000007A  0000   261 adm_adec_r10	= ^x7a			; -(r10)
                           0000008A  0000   262 adm_ainc_r10	= ^x8a			; (r10)+
                           000000AA  0000   263 adm_b_dis_r10	= ^xaa			; b^(r10)
                           0000006B  0000   264 adm_def_r11	= ^x6b			; (r11)
                           0000007B  0000   265 adm_adec_r11	= ^x7b			; -(r11)
                           0000008B  0000   266 adm_ainc_r11	= ^x8b			; (r11)+
                           0000008F  0000   267 adm_immediate	= ^x8f			; immediate mode
                           0000009F  0000   268 adm_absolute	= ^x9f			; absolute mode
                           000000AF  0000   269 adm_b_rel	= ^xaf			; byte relative
                                     0000   270 
                                     0000   271 ;
                                     0000   272 ; Assembly-time vocabulary links -- symbols used during assembly to link
                                     0000   273 ;	the starting vocabularies together.   These start out at 0 so that
                                     0000   274 ;	all vocabularies will end with a null pointer.	During assembly,
                                     0000   275 ;	each link holds the address of the link fields of the most recently
                                     0000   276 ;	defined.  When a word is defined with the `header' macro then
                                     0000   277 ;	link field of the new word is initialized to the valu of the
                                     0000   278 ;	link and the link is changed to the address of the link field of the
                                     0000   279 ;	new word.
                                     0000   280 ;
                           00000000  0000   281 vl_compiler = 0		   ; Links the compiler vocabulary together
                           00000000  0000   282 vl_kernel = 0		   ; Links the kernel vocabulary together
                                     0000   283 ;******************************************************************************
                                     0000   284 	newpage <Macros>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  12
V1.01                           Macros                                   31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.sbttl	Macros
                                     0000       	
                                     0000   285 ;******************************************************************************
                                     0000   286 ;
                                     0000   287 ; Macros -- Macro Definitions
                                     0000   288 ;
                                     0000   289 ;******************************************************************************
                                     0000   290 ;!+++t
                                     0000   291 ;m> header -- macro to start all words in code
                                     0000   292 ;	This macro sets up the header for the VTIL words, and inserts it
                                     0000   293 ;	into the linked vocabulary list.  Because it uses backslash delimited
                                     0000   294 ;	strings, none of the words in the starting vocabularies built in
                                     0000   295 ;	the macro source code should have backslashes in their names.
                                     0000   296 ;
                                     0000   297 ;!---
                                     0000   298 	.macro	header	macname,name=<>,branch=vl_kernel
                                     0000   299 	.long	branch		; back link to the previous word in this branch
                                     0000   300 	branch = . - 4		; where to link the next word to in this branch
                                     0000   301 	.nchr  nchr, ^\name\	; nchr = length( name )
                                     0000   302 	.if    le, nchr		; nchr <= 0
                                     0000   303 	   .ascic \macname\	; no auxillary name, use principle one
                                     0000   304 	.if_false		; else
                                     0000   305 	  .ascic \name\		; use auxillary name
                                     0000   306 	.endc			; end if
                                     0000   307 macname:			; use name of word as branch label
                                     0000   308 	.endm			; end of macro header
                                     0000   309 
                                     0000   310 
                                     0000   311 ;!+++
                                     0000   312 ;m> iserror -- simplistic error checking routine.  If error code in r0,
                                     0000   313 ;	die messily.
                                     0000   314 ;!---
                                     0000   315 	.macro	iserror badwhere=_error_exit,?goodwhere
                                     0000   316 	blbs	r0,goodwhere	; no error, go on
                                     0000   317 	brw	badwhere	; error, branch to error handler
                                     0000   318 goodwhere:
                                     0000   319 	.endm	iserror
                                     0000   320 
                                     0000   321 
                                     0000   322 ;!+++
                                     0000   323 ;m> isstrerr -- simplistic error checking routine.  If error code in r0,
                                     0000   324 ;	unless lib$_inpstrtru, die messily
                                     0000   325 ;!---
                                     0000   326 	.macro	isstrerr badwhere=_error_exit,?goodwhere
                                     0000   327 	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                                     0000   328 	beql	goodwhere		; yes, ignore and go on
                                     0000   329 	blbs	r0,goodwhere		; no error, go on
                                     0000   330 	brw	badwhere		; error, branch to error handler
                                     0000   331 goodwhere:
                                     0000   332 	.endm	isstrerr
                                     0000   333 
                                     0000   334 	newpage <Data Section>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  13
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.sbttl	Data Section
                                     0000       	
                                     0000   335 ;******************************************************************************
                                     0000   336 ;
                                     0000   337 ; Data Section -- Contains the stacks, i/o buffers, misc buffers,
                                     0000   338 ;	and the system variables.
                                     0000   339 ;
                                     0000   340 ;******************************************************************************
                                 00000000   341 	.psect	vtildata,long,noexe
                                     0000   342 ;
                                     0000   343 ; data stack allocation
                                     0000   344 ;
                                     0000   345 c_ds_end:
                           00001000  0000   346 	.blkb	c_ds_size	; reserve c_ds_size bytes for data stack
                                     1000   347 c_ds_start:
                                     1000   348 ;
                                     1000   349 ; Loop stack allocation
                                     1000   350 ;
                                     1000   351 c_ls_end:
                           00001800  1000   352 	.blkb	c_ls_size	; reserve c_ls_size bytes for loop stack
                                     1800   353 c_ls_start:
                                     1800   354 
                                     1800   355 
                                     1800   356 ;
                                     1800   357 ; message string variables
                                     1800   358 ;	.ascid strings are used by lib$get_input and lib$put_output
                                     1800   359 ;	.ascic strings are used by { write }
                                     1800   360 ;
                                     1800   361 v_greeting:
76 20 4C 49 54 56 00001808'010E0000' 1800   362 	.ascid	/VTIL v1.01 -- Welcome to TIL-land!/	; Greet the user
63 6C 65 57 20 2D 2D 20 31 30 2E 31  180E       
6C 2D 4C 49 54 20 6F 74 20 65 6D 6F  181A       
                        21 64 6E 61  1826       
                                     182A   363 v_vtilprompt:
20 3E 4C 49 54 56 00001832'010E0000' 182A   364 	.ascid	/VTIL> /	; prompt for system input
                                     1838   365 v_usrprompt:
            20 3F 00001840'010E0000' 1838   366 	.ascid	/? /		; prompt for programmer input
                                     1842   367 v_undermess:
20 6B 63 61 74 53 0000184A'010E0000' 1842   368 	.ascid	/Stack Underflow!/
      21 77 6F 6C 66 72 65 64 6E 55  1850       
                                     185A   369 v_overmess:
20 6B 63 61 74 53 00001862'010E0000' 185A   370 	.ascid	/Stack Overflow!/
         21 77 6F 6C 66 72 65 76 4F  1868       
                                     1871   371 v_unknown:
6B 6F 74 20 6E 77 6F 6E 6B 6E 55 00' 1871   372 	.ascic	/Unknown token: { /
                  20 7B 20 3A 6E 65  187D       
                                 11  1871       
                                     1883   373 v_unknown2:
3A 65 6E 69 6C 20 6E 69 20 7D 20 00' 1883   374 	.ascic	/ } in line: /
                                 20  188F       
                                 0C  1883       
                                     1890   375 v_infilemess:
      20 3A 65 6C 69 66 20 6E 49 00' 1890   376 	.ascic	/In file: /
                                 09  1890       
                                     189A   377 v_filenotfound:
6E 20 65 6C 69 46 000018A2'010E0000' 189A   378 	.ascid	/File not found!/
         21 64 6E 75 6F 66 20 74 6F  18A8       
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  14
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     18B1   379 v_unkn_blk_mess:
63 6F 6C 42 20 6E 77 6F 6E 6B 55 00' 18B1   380 	.ascic	/Uknown Block Number: /
      20 3A 72 65 62 6D 75 4E 20 6B  18BD       
                                 15  18B1       
                                     18C7   381 v_wordnotfound:
6F 46 20 74 6F 4E 20 64 72 6F 57 00' 18C7   382 	.ascic	/Word Not Found: /
                     20 3A 64 6E 75  18D3       
                                 10  18C7       
                                     18D8   383 v_nametoolong:
6F 6C 20 6F 6F 74 20 65 6D 61 4E 00' 18D8   384 	.ascic	/Name too long: /
                        20 3A 67 6E  18E4       
                                 0F  18D8       
                                     18E8   385 v_nametrunc:
74 20 64 65 74 61 63 6E 75 72 54 00' 18E8   386 	.ascic	/Truncated to: /
                           20 3A 6F  18F4       
                                 0E  18E8       
                                     18F7   387 
                                     18F7   388 
                                     18F7   389 ;
                                     18F7   390 ; variables for system input
                                     18F7   391 ;
                                     18F7   392 v_inbuf:
                           00001997  18F7   393 	.blkb	c_max_len	; buffer for system input
                                     1997   394 v_org_inlen:
                               0000  1997   395 	.word	0		; original length of line
                                     1999   396 v_inlen:			; word to hold length of remaining unprocessed
                               0000  1999   397 	.word	0		; characters
                                     199B   398 v_inptr:
                           000018F7' 199B   399 	.long	v_inbuf		; pointer to current location in string
                                     199F   400 v_in_dsc:
                               00A0  199F   401 	.word	c_max_len	; maximum length for system input
                                 00' 19A1   402 	.byte	dsc$k_dtype_t	; data type text
                                 00' 19A2   403 	.byte	dsc$k_class_s	; descriptor class
                           000018F7' 19A3   404 	.long	v_inbuf		; pointer to input buffer
                                     19A7   405 
                                     19A7   406 
                                     19A7   407 ;
                                     19A7   408 ; rms buffers for loading source from a file instead of keyboard
                                     19A7   409 ;
                                     19A7   410 	.align	long			; so rms macros won't complain
                                     19A8   411 v_infab:
                                     19A8   412 	$fab
                                     19A8       	$FABDEF
                                     19A8       	$DEFINI	FAB,
                                     19A8       	.SAVE	LOCAL_BLOCK
                                     19A8       	.NOCROSS
                                     19A8       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     19A8       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  15
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	FAB$C_BID	3
                           00000003  0000       	FAB$C_BID=3
                                     0000       	
                                     0000       $EQU	FAB$M_PPF_RAT	16320
                           00003FC0  0000       	FAB$M_PPF_RAT=16320
                                     0000       	
                                     0000       $EQU	FAB$M_PPF_IND	16384
                           00004000  0000       	FAB$M_PPF_IND=16384
                                     0000       	
                                     0000       $EQU	FAB$M_PPIFI	32768
                           00008000  0000       	FAB$M_PPIFI=32768
                                     0000       	
                                     0000       $EQU	FAB$M_ASY	1
                           00000001  0000       	FAB$M_ASY=1
                                     0000       	
                                     0000       $EQU	FAB$M_MXV	2
                           00000002  0000       	FAB$M_MXV=2
                                     0000       	
                                     0000       $EQU	FAB$M_SUP	4
                           00000004  0000       	FAB$M_SUP=4
                                     0000       	
                                     0000       $EQU	FAB$M_TMP	8
                           00000008  0000       	FAB$M_TMP=8
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  16
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$M_TMD	16
                           00000010  0000       	FAB$M_TMD=16
                                     0000       	
                                     0000       $EQU	FAB$M_DFW	32
                           00000020  0000       	FAB$M_DFW=32
                                     0000       	
                                     0000       $EQU	FAB$M_SQO	64
                           00000040  0000       	FAB$M_SQO=64
                                     0000       	
                                     0000       $EQU	FAB$M_RWO	128
                           00000080  0000       	FAB$M_RWO=128
                                     0000       	
                                     0000       $EQU	FAB$M_POS	256
                           00000100  0000       	FAB$M_POS=256
                                     0000       	
                                     0000       $EQU	FAB$M_WCK	512
                           00000200  0000       	FAB$M_WCK=512
                                     0000       	
                                     0000       $EQU	FAB$M_NEF	1024
                           00000400  0000       	FAB$M_NEF=1024
                                     0000       	
                                     0000       $EQU	FAB$M_RWC	2048
                           00000800  0000       	FAB$M_RWC=2048
                                     0000       	
                                     0000       $EQU	FAB$M_DMO	4096
                           00001000  0000       	FAB$M_DMO=4096
                                     0000       	
                                     0000       $EQU	FAB$M_SPL	8192
                           00002000  0000       	FAB$M_SPL=8192
                                     0000       	
                                     0000       $EQU	FAB$M_SCF	16384
                           00004000  0000       	FAB$M_SCF=16384
                                     0000       	
                                     0000       $EQU	FAB$M_DLT	32768
                           00008000  0000       	FAB$M_DLT=32768
                                     0000       	
                                     0000       $EQU	FAB$M_NFS	65536
                           00010000  0000       	FAB$M_NFS=65536
                                     0000       	
                                     0000       $EQU	FAB$M_UFO	131072
                           00020000  0000       	FAB$M_UFO=131072
                                     0000       	
                                     0000       $EQU	FAB$M_PPF	262144
                           00040000  0000       	FAB$M_PPF=262144
                                     0000       	
                                     0000       $EQU	FAB$M_INP	524288
                           00080000  0000       	FAB$M_INP=524288
                                     0000       	
                                     0000       $EQU	FAB$M_CTG	1048576
                           00100000  0000       	FAB$M_CTG=1048576
                                     0000       	
                                     0000       $EQU	FAB$M_CBT	2097152
                           00200000  0000       	FAB$M_CBT=2097152
                                     0000       	
                                     0000       $EQU	FAB$M_SYNCSTS	4194304
                           00400000  0000       	FAB$M_SYNCSTS=4194304
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  17
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$M_RCK	8388608
                           00800000  0000       	FAB$M_RCK=8388608
                                     0000       	
                                     0000       $EQU	FAB$M_NAM	16777216
                           01000000  0000       	FAB$M_NAM=16777216
                                     0000       	
                                     0000       $EQU	FAB$M_CIF	33554432
                           02000000  0000       	FAB$M_CIF=33554432
                                     0000       	
                                     0000       $EQU	FAB$M_ESC	134217728
                           08000000  0000       	FAB$M_ESC=134217728
                                     0000       	
                                     0000       $EQU	FAB$M_TEF	268435456
                           10000000  0000       	FAB$M_TEF=268435456
                                     0000       	
                                     0000       $EQU	FAB$M_OFP	536870912
                           20000000  0000       	FAB$M_OFP=536870912
                                     0000       	
                                     0000       $EQU	FAB$M_KFO	1073741824
                           40000000  0000       	FAB$M_KFO=1073741824
                                     0000       	
                                     0000       $EQU	FAB$M_PUT	1
                           00000001  0000       	FAB$M_PUT=1
                                     0000       	
                                     0000       $EQU	FAB$M_GET	2
                           00000002  0000       	FAB$M_GET=2
                                     0000       	
                                     0000       $EQU	FAB$M_DEL	4
                           00000004  0000       	FAB$M_DEL=4
                                     0000       	
                                     0000       $EQU	FAB$M_UPD	8
                           00000008  0000       	FAB$M_UPD=8
                                     0000       	
                                     0000       $EQU	FAB$M_TRN	16
                           00000010  0000       	FAB$M_TRN=16
                                     0000       	
                                     0000       $EQU	FAB$M_BIO	32
                           00000020  0000       	FAB$M_BIO=32
                                     0000       	
                                     0000       $EQU	FAB$M_BRO	64
                           00000040  0000       	FAB$M_BRO=64
                                     0000       	
                                     0000       $EQU	FAB$M_EXE	128
                           00000080  0000       	FAB$M_EXE=128
                                     0000       	
                                     0000       $EQU	FAB$M_SHRPUT	1
                           00000001  0000       	FAB$M_SHRPUT=1
                                     0000       	
                                     0000       $EQU	FAB$M_SHRGET	2
                           00000002  0000       	FAB$M_SHRGET=2
                                     0000       	
                                     0000       $EQU	FAB$M_SHRDEL	4
                           00000004  0000       	FAB$M_SHRDEL=4
                                     0000       	
                                     0000       $EQU	FAB$M_SHRUPD	8
                           00000008  0000       	FAB$M_SHRUPD=8
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  18
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$M_MSE	16
                           00000010  0000       	FAB$M_MSE=16
                                     0000       	
                                     0000       $EQU	FAB$M_NIL	32
                           00000020  0000       	FAB$M_NIL=32
                                     0000       	
                                     0000       $EQU	FAB$M_UPI	64
                           00000040  0000       	FAB$M_UPI=64
                                     0000       	
                                     0000       $EQU	FAB$M_ORG	240
                           000000F0  0000       	FAB$M_ORG=240
                                     0000       	
                                     0000       $EQU	FAB$C_SEQ	0
                           00000000  0000       	FAB$C_SEQ=0
                                     0000       	
                                     0000       $EQU	FAB$C_REL	16
                           00000010  0000       	FAB$C_REL=16
                                     0000       	
                                     0000       $EQU	FAB$C_IDX	32
                           00000020  0000       	FAB$C_IDX=32
                                     0000       	
                                     0000       $EQU	FAB$C_HSH	48
                           00000030  0000       	FAB$C_HSH=48
                                     0000       	
                                     0000       $EQU	FAB$M_FTN	1
                           00000001  0000       	FAB$M_FTN=1
                                     0000       	
                                     0000       $EQU	FAB$M_CR	2
                           00000002  0000       	FAB$M_CR=2
                                     0000       	
                                     0000       $EQU	FAB$M_PRN	4
                           00000004  0000       	FAB$M_PRN=4
                                     0000       	
                                     0000       $EQU	FAB$M_BLK	8
                           00000008  0000       	FAB$M_BLK=8
                                     0000       	
                                     0000       $EQU	FAB$C_RFM_DFLT	2
                           00000002  0000       	FAB$C_RFM_DFLT=2
                                     0000       	
                                     0000       $EQU	FAB$C_UDF	0
                           00000000  0000       	FAB$C_UDF=0
                                     0000       	
                                     0000       $EQU	FAB$C_FIX	1
                           00000001  0000       	FAB$C_FIX=1
                                     0000       	
                                     0000       $EQU	FAB$C_VAR	2
                           00000002  0000       	FAB$C_VAR=2
                                     0000       	
                                     0000       $EQU	FAB$C_VFC	3
                           00000003  0000       	FAB$C_VFC=3
                                     0000       	
                                     0000       $EQU	FAB$C_STM	4
                           00000004  0000       	FAB$C_STM=4
                                     0000       	
                                     0000       $EQU	FAB$C_STMLF	5
                           00000005  0000       	FAB$C_STMLF=5
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  19
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$C_STMCR	6
                           00000006  0000       	FAB$C_STMCR=6
                                     0000       	
                                     0000       $EQU	FAB$C_MAXRFM	6
                           00000006  0000       	FAB$C_MAXRFM=6
                                     0000       	
                                     0000       $EQU	FAB$M_ONLY_RU	1
                           00000001  0000       	FAB$M_ONLY_RU=1
                                     0000       	
                                     0000       $EQU	FAB$M_RU	2
                           00000002  0000       	FAB$M_RU=2
                                     0000       	
                                     0000       $EQU	FAB$M_BI	4
                           00000004  0000       	FAB$M_BI=4
                                     0000       	
                                     0000       $EQU	FAB$M_AI	8
                           00000008  0000       	FAB$M_AI=8
                                     0000       	
                                     0000       $EQU	FAB$M_AT	16
                           00000010  0000       	FAB$M_AT=16
                                     0000       	
                                     0000       $EQU	FAB$M_NEVER_RU	32
                           00000020  0000       	FAB$M_NEVER_RU=32
                                     0000       	
                                     0000       $EQU	FAB$M_JOURNAL_FILE	64
                           00000040  0000       	FAB$M_JOURNAL_FILE=64
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_RU	1
                           00000001  0000       	FAB$M_RCF_RU=1
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_AI	2
                           00000002  0000       	FAB$M_RCF_AI=2
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_BI	4
                           00000004  0000       	FAB$M_RCF_BI=4
                                     0000       	
                                     0000       $EQU	FAB$K_BLN	80
                           00000050  0000       	FAB$K_BLN=80
                                     0000       	
                                     0000       $EQU	FAB$C_BLN	80
                           00000050  0000       	FAB$C_BLN=80
                                     0000       	
                                     0000       $EQU	FAB$S_FABDEF	80
                           00000050  0000       	FAB$S_FABDEF=80
                                     0000       	
                                     0000       $EQU	FAB$B_BID	0
                           00000000  0000       	FAB$B_BID=0
                                     0000       	
                                     0000       $EQU	FAB$B_BLN	1
                           00000001  0000       	FAB$B_BLN=1
                                     0000       	
                                     0000       $EQU	FAB$R_IFI_OVERLAY	2
                           00000002  0000       	FAB$R_IFI_OVERLAY=2
                                     0000       	
                                     0000       $EQU	FAB$W_IFI	2
                           00000002  0000       	FAB$W_IFI=2
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  20
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$R_IFI_BITS	2
                           00000002  0000       	FAB$R_IFI_BITS=2
                                     0000       	
                                     0000       $EQU	FAB$S_PPF_RAT	8
                           00000008  0000       	FAB$S_PPF_RAT=8
                                     0000       	
                                     0000       $EQU	FAB$V_PPF_RAT	6
                           00000006  0000       	FAB$V_PPF_RAT=6
                                     0000       	
                                     0000       $EQU	FAB$V_PPF_IND	14
                           0000000E  0000       	FAB$V_PPF_IND=14
                                     0000       	
                                     0000       $EQU	FAB$V_PPIFI	15
                           0000000F  0000       	FAB$V_PPIFI=15
                                     0000       	
                                     0000       $EQU	FAB$R_FOP_OVERLAY	4
                           00000004  0000       	FAB$R_FOP_OVERLAY=4
                                     0000       	
                                     0000       $EQU	FAB$L_FOP	4
                           00000004  0000       	FAB$L_FOP=4
                                     0000       	
                                     0000       $EQU	FAB$R_FOP_BITS	4
                           00000004  0000       	FAB$R_FOP_BITS=4
                                     0000       	
                                     0000       $EQU	FAB$V_ASY	0
                           00000000  0000       	FAB$V_ASY=0
                                     0000       	
                                     0000       $EQU	FAB$V_MXV	1
                           00000001  0000       	FAB$V_MXV=1
                                     0000       	
                                     0000       $EQU	FAB$V_SUP	2
                           00000002  0000       	FAB$V_SUP=2
                                     0000       	
                                     0000       $EQU	FAB$V_TMP	3
                           00000003  0000       	FAB$V_TMP=3
                                     0000       	
                                     0000       $EQU	FAB$V_TMD	4
                           00000004  0000       	FAB$V_TMD=4
                                     0000       	
                                     0000       $EQU	FAB$V_DFW	5
                           00000005  0000       	FAB$V_DFW=5
                                     0000       	
                                     0000       $EQU	FAB$V_SQO	6
                           00000006  0000       	FAB$V_SQO=6
                                     0000       	
                                     0000       $EQU	FAB$V_RWO	7
                           00000007  0000       	FAB$V_RWO=7
                                     0000       	
                                     0000       $EQU	FAB$V_POS	8
                           00000008  0000       	FAB$V_POS=8
                                     0000       	
                                     0000       $EQU	FAB$V_WCK	9
                           00000009  0000       	FAB$V_WCK=9
                                     0000       	
                                     0000       $EQU	FAB$V_NEF	10
                           0000000A  0000       	FAB$V_NEF=10
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  21
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$V_RWC	11
                           0000000B  0000       	FAB$V_RWC=11
                                     0000       	
                                     0000       $EQU	FAB$V_DMO	12
                           0000000C  0000       	FAB$V_DMO=12
                                     0000       	
                                     0000       $EQU	FAB$V_SPL	13
                           0000000D  0000       	FAB$V_SPL=13
                                     0000       	
                                     0000       $EQU	FAB$V_SCF	14
                           0000000E  0000       	FAB$V_SCF=14
                                     0000       	
                                     0000       $EQU	FAB$V_DLT	15
                           0000000F  0000       	FAB$V_DLT=15
                                     0000       	
                                     0000       $EQU	FAB$V_NFS	16
                           00000010  0000       	FAB$V_NFS=16
                                     0000       	
                                     0000       $EQU	FAB$V_UFO	17
                           00000011  0000       	FAB$V_UFO=17
                                     0000       	
                                     0000       $EQU	FAB$V_PPF	18
                           00000012  0000       	FAB$V_PPF=18
                                     0000       	
                                     0000       $EQU	FAB$V_INP	19
                           00000013  0000       	FAB$V_INP=19
                                     0000       	
                                     0000       $EQU	FAB$V_CTG	20
                           00000014  0000       	FAB$V_CTG=20
                                     0000       	
                                     0000       $EQU	FAB$V_CBT	21
                           00000015  0000       	FAB$V_CBT=21
                                     0000       	
                                     0000       $EQU	FAB$V_SYNCSTS	22
                           00000016  0000       	FAB$V_SYNCSTS=22
                                     0000       	
                                     0000       $EQU	FAB$V_RCK	23
                           00000017  0000       	FAB$V_RCK=23
                                     0000       	
                                     0000       $EQU	FAB$V_NAM	24
                           00000018  0000       	FAB$V_NAM=24
                                     0000       	
                                     0000       $EQU	FAB$V_CIF	25
                           00000019  0000       	FAB$V_CIF=25
                                     0000       	
                                     0000       $EQU	FAB$V_ESC	27
                           0000001B  0000       	FAB$V_ESC=27
                                     0000       	
                                     0000       $EQU	FAB$V_TEF	28
                           0000001C  0000       	FAB$V_TEF=28
                                     0000       	
                                     0000       $EQU	FAB$V_OFP	29
                           0000001D  0000       	FAB$V_OFP=29
                                     0000       	
                                     0000       $EQU	FAB$V_KFO	30
                           0000001E  0000       	FAB$V_KFO=30
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  22
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$L_STS	8
                           00000008  0000       	FAB$L_STS=8
                                     0000       	
                                     0000       $EQU	FAB$L_STV	12
                           0000000C  0000       	FAB$L_STV=12
                                     0000       	
                                     0000       $EQU	FAB$L_ALQ	16
                           00000010  0000       	FAB$L_ALQ=16
                                     0000       	
                                     0000       $EQU	FAB$W_DEQ	20
                           00000014  0000       	FAB$W_DEQ=20
                                     0000       	
                                     0000       $EQU	FAB$R_FAC_OVERLAY	22
                           00000016  0000       	FAB$R_FAC_OVERLAY=22
                                     0000       	
                                     0000       $EQU	FAB$B_FAC	22
                           00000016  0000       	FAB$B_FAC=22
                                     0000       	
                                     0000       $EQU	FAB$R_FAC_BITS	22
                           00000016  0000       	FAB$R_FAC_BITS=22
                                     0000       	
                                     0000       $EQU	FAB$V_PUT	0
                           00000000  0000       	FAB$V_PUT=0
                                     0000       	
                                     0000       $EQU	FAB$V_GET	1
                           00000001  0000       	FAB$V_GET=1
                                     0000       	
                                     0000       $EQU	FAB$V_DEL	2
                           00000002  0000       	FAB$V_DEL=2
                                     0000       	
                                     0000       $EQU	FAB$V_UPD	3
                           00000003  0000       	FAB$V_UPD=3
                                     0000       	
                                     0000       $EQU	FAB$V_TRN	4
                           00000004  0000       	FAB$V_TRN=4
                                     0000       	
                                     0000       $EQU	FAB$V_BIO	5
                           00000005  0000       	FAB$V_BIO=5
                                     0000       	
                                     0000       $EQU	FAB$V_BRO	6
                           00000006  0000       	FAB$V_BRO=6
                                     0000       	
                                     0000       $EQU	FAB$V_EXE	7
                           00000007  0000       	FAB$V_EXE=7
                                     0000       	
                                     0000       $EQU	FAB$R_SHR_OVERLAY	23
                           00000017  0000       	FAB$R_SHR_OVERLAY=23
                                     0000       	
                                     0000       $EQU	FAB$B_SHR	23
                           00000017  0000       	FAB$B_SHR=23
                                     0000       	
                                     0000       $EQU	FAB$R_SHR_BITS	23
                           00000017  0000       	FAB$R_SHR_BITS=23
                                     0000       	
                                     0000       $EQU	FAB$V_SHRPUT	0
                           00000000  0000       	FAB$V_SHRPUT=0
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  23
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$V_SHRGET	1
                           00000001  0000       	FAB$V_SHRGET=1
                                     0000       	
                                     0000       $EQU	FAB$V_SHRDEL	2
                           00000002  0000       	FAB$V_SHRDEL=2
                                     0000       	
                                     0000       $EQU	FAB$V_SHRUPD	3
                           00000003  0000       	FAB$V_SHRUPD=3
                                     0000       	
                                     0000       $EQU	FAB$V_MSE	4
                           00000004  0000       	FAB$V_MSE=4
                                     0000       	
                                     0000       $EQU	FAB$V_NIL	5
                           00000005  0000       	FAB$V_NIL=5
                                     0000       	
                                     0000       $EQU	FAB$V_UPI	6
                           00000006  0000       	FAB$V_UPI=6
                                     0000       	
                                     0000       $EQU	FAB$L_CTX	24
                           00000018  0000       	FAB$L_CTX=24
                                     0000       	
                                     0000       $EQU	FAB$B_RTV	28
                           0000001C  0000       	FAB$B_RTV=28
                                     0000       	
                                     0000       $EQU	FAB$R_ORG_OVERLAY	29
                           0000001D  0000       	FAB$R_ORG_OVERLAY=29
                                     0000       	
                                     0000       $EQU	FAB$B_ORG	29
                           0000001D  0000       	FAB$B_ORG=29
                                     0000       	
                                     0000       $EQU	FAB$R_ORG_BITS	29
                           0000001D  0000       	FAB$R_ORG_BITS=29
                                     0000       	
                                     0000       $EQU	FAB$S_ORG	4
                           00000004  0000       	FAB$S_ORG=4
                                     0000       	
                                     0000       $EQU	FAB$V_ORG	4
                           00000004  0000       	FAB$V_ORG=4
                                     0000       	
                                     0000       $EQU	FAB$R_RAT_OVERLAY	30
                           0000001E  0000       	FAB$R_RAT_OVERLAY=30
                                     0000       	
                                     0000       $EQU	FAB$B_RAT	30
                           0000001E  0000       	FAB$B_RAT=30
                                     0000       	
                                     0000       $EQU	FAB$R_RAT_BITS	30
                           0000001E  0000       	FAB$R_RAT_BITS=30
                                     0000       	
                                     0000       $EQU	FAB$V_FTN	0
                           00000000  0000       	FAB$V_FTN=0
                                     0000       	
                                     0000       $EQU	FAB$V_CR	1
                           00000001  0000       	FAB$V_CR=1
                                     0000       	
                                     0000       $EQU	FAB$V_PRN	2
                           00000002  0000       	FAB$V_PRN=2
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  24
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$V_BLK	3
                           00000003  0000       	FAB$V_BLK=3
                                     0000       	
                                     0000       $EQU	FAB$B_RFM	31
                           0000001F  0000       	FAB$B_RFM=31
                                     0000       	
                                     0000       $EQU	FAB$R_JOURNAL_OVERLAY	32
                           00000020  0000       	FAB$R_JOURNAL_OVERLAY=32
                                     0000       	
                                     0000       $EQU	FAB$B_JOURNAL	32
                           00000020  0000       	FAB$B_JOURNAL=32
                                     0000       	
                                     0000       $EQU	FAB$R_JOURNAL_BITS	32
                           00000020  0000       	FAB$R_JOURNAL_BITS=32
                                     0000       	
                                     0000       $EQU	FAB$V_ONLY_RU	0
                           00000000  0000       	FAB$V_ONLY_RU=0
                                     0000       	
                                     0000       $EQU	FAB$V_RU	1
                           00000001  0000       	FAB$V_RU=1
                                     0000       	
                                     0000       $EQU	FAB$V_BI	2
                           00000002  0000       	FAB$V_BI=2
                                     0000       	
                                     0000       $EQU	FAB$V_AI	3
                           00000003  0000       	FAB$V_AI=3
                                     0000       	
                                     0000       $EQU	FAB$V_AT	4
                           00000004  0000       	FAB$V_AT=4
                                     0000       	
                                     0000       $EQU	FAB$V_NEVER_RU	5
                           00000005  0000       	FAB$V_NEVER_RU=5
                                     0000       	
                                     0000       $EQU	FAB$V_JOURNAL_FILE	6
                           00000006  0000       	FAB$V_JOURNAL_FILE=6
                                     0000       	
                                     0000       $EQU	FAB$B_RU_FACILITY	33
                           00000021  0000       	FAB$B_RU_FACILITY=33
                                     0000       	
                                     0000       $EQU	FAB$L_XAB	36
                           00000024  0000       	FAB$L_XAB=36
                                     0000       	
                                     0000       $EQU	FAB$L_NAM	40
                           00000028  0000       	FAB$L_NAM=40
                                     0000       	
                                     0000       $EQU	FAB$L_FNA	44
                           0000002C  0000       	FAB$L_FNA=44
                                     0000       	
                                     0000       $EQU	FAB$L_DNA	48
                           00000030  0000       	FAB$L_DNA=48
                                     0000       	
                                     0000       $EQU	FAB$B_FNS	52
                           00000034  0000       	FAB$B_FNS=52
                                     0000       	
                                     0000       $EQU	FAB$B_DNS	53
                           00000035  0000       	FAB$B_DNS=53
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  25
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$W_MRS	54
                           00000036  0000       	FAB$W_MRS=54
                                     0000       	
                                     0000       $EQU	FAB$L_MRN	56
                           00000038  0000       	FAB$L_MRN=56
                                     0000       	
                                     0000       $EQU	FAB$W_BLS	60
                           0000003C  0000       	FAB$W_BLS=60
                                     0000       	
                                     0000       $EQU	FAB$B_BKS	62
                           0000003E  0000       	FAB$B_BKS=62
                                     0000       	
                                     0000       $EQU	FAB$B_FSZ	63
                           0000003F  0000       	FAB$B_FSZ=63
                                     0000       	
                                     0000       $EQU	FAB$L_DEV	64
                           00000040  0000       	FAB$L_DEV=64
                                     0000       	
                                     0000       $EQU	FAB$L_SDC	68
                           00000044  0000       	FAB$L_SDC=68
                                     0000       	
                                     0000       $EQU	FAB$W_GBC	72
                           00000048  0000       	FAB$W_GBC=72
                                     0000       	
                                     0000       $EQU	FAB$R_ACMODES_OVERLAY	74
                           0000004A  0000       	FAB$R_ACMODES_OVERLAY=74
                                     0000       	
                                     0000       $EQU	FAB$B_ACMODES	74
                           0000004A  0000       	FAB$B_ACMODES=74
                                     0000       	
                                     0000       $EQU	FAB$R_ACMODES_BITS	74
                           0000004A  0000       	FAB$R_ACMODES_BITS=74
                                     0000       	
                                     0000       $EQU	FAB$S_LNM_MODE	2
                           00000002  0000       	FAB$S_LNM_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_LNM_MODE	0
                           00000000  0000       	FAB$V_LNM_MODE=0
                                     0000       	
                                     0000       $EQU	FAB$S_CHAN_MODE	2
                           00000002  0000       	FAB$S_CHAN_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_CHAN_MODE	2
                           00000002  0000       	FAB$V_CHAN_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$S_FILE_MODE	2
                           00000002  0000       	FAB$S_FILE_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_FILE_MODE	4
                           00000004  0000       	FAB$V_FILE_MODE=4
                                     0000       	
                                     0000       $EQU	FAB$S_CALLERS_MODE	2
                           00000002  0000       	FAB$S_CALLERS_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_CALLERS_MODE	6       ;  ACMODE for user structure probing
                           00000006  0000       	FAB$V_CALLERS_MODE=6
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  26
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       $EQU	FAB$R_RCF_OVERLAY	75
                           0000004B  0000       	FAB$R_RCF_OVERLAY=75
                                     0000       	
                                     0000       $EQU	FAB$B_RCF	75
                           0000004B  0000       	FAB$B_RCF=75
                                     0000       	
                                     0000       $EQU	FAB$R_RCF_BITS	75
                           0000004B  0000       	FAB$R_RCF_BITS=75
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_RU	0
                           00000000  0000       	FAB$V_RCF_RU=0
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_AI	1
                           00000001  0000       	FAB$V_RCF_AI=1
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_BI	2
                           00000002  0000       	FAB$V_RCF_BI=2
                                     0000       	
                                     0000       	$DEFEND	FAB,,DEF
                                     0000       	.MACRO	$FABDEF A
                                     0000       	.ENDM	$FABDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                 000019A8       	.RESTORE
                                     19A8       	
                                     19A8       	
                                     19A8       	$$R_TABINIT	FAB$C_BID, FAB$C_BLN
                                     19A8       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           000019A8  19A8       $$.TAB=.
                                 03  19A8       	.BYTE FAB$C_BID
                                 50  19A9       	.BYTE FAB$C_BLN
                           000019F8  19AA       	.BLKB FAB$C_BLN-2
                           000019F8  19F8       $$.TABEND=.
                                     19F8       
                                     19F8       	$$R_VBFSET	FAB,<>
                           00000000  19F8       $$.TMP=0
                                     19F8       	.IRP X,<>
                                     19F8       	.IF DF FAB$V_'X
                                     19F8       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19F8       	.IFF
                                     19F8       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19F8       	.ENDC
                                     19F8       	.ENDR
                                     19F8       	
                           000019AC  19F8       	.=$$.TAB+FAB$L_FOP
                           00000000' 19AC       	.ADDRESS	$$.TMP
                           000019B8  19B0       	.=$$.TAB+FAB$L_ALQ
                           00000000' 19B8       	.ADDRESS	0
                               0000  19BC       	.WORD	0
                                     19BE       	$$R_VBFSET	FAB,<>
                           00000000  19BE       $$.TMP=0
                                     19BE       	.IRP X,<>
                                     19BE       	.IF DF FAB$V_'X
                                     19BE       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19BE       	.IFF
                                     19BE       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19BE       	.ENDC
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  27
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     19BE       	.ENDR
                                     19BE       	
                                 00  19BE       	.BYTE	$$.TMP
                                     19BF       	$$R_VBFSET	FAB,<>
                           00000000  19BF       $$.TMP=0
                                     19BF       	.IRP X,<>
                                     19BF       	.IF DF FAB$V_'X
                                     19BF       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19BF       	.IFF
                                     19BF       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19BF       	.ENDC
                                     19BF       	.ENDR
                                     19BF       	
                                 00  19BF       	.BYTE	$$.TMP
                           00000000' 19C0       	.ADDRESS	0
                                 00  19C4       	.BYTE	0
                                     19C5       	.IF DF FAB$C_SEQ
                                 00  19C5       	.BYTE	FAB$C_SEQ
                                     19C6       	.IFF
                                     19C6       	.BYTE
                                     19C6       	.ERROR			; UNDEFINED VALUE FOR FIELD : SEQ;
                                     19C6       	.ENDC
                                     19C6       	$$R_VBFSET	FAB,<>
                           00000000  19C6       $$.TMP=0
                                     19C6       	.IRP X,<>
                                     19C6       	.IF DF FAB$V_'X
                                     19C6       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19C6       	.IFF
                                     19C6       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19C6       	.ENDC
                                     19C6       	.ENDR
                                     19C6       	
                                 00  19C6       	.BYTE	$$.TMP
                                     19C7       	.IF DF FAB$C_VAR
                                 02  19C7       	.BYTE	FAB$C_VAR
                                     19C8       	.IFF
                                     19C8       	.BYTE
                                     19C8       	.ERROR			; UNDEFINED VALUE FOR FIELD : VAR;
                                     19C8       	.ENDC
                                     19C8       	$$R_VBFSET	FAB,<>
                           00000000  19C8       $$.TMP=0
                                     19C8       	.IRP X,<>
                                     19C8       	.IF DF FAB$V_'X
                                     19C8       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19C8       	.IFF
                                     19C8       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19C8       	.ENDC
                                     19C8       	.ENDR
                                     19C8       	
                                 00  19C8       	.BYTE	$$.TMP
                                 00  19C9       	.BYTE	0
                               0000  19CA       	.WORD
                           00000000' 19CC       	.ADDRESS	0
                           00000000' 19D0       	.ADDRESS	0
                           00000000' 19D4       	.ADDRESS	0
                           00000000' 19D8       	.ADDRESS	0
                                 00  19DC       	.BYTE	0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  28
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 00  19DD       	.BYTE	0
                               0000  19DE       	.WORD	0
                           00000000' 19E0       	.ADDRESS	0
                               0000  19E4       	.WORD	0
                                 00  19E6       	.BYTE	0
                                 00  19E7       	.BYTE	0
                           000019F0  19E8       	.=$$.TAB+FAB$W_GBC
                               0000  19F0       	.WORD	0
                                 00  19F2       	.BYTE	<<0@FAB$V_LNM_MODE> + <0@FAB$V_CHAN_MODE> + -
                                     19F3       		<0@FAB$V_FILE_MODE>>
                                     19F3       	.IIF NE 8-8, .ERROR	; INVALID BYTE SIZE
                                     19F3       	.IF NB <>
                                     19F3       	.SAVE
                                     19F3       	.PSECT $RMSNAM
                                     19F3       	$$.TMPX=.
                                     19F3       	.ASCII %%
                                     19F3       	$$.TMPX1=.-$$.TMPX
                                     19F3       	.RESTORE
                                     19F3       	.=$$.TAB+FAB$L_FNA
                                     19F3       	.ADDRESS	$$.TMPX
                                     19F3       	.=$$.TAB+FAB$B_FNS
                                     19F3       	.BYTE	$$.TMPX1
                                     19F3       	.ENDC
                                     19F3       	.IF NB <>
                                     19F3       	.SAVE
                                     19F3       	.PSECT $RMSNAM
                                     19F3       	$$.TMPX=.
                                     19F3       	.ASCII %%
                                     19F3       	$$.TMPX1=.-$$.TMPX
                                     19F3       	.RESTORE
                                     19F3       	.=$$.TAB+FAB$L_DNA
                                     19F3       	.ADDRESS	$$.TMPX
                                     19F3       	.=$$.TAB+FAB$B_DNS
                                     19F3       	.BYTE	$$.TMPX1
                                     19F3       	.ENDC
                           000019F8  19F3       	.=$$.TABEND
                                     19F8       	
                                     19F8   413 ;		fnm=<infile>,-		; primary input file name
                                     19F8   414 ;		dnm=<vtil.vtil>		; default input file extension
                                     19F8   415 v_inrab:
                                     19F8   416 	$rab	fab=v_infab,-		; pointer to fab
                                     19F8   417 		rop=rah,-		; read-ahead option
                                     19F8   418 		ubf=v_inbuf,-		; record buffer
                                     19F8   419 		usz=c_max_len		; and size
                                     19F8       $RABDEF
                                     19F8       	$DEFINI	RAB,
                                     19F8       	.SAVE	LOCAL_BLOCK
                                     19F8       	.NOCROSS
                                     19F8       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     19F8       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  29
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	RAB$C_BID	1
                           00000001  0000       	RAB$C_BID=1
                                     0000       	
                                     0000       $EQU	RAB$M_PPF_RAT	16320
                           00003FC0  0000       	RAB$M_PPF_RAT=16320
                                     0000       	
                                     0000       $EQU	RAB$M_PPF_IND	16384
                           00004000  0000       	RAB$M_PPF_IND=16384
                                     0000       	
                                     0000       $EQU	RAB$M_PPISI	32768
                           00008000  0000       	RAB$M_PPISI=32768
                                     0000       	
                                     0000       $EQU	RAB$M_ASY	1
                           00000001  0000       	RAB$M_ASY=1
                                     0000       	
                                     0000       $EQU	RAB$M_TPT	2
                           00000002  0000       	RAB$M_TPT=2
                                     0000       	
                                     0000       $EQU	RAB$M_REA	4
                           00000004  0000       	RAB$M_REA=4
                                     0000       	
                                     0000       $EQU	RAB$M_RRL	8
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  30
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000008  0000       	RAB$M_RRL=8
                                     0000       	
                                     0000       $EQU	RAB$M_UIF	16
                           00000010  0000       	RAB$M_UIF=16
                                     0000       	
                                     0000       $EQU	RAB$M_MAS	32
                           00000020  0000       	RAB$M_MAS=32
                                     0000       	
                                     0000       $EQU	RAB$M_FDL	64
                           00000040  0000       	RAB$M_FDL=64
                                     0000       	
                                     0000       $EQU	RAB$M_HSH	128
                           00000080  0000       	RAB$M_HSH=128
                                     0000       	
                                     0000       $EQU	RAB$M_EOF	256
                           00000100  0000       	RAB$M_EOF=256
                                     0000       	
                                     0000       $EQU	RAB$M_RAH	512
                           00000200  0000       	RAB$M_RAH=512
                                     0000       	
                                     0000       $EQU	RAB$M_WBH	1024
                           00000400  0000       	RAB$M_WBH=1024
                                     0000       	
                                     0000       $EQU	RAB$M_BIO	2048
                           00000800  0000       	RAB$M_BIO=2048
                                     0000       	
                                     0000       $EQU	RAB$M_CDK	4096
                           00001000  0000       	RAB$M_CDK=4096
                                     0000       	
                                     0000       $EQU	RAB$M_LOA	8192
                           00002000  0000       	RAB$M_LOA=8192
                                     0000       	
                                     0000       $EQU	RAB$M_LIM	16384
                           00004000  0000       	RAB$M_LIM=16384
                                     0000       	
                                     0000       $EQU	RAB$M_SYNCSTS	32768
                           00008000  0000       	RAB$M_SYNCSTS=32768
                                     0000       	
                                     0000       $EQU	RAB$M_LOC	65536
                           00010000  0000       	RAB$M_LOC=65536
                                     0000       	
                                     0000       $EQU	RAB$M_WAT	131072
                           00020000  0000       	RAB$M_WAT=131072
                                     0000       	
                                     0000       $EQU	RAB$M_ULK	262144
                           00040000  0000       	RAB$M_ULK=262144
                                     0000       	
                                     0000       $EQU	RAB$M_RLK	524288
                           00080000  0000       	RAB$M_RLK=524288
                                     0000       	
                                     0000       $EQU	RAB$M_NLK	1048576
                           00100000  0000       	RAB$M_NLK=1048576
                                     0000       	
                                     0000       $EQU	RAB$M_KGE	2097152
                           00200000  0000       	RAB$M_KGE=2097152
                                     0000       	
                                     0000       $EQU	RAB$M_KGT	4194304
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  31
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00400000  0000       	RAB$M_KGT=4194304
                                     0000       	
                                     0000       $EQU	RAB$M_NXR	8388608
                           00800000  0000       	RAB$M_NXR=8388608
                                     0000       	
                                     0000       $EQU	RAB$M_RNE	16777216
                           01000000  0000       	RAB$M_RNE=16777216
                                     0000       	
                                     0000       $EQU	RAB$M_TMO	33554432
                           02000000  0000       	RAB$M_TMO=33554432
                                     0000       	
                                     0000       $EQU	RAB$M_CVT	67108864
                           04000000  0000       	RAB$M_CVT=67108864
                                     0000       	
                                     0000       $EQU	RAB$M_RNF	134217728
                           08000000  0000       	RAB$M_RNF=134217728
                                     0000       	
                                     0000       $EQU	RAB$M_ETO	268435456
                           10000000  0000       	RAB$M_ETO=268435456
                                     0000       	
                                     0000       $EQU	RAB$M_PTA	536870912
                           20000000  0000       	RAB$M_PTA=536870912
                                     0000       	
                                     0000       $EQU	RAB$M_PMT	1073741824
                           40000000  0000       	RAB$M_PMT=1073741824
                                     0000       	
                                     0000       $EQU	RAB$M_CCO	-2147483648
                           80000000  0000       	RAB$M_CCO=-2147483648
                                     0000       	
                                     0000       $EQU	RAB$M_EQNXT	2097152
                           00200000  0000       	RAB$M_EQNXT=2097152
                                     0000       	
                                     0000       $EQU	RAB$M_NXT	4194304
                           00400000  0000       	RAB$M_NXT=4194304
                                     0000       	
                                     0000       $EQU	RAB$C_SEQ	0
                           00000000  0000       	RAB$C_SEQ=0
                                     0000       	
                                     0000       $EQU	RAB$C_KEY	1
                           00000001  0000       	RAB$C_KEY=1
                                     0000       	
                                     0000       $EQU	RAB$C_RFA	2
                           00000002  0000       	RAB$C_RFA=2
                                     0000       	
                                     0000       $EQU	RAB$C_STM	3
                           00000003  0000       	RAB$C_STM=3
                                     0000       	
                                     0000       $EQU	RAB$C_MAXRAC	2
                           00000002  0000       	RAB$C_MAXRAC=2
                                     0000       	
                                     0000       $EQU	RAB$K_BLN	68
                           00000044  0000       	RAB$K_BLN=68
                                     0000       	
                                     0000       $EQU	RAB$C_BLN	68
                           00000044  0000       	RAB$C_BLN=68
                                     0000       	
                                     0000       $EQU	RAB$S_RABDEF	68
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  32
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000044  0000       	RAB$S_RABDEF=68
                                     0000       	
                                     0000       $EQU	RAB$B_BID	0
                           00000000  0000       	RAB$B_BID=0
                                     0000       	
                                     0000       $EQU	RAB$B_BLN	1
                           00000001  0000       	RAB$B_BLN=1
                                     0000       	
                                     0000       $EQU	RAB$R_ISI_OVERLAY	2
                           00000002  0000       	RAB$R_ISI_OVERLAY=2
                                     0000       	
                                     0000       $EQU	RAB$W_ISI	2
                           00000002  0000       	RAB$W_ISI=2
                                     0000       	
                                     0000       $EQU	RAB$R_ISI_BITS	2
                           00000002  0000       	RAB$R_ISI_BITS=2
                                     0000       	
                                     0000       $EQU	RAB$S_PPF_RAT	8
                           00000008  0000       	RAB$S_PPF_RAT=8
                                     0000       	
                                     0000       $EQU	RAB$V_PPF_RAT	6
                           00000006  0000       	RAB$V_PPF_RAT=6
                                     0000       	
                                     0000       $EQU	RAB$V_PPF_IND	14
                           0000000E  0000       	RAB$V_PPF_IND=14
                                     0000       	
                                     0000       $EQU	RAB$V_PPISI	15
                           0000000F  0000       	RAB$V_PPISI=15
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_OVERLAY	4
                           00000004  0000       	RAB$R_ROP_OVERLAY=4
                                     0000       	
                                     0000       $EQU	RAB$L_ROP	4
                           00000004  0000       	RAB$L_ROP=4
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_BITS0	4
                           00000004  0000       	RAB$R_ROP_BITS0=4
                                     0000       	
                                     0000       $EQU	RAB$V_ASY	0
                           00000000  0000       	RAB$V_ASY=0
                                     0000       	
                                     0000       $EQU	RAB$V_TPT	1
                           00000001  0000       	RAB$V_TPT=1
                                     0000       	
                                     0000       $EQU	RAB$V_REA	2
                           00000002  0000       	RAB$V_REA=2
                                     0000       	
                                     0000       $EQU	RAB$V_RRL	3
                           00000003  0000       	RAB$V_RRL=3
                                     0000       	
                                     0000       $EQU	RAB$V_UIF	4
                           00000004  0000       	RAB$V_UIF=4
                                     0000       	
                                     0000       $EQU	RAB$V_MAS	5
                           00000005  0000       	RAB$V_MAS=5
                                     0000       	
                                     0000       $EQU	RAB$V_FDL	6
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  33
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000006  0000       	RAB$V_FDL=6
                                     0000       	
                                     0000       $EQU	RAB$V_HSH	7
                           00000007  0000       	RAB$V_HSH=7
                                     0000       	
                                     0000       $EQU	RAB$V_EOF	8
                           00000008  0000       	RAB$V_EOF=8
                                     0000       	
                                     0000       $EQU	RAB$V_RAH	9
                           00000009  0000       	RAB$V_RAH=9
                                     0000       	
                                     0000       $EQU	RAB$V_WBH	10
                           0000000A  0000       	RAB$V_WBH=10
                                     0000       	
                                     0000       $EQU	RAB$V_BIO	11
                           0000000B  0000       	RAB$V_BIO=11
                                     0000       	
                                     0000       $EQU	RAB$V_CDK	12
                           0000000C  0000       	RAB$V_CDK=12
                                     0000       	
                                     0000       $EQU	RAB$V_LOA	13
                           0000000D  0000       	RAB$V_LOA=13
                                     0000       	
                                     0000       $EQU	RAB$V_LIM	14
                           0000000E  0000       	RAB$V_LIM=14
                                     0000       	
                                     0000       $EQU	RAB$V_SYNCSTS	15
                           0000000F  0000       	RAB$V_SYNCSTS=15
                                     0000       	
                                     0000       $EQU	RAB$V_LOC	16
                           00000010  0000       	RAB$V_LOC=16
                                     0000       	
                                     0000       $EQU	RAB$V_WAT	17
                           00000011  0000       	RAB$V_WAT=17
                                     0000       	
                                     0000       $EQU	RAB$V_ULK	18
                           00000012  0000       	RAB$V_ULK=18
                                     0000       	
                                     0000       $EQU	RAB$V_RLK	19
                           00000013  0000       	RAB$V_RLK=19
                                     0000       	
                                     0000       $EQU	RAB$V_NLK	20
                           00000014  0000       	RAB$V_NLK=20
                                     0000       	
                                     0000       $EQU	RAB$V_KGE	21
                           00000015  0000       	RAB$V_KGE=21
                                     0000       	
                                     0000       $EQU	RAB$V_KGT	22
                           00000016  0000       	RAB$V_KGT=22
                                     0000       	
                                     0000       $EQU	RAB$V_NXR	23
                           00000017  0000       	RAB$V_NXR=23
                                     0000       	
                                     0000       $EQU	RAB$V_RNE	24
                           00000018  0000       	RAB$V_RNE=24
                                     0000       	
                                     0000       $EQU	RAB$V_TMO	25
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  34
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000019  0000       	RAB$V_TMO=25
                                     0000       	
                                     0000       $EQU	RAB$V_CVT	26
                           0000001A  0000       	RAB$V_CVT=26
                                     0000       	
                                     0000       $EQU	RAB$V_RNF	27
                           0000001B  0000       	RAB$V_RNF=27
                                     0000       	
                                     0000       $EQU	RAB$V_ETO	28
                           0000001C  0000       	RAB$V_ETO=28
                                     0000       	
                                     0000       $EQU	RAB$V_PTA	29
                           0000001D  0000       	RAB$V_PTA=29
                                     0000       	
                                     0000       $EQU	RAB$V_PMT	30
                           0000001E  0000       	RAB$V_PMT=30
                                     0000       	
                                     0000       $EQU	RAB$V_CCO	31
                           0000001F  0000       	RAB$V_CCO=31
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_BITS1	4
                           00000004  0000       	RAB$R_ROP_BITS1=4
                                     0000       	
                                     0000       $EQU	RAB$V_EQNXT	21
                           00000015  0000       	RAB$V_EQNXT=21
                                     0000       	
                                     0000       $EQU	RAB$V_NXT	22
                           00000016  0000       	RAB$V_NXT=22
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_FIELDS	4
                           00000004  0000       	RAB$R_ROP_FIELDS=4
                                     0000       	
                                     0000       $EQU	RAB$B_ROP1	5
                           00000005  0000       	RAB$B_ROP1=5
                                     0000       	
                                     0000       $EQU	RAB$B_ROP2	6
                           00000006  0000       	RAB$B_ROP2=6
                                     0000       	
                                     0000       $EQU	RAB$B_ROP3	7
                           00000007  0000       	RAB$B_ROP3=7
                                     0000       	
                                     0000       $EQU	RAB$L_STS	8
                           00000008  0000       	RAB$L_STS=8
                                     0000       	
                                     0000       $EQU	RAB$R_STV_OVERLAY	12
                           0000000C  0000       	RAB$R_STV_OVERLAY=12
                                     0000       	
                                     0000       $EQU	RAB$L_STV	12
                           0000000C  0000       	RAB$L_STV=12
                                     0000       	
                                     0000       $EQU	RAB$R_STV_FIELDS	12
                           0000000C  0000       	RAB$R_STV_FIELDS=12
                                     0000       	
                                     0000       $EQU	RAB$W_STV0	12
                           0000000C  0000       	RAB$W_STV0=12
                                     0000       	
                                     0000       $EQU	RAB$W_STV2	14
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  35
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           0000000E  0000       	RAB$W_STV2=14
                                     0000       	
                                     0000       $EQU	RAB$R_RFA_OVERLAY	16
                           00000010  0000       	RAB$R_RFA_OVERLAY=16
                                     0000       	
                                     0000       $EQU	RAB$S_RFA	6
                           00000006  0000       	RAB$S_RFA=6
                                     0000       	
                                     0000       $EQU	RAB$W_RFA	16
                           00000010  0000       	RAB$W_RFA=16
                                     0000       	
                                     0000       $EQU	RAB$R_RFA_FIELDS	16
                           00000010  0000       	RAB$R_RFA_FIELDS=16
                                     0000       	
                                     0000       $EQU	RAB$L_RFA0	16
                           00000010  0000       	RAB$L_RFA0=16
                                     0000       	
                                     0000       $EQU	RAB$W_RFA4	20
                           00000014  0000       	RAB$W_RFA4=20
                                     0000       	
                                     0000       $EQU	RAB$L_CTX	24
                           00000018  0000       	RAB$L_CTX=24
                                     0000       	
                                     0000       $EQU	RAB$B_RAC	30
                           0000001E  0000       	RAB$B_RAC=30
                                     0000       	
                                     0000       $EQU	RAB$B_TMO	31
                           0000001F  0000       	RAB$B_TMO=31
                                     0000       	
                                     0000       $EQU	RAB$W_USZ	32
                           00000020  0000       	RAB$W_USZ=32
                                     0000       	
                                     0000       $EQU	RAB$W_RSZ	34
                           00000022  0000       	RAB$W_RSZ=34
                                     0000       	
                                     0000       $EQU	RAB$L_UBF	36
                           00000024  0000       	RAB$L_UBF=36
                                     0000       	
                                     0000       $EQU	RAB$L_RBF	40
                           00000028  0000       	RAB$L_RBF=40
                                     0000       	
                                     0000       $EQU	RAB$L_RHB	44
                           0000002C  0000       	RAB$L_RHB=44
                                     0000       	
                                     0000       $EQU	RAB$R_KBF_OVERLAY	48
                           00000030  0000       	RAB$R_KBF_OVERLAY=48
                                     0000       	
                                     0000       $EQU	RAB$L_KBF	48
                           00000030  0000       	RAB$L_KBF=48
                                     0000       	
                                     0000       $EQU	RAB$L_PBF	48
                           00000030  0000       	RAB$L_PBF=48
                                     0000       	
                                     0000       $EQU	RAB$R_KSZ_OVERLAY	52
                           00000034  0000       	RAB$R_KSZ_OVERLAY=52
                                     0000       	
                                     0000       $EQU	RAB$B_KSZ	52
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  36
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000034  0000       	RAB$B_KSZ=52
                                     0000       	
                                     0000       $EQU	RAB$B_PSZ	52
                           00000034  0000       	RAB$B_PSZ=52
                                     0000       	
                                     0000       $EQU	RAB$B_KRF	53
                           00000035  0000       	RAB$B_KRF=53
                                     0000       	
                                     0000       $EQU	RAB$B_MBF	54
                           00000036  0000       	RAB$B_MBF=54
                                     0000       	
                                     0000       $EQU	RAB$B_MBC	55
                           00000037  0000       	RAB$B_MBC=55
                                     0000       	
                                     0000       $EQU	RAB$R_BKT_OVERLAY	56
                           00000038  0000       	RAB$R_BKT_OVERLAY=56
                                     0000       	
                                     0000       $EQU	RAB$L_BKT	56
                           00000038  0000       	RAB$L_BKT=56
                                     0000       	
                                     0000       $EQU	RAB$L_DCT	56
                           00000038  0000       	RAB$L_DCT=56
                                     0000       	
                                     0000       $EQU	RAB$L_FAB	60
                           0000003C  0000       	RAB$L_FAB=60
                                     0000       	
                                     0000       $EQU	RAB$L_XAB	64
                           00000040  0000       	RAB$L_XAB=64
                                     0000       	
                                     0000       	$DEFEND	RAB,,DEF
                                     0000       	.MACRO	$RABDEF A
                                     0000       	.ENDM	$RABDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                 000019F8       	.RESTORE
                                     19F8       	
                                     19F8       	
                                     19F8       $$R_TABINIT		RAB$C_BID,RAB$C_BLN
                                     19F8       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           000019F8  19F8       $$.TAB=.
                                 01  19F8       	.BYTE RAB$C_BID
                                 44  19F9       	.BYTE RAB$C_BLN
                           00001A3C  19FA       	.BLKB RAB$C_BLN-2
                           00001A3C  1A3C       $$.TABEND=.
                                     1A3C       
                                     1A3C       	$$R_VBFSET RAB,<rah>
                           00000000  1A3C       $$.TMP=0
                                     1A3C       	.IRP X,<rah>
                                     1A3C       	.IF DF RAB$V_'X
                                     1A3C       		$$.TMP=$$.TMP!<1@RAB$V_'X>
                                     1A3C       	.IFF
                                     1A3C       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1A3C       	.ENDC
                                     1A3C       	.ENDR
                                     1A3C       	.IF DF RAB$V_rah
                           00000200  1A3C       		$$.TMP=$$.TMP!<1@RAB$V_rah>
                                     1A3C       	.IFF
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  37
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1A3C       		.ERROR		; UNDEFINED BIT VALUE CODE: rah;
                                     1A3C       	.ENDC
                                     1A3C       	
                                     1A3C       	
                           000019FC  1A3C       	.=$$.TAB+RAB$L_ROP
                           00000200' 19FC       	.ADDRESS	$$.TMP
                           00001A10  1A00       	.=$$.TAB+RAB$L_CTX
                           00000000' 1A10       	.ADDRESS	0
                           00001A16  1A14       	.=$$.TAB+RAB$B_RAC
                                     1A16       	.IF DF RAB$C_SEQ
                                 00  1A16       	.BYTE	RAB$C_SEQ
                                     1A17       	.IFF
                                     1A17       	.BYTE
                                     1A17       	.ERROR				; UNDEFINED VALUE FOR FIELD: CNST;
                                     1A17       	.ENDC
                                 00  1A17       	.BYTE	0
                               00A0  1A18       	.WORD	c_max_len
                               0000  1A1A       	.WORD	0
                           000018F7' 1A1C       	.ADDRESS	v_inbuf
                           00000000' 1A20       	.ADDRESS	0
                           00000000' 1A24       	.ADDRESS	0
                           00000000' 1A28       	.ADDRESS	0
                                     1A2C       	.IF NB <>
                                     1A2C       	.=$$.TAB+RAB$L_PBF
                                     1A2C       	.ADDRESS	
                                     1A2C       	.ENDC
                                 00  1A2C       	.BYTE	0
                                     1A2D       	.IF NB <>
                                     1A2D       	.=$$.TAB+RAB$B_PSZ
                                     1A2D       	.BYTE	
                                     1A2D       	.ENDC
                                 00  1A2D       	.BYTE	0
                                 00  1A2E       	.BYTE	0
                                 00  1A2F       	.BYTE	0
                           00000000' 1A30       	.ADDRESS	0
                           000019A8' 1A34       	.ADDRESS	v_infab
                           00000000' 1A38       	.ADDRESS	0
                           00001A3C  1A3C       	.=$$.TABEND
                                     1A3C       	
                                     1A3C   420 v_fnamelen:
                                 00  1A3C   421 	.byte	0		; length of file name for { load }
                                     1A3D   422 v_fname:
                           00001ADD  1A3D   423 	.blkb	c_max_len	; buffer for fil ename for {load}
                                     1ADD   424 
                                     1ADD   425 
                                     1ADD   426 ;
                                     1ADD   427 ; rms buffers for VTIL block i/o (which is actually rms record i/o)
                                     1ADD   428 ;
                                     1ADD   429 	.align long
                                     1AE0   430 v_blkfab:
                                     1AE0   431 	$fab	dnm=<vtilblocks.dat>,-	; default input file name
                                     1AE0   432 		fac=<get,upd>,-		; block i/o operations
                                     1AE0   433 		fnm=<vtilblocks>,-	; input file name
                                     1AE0   434 		mrs=c_block_size,-	; maximum record size
                                     1AE0   435 		rfm=<fix>		; fixed length records
                                     1AE0       	$FABDEF
                                     1AE0       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  38
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1AE0       	$$R_TABINIT	FAB$C_BID, FAB$C_BLN
                                     1AE0       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           00001AE0  1AE0       $$.TAB=.
                                 03  1AE0       	.BYTE FAB$C_BID
                                 50  1AE1       	.BYTE FAB$C_BLN
                           00001B30  1AE2       	.BLKB FAB$C_BLN-2
                           00001B30  1B30       $$.TABEND=.
                                     1B30       
                                     1B30       	$$R_VBFSET	FAB,<>
                           00000000  1B30       $$.TMP=0
                                     1B30       	.IRP X,<>
                                     1B30       	.IF DF FAB$V_'X
                                     1B30       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1B30       	.IFF
                                     1B30       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B30       	.ENDC
                                     1B30       	.ENDR
                                     1B30       	
                           00001AE4  1B30       	.=$$.TAB+FAB$L_FOP
                           00000000' 1AE4       	.ADDRESS	$$.TMP
                           00001AF0  1AE8       	.=$$.TAB+FAB$L_ALQ
                           00000000' 1AF0       	.ADDRESS	0
                               0000  1AF4       	.WORD	0
                                     1AF6       	$$R_VBFSET	FAB,<get,upd>
                           00000000  1AF6       $$.TMP=0
                                     1AF6       	.IRP X,<get,upd>
                                     1AF6       	.IF DF FAB$V_'X
                                     1AF6       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AF6       	.ENDC
                                     1AF6       	.ENDR
                                     1AF6       	.IF DF FAB$V_get
                           00000002  1AF6       		$$.TMP=$$.TMP!<1@FAB$V_get>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: get;
                                     1AF6       	.ENDC
                                     1AF6       	
                                     1AF6       	.IF DF FAB$V_upd
                           0000000A  1AF6       		$$.TMP=$$.TMP!<1@FAB$V_upd>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: upd;
                                     1AF6       	.ENDC
                                     1AF6       	
                                     1AF6       	
                                 0A  1AF6       	.BYTE	$$.TMP
                                     1AF7       	$$R_VBFSET	FAB,<>
                           00000000  1AF7       $$.TMP=0
                                     1AF7       	.IRP X,<>
                                     1AF7       	.IF DF FAB$V_'X
                                     1AF7       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AF7       	.IFF
                                     1AF7       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AF7       	.ENDC
                                     1AF7       	.ENDR
                                     1AF7       	
                                 00  1AF7       	.BYTE	$$.TMP
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  39
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000000' 1AF8       	.ADDRESS	0
                                 00  1AFC       	.BYTE	0
                                     1AFD       	.IF DF FAB$C_SEQ
                                 00  1AFD       	.BYTE	FAB$C_SEQ
                                     1AFE       	.IFF
                                     1AFE       	.BYTE
                                     1AFE       	.ERROR			; UNDEFINED VALUE FOR FIELD : SEQ;
                                     1AFE       	.ENDC
                                     1AFE       	$$R_VBFSET	FAB,<>
                           00000000  1AFE       $$.TMP=0
                                     1AFE       	.IRP X,<>
                                     1AFE       	.IF DF FAB$V_'X
                                     1AFE       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AFE       	.IFF
                                     1AFE       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AFE       	.ENDC
                                     1AFE       	.ENDR
                                     1AFE       	
                                 00  1AFE       	.BYTE	$$.TMP
                                     1AFF       	.IF DF FAB$C_fix
                                 01  1AFF       	.BYTE	FAB$C_fix
                                     1B00       	.IFF
                                     1B00       	.BYTE
                                     1B00       	.ERROR			; UNDEFINED VALUE FOR FIELD : fix;
                                     1B00       	.ENDC
                                     1B00       	$$R_VBFSET	FAB,<>
                           00000000  1B00       $$.TMP=0
                                     1B00       	.IRP X,<>
                                     1B00       	.IF DF FAB$V_'X
                                     1B00       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1B00       	.IFF
                                     1B00       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B00       	.ENDC
                                     1B00       	.ENDR
                                     1B00       	
                                 00  1B00       	.BYTE	$$.TMP
                                 00  1B01       	.BYTE	0
                               0000  1B02       	.WORD
                           00000000' 1B04       	.ADDRESS	0
                           00000000' 1B08       	.ADDRESS	0
                           00000000' 1B0C       	.ADDRESS	0
                           00000000' 1B10       	.ADDRESS	0
                                 00  1B14       	.BYTE	0
                                 00  1B15       	.BYTE	0
                               0400  1B16       	.WORD	c_block_size
                           00000000' 1B18       	.ADDRESS	0
                               0000  1B1C       	.WORD	0
                                 00  1B1E       	.BYTE	0
                                 00  1B1F       	.BYTE	0
                           00001B28  1B20       	.=$$.TAB+FAB$W_GBC
                               0000  1B28       	.WORD	0
                                 00  1B2A       	.BYTE	<<0@FAB$V_LNM_MODE> + <0@FAB$V_CHAN_MODE> + -
                                     1B2B       		<0@FAB$V_FILE_MODE>>
                                     1B2B       	.IIF NE 8-8, .ERROR	; INVALID BYTE SIZE
                                     1B2B       	.IF NB <vtilblocks>
                                     1B2B       	.SAVE
                                 00000000       	.PSECT $RMSNAM
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  40
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000000  0000       	$$.TMPX=.
      73 6B 63 6F 6C 62 6C 69 74 76  0000       	.ASCII %vtilblocks%
                           0000000A  000A       	$$.TMPX1=.-$$.TMPX
                                 00001B2B       	.RESTORE
                           00001B0C  1B2B       	.=$$.TAB+FAB$L_FNA
                           00000000' 1B0C       	.ADDRESS	$$.TMPX
                           00001B14  1B10       	.=$$.TAB+FAB$B_FNS
                                 0A  1B14       	.BYTE	$$.TMPX1
                                     1B15       	.ENDC
                                     1B15       	.IF NB <vtilblocks.dat>
                                     1B15       	.SAVE
                                 0000000A       	.PSECT $RMSNAM
                           0000000A  000A       	$$.TMPX=.
64 2E 73 6B 63 6F 6C 62 6C 69 74 76  000A       	.ASCII %vtilblocks.dat%
                              74 61  0016       
                           0000000E  0018       	$$.TMPX1=.-$$.TMPX
                                 00001B15       	.RESTORE
                           00001B10  1B15       	.=$$.TAB+FAB$L_DNA
                           0000000A' 1B10       	.ADDRESS	$$.TMPX
                           00001B15  1B14       	.=$$.TAB+FAB$B_DNS
                                 0E  1B15       	.BYTE	$$.TMPX1
                                     1B16       	.ENDC
                           00001B30  1B16       	.=$$.TABEND
                                     1B30       	
                                     1B30   436 v_blkrab:
                                     1B30   437 	$rab	fab=v_blkfab,-		; pointer to fab
                                     1B30   438 		kfb=v_blkkey,-		; pointer to key
                                     1B30   439 		ksz=c_keysize,-		; size of key
                                     1B30   440 		rac=<key>,-		; random access by record number
                                     1B30   441 		ubf=v_blkbuff,-		; address of user buffer
                                     1B30   442 		usz=c_block_size	; and the record size
                                     1B30       $RABDEF
                                     1B30       	
                                     1B30       $$R_TABINIT		RAB$C_BID,RAB$C_BLN
                                     1B30       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           00001B30  1B30       $$.TAB=.
                                 01  1B30       	.BYTE RAB$C_BID
                                 44  1B31       	.BYTE RAB$C_BLN
                           00001B74  1B32       	.BLKB RAB$C_BLN-2
                           00001B74  1B74       $$.TABEND=.
                                     1B74       
                                     1B74       	$$R_VBFSET RAB,<>
                           00000000  1B74       $$.TMP=0
                                     1B74       	.IRP X,<>
                                     1B74       	.IF DF RAB$V_'X
                                     1B74       		$$.TMP=$$.TMP!<1@RAB$V_'X>
                                     1B74       	.IFF
                                     1B74       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B74       	.ENDC
                                     1B74       	.ENDR
                                     1B74       	
                           00001B34  1B74       	.=$$.TAB+RAB$L_ROP
                           00000000' 1B34       	.ADDRESS	$$.TMP
                           00001B48  1B38       	.=$$.TAB+RAB$L_CTX
                           00000000' 1B48       	.ADDRESS	0
                           00001B4E  1B4C       	.=$$.TAB+RAB$B_RAC
                                     1B4E       	.IF DF RAB$C_key
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  41
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 01  1B4E       	.BYTE	RAB$C_key
                                     1B4F       	.IFF
                                     1B4F       	.BYTE
                                     1B4F       	.ERROR				; UNDEFINED VALUE FOR FIELD: CNST;
                                     1B4F       	.ENDC
                                 00  1B4F       	.BYTE	0
                               0400  1B50       	.WORD	c_block_size
                               0000  1B52       	.WORD	0
                           00004000' 1B54       	.ADDRESS	v_blkbuff
                           00000000' 1B58       	.ADDRESS	0
                           00000000' 1B5C       	.ADDRESS	0
                           00000000' 1B60       	.ADDRESS	0
                                     1B64       	.IF NB <>
                                     1B64       	.=$$.TAB+RAB$L_PBF
                                     1B64       	.ADDRESS	
                                     1B64       	.ENDC
                                 04  1B64       	.BYTE	c_keysize
                                     1B65       	.IF NB <>
                                     1B65       	.=$$.TAB+RAB$B_PSZ
                                     1B65       	.BYTE	
                                     1B65       	.ENDC
                                 00  1B65       	.BYTE	0
                                 00  1B66       	.BYTE	0
                                 00  1B67       	.BYTE	0
                           00000000' 1B68       	.ADDRESS	0
                           00001AE0' 1B6C       	.ADDRESS	v_blkfab
                           00000000' 1B70       	.ADDRESS	0
                           00001B74  1B74       	.=$$.TABEND
                                     1B74       	
                                     1B74   443 v_blkkey:
                           00000000  1B74   444 	.long				; buffer for key (longword pos rec #)
                                     1B78   445 v_blockio:
                                 00  1B78   446 	.byte	c_false			; true when block file is open
                                     1B79   447 v_current_buff:				; Buffer # of most recently accessed
                           00000000  1B79   448 	.long	0			; block
                                     1B7D   449 
                                     1B7D   450 v_buf_inuse:
                           00001B80  1B7D   451 	.blkb	c_max_blocks		; flags for inuse and modified
                                     1B80   452 v_buf_blk_nums:
                           00001B8C  1B80   453 	.blkl	c_max_blocks		; block numbers in buffers
                                     1B8C   454 
                                     1B8C   455 ;
                                     1B8C   456 ; Moved the Block i/o buffers away from the rest of the block i/o stuff
                                     1B8C   457 ; to the end of the dictionary because that is safer.  They are away from
                                     1B8C   458 ; other variables that might get overwritten if someone tries to write
                                     1B8C   459 ; too long a string to the buffers, for instance.
                                     1B8C   460 ;
                                     1B8C   461 
                                     1B8C   462 
                                     1B8C   463 ;
                                     1B8C   464 ; variables for terminal input
                                     1B8C   465 ;
                                     1B8C   466 v_readlen:
                               0000  1B8C   467 	.word			; length of returned input
                                     1B8E   468 v_readdsc:
                               00A0  1B8E   469 	.word	c_max_len	; maximum length
                                 00' 1B90   470 	.byte	dsc$k_dtype_t	; data type text
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  42
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 00' 1B91   471 	.byte	dsc$k_class_s	; descriptor class
                                     1B92   472 v_readaddr:
                           00000000  1B92   473 	.long	0		; pointer to the input buffer
                                     1B96   474 ; v_static_dsc is the middle of a descriptor so it can be copied onto ds
                                     1B96   475 ; to make full desciptor when top fo stack is ( addr count )
                                     1B96   476 v_static_dsc:
                                 00' 1B96   477 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1B97   478 	.byte	dsc$k_class_s	; descriptor class
                                     1B98   479 v_outlen:
                               0000  1B98   480 	.word	0		; length of output
                                     1B9A   481 v_outbuf:
                           00001C3A  1B9A   482 	.blkb	c_max_len	; output bufer
                                     1C3A   483 
                                     1C3A   484 
                                     1C3A   485 ;
                                     1C3A   486 ; Variables for calling the EVE editor using its callable interface.
                                     1C3A   487 ;
                                     1C3A   488 v_tpu_com:			; buffer for constant section of command
3D 6E 6F 69 74 63 65 73 2F 75 70 74  1C3A   489 	.ascii	\tpu/section=eve$dir:eve_edt \ ; use my version of eve
5F 65 76 65 3A 72 69 64 24 65 76 65  1C46       
                        20 74 64 65  1C52       
                           0000001C  1C56   490 c_tpu_com_len = . - v_tpu_com	; length of command is a constant
                                     1C56   491 v_tpu_com2:			; buffer for user section of command
                           00001CF6  1C56   492 	.blkb	c_max_len
                                     1CF6   493 v_tpu_dsc:
                               0000  1CF6   494 	.word	0		; descriptor for command to pass to tpu$tpu
                                 00' 1CF8   495 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1CF9   496 	.byte	dsc$k_class_s	; descriptor class
                           00001C3A' 1CFA   497 	.long	 v_tpu_com	; pointer to tpu command buffer
                                     1CFE   498 ;
                                     1CFE   499 ; Buffers for $ASSIGN, $DASSIGN, and $QIO
                                     1CFE   500 ;
                                     1CFE   501 v_input_name:
6F 63 24 73 79 73 00001D06'010E0000' 1CFE   502 	.ascid	/sys$command/
                     64 6E 61 6D 6D  1D0C       
                                     1D11   503 v_input_chan:
                           00001D13  1D11   504 	.blkw	1
                                     1D13   505 ;
                                     1D13   506 ; Buffers for $GETCHN_S
                                     1D13   507 ;
                                     1D13   508 v_getchn_ret_len:		; returned length of buffer info
                           00000000  1D13   509 	.long	0
                                     1D17   510 v_getchn_in_buf:		; input buffer for getchn, tells about output
                                     1D17   511 				; buffer
                           00000008  1D17   512 	.long	8		; length of output buffer
                                     1D1B   513 v_getchn_buf_adr:
                           00001D1F' 1D1B   514 	.long	v_getchn_buf	; address of output buffer
                                     1D1F   515 v_getchn_buf:			; output buffer
                  00000000 00000000  1D1F   516 	.quad	0		; cleared to begin
                                     1D27   517 
                                     1D27   518 ;
                                     1D27   519 ; System Variables
                                     1D27   520 ;
                                     1D27   521 v_trap_depth:		; depth to unwind stack in trap handler
                           00000001  1D27   522 	.long	1	; unwind to establisher, i.e, main body, 1 deep
                                     1D2B   523 v_ctrlc_depth:		; depth to unwind stack in control/c handler
                           00000002  1D2B   524 	.long	2	; unwind to main program, 2 deep (ctrlc and a_start)
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  43
V1.01                           Data Section                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1D2F   525 v_errors:
                           00000000  1D2F   526 	.long	0	; Number of errors caught by condition handler so far
                                     1D33   527 v_returnstack:		; original return stack pointer.  Save it when we
                           00000000  1D33   528 	.long	0	; abort out of jsb's we return from the right spot
                                     1D37   529 v_context:		; points to data field of the word for the vocabulary
                           00000000  1D37   530 	.long	0	; in which words are searched for.
                                     1D3B   531 v_current:		; points to data field of the word for the vocabulary
                           00000000  1D3B   532 	.long	0	; that new words are linked into.
                                     1D3F   533 v_compiler:		; Pointer to most recent word in compiler vocabulary
                           00000000  1D3F   534 	.long	0
                                     1D43   535 v_kernel:		; Pointer to most recnet word in kernel vocabulary
                           00000000  1D43   536 	.long	0	; data field of { kernel }
                                     1D47   537 v_infile:		; Flag.	 If true, reading from an input file.
                                 00  1D47   538 	.byte	c_false	; If false, reading from terminal.  Set by { load }
                                     1D48   539 v_filelinenum:		; number of lines read from input file
                           00000000  1D48   540 	.long	0	; used in error reporting
                                     1D4C   541 v_state:		; Flag.	 True if compiletime word found
                                 00  1D4C   542 	.byte	c_false ; in compile mode (then set to false by ?execute),
                                     1D4D   543 			; otherwise false.
                                     1D4D   544 v_mode:			; Flag.	 True if in compile mode, false if execute mode.
                                 00  1D4D   545 	.byte	c_false ; true => compile word, false => execute word
                                     1D4E   546 v_radix:
                           0000000A  1D4E   547 	.long	10	; base for number conversion on input and output
                                     1D52   548 v_hld:
                           00000000  1D52   549 	.long	0	; pointer to number output conversion buffer
                                     1D56   550 
                                     1D56   551 	newpage <Kernel Built-ins>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  44
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1D56       	.sbttl	Kernel Built-ins
                                     1D56       	
                                 00000000   552 	.psect	vtilcode,exe,nowrt
                                     0000   553 ;******************************************************************************
                                     0000   554 ;
                                     0000   555 ; Kernel Built-Ins -- Original vocabulary of words.  All other vocabularies
                                     0000   556 ;	link into this one, except the compiler (compiletime word) vocabulary.
                                     0000   557 ;
                                     0000   558 ;******************************************************************************
                                     0000   559 _kernel_begin:
                                     0000   560 
                                     0000   561 
                                     0000   562 ;+++t
                                     0000   563 ;k> ! (store) -- ( n a -- ) store longword `n?' at `a'.
                                     0000   564 ;---
                                     0000   565 	header	i_store,<!>
                           00000000  0000       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000000  0004       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  0004       	.nchr  nchr, ^\!\	; nchr = length( ! )
                           00000001  0004       	.if    le, nchr		; nchr <= 0
                                     0004       	   .ascic \i_store\	; no auxillary !, use principle one
                                     0004       	.if_false		; else
                              21 00' 0004       	  .ascic \!\		; use auxillary !
                                 01  0004       
                                     0006       	.endc			; end if
                                     0006       i_store:			; use ! of word as vl_kernel label
                                     0006       	
                 00 BB   04 AB   D0  0006   566 	movl	4(r11),@(r11)		; store item at what's pointed to by
                                     000B   567 					; top of stack
                       5B   08   C0  000B   568 	addl2	#8,r11			; pop arguments
                                 05  000E   569 	rsb				; end of !
                                     000F   570 
                                     000F   571 
                                     000F   572 ;+++
                                     000F   573 ;k> # -- ( n1 -- n2 ) generate next output character in number conversion.
                                     000F   574 ;	used between { <# } and { #> }.
                                     000F   575 ;---
                                     000F   576 	header	i_sharp,<#>
                           00000000' 000F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000000F  0013       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  0013       	.nchr  nchr, ^\#\	; nchr = length( # )
                           00000001  0013       	.if    le, nchr		; nchr <= 0
                                     0013       	   .ascic \i_sharp\	; no auxillary #, use principle one
                                     0013       	.if_false		; else
                              23 00' 0013       	  .ascic \#\		; use auxillary #
                                 01  0013       
                                     0015       	.endc			; end if
                                     0015       i_sharp:			; use # of word as vl_kernel label
                                     0015       	
              7B   00001D4E'EF   D0  0015   577 	movl	v_radix,-(r11)	; put radix on stack
                   000001CD'EF   16  001C   578 	jsb	i_div_mod	; get next digit
                   000012C1'EF   16  0022   579 	jsb	tochar		; make it appropriate ascii char
                   00000B13'EF   16  0028   580 	jsb	hold		; put in output string
                                 05  002E   581 	rsb			; end of #
                                     002F   582 
                                     002F   583 
                                     002F   584 ;+++
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  45
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     002F   585 ;k> #> -- ( n1 -- a n2 ) End numeric output.  Leaves length and address of
                                     002F   586 ;	numeric text on stack for { write }.
                                     002F   587 ;---
                                     002F   588 	header	i_sharp_greater,^\#>\
                           0000000F' 002F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000002F  0033       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0033       	.nchr  nchr, ^\#>\	; nchr = length( #> )
                           00000002  0033       	.if    le, nchr		; nchr <= 0
                                     0033       	   .ascic \i_sharp_greater\	; no auxillary #>, use principle one
                                     0033       	.if_false		; else
                           3E 23 00' 0033       	  .ascic \#>\		; use auxillary #>
                                 02  0033       
                                     0036       	.endc			; end if
                                     0036       i_sharp_greater:			; use #> of word as vl_kernel label
                                     0036       	
              6B   00001D52'EF   D0  0036   589 	movl	v_hld,(r11)		; drop number, put address of output
                                     003D   590 					; on stack
         50   00000109 8F   59   C1  003D   591 	addl3	r9,#c_pad_moat,r0	; get address of pad
         7B   50   00001D52'EF   C3  0045   592 	subl3	v_hld,r0,-(r11)		; put count on stack
                                     004D   593 					; count = pad - hld
                                 05  004D   594 	rsb				; end of #>
                                     004E   595 
                                     004E   596 
                                     004E   597 ;+++
                                     004E   598 ;k> #s -- ( n1 -- n2 ) Convert all all digits of n1 to output string.  Leaves 0.
                                     004E   599 ;	Used between { <# } and { #> }.
                                     004E   600 ;---
                                     004E   601 	header	i_sharp_s,<#s>
                           0000002F' 004E       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000004E  0052       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0052       	.nchr  nchr, ^\#s\	; nchr = length( #s )
                           00000002  0052       	.if    le, nchr		; nchr <= 0
                                     0052       	   .ascic \i_sharp_s\	; no auxillary #s, use principle one
                                     0052       	.if_false		; else
                           73 23 00' 0052       	  .ascic \#s\		; use auxillary #s
                                 02  0052       
                                     0055       	.endc			; end if
                                     0055       i_sharp_s:			; use #s of word as vl_kernel label
                                     0055       	
                         BD AF   16  0055   602 	jsb	i_sharp			; output at least one character
                            6B   D5  0058   603 	tstl	(r11)			; is top not = 0?
                            F9   12  005A   604 	bneq	i_sharp_s		; yes, do it again
                                 05  005C   605 	rsb				; no, exit
                                     005D   606 					; end of #s
                                     005D   607 
                                     005D   608 
                                     005D   609 ;+++
                                     005D   610 ;k> (# -- ( -- ) Start count of items on the stack.  Used with { #) }.
                                     005D   611 ;	Uses the loop stack!
                                     005D   612 ;---
                                     005D   613 	header	i_count_begin,<(#>
                           0000004E' 005D       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000005D  0061       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0061       	.nchr  nchr, ^\(#\	; nchr = length( (# )
                           00000002  0061       	.if    le, nchr		; nchr <= 0
                                     0061       	   .ascic \i_count_begin\	; no auxillary (#, use principle one
                                     0061       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  46
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           23 28 00' 0061       	  .ascic \(#\		; use auxillary (#
                                 02  0061       
                                     0064       	.endc			; end if
                                     0064       i_count_begin:			; use (# of word as vl_kernel label
                                     0064       	
                       7A   5B   D0  0064   614 	movl	r11,-(r10)		; save address of top of stack
                                 05  0067   615 	rsb				; end of (#
                                     0068   616 
                                     0068   617 
                                     0068   618 ;+++
                                     0068   619 ;k> (and) -- ( n1 n2 -- n3 ) bitwise and of n1 and n2.
                                     0068   620 ;---
                                     0068   621 	header	i_bit_and,<(and)>
                           0000005D' 0068       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000068  006C       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  006C       	.nchr  nchr, ^\(and)\	; nchr = length( (and) )
                           00000005  006C       	.if    le, nchr		; nchr <= 0
                                     006C       	   .ascic \i_bit_and\	; no auxillary (and), use principle one
                                     006C       	.if_false		; else
                  29 64 6E 61 28 00' 006C       	  .ascic \(and)\		; use auxillary (and)
                                 05  006C       
                                     0072       	.endc			; end if
                                     0072       i_bit_and:			; use (and) of word as vl_kernel label
                                     0072       	
                       6B   6B   D2  0072   622 	mcoml	(r11),(r11)		; make ones comp because blc ones
                                     0075   623 					; comps mask
                       6B   8B   CA  0075   624 	bicl2	(r11)+,(r11)		; and it
                                 05  0078   625 	rsb				; end of (and)
                                     0079   626 
                                     0079   627 
                                     0079   628 ;+++
                                     0079   629 ;k> (not) -- ( n1 n2 -- n3 ) bitwise not of n1 and n2.
                                     0079   630 ;---
                                     0079   631 	header	i_bit_not,<(not)>
                           00000068' 0079       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000079  007D       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  007D       	.nchr  nchr, ^\(not)\	; nchr = length( (not) )
                           00000005  007D       	.if    le, nchr		; nchr <= 0
                                     007D       	   .ascic \i_bit_not\	; no auxillary (not), use principle one
                                     007D       	.if_false		; else
                  29 74 6F 6E 28 00' 007D       	  .ascic \(not)\		; use auxillary (not)
                                 05  007D       
                                     0083       	.endc			; end if
                                     0083       i_bit_not:			; use (not) of word as vl_kernel label
                                     0083       	
                       6B   6B   D2  0083   632 	mcoml	(r11),(r11)		; not it
                                 05  0086   633 	rsb				; end of (not)
                                     0087   634 
                                     0087   635 
                                     0087   636 ;+++
                                     0087   637 ;k> (or) -- ( n1 n2 -- n3 ) bitwise or of n1 and n2.
                                     0087   638 ;---
                                     0087   639 	header	i_bit_or,<(or)>
                           00000079' 0087       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000087  008B       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  008B       	.nchr  nchr, ^\(or)\	; nchr = length( (or) )
                           00000004  008B       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  47
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     008B       	   .ascic \i_bit_or\	; no auxillary (or), use principle one
                                     008B       	.if_false		; else
                     29 72 6F 28 00' 008B       	  .ascic \(or)\		; use auxillary (or)
                                 04  008B       
                                     0090       	.endc			; end if
                                     0090       i_bit_or:			; use (or) of word as vl_kernel label
                                     0090       	
                       6B   8B   C8  0090   640 	bisl2	(r11)+,(r11)		; or it
                                 05  0093   641 	rsb				; end of (or)
                                     0094   642 
                                     0094   643 
                                     0094   644 ;+++
                                     0094   645 ;k> (xor) -- ( n1 n2 -- n3) bitwise xor of n1 and n2.
                                     0094   646 ;---
                                     0094   647 	header	i_bit_xor,<(xor)>
                           00000087' 0094       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000094  0098       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  0098       	.nchr  nchr, ^\(xor)\	; nchr = length( (xor) )
                           00000005  0098       	.if    le, nchr		; nchr <= 0
                                     0098       	   .ascic \i_bit_xor\	; no auxillary (xor), use principle one
                                     0098       	.if_false		; else
                  29 72 6F 78 28 00' 0098       	  .ascic \(xor)\		; use auxillary (xor)
                                 05  0098       
                                     009E       	.endc			; end if
                                     009E       i_bit_xor:			; use (xor) of word as vl_kernel label
                                     009E       	
                       6B   8B   CC  009E   648 	xorl2	(r11)+,(r11)		; xor it
                                 05  00A1   649 	rsb				; end of (xor)
                                     00A2   650 
                                     00A2   651 
                                     00A2   652 ;+++t
                                     00A2   653 ;k> * -- ( n1 n2 -- n3) multiply top two stack items, leave result on stack.
                                     00A2   654 ;---
                                     00A2   655 	header	i_multiply,<*>
                           00000094' 00A2       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000A2  00A6       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  00A6       	.nchr  nchr, ^\*\	; nchr = length( * )
                           00000001  00A6       	.if    le, nchr		; nchr <= 0
                                     00A6       	   .ascic \i_multiply\	; no auxillary *, use principle one
                                     00A6       	.if_false		; else
                              2A 00' 00A6       	  .ascic \*\		; use auxillary *
                                 01  00A6       
                                     00A8       	.endc			; end if
                                     00A8       i_multiply:			; use * of word as vl_kernel label
                                     00A8       	
                       6B   8B   C4  00A8   656 	mull2	(r11)+,(r11)		; multiply them
                                 05  00AB   657 	rsb				; end of *
                                     00AC   658 
                                     00AC   659 
                                     00AC   660 ;+++
                                     00AC   661 ;k> #) -- ( -- n ) Return number of items on stack since last { (# }.
                                     00AC   662 ;	uses the loop stack!
                                     00AC   663 ;---
                                     00AC   664 	header	i_count_end,<#)>
                           000000A2' 00AC       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000AC  00B0       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  00B0       	.nchr  nchr, ^\#)\	; nchr = length( #) )
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  48
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000002  00B0       	.if    le, nchr		; nchr <= 0
                                     00B0       	   .ascic \i_count_end\	; no auxillary #), use principle one
                                     00B0       	.if_false		; else
                           29 23 00' 00B0       	  .ascic \#)\		; use auxillary #)
                                 02  00B0       
                                     00B3       	.endc			; end if
                                     00B3       i_count_end:			; use #) of word as vl_kernel label
                                     00B3       	
                  7B   8A   5B   C3  00B3   665 	subl3	r11,(r10)+,-(r11)	; number of bytes difference in
                                     00B7   666 					; top of stack then and now.
                       6B   04   C6  00B7   667 	divl2	#4,(r11)		; divide to get number of stack
                                     00BA   668 					; items (longwords)
                                 05  00BA   669 	rsb				; end of #)
                                     00BB   670 
                                     00BB   671 
                                     00BB   672 ;+++t
                                     00BB   673 ;k> + -- ( n1 n2 -- n3 ) add the top two stack items, leave result on stack.~~~ Why i_add and not i_plus???
                                     00BB   674 ;---
                                     00BB   675 	header	i_add,<+>
                           000000AC' 00BB       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000BB  00BF       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  00BF       	.nchr  nchr, ^\+\	; nchr = length( + )
                           00000001  00BF       	.if    le, nchr		; nchr <= 0
                                     00BF       	   .ascic \i_add\	; no auxillary +, use principle one
                                     00BF       	.if_false		; else
                              2B 00' 00BF       	  .ascic \+\		; use auxillary +
                                 01  00BF       
                                     00C1       	.endc			; end if
                                     00C1       i_add:			; use + of word as vl_kernel label
                                     00C1       	
                       6B   8B   C0  00C1   676 	addl2	(r11)+,(r11)		; add them and leave the result on stack
                                 05  00C4   677 	rsb				; end of +
                                     00C5   678 
                                     00C5   679 
                                     00C5   680 ;+++
                                     00C5   681 ;k> +! -- ( n a -- ) Adds `n' to contents of `a'.
                                     00C5   682 ;---
                                     00C5   683 	header	i_plus_store,<+!>
                           000000BB' 00C5       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000C5  00C9       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  00C9       	.nchr  nchr, ^\+!\	; nchr = length( +! )
                           00000002  00C9       	.if    le, nchr		; nchr <= 0
                                     00C9       	   .ascic \i_plus_store\	; no auxillary +!, use principle one
                                     00C9       	.if_false		; else
                           21 2B 00' 00C9       	  .ascic \+!\		; use auxillary +!
                                 02  00C9       
                                     00CC       	.endc			; end if
                                     00CC       i_plus_store:			; use +! of word as vl_kernel label
                                     00CC       	
                                     00CC   684 ; Add top of stack to cents of address that is top of stack.
                 00 BB   04 AB   C0  00CC   685 	addl2	   4(r11),@(r11)	;
                       5B   08   C0  00D1   686 	addl2	   #8,r11		; pop arguments
                                 05  00D4   687 	rsb				; end of +!
                                     00D5   688 
                                     00D5   689 
                                     00D5   690 ;+++
                                     00D5   691 ;k> +rot - (n1 n2 n3 -- n3 n1 n2 ) rotate top 3 items on the stack up,
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  49
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     00D5   692 ;	bringing the second to the top.
                                     00D5   693 ;---
                                     00D5   694 	header	i_plus_rot,<+rot>
                           000000C5' 00D5       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000D5  00D9       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  00D9       	.nchr  nchr, ^\+rot\	; nchr = length( +rot )
                           00000004  00D9       	.if    le, nchr		; nchr <= 0
                                     00D9       	   .ascic \i_plus_rot\	; no auxillary +rot, use principle one
                                     00D9       	.if_false		; else
                     74 6F 72 2B 00' 00D9       	  .ascic \+rot\		; use auxillary +rot
                                 04  00D9       
                                     00DE       	.endc			; end if
                                     00DE       i_plus_rot:			; use +rot of word as vl_kernel label
                                     00DE       	
                       50   6B   D0  00DE   695 	movl	(r11),r0		; t1 = n3
                    6B   04 AB   D0  00E1   696 	movl	4(r11),(r11)		; n3 = n2
                 04 AB   08 AB   D0  00E5   697 	movl	8(r11),4(r11)		; n2 = n1
                    08 AB   50   D0  00EA   698 	movl	r0,8(r11)		; n1 = t1 (old n3)
                                 05  00EE   699 	rsb				; end of +rot
                                     00EF   700 
                                     00EF   701 
                                     00EF   702 ;+++
                                     00EF   703 ;k> , -- ( n -- ) Compile a longword `n' into the dictionary.
                                     00EF   704 ;---
                                     00EF   705 	header	i_comma,<,>
                           000000D5' 00EF       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000EF  00F3       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  00F3       	.nchr  nchr, ^\,\	; nchr = length( , )
                           00000001  00F3       	.if    le, nchr		; nchr <= 0
                                     00F3       	   .ascic \i_comma\	; no auxillary ,, use principle one
                                     00F3       	.if_false		; else
                              2C 00' 00F3       	  .ascic \,\		; use auxillary ,
                                 01  00F3       
                                     00F5       	.endc			; end if
                                     00F5       i_comma:			; use , of word as vl_kernel label
                                     00F5       	
                       89   8B   D0  00F5   706 	movl	(r11)+,(r9)+		; store longword in dictionary
                                 05  00F8   707 	rsb				; end of ,
                                     00F9   708 
                                     00F9   709 
                                     00F9   710 ;+++t
                                     00F9   711 ;k> - -- ( n1 n2 -- n3 ) subtract the top stack item from the next stack item.
                                     00F9   712 ;---
                                     00F9   713 	header	i_subtract,<->
                           000000EF' 00F9       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000000F9  00FD       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  00FD       	.nchr  nchr, ^\-\	; nchr = length( - )
                           00000001  00FD       	.if    le, nchr		; nchr <= 0
                                     00FD       	   .ascic \i_subtract\	; no auxillary -, use principle one
                                     00FD       	.if_false		; else
                              2D 00' 00FD       	  .ascic \-\		; use auxillary -
                                 01  00FD       
                                     00FF       	.endc			; end if
                                     00FF       i_subtract:			; use - of word as vl_kernel label
                                     00FF       	
                       6B   8B   C2  00FF   714 	subl2	(r11)+,(r11)		; subract and leave result on stack.
                                 05  0102   715 	rsb				; end of -
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  50
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0103   716 
                                     0103   717 
                                     0103   718 ;+++
                                     0103   719 ;k> -rot -- ( n1 n2 n3 -- n2 n3 n1 ) rotate top 3 items on the stack down,
                                     0103   720 ;	bringing the third to the top.
                                     0103   721 ;---
                                     0103   722 	header	i_minus_rot,<-rot>
                           000000F9' 0103       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000103  0107       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  0107       	.nchr  nchr, ^\-rot\	; nchr = length( -rot )
                           00000004  0107       	.if    le, nchr		; nchr <= 0
                                     0107       	   .ascic \i_minus_rot\	; no auxillary -rot, use principle one
                                     0107       	.if_false		; else
                     74 6F 72 2D 00' 0107       	  .ascic \-rot\		; use auxillary -rot
                                 04  0107       
                                     010C       	.endc			; end if
                                     010C       i_minus_rot:			; use -rot of word as vl_kernel label
                                     010C       	
                    50   08 AB   D0  010C   723 	movl	8(r11),r0		; t1 = n1
                 08 AB   04 AB   D0  0110   724 	movl	4(r11),8(r11)		; n1 = n2
                    04 AB   6B   D0  0115   725 	movl	(r11),4(r11)		; n2 = n3
                       6B   50   D0  0119   726 	movl	r0,(r11)		; n3 = n1
                                 05  011C   727 	rsb				; end of -rot
                                     011D   728 
                                     011D   729 
                                     011D   730 ;+++
                                     011D   731 ;k> . -- ( n -- ) output the top of the stack as a signed number and pop it.
                                     011D   732 ;---
                                     011D   733 	header	i_dot,<.>
                           00000103' 011D       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000011D  0121       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  0121       	.nchr  nchr, ^\.\	; nchr = length( . )
                           00000001  0121       	.if    le, nchr		; nchr <= 0
                                     0121       	   .ascic \i_dot\	; no auxillary ., use principle one
                                     0121       	.if_false		; else
                              2E 00' 0121       	  .ascic \.\		; use auxillary .
                                 01  0121       
                                     0123       	.endc			; end if
                                     0123       i_dot:			; use . of word as vl_kernel label
                                     0123       	
                       7A   6B   D0  0123   734 	movl	(r11),-(r10)		; dup ds>ls
                   000003AE'EF   16  0126   735 	jsb	abs			; abs
                   00000239'EF   16  012C   736 	jsb	i_less_sharp		; <#
                       FF1F CF   16  0132   737 	jsb	i_sharp_s		; #s
                       7B   8A   D0  0136   738 	movl	(r10)+,-(r11)		; ls>ds
                   00000FE3'EF   16  0139   739 	jsb	sign			; sign
                       FEF3 CF   16  013F   740 	jsb	i_sharp_greater		; #>
                   00001450'EF   16  0143   741 	jsb	write			; output it
                       7B   20   D0  0149   742 	movl	#c_blank,-(r11)		; put space on stack
                   00000DEE'EF   16  014C   743 	jsb	putc			; output it
                                 05  0152   744 	rsb				; end of .
                                     0153   745 
                                     0153   746 
                                     0153   747 ;+++
                                     0153   748 ;k> .( -- ( -- ) write the text following until the next `)' to the screen.
                                     0153   749 ;	This word should only be used *OUTSIDE* a definition (i.e.,
                                     0153   750 ;	in execute mode).
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  51
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0153   751 ;---
                                     0153   752 	header	i_dot_lparen,<.(>
                           0000011D' 0153       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000153  0157       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0157       	.nchr  nchr, ^\.(\	; nchr = length( .( )
                           00000002  0157       	.if    le, nchr		; nchr <= 0
                                     0157       	   .ascic \i_dot_lparen\	; no auxillary .(, use principle one
                                     0157       	.if_false		; else
                           28 2E 00' 0157       	  .ascic \.(\		; use auxillary .(
                                 02  0157       
                                     015A       	.endc			; end if
                                     015A       i_dot_lparen:			; use .( of word as vl_kernel label
                                     015A       	
                       7B   29   D0  015A   753 	movl	#^a\)\,-(r11)		; set up for `)' delimited token.
                   000012E2'EF   16  015D   754 	jsb	token			; get the token
                  7B   59   01   C1  0163   755 	addl3	#1,r9,-(r11)		; address of string
                       7B   69   9A  0167   756 	movzbl	(r9),-(r11)		; get count of string on stack
                   00001450'EF   16  016A   757 	jsb	write			; put it on the screen
                                 05  0170   758 	rsb				; end of .(
                                     0171   759 
                                     0171   760 
                                     0171   761 ;---
                                     0171   762 ;k> .sb -- ( -- ) output the stack from the bottom up without consuming it.
                                     0171   763 ;	The last item printed is the top of the stack.
                                     0171   764 ;---
                                     0171   765 	header	i_dot_sb,<.sb>
                           00000153' 0171       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000171  0175       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  0175       	.nchr  nchr, ^\.sb\	; nchr = length( .sb )
                           00000003  0175       	.if    le, nchr		; nchr <= 0
                                     0175       	   .ascic \i_dot_sb\	; no auxillary .sb, use principle one
                                     0175       	.if_false		; else
                        62 73 2E 00' 0175       	  .ascic \.sb\		; use auxillary .sb
                                 03  0175       
                                     0179       	.endc			; end if
                                     0179       i_dot_sb:			; use .sb of word as vl_kernel label
                                     0179       	
              7A   00001000'8F   D0  0179   766 	movl	#c_ds_start,-(r10)	; save end of stack.
                                     0180   767 10$:
                       6A   5B   D1  0180   768 	cmpl	r11,(r10)		; at top of stack yet?
                            0C   18  0183   769 	bgeq	100$			; yes, leave
                       6A   04   C2  0185   770 	subl2	#4,(r10)		; move to item
                    7B   00 BA   D0  0188   771 	movl	@(r10),-(r11)		; put item on top of stack
                         94 AF   16  018C   772 	jsb	i_dot			; print it
                            EF   11  018F   773 	brb	10$			; do it again
                                     0191   774 100$:
                       5A   04   C0  0191   775 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  0194   776 	rsb				; end of .sb
                                     0195   777 
                                     0195   778 
                                     0195   779 ;+++
                                     0195   780 ;k> .st -- ( -- ) output stack from the top down without consuming it.
                                     0195   781 ;	The last item printed is the bottom of the stack.
                                     0195   782 ;---
                                     0195   783 	header	i_dot_st,<.st>
                           00000171' 0195       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000195  0199       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  52
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000003  0199       	.nchr  nchr, ^\.st\	; nchr = length( .st )
                           00000003  0199       	.if    le, nchr		; nchr <= 0
                                     0199       	   .ascic \i_dot_st\	; no auxillary .st, use principle one
                                     0199       	.if_false		; else
                        74 73 2E 00' 0199       	  .ascic \.st\		; use auxillary .st
                                 03  0199       
                                     019D       	.endc			; end if
                                     019D       i_dot_st:			; use .st of word as vl_kernel label
                                     019D       	
                       7A   5B   D0  019D   784 	movl	r11,-(r10)		; save sp on top of loop stack
                                     01A0   785 10$:
              00001000'8F   6A   D1  01A0   786 	cmpl	(r10),#c_ds_start	; Is stack empty?
                            0D   18  01A7   787 	bgeq	20$			; yes
                    7B   00 BA   D0  01A9   788 	movl	@(r10),-(r11)		; put item on top
                       FF72 CF   16  01AD   789 	jsb	i_dot			; print it
                       6A   04   C0  01B1   790 	addl2	#4,(r10)		; move down stack
                            EA   11  01B4   791 	brb	10$			; do it again
                                     01B6   792 20$:
                       5A   04   C0  01B6   793 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  01B9   794 	rsb				; end of .st
                                     01BA   795 
                                     01BA   796 
                                     01BA   797 ;+++t
                                     01BA   798 ;k> / -- ( n1 n2 -- n3 ) divides second stack item by top stack item, leaves
                                     01BA   799 ;	result on stack.  n3 = n1 / n2.
                                     01BA   800 ;---
                                     01BA   801 	header	i_divide,</>
                           00000195' 01BA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000001BA  01BE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  01BE       	.nchr  nchr, ^\/\	; nchr = length( / )
                           00000001  01BE       	.if    le, nchr		; nchr <= 0
                                     01BE       	   .ascic \i_divide\	; no auxillary /, use principle one
                                     01BE       	.if_false		; else
                              2F 00' 01BE       	  .ascic \/\		; use auxillary /
                                 01  01BE       
                                     01C0       	.endc			; end if
                                     01C0       i_divide:			; use / of word as vl_kernel label
                                     01C0       	
                       6B   8B   C6  01C0   802 	divl2	(r11)+,(r11)
                                 05  01C3   803 	rsb				; end of /
                                     01C4   804 
                                     01C4   805 
                                     01C4   806 ;+++
                                     01C4   807 ;k> /mod -- ( n1 n2 -- n3 n4 ) divides second stack item by top stack item,
                                     01C4   808 ;	leaves ( quotient remainder ) on the stack.  n3 = n1 / n2, n4 = n1 - (n3 * n2).
                                     01C4   809 ;---
                                     01C4   810 	header	i_div_mod,</mod>
                           000001BA' 01C4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000001C4  01C8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  01C8       	.nchr  nchr, ^\/mod\	; nchr = length( /mod )
                           00000004  01C8       	.if    le, nchr		; nchr <= 0
                                     01C8       	   .ascic \i_div_mod\	; no auxillary /mod, use principle one
                                     01C8       	.if_false		; else
                     64 6F 6D 2F 00' 01C8       	  .ascic \/mod\		; use auxillary /mod
                                 04  01C8       
                                     01CD       	.endc			; end if
                                     01CD       i_div_mod:			; use /mod of word as vl_kernel label
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  53
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     01CD       	
               50   04 AB   6B   C7  01CD   811 	divl3	(r11),4(r11),r0		; r0 = n1 / n2 = n3
                  51   8B   50   C5  01D2   812 	mull3	r0,(r11)+,r1		; tmp = n2 * n3
                  51   8B   51   C3  01D6   813 	subl3	r1,(r11)+,r1		; r1 = n1 - (n2 * n3) = n4
                       7B   50   D0  01DA   814 	movl	r0,-(r11)		; push n3, quotient
                       7B   51   D0  01DD   815 	movl	r1,-(r11)		; push n4, remainder
                                 05  01E0   816 	rsb				; end of /mod
                                     01E1   817 
                                     01E1   818 
                                     01E1   819 ;+++
                                     01E1   820 ;k> 1+ -- ( n -- n+1 ) Add one to the top of the stack.
                                     01E1   821 ;---
                                     01E1   822 	header	i_one_plus,<1+>
                           000001C4' 01E1       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000001E1  01E5       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  01E5       	.nchr  nchr, ^\1+\	; nchr = length( 1+ )
                           00000002  01E5       	.if    le, nchr		; nchr <= 0
                                     01E5       	   .ascic \i_one_plus\	; no auxillary 1+, use principle one
                                     01E5       	.if_false		; else
                           2B 31 00' 01E5       	  .ascic \1+\		; use auxillary 1+
                                 02  01E5       
                                     01E8       	.endc			; end if
                                     01E8       i_one_plus:			; use 1+ of word as vl_kernel label
                                     01E8       	
                            6B   D6  01E8   823 	incl	(r11)			; dd one to the top of the stack.
                                 05  01EA   824 	rsb				; end of 1+
                                     01EB   825 
                                     01EB   826 
                                     01EB   827 ;+++
                                     01EB   828 ;k> 1- -- ( n -- n-1 ) Subtract one from the top of the stack.
                                     01EB   829 ;---
                                     01EB   830 	header	i_one_minus,<1->
                           000001E1' 01EB       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000001EB  01EF       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  01EF       	.nchr  nchr, ^\1-\	; nchr = length( 1- )
                           00000002  01EF       	.if    le, nchr		; nchr <= 0
                                     01EF       	   .ascic \i_one_minus\	; no auxillary 1-, use principle one
                                     01EF       	.if_false		; else
                           2D 31 00' 01EF       	  .ascic \1-\		; use auxillary 1-
                                 02  01EF       
                                     01F2       	.endc			; end if
                                     01F2       i_one_minus:			; use 1- of word as vl_kernel label
                                     01F2       	
                            6B   D7  01F2   831 	decl	(r11)			; subtract one from top of stack
                                 05  01F4   832 	rsb				; end of 1-
                                     01F5   833 
                                     01F5   834 
                                     01F5   835 ;+++
                                     01F5   836 ;k> : -- ( -- ) (colon) defining word that starts a word definition.
                                     01F5   837 ;	sets { mode } to true
                                     01F5   838 ;	Note that { : } is a compiling word an so is in compiler vocab.
                                     01F5   839 ;---
                                     01F5   840 	header	i_colon,<:>
                           000001EB' 01F5       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000001F5  01F9       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  01F9       	.nchr  nchr, ^\:\	; nchr = length( : )
                           00000001  01F9       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  54
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     01F9       	   .ascic \i_colon\	; no auxillary :, use principle one
                                     01F9       	.if_false		; else
                              3A 00' 01F9       	  .ascic \:\		; use auxillary :
                                 01  01F9       
                                     01FB       	.endc			; end if
                                     01FB       i_colon:			; use : of word as vl_kernel label
                                     01FB       	
     00001D37'EF   00001D3B'EF   D0  01FB   841 	movl	v_current,v_context	; search same vocab we are defining into
                   00000842'EF   16  0206   842 	jsb	create			; create header for new word
                                     020C   843 ;??? Should I now set the high bit in the length byte (To prevent word from
                                     020C   844 ; being found during its own definition)?
                   00000FFA'EF   16  020C   845 	jsb	smudge			; set smudge bit so word isn't found
           00001D4D'EF   FF 8F   90  0212   846 	movb	#c_true,v_mode		; set compiler v_mode
                                 05  021A   847 	rsb				; end of :
                                     021B   848 
                                     021B   849 
                                     021B   850 ;+++t
                                     021B   851 ;k> < -- ( n1 n2 -- f ) true if n1 < n2, false otherwise.
                                     021B   852 ;---
                                     021B   853 	header	i_less,^\<\
                           000001F5' 021B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000021B  021F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  021F       	.nchr  nchr, ^\<\	; nchr = length( < )
                           00000001  021F       	.if    le, nchr		; nchr <= 0
                                     021F       	   .ascic \i_less\	; no auxillary <, use principle one
                                     021F       	.if_false		; else
                              3C 00' 021F       	  .ascic \<\		; use auxillary <
                                 01  021F       
                                     0221       	.endc			; end if
                                     0221       i_less:			; use < of word as vl_kernel label
                                     0221       	
                       8B   8B   D1  0221   854 	cmpl	(r11)+,(r11)+		; reverse order, so n2 > n1
                            04   14  0224   855 	bgtr	10$			; yes
                       7B   00   D0  0226   856 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0229   857 	rsb				; return
                                     022A   858 10$:
              7B   FFFFFFFF 8F   D0  022A   859 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0231   860 	rsb				; end of <
                                     0232   861 
                                     0232   862 
                                     0232   863 ;+++
                                     0232   864 ;k> <# -- ( -- ) start numeric output conversion.
                                     0232   865 ;---
                                     0232   866 	header	i_less_sharp,^\<#\
                           0000021B' 0232       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000232  0236       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0236       	.nchr  nchr, ^\<#\	; nchr = length( <# )
                           00000002  0236       	.if    le, nchr		; nchr <= 0
                                     0236       	   .ascic \i_less_sharp\	; no auxillary <#, use principle one
                                     0236       	.if_false		; else
                           23 3C 00' 0236       	  .ascic \<#\		; use auxillary <#
                                 02  0236       
                                     0239       	.endc			; end if
                                     0239       i_less_sharp:			; use <# of word as vl_kernel label
                                     0239       	
00001D52'EF   00000109 8F   59   C1  0239   867 	addl3	r9,#c_pad_moat,v_hld	; pad hld !
                                 05  0245   868 	rsb				; end of <#
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  55
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0246   869 
                                     0246   870 
                                     0246   871 ;+++t
                                     0246   872 ;k> <= -- ( n1 n2 -- f ) true if n1 <= n2, false otherwise.
                                     0246   873 ;---
                                     0246   874 	header	i_less_equal,^\<=\
                           00000232' 0246       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000246  024A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  024A       	.nchr  nchr, ^\<=\	; nchr = length( <= )
                           00000002  024A       	.if    le, nchr		; nchr <= 0
                                     024A       	   .ascic \i_less_equal\	; no auxillary <=, use principle one
                                     024A       	.if_false		; else
                           3D 3C 00' 024A       	  .ascic \<=\		; use auxillary <=
                                 02  024A       
                                     024D       	.endc			; end if
                                     024D       i_less_equal:			; use <= of word as vl_kernel label
                                     024D       	
                       8B   8B   D1  024D   875 	cmpl	(r11)+,(r11)+		; reverse order, so n2 >= n1
                            04   18  0250   876 	bgeq	10$			; yes
                       7B   00   D0  0252   877 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0255   878 	rsb				; return
                                     0256   879 10$:
              7B   FFFFFFFF 8F   D0  0256   880 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  025D   881 	rsb				; end of <
                                     025E   882 
                                     025E   883 
                                     025E   884 ;+++t
                                     025E   885 ;k> = -- ( n1 n2 -- f ) true if n1 = n2, false otherwise
                                     025E   886 ;---
                                     025E   887 	header	i_equal,<=>
                           00000246' 025E       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000025E  0262       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  0262       	.nchr  nchr, ^\=\	; nchr = length( = )
                           00000001  0262       	.if    le, nchr		; nchr <= 0
                                     0262       	   .ascic \i_equal\	; no auxillary =, use principle one
                                     0262       	.if_false		; else
                              3D 00' 0262       	  .ascic \=\		; use auxillary =
                                 01  0262       
                                     0264       	.endc			; end if
                                     0264       i_equal:			; use = of word as vl_kernel label
                                     0264       	
                       8B   8B   D1  0264   888 	cmpl	(r11)+,(r11)+		; n2 = n1?
                            04   13  0267   889 	beql	10$			; yes
                       7B   00   D0  0269   890 	movl	#c_false,-(r11)		; no, leave with false
                                 05  026C   891 	rsb				; return
                                     026D   892 10$:
              7B   FFFFFFFF 8F   D0  026D   893 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0274   894 	rsb				; end of =
                                     0275   895 
                                     0275   896 
                                     0275   897 ;+++
                                     0275   898 ;K> =text -- ( a1 a2 n -- f ) compare strings of length `n' at `a1' and `a2',
                                     0275   899 ;	return true if they are equal, false otherwise.
                                     0275   900 ;---
                                     0275   901 	header	i_equal_text,<=text>
                           0000025E' 0275       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000275  0279       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  56
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000005  0279       	.nchr  nchr, ^\=text\	; nchr = length( =text )
                           00000005  0279       	.if    le, nchr		; nchr <= 0
                                     0279       	   .ascic \i_equal_text\	; no auxillary =text, use principle one
                                     0279       	.if_false		; else
                  74 78 65 74 3D 00' 0279       	  .ascic \=text\		; use auxillary =text
                                 05  0279       
                                     027F       	.endc			; end if
                                     027F       i_equal_text:			; use =text of word as vl_kernel label
                                     027F       	
            08 BB   04 BB   6B   29  027F   902 	cmpc3	(r11),@4(r11),@8(r11)	; Are they equal>
                            0B   12  0285   903 	bneq	10$			; no
                       5B   0C   C0  0287   904 	addl2	#12,r11			; pop arguments
              7B   FFFFFFFF 8F   D0  028A   905 	movl	#c_true,-(r11)		; yes, leave true
                                 05  0291   906 	rsb				; return
                                     0292   907 10$:
                       5B   0C   C0  0292   908 	addl2	#12,r11			; pop arguments
                       7B   00   D0  0295   909 	movl	#c_false,-(r11)		; no, they aren't equal, leave false.
                                 05  0298   910 	rsb				; end of =text
                                     0299   911 
                                     0299   912 
                                     0299   913 ;+++t
                                     0299   914 ;k> > -- ( n1 n2 -- f ) true if n1 > n2, false otherwise.
                                     0299   915 ;---
                                     0299   916 	header	i_greter,^\>\
                           00000275' 0299       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000299  029D       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  029D       	.nchr  nchr, ^\>\	; nchr = length( > )
                           00000001  029D       	.if    le, nchr		; nchr <= 0
                                     029D       	   .ascic \i_greter\	; no auxillary >, use principle one
                                     029D       	.if_false		; else
                              3E 00' 029D       	  .ascic \>\		; use auxillary >
                                 01  029D       
                                     029F       	.endc			; end if
                                     029F       i_greter:			; use > of word as vl_kernel label
                                     029F       	
                       8B   8B   D1  029F   917 	cmpl	(r11)+,(r11)+		; reverse order, so n2 < n1
                            04   19  02A2   918 	blss	10$			; yes
                       7B   00   D0  02A4   919 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02A7   920 	rsb				; return
                                     02A8   921 10$:
                       7B   00   D0  02A8   922 	movl	#c_false,-(r11)		; yes, leave with false
                                 05  02AB   923 	rsb				; end of >
                                     02AC   924 
                                     02AC   925 
                                     02AC   926 ;+++t
                                     02AC   927 ;k> >= -- ( n1 n2 -- f ) true if n1 >= n2; false otherwise.
                                     02AC   928 ;---
                                     02AC   929 	header	i_greater_equal,^\>=\
                           00000299' 02AC       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000002AC  02B0       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  02B0       	.nchr  nchr, ^\>=\	; nchr = length( >= )
                           00000002  02B0       	.if    le, nchr		; nchr <= 0
                                     02B0       	   .ascic \i_greater_equal\	; no auxillary >=, use principle one
                                     02B0       	.if_false		; else
                           3D 3E 00' 02B0       	  .ascic \>=\		; use auxillary >=
                                 02  02B0       
                                     02B3       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  57
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     02B3       i_greater_equal:			; use >= of word as vl_kernel label
                                     02B3       	
                       8B   8B   D1  02B3   930 	cmpl	(r11)+,(r11)+		; reverse order, so n2 <= n1
                            04   15  02B6   931 	bleq	10$			; yes
                       7B   00   D0  02B8   932 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02BB   933 	rsb				; return
                                     02BC   934 10$:
              7B   FFFFFFFF 8F   D0  02BC   935 	movl	#c_true,-(r11)		; yes, leave with false
                                 05  02C3   936 	rsb				; end of >=
                                     02C4   937 
                                     02C4   938 
                                     02C4   939 ;+++
                                     02C4   940 ;k> ? -- ( a -- ) Output contents of `a' as a long in current radix.
                                     02C4   941 ;---
                                     02C4   942 ; Remark on the internal name of this word: { header q_,<?> } is aesthetically
                                     02C4   943 ; displeasing, so make it i_question by analogoy with i_dot for { . }.
                                     02C4   944 	header	i_question,<?>
                           000002AC' 02C4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000002C4  02C8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  02C8       	.nchr  nchr, ^\?\	; nchr = length( ? )
                           00000001  02C8       	.if    le, nchr		; nchr <= 0
                                     02C8       	   .ascic \i_question\	; no auxillary ?, use principle one
                                     02C8       	.if_false		; else
                              3F 00' 02C8       	  .ascic \?\		; use auxillary ?
                                 01  02C8       
                                     02CA       	.endc			; end if
                                     02CA       i_question:			; use ? of word as vl_kernel label
                                     02CA       	
                    6B   00 BB   D0  02CA   945 	movl	@(r11),(r11)		; get contents of `a'.
                       FE51 CF   16  02CE   946 	jsb	i_dot			; print contents
                                 05  02D2   947 	rsb				; end of ?
                                     02D3   948 
                                     02D3   949 
                                     02D3   950 ;+++
                                     02D3   951 ;k> ?cr -- ( -- ) start a new line unless already at beginning of line.
                                     02D3   952 ;---
                                     02D3   953 	header	q_cr,<?cr>
                           000002C4' 02D3       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000002D3  02D7       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  02D7       	.nchr  nchr, ^\?cr\	; nchr = length( ?cr )
                           00000003  02D7       	.if    le, nchr		; nchr <= 0
                                     02D7       	   .ascic \q_cr\	; no auxillary ?cr, use principle one
                                     02D7       	.if_false		; else
                        72 63 3F 00' 02D7       	  .ascic \?cr\		; use auxillary ?cr
                                 03  02D7       
                                     02DB       	.endc			; end if
                                     02DB       q_cr:			; use ?cr of word as vl_kernel label
                                     02DB       	
                   00001B98'EF   B5  02DB   954 	tstw	v_outlen		; At beginning of line?
                            06   13  02E1   955 	beql	10$			; yes, exit
                   0000080E'EF   16  02E3   956 	jsb	cr			; no, start new line
                                     02E9   957 10$:
                                 05  02E9   958 	rsb				; end of ?cr
                                     02EA   959 
                                     02EA   960 
                                     02EA   961 ;+++
                                     02EA   962 ;k> ?dup -- ( f -- f ? f ) Duplicate top of stack only if it is true (non-zero).
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  58
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     02EA   963 ;	Used so don't always have to drop 0 in else.
                                     02EA   964 ;---
                                     02EA   965 	header	q_dup,<?dup>
                           000002D3' 02EA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000002EA  02EE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  02EE       	.nchr  nchr, ^\?dup\	; nchr = length( ?dup )
                           00000004  02EE       	.if    le, nchr		; nchr <= 0
                                     02EE       	   .ascic \q_dup\	; no auxillary ?dup, use principle one
                                     02EE       	.if_false		; else
                     70 75 64 3F 00' 02EE       	  .ascic \?dup\		; use auxillary ?dup
                                 04  02EE       
                                     02F3       	.endc			; end if
                                     02F3       q_dup:			; use ?dup of word as vl_kernel label
                                     02F3       	
                            6B   D5  02F3   966 	tstl	(r11)			; is it zero?
                            03   13  02F5   967 	beql	10$			; yes, don't duplicate it.
                       7B   6B   D0  02F7   968 	movl	(r11),-(r11)		; no, duplicate it.
                                     02FA   969 10$:
                                 05  02FA   970 	rsb				; end of ?dup
                                     02FB   971 
                                     02FB   972 
                                     02FB   973 ;+++
                                     02FB   974 ;k> ?n-cr -- ( n -- ) starts new line on terminal if < n chars left on line.
                                     02FB   975 ;---
                                     02FB   976 	header	q_n_cr,<?n-cr>
                           000002EA' 02FB       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000002FB  02FF       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  02FF       	.nchr  nchr, ^\?n-cr\	; nchr = length( ?n-cr )
                           00000005  02FF       	.if    le, nchr		; nchr <= 0
                                     02FF       	   .ascic \q_n_cr\	; no auxillary ?n-cr, use principle one
                                     02FF       	.if_false		; else
                  72 63 2D 6E 3F 00' 02FF       	  .ascic \?n-cr\		; use auxillary ?n-cr
                                 05  02FF       
                                     0305       	.endc			; end if
                                     0305       q_n_cr:			; use ?n-cr of word as vl_kernel label
                                     0305       	
              50   00001B98'EF   3C  0305   977 	movzwl	v_outlen,r0		; get current length of line.
         50   00000050 8F   50   C3  030C   978 	subl3	r0,#c_screen_len,r0	; get current length of line
                       50   8B   D1  0314   979 	cmpl	(r11)+,r0		; enough characers left?
                            06   19  0317   980 	blss	10$			; yes, go to return
                                     0319   981 ; no, not enough characters left on line.
                   0000080E'EF   16  0319   982 	jsb	cr			; start a new line
                                     031F   983 10$:
                                 05  031F   984 	rsb				; end of ?n-cr
                                     0320   985 
                                     0320   986 
                                     0320   987 ;+++t
                                     0320   988 ;k> ?number -- ( -- n ? f ) Convert token at eodp to a number, and if compiling
                                     0320   989 ;	enclose it as a literal in the current word.  If executing, push on
                                     0320   990 ;	the  stack.  If not a number, leave false on stack.  If a number leave
                                     0320   991 ;	a true on stack.
                                     0320   992 ;---
                                     0320   993 	header	q_number,<?number>
                           000002FB' 0320       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000320  0324       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000007  0324       	.nchr  nchr, ^\?number\	; nchr = length( ?number )
                           00000007  0324       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  59
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0324       	   .ascic \q_number\	; no auxillary ?number, use principle one
                                     0324       	.if_false		; else
            72 65 62 6D 75 6E 3F 00' 0324       	  .ascic \?number\		; use auxillary ?number
                                 07  0324       
                                     032C       	.endc			; end if
                                     032C       q_number:			; use ?number of word as vl_kernel label
                                     032C       	
                   00000D20'EF   16  032C   994 	jsb	number			; try to make it a number
                            6B   D5  0332   995 	tstl	(r11)			; is it a number?
                            18   13  0334   996 	beql	10$			; no, exit leaving false on the stack
                       5B   04   C0  0336   997 	addl2	#4,r11			; yes.	pop flag
                   00001D4D'EF   95  0339   998 	tstb	v_mode			; are we compiling?
                            06   13  033F   999 	beql	20$			; no, leaving it on stack
                   0000179F'EF   16  0341  1000 	jsb	literal			; yes, include in dictionary as
                                     0347  1001 					; a literal
                                     0347  1002 20$:
              7B   FFFFFFFF 8F   D0  0347  1003 	movl	#c_true,-(r11)		; leave with true on stack
                                     034E  1004 10$:
                                 05  034E  1005 	rsb				; end of ?number
                                     034F  1006 
                                     034F  1007 
                                     034F  1008 ;+++t
                                     034F  1009 ;k> ?search -- ( -- a ? f )  search context vocabulary for most recent token,
                                     034F  1010 ;	return false if not found, or ( addr true ) if found.  If compiling,
                                     034F  1011 ;	search compiler vocab if not found in context and set { state }
                                     034F  1012 ;	true.  Compare byte-counted string at eodp to find.
                                     034F  1013 ;---
                                     034F  1014 	header	q_search,<?search>
                           00000320' 034F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000034F  0353       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000007  0353       	.nchr  nchr, ^\?search\	; nchr = length( ?search )
                           00000007  0353       	.if    le, nchr		; nchr <= 0
                                     0353       	   .ascic \q_search\	; no auxillary ?search, use principle one
                                     0353       	.if_false		; else
            68 63 72 61 65 73 3F 00' 0353       	  .ascic \?search\		; use auxillary ?search
                                 07  0353       
                                     035B       	.endc			; end if
                                     035B       q_search:			; use ?search of word as vl_kernel label
                                     035B       	
                                     035B  1015 ;??? this next perhaps should have been
                                     035B  1016 ;	movl	@v_context,(r11)
                                     035B  1017 ;	tstb	v_mode
                                     035B  1018 ;	beql	5$
                                     035B  1019 ;	movl	@(r11),(r11)
                                     035B  1020 ;5$:
                                     035B  1021 ; which would (during compilation of new words)
                                     035B  1022 ; start the search at the word before the one currently being compiled;
                                     035B  1023 ; this would allow use of older definition of word `x' in new definition
                                     035B  1024 ; of word `x'.	However, as it stands it allows easy recursion.
                                     035B  1025 ;??? changed to eliminate recusion by default, as that is probably more
                                     035B  1026 ; useful, since RECURSE is a simple way to get recusion.
                                     035B  1027 ;??? The problem with this is that if you switch vocabularies while defining
                                     035B  1028 ; a word, the new vocab (which you want to search from the first) also is
                                     035B  1029 ; searched from the second word.  Perhaps I should set the smudge bit (gasp!
                                     035B  1030 ; Horrors!).
                                     035B  1031 ; get pointer to pointer to start of vocab
              7B   00001D37'FF   D0  035B  1032 	movl @v_context,-(r11)		; get address of current word
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  60
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0362  1033 ;??? took out to test smudge bit
                                     0362  1034 ;	tstb  v_mode			; Are we compiling?
                                     0362  1035 ;	beql  5$			; no, go on.
                                     0362  1036 ; yes, so skip address of word we are defining, so we can use
                                     0362  1037 ; previous definitions of this word.
                                     0362  1038 ;	movl	@(r11),(r11)		; get address of previous word
                                     0362  1039 5$:
                   00000F86'EF   16  0362  1040 	jsb	search			; search it
                            6B   D5  0368  1041 	tstl	(r11)			; Was it found?
                            21   12  036A  1042 	bneq	10$			; yes, exit with ( addr true ) on dstack
                   00001D4D'EF   95  036C  1043 	tstb	v_mode			; no. Are we compiling?
                            19   13  0372  1044 	beql	10$			; no, exit leaving false on dstack
              6B   00001D3F'EF   D0  0374  1045 	movl	v_compiler,(r11)	; yes, get adddress of compiler vocab
                   00000F86'EF   16  037B  1046 	jsb	search			; search it
                            6B   D5  0381  1047 	tstl	(r11)			; Was it found?
                            08   13  0383  1048 	beql	10$			; no, exit with false on dstack
           00001D4C'EF   FF 8F   90  0385  1049 	movb	#c_true,v_state		; yes, set v_state flag
                                     038D  1050 					; exit with ( addr true ) on dstack
                                     038D  1051 10$:
                                 05  038D  1052 	rsb				; end of ?search
                                     038E  1053 ;??? Should the compiler vocabulary be searched *before* the context vocabulary
                                     038E  1054 ; when we are compiling?  This would allow defining new versions in compiler
                                     038E  1055 ; of words in context that would be more efficient during compilation (or
                                     038E  1056 ; have a different effect, or allow immediate and noimmediate words that
                                     038E  1057 ; should do the same thing, like { % }).
                                     038E  1058 
                                     038E  1059 
                                     038E  1060 
                                     038E  1061 ;+++t
                                     038E  1062 ;k> @ -- (fetch) ( a -- l ) Fetches contents of longword at `a'.
                                     038E  1063 ;---
                                     038E  1064 	header	i_fetch,<@>
                           0000034F' 038E       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000038E  0392       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  0392       	.nchr  nchr, ^\@\	; nchr = length( @ )
                           00000001  0392       	.if    le, nchr		; nchr <= 0
                                     0392       	   .ascic \i_fetch\	; no auxillary @, use principle one
                                     0392       	.if_false		; else
                              40 00' 0392       	  .ascic \@\		; use auxillary @
                                 01  0392       
                                     0394       	.endc			; end if
                                     0394       i_fetch:			; use @ of word as vl_kernel label
                                     0394       	
                    6B   00 BB   D0  0394  1065 	movl	@(r11),(r11)		; get contents of address at top-of-ds
                                 05  0398  1066 	rsb				; end of @
                                     0399  1067 
                                     0399  1068 
                                     0399  1069 ;+++
                                     0399  1070 ;k> abort -- ( -- ) clear data stack and restart VTIL.
                                     0399  1071 ;---
                                     0399  1072 	header	abort
                           0000038E' 0399       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000399  039D       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  039D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  039D       	.if    le, nchr		; nchr <= 0
                  74 72 6F 62 61 00' 039D       	   .ascic \abort\	; no auxillary , use principle one
                                 05  039D       
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  61
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     03A3       	.if_false		; else
                                     03A3       	  .ascic \\		; use auxillary 
                                     03A3       	.endc			; end if
                                     03A3       abort:			; use  of word as vl_kernel label
                                     03A3       	
                          162C   31  03A3  1073 	brw	r_warm_start		; end of abort
                                     03A6  1074 
                                     03A6  1075 
                                     03A6  1076 ;+++
                                     03A6  1077 ;k> abs -- ( n1 -- n2 ) Takes the absolute value of top of stack.
                                     03A6  1078 ;---
                                     03A6  1079 	header	abs
                           00000399' 03A6       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000003A6  03AA       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  03AA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03AA       	.if    le, nchr		; nchr <= 0
                        73 62 61 00' 03AA       	   .ascic \abs\	; no auxillary , use principle one
                                 03  03AA       
                                     03AE       	.if_false		; else
                                     03AE       	  .ascic \\		; use auxillary 
                                     03AE       	.endc			; end if
                                     03AE       abs:			; use  of word as vl_kernel label
                                     03AE       	
                            6B   D5  03AE  1080 	tstl	(r11)			; is top of stack < 0?
                            03   18  03B0  1081 	bgeq	10$			; no, go on
                       6B   6B   CE  03B2  1082 	mnegl	(r11),(r11)		; yes, negate it
                                     03B5  1083 10$:
                                 05  03B5  1084 	rsb				; end of abs
                                     03B6  1085 
                                     03B6  1086 
                                     03B6  1087 ;+++t
                                     03B6  1088 ;k> ac: -- ( b -- ) assembler constant (makes opcode & operand defintions)
                                     03B6  1089 ;	ac creates a word that compiles the byte on the top of the stack at
                                     03B6  1090 ;	definition into the dictionary.
                                     03B6  1091 ;---
                                     03B6  1092 	header	i_ac_colon,<ac:>
                           000003A6' 03B6       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000003B6  03BA       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  03BA       	.nchr  nchr, ^\ac:\	; nchr = length( ac: )
                           00000003  03BA       	.if    le, nchr		; nchr <= 0
                                     03BA       	   .ascic \i_ac_colon\	; no auxillary ac:, use principle one
                                     03BA       	.if_false		; else
                        3A 63 61 00' 03BA       	  .ascic \ac:\		; use auxillary ac:
                                 03  03BA       
                                     03BE       	.endc			; end if
                                     03BE       i_ac_colon:			; use ac: of word as vl_kernel label
                                     03BE       	
                   00000842'EF   16  03BE  1093 	jsb	create			; enclose name in dictionary
                    89   90 8F   90  03C4  1094 	movb	#op_movb,(r9)+		; `movb'
                    89   AF 8F   90  03C8  1095 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  03CC  1096 	movb	#2,(r9)+		; (pc+2)
                    89   89 8F   90  03CF  1097 	movb	#adm_ainc_r9,(r9)+	; (r9)+
                       89   05   90  03D3  1098 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  03D6  1099 	movb	(r11),(r9)+		; enclose byte value in dictionary
                       5B   04   C0  03D9  1100 	addl	#4,r11			; pop argument
                                     03DC  1101 ; Make it an compiletime word so it will compile the machine language into the
                                     03DC  1102 ; dictionary when defining a new word and will not be found otherwise.
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  62
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                   000007C1'EF   16  03DC  1103 	jsb	compiletime
                                 05  03E2  1104 	rsb				; end of ac:
                                     03E3  1105 
                                     03E3  1106 
                                     03E3  1107 ;+++t
                                     03E3  1108 ;k> and -- ( f1 f2 -- f ) logical and f1 and f2
                                     03E3  1109 ;---
                                     03E3  1110 	header	and
                           000003B6' 03E3       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000003E3  03E7       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  03E7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03E7       	.if    le, nchr		; nchr <= 0
                        64 6E 61 00' 03E7       	   .ascic \and\	; no auxillary , use principle one
                                 03  03E7       
                                     03EB       	.if_false		; else
                                     03EB       	  .ascic \\		; use auxillary 
                                     03EB       	.endc			; end if
                                     03EB       and:			; use  of word as vl_kernel label
                                     03EB       	
                            8B   D5  03EB  1111 	tstl	(r11)+			; is first false?
                            0C   13  03ED  1112 	beql	10$			; yes
                            8B   D5  03EF  1113 	tstl	(r11)+			; no, is second false?
                            0B   13  03F1  1114 	beql	20$			; yes
              7B   FFFFFFFF 8F   D0  03F3  1115 	movl	#c_true,-(r11)		; no, both true, leave with true
                                 05  03FA  1116 	rsb				; return
                                     03FB  1117 10$:
                       6B   04   C0  03FB  1118 	addl2	#4,(r11)		; pop second item off, don't need
                                     03FE  1119 					; to check
                                     03FE  1120 20$:
                       7B   00   D0  03FE  1121 	movl	#c_false,-(r11)		; leave with false
                                 05  0401  1122 	rsb				; end of and
                                     0402  1123 
                                     0402  1124 
                                     0402  1125 ;+++
                                     0402  1126 ;k> array -- ( n -- ) create word that pushes addres of `n' bytes
                                     0402  1127 ;	which are saved in the dictionary.
                                     0402  1128 ;---
                                     0402  1129 	header	array
                           000003E3' 0402       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000402  0406       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0406       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0406       	.if    le, nchr		; nchr <= 0
                  79 61 72 72 61 00' 0406       	   .ascic \array\	; no auxillary , use principle one
                                 05  0406       
                                     040C       	.if_false		; else
                                     040C       	  .ascic \\		; use auxillary 
                                     040C       	.endc			; end if
                                     040C       array:			; use  of word as vl_kernel label
                                     040C       	
                   00000842'EF   16  040C  1130 	jsb	create			; enclose next token in dictinary
                    89   9E 8F   90  0412  1131 	movb	#op_movab,(r9)+		; `moval'
                    89   AF 8F   90  0416  1132 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  041A  1133 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  041D  1134 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0421  1135 	movb	#op_rsb,(r9)+		; `rsb'
                       59   8B   C0  0424  1136 	addl2	(r11)+,r9		; save `n' bytes in dictionary
                                 05  0427  1137 	rsb				; end of array
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  63
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0428  1138 
                                     0428  1139 
                                     0428  1140 ;+++
                                     0428  1141 ;k> ascii -- ( -- n ) put ascii value of first character of next token on stack.
                                     0428  1142 ;	Note that this cannot be used in colon definitions!  (See { [ascii] }.)
                                     0428  1143 ;---
                                     0428  1144 	header	ascii
                           00000402' 0428       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000428  042C       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  042C       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  042C       	.if    le, nchr		; nchr <= 0
                  69 69 63 73 61 00' 042C       	   .ascic \ascii\	; no auxillary , use principle one
                                 05  042C       
                                     0432       	.if_false		; else
                                     0432       	  .ascic \\		; use auxillary 
                                     0432       	.endc			; end if
                                     0432       ascii:			; use  of word as vl_kernel label
                                     0432       	
                       7B   20   D0  0432  1145 	movl	#c_blank,-(r11)		; set up for blank separated token
                   000012E2'EF   16  0435  1146 	jsb	token			; get it
                    7B   01 A9   9A  043B  1147 	movzbl	1(r9),-(r11)		; put ascii value of token on stack
                                 05  043F  1148 	rsb				; end of ascii
                                     0440  1149 
                                     0440  1150 
                                     0440  1151 ;+++
                                     0440  1152 ;k> b! -- ( b a -- ) store 8 bits of `b' at address `a'.
                                     0440  1153 ;---
                                     0440  1154 	header	i_b_store,<b!>
                           00000428' 0440       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000440  0444       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0444       	.nchr  nchr, ^\b!\	; nchr = length( b! )
                           00000002  0444       	.if    le, nchr		; nchr <= 0
                                     0444       	   .ascic \i_b_store\	; no auxillary b!, use principle one
                                     0444       	.if_false		; else
                           21 62 00' 0444       	  .ascic \b!\		; use auxillary b!
                                 02  0444       
                                     0447       	.endc			; end if
                                     0447       i_b_store:			; use b! of word as vl_kernel label
                                     0447       	
                 00 BB   04 AB   90  0447  1155 	movb	4(r11),@(r11)		; store byte at what's pointed to by
                                     044C  1156 					; top of stack
                       5B   08   C0  044C  1157 	addl2	#8,r11			; pop arguments
                                 05  044F  1158 	rsb				; end of b!
                                     0450  1159 
                                     0450  1160 
                                     0450  1161 ;+++
                                     0450  1162 ;k> b, -- ( b -- ) store low byte of top stack entry into dictionary.
                                     0450  1163 ;---
                                     0450  1164 	header	i_b_comma,<b,>
                           00000440' 0450       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000450  0454       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0454       	.nchr  nchr, ^\b,\	; nchr = length( b, )
                           00000002  0454       	.if    le, nchr		; nchr <= 0
                                     0454       	   .ascic \i_b_comma\	; no auxillary b,, use principle one
                                     0454       	.if_false		; else
                           2C 62 00' 0454       	  .ascic \b,\		; use auxillary b,
                                 02  0454       
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  64
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0457       	.endc			; end if
                                     0457       i_b_comma:			; use b, of word as vl_kernel label
                                     0457       	
                       89   6B   90  0457  1165 	movb	(r11),(r9)+		; store in dictinary
                       5B   04   C0  045A  1166 	addl2	#4,r11			; pop argument
                                 05  045D  1167 	rsb				; end of b,
                                     045E  1168 
                                     045E  1169 
                                     045E  1170 ;+++
                                     045E  1171 ;k> b@ -- ( a -- b ) Fetch byte from address `a'.
                                     045E  1172 ;---
                                     045E  1173 	header	i_b_fetch,<b@>
                           00000450' 045E       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000045E  0462       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0462       	.nchr  nchr, ^\b@\	; nchr = length( b@ )
                           00000002  0462       	.if    le, nchr		; nchr <= 0
                                     0462       	   .ascic \i_b_fetch\	; no auxillary b@, use principle one
                                     0462       	.if_false		; else
                           40 62 00' 0462       	  .ascic \b@\		; use auxillary b@
                                 02  0462       
                                     0465       	.endc			; end if
                                     0465       i_b_fetch:			; use b@ of word as vl_kernel label
                                     0465       	
                    6B   00 BB   9A  0465  1174 	movzbl	@(r11),(r11)
                                 05  0469  1175 	rsb				; end of b@
                                     046A  1176 
                                     046A  1177 
                                     046A  1178 ;+++
                                     046A  1179 ;k> bcount -- ( a -- a n ) Given the address of a byte-counted
                                     046A  1180 ;	string, leave address of first character in string and the
                                     046A  1181 ;	count of the string on the stack.
                                     046A  1182 ;---
                                     046A  1183 	header	bcount
                           0000045E' 046A       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000046A  046E       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  046E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  046E       	.if    le, nchr		; nchr <= 0
               74 6E 75 6F 63 62 00' 046E       	   .ascic \bcount\	; no auxillary , use principle one
                                 06  046E       
                                     0475       	.if_false		; else
                                     0475       	  .ascic \\		; use auxillary 
                                     0475       	.endc			; end if
                                     0475       bcount:			; use  of word as vl_kernel label
                                     0475       	
                    50   00 BB   9A  0475  1184 	movzbl	@(r11),r0		; get length of string
                            6B   D6  0479  1185 	incl	(r11)			; move over byte-count
                       7B   50   D0  047B  1186 	movl	r0,-(r11)		; put count on stack
                                 05  047E  1187 	rsb				; end of bcount
                                     047F  1188 
                                     047F  1189 
                                     047F  1190 ;+++
                                     047F  1191 ;k> binary -- ( -- ) Set the base to binary
                                     047F  1192 ;---
                                     047F  1193 	header	binary
                           0000046A' 047F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000047F  0483       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0483       	.nchr  nchr, ^\\	; nchr = length(  )
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  65
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000000  0483       	.if    le, nchr		; nchr <= 0
               79 72 61 6E 69 62 00' 0483       	   .ascic \binary\	; no auxillary , use principle one
                                 06  0483       
                                     048A       	.if_false		; else
                                     048A       	  .ascic \\		; use auxillary 
                                     048A       	.endc			; end if
                                     048A       binary:			; use  of word as vl_kernel label
                                     048A       	
              00001D4E'EF   02   D0  048A  1194 	movl	#2,v_radix		; switch to base 2
                                 05  0491  1195 	rsb				; end of binary
                                     0492  1196 
                                     0492  1197 
                                     0492  1198 ;+++
                                     0492  1199 ;k> (bl) -- ( -- c ) Pushes ascii value of a blank on the stack.
                                     0492  1200 ;---
                                     0492  1201 	header	i_bl,<(bl)>
                           0000047F' 0492       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000492  0496       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  0496       	.nchr  nchr, ^\(bl)\	; nchr = length( (bl) )
                           00000004  0496       	.if    le, nchr		; nchr <= 0
                                     0496       	   .ascic \i_bl\	; no auxillary (bl), use principle one
                                     0496       	.if_false		; else
                     29 6C 62 28 00' 0496       	  .ascic \(bl)\		; use auxillary (bl)
                                 04  0496       
                                     049B       	.endc			; end if
                                     049B       i_bl:			; use (bl) of word as vl_kernel label
                                     049B       	
                       7B   20   D0  049B  1202 	movl	#c_blank,-(r11)		; put on stack
                                 05  049E  1203 	rsb				; end of (bl)
                                     049F  1204 
                                     049F  1205 
                                     049F  1206 ;+++
                                     049F  1207 ;k> blank --- ( a w -- ) fill `w' bytes from `a' with blanks.
                                     049F  1208 ;---
                                     049F  1209 	header	blank
                           00000492' 049F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000049F  04A3       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  04A3       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  04A3       	.if    le, nchr		; nchr <= 0
                  6B 6E 61 6C 62 00' 04A3       	   .ascic \blank\	; no auxillary , use principle one
                                 05  04A3       
                                     04A9       	.if_false		; else
                                     04A9       	  .ascic \\		; use auxillary 
                                     04A9       	.endc			; end if
                                     04A9       blank:			; use  of word as vl_kernel label
                                     04A9       	
                       69   00   2C  04A9  1210 	movc5	#0,(r9),-		; srclen,src  use (r9) to be safe
                            20       04AC  1211 		#c_blank,-		; fill with blanks
                    04 BB   6B       04AD  1212 		(r11),@4(r11)		; destlen, dest
                       5B   08   C0  04B0  1213 	addl2	#8,r11			; pop arguments
                                 05  04B3  1214 	rsb				; end of blank
                                     04B4  1215 
                                     04B4  1216 
                                     04B4  1217 ;+++
                                     04B4  1218 ;k> block -- ( l -- a ) Get block `l' into buffer at address `a'.
                                     04B4  1219 ;---
                                     04B4  1220 	header	block
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  66
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           0000049F' 04B4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000004B4  04B8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  04B8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  04B8       	.if    le, nchr		; nchr <= 0
                  6B 63 6F 6C 62 00' 04B8       	   .ascic \block\	; no auxillary , use principle one
                                 05  04B8       
                                     04BE       	.if_false		; else
                                     04BE       	  .ascic \\		; use auxillary 
                                     04BE       	.endc			; end if
                                     04BE       block:			; use  of word as vl_kernel label
                                     04BE       	
                                     04BE  1221 ; Is the block already in memory?
                            50   D4  04BE  1222 	clrl   r0			; start with buffer 0
                                     04C0  1223 10$:
                            6B   D1  04C0  1224 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       04C2  1225 		v_buf_blk_nums[r0]	;   block we are looking for?
                            4E   13  04C8  1226 	beql	100$			; yes, go on
                    F2 50   03   F2  04CA  1227 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     04CE  1228 ;
                                     04CE  1229 ; not in memory, so we have to get it in
                                     04CE  1230 ;
                                     04CE  1231 ; Are there any unused buffers?
                            50   D4  04CE  1232 	clrl	r0			; start with buffer 0
                                     04D0  1233 20$:
                 00001B7D'EF40   95  04D0  1234 	tstb	v_buf_inuse[r0]		; is it in use?
                            25   13  04D7  1235 	beql	90$			; no, read block into it
                    F3 50   03   F2  04D9  1236 	aoblss	#c_max_blocks,r0,20$	; move to next buffer, if any
                                     04DD  1237 ; Are there any unmodified buffers?
                            50   D4  04DD  1238 	clrl	r0
                                     04DF  1239 30$:
                            02   91  04DF  1240 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       04E1  1241 		v_buf_inuse[r0]		;   been modified?
                            15   12  04E7  1242 	bneq	90$			; no, read block into it
                    F2 50   03   F2  04E9  1243 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     04ED  1244 ; all buffers are modified, so we must write out out and use it.
                            50   D4  04ED  1245 	clrl	r0			; for now, always use the zero'th one
                       7A   50   D0  04EF  1246 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  04F2  1247 	movl	r0,-(r11)		; set up for buffer-write
                   000006F8'EF   16  04F5  1248 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  04FB  1249 	movl	(r10)+,r0		; get the buffer number back
                                     04FE  1250 ; read block into buffer
                                     04FE  1251 90$:
                            6B   D0  04FE  1252 	movl	(r11),-			; Save the new block number in
                 FFFFE480'EF40       0500  1253 		-v_buf_blk_nums[r0]	;   buffer
                            01   90  0506  1254 	movb	#c_inuse,-		; flag that buffer is in use
                 00001B7D'EF40       0508  1255 		v_buf_inuse[r0]
                       6B   50   D0  050E  1256 	movl	r0,(r11)		; set up for buffer-read
                   000006BC'EF   16  0511  1257 	jsb	i_buffer_read		; read block into buffer
                                 05  0517  1258 	rsb				; return
                                     0518  1259 ;
                                     0518  1260 ; block already in memory
                                     0518  1261 ;
                                     0518  1262 100$:
                                     0518  1263 ; Comes here if block already in memory, with buffers in r0, block# on stack
         6B   00000400 8F   50   C5  0518  1264 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  0520  1265 	addl2	#v_blkbuff,(r11)	; calcualte addressof `r0'th buffer
              00001B79'EF   50   D0  0527  1266 	movl	r0,v_current_buff	; mark this as most current block
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  67
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 05  052E  1267 	rsb				; end of block
                                     052F  1268 
                                     052F  1269 
                                     052F  1270 
                                     052F  1271 ;+++
                                     052F  1272 ;k> block-close -- ( -- ) Close the block file
                                     052F  1273 ;---
                                     052F  1274 	header	i_block_close,<block-close>
                           000004B4' 052F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000052F  0533       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000B  0533       	.nchr  nchr, ^\block-close\	; nchr = length( block-close )
                           0000000B  0533       	.if    le, nchr		; nchr <= 0
                                     0533       	   .ascic \i_block_close\	; no auxillary block-close, use principle one
                                     0533       	.if_false		; else
65 73 6F 6C 63 2D 6B 63 6F 6C 62 00' 0533       	  .ascic \block-close\		; use auxillary block-close
                                 0B  0533       
                                     053F       	.endc			; end if
                                     053F       i_block_close:			; use block-close of word as vl_kernel label
                                     053F       	
                   00001B78'EF   95  053F  1275 	tstb	v_blockio		; is the block file open?
                            1A   13  0545  1276 	beql	100$			; no, return
                                     0547  1277 	$close	fab=v_blkfab		; Yes, close block file
                                     0547       		$RMSCALL	CLOSE,v_blkfab,,
                                     0547       	.GLOBL	SYS$CLOSE
                                     0547       	.IF	B <v_blkfab>
                                     0547       	CALLG	(AP),G^SYS$CLOSE
                                     0547       	$$.TMP=0
                                     0547       	.IF	NB <>
                                     0547       	$$.TMP=1
                                     0547       	.ENDC
                                     0547       	.IF	NB <>
                                     0547       	$$.TMP=1
                                     0547       	.ENDC
                                     0547       	.IF	NE $$.TMP
                                     0547       	.ERROR				; v_blkfab= parameter missing;
                                     0547       	.ENDC
                                     0547       	.ENDC
                                     0547       	.IF	NB <v_blkfab>
                           00000001  0547       	$$.TMP1=1
                                     0547       	.IF	NB <>
                                     0547       	PUSHAL	
                                     0547       	$$.TMP1=3
                                     0547       	.ENDC
                                     0547       	.IF	NB <>
                                     0547       	PUSHAL	
                                     0547       	.IF	EQ <$$.TMP1-1>
                                     0547       	$$.TMP1=2
                                     0547       	.ENDC
                                     0547       	.IFF
                           FFFFFFFE  0547       	.IF	EQ <$$.TMP1-3>
                                     0547       	PUSHL	#0
                                     0547       	.ENDC
                                     0547       	.ENDC
                           000000CF  0547       	.NTYPE	$$.TMP2,v_blkfab
                           00000070  0547       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0547       	PUSHL	v_blkfab
                                     0547       	.IFF
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  68
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           000000B0  0547       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0547       	PUSHL	v_blkfab
                                     0547       	.IFF
                   00001AE0'EF   DF  0547       	PUSHAL	v_blkfab
                                     054D       	.ENDC
                                     054D       	.ENDC
              00000000'GF   01   FB  054D       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     0554       	.ENDC
                                     0554       	
                                     0554       	
                         03 50   E8  0554  1278 	blbs	r0,10$			; go on if no error
                          15FE   31  0557  1279 	brw	_error_exit		; exit with error message
                                     055A  1280 10$:
              00001B78'EF   00   90  055A  1281 	movb	#c_false,v_blockio	; we're not using block file
                                     0561  1282 100$:
                                 05  0561  1283 	rsb				; end of block-close
                                     0562  1284 
                                     0562  1285 
                                     0562  1286 ;+++
                                     0562  1287 ;k> blocok-open -- ( -- ) Open the block file.
                                     0562  1288 ;---
                                     0562  1289 	header	i_block_open,<block-open>
                           0000052F' 0562       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000562  0566       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000A  0566       	.nchr  nchr, ^\block-open\	; nchr = length( block-open )
                           0000000A  0566       	.if    le, nchr		; nchr <= 0
                                     0566       	   .ascic \i_block_open\	; no auxillary block-open, use principle one
                                     0566       	.if_false		; else
   6E 65 70 6F 2D 6B 63 6F 6C 62 00' 0566       	  .ascic \block-open\		; use auxillary block-open
                                 0A  0566       
                                     0571       	.endc			; end if
                                     0571       i_block_open:			; use block-open of word as vl_kernel label
                                     0571       	
                   00001B78'EF   95  0571  1290 	tstb	v_blockio		; Is block file open?
                            2E   12  0577  1291 	bneq	100$			; Yes, don't open again
                                     0579  1292 ; no, open it
                                     0579  1293 	$open	fab=v_blkfab		; open block file
                                     0579       		$RMSCALL	OPEN,v_blkfab,,
                                     0579       	.GLOBL	SYS$OPEN
                                     0579       	.IF	B <v_blkfab>
                                     0579       	CALLG	(AP),G^SYS$OPEN
                                     0579       	$$.TMP=0
                                     0579       	.IF	NB <>
                                     0579       	$$.TMP=1
                                     0579       	.ENDC
                                     0579       	.IF	NB <>
                                     0579       	$$.TMP=1
                                     0579       	.ENDC
                                     0579       	.IF	NE $$.TMP
                                     0579       	.ERROR				; v_blkfab= parameter missing;
                                     0579       	.ENDC
                                     0579       	.ENDC
                                     0579       	.IF	NB <v_blkfab>
                           00000001  0579       	$$.TMP1=1
                                     0579       	.IF	NB <>
                                     0579       	PUSHAL	
                                     0579       	$$.TMP1=3
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  69
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0579       	.ENDC
                                     0579       	.IF	NB <>
                                     0579       	PUSHAL	
                                     0579       	.IF	EQ <$$.TMP1-1>
                                     0579       	$$.TMP1=2
                                     0579       	.ENDC
                                     0579       	.IFF
                           FFFFFFFE  0579       	.IF	EQ <$$.TMP1-3>
                                     0579       	PUSHL	#0
                                     0579       	.ENDC
                                     0579       	.ENDC
                           000000CF  0579       	.NTYPE	$$.TMP2,v_blkfab
                           00000070  0579       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0579       	PUSHL	v_blkfab
                                     0579       	.IFF
                           000000B0  0579       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0579       	PUSHL	v_blkfab
                                     0579       	.IFF
                   00001AE0'EF   DF  0579       	PUSHAL	v_blkfab
                                     057F       	.ENDC
                                     057F       	.ENDC
              00000000'GF   01   FB  057F       	CALLS	#$$.TMP1,G^SYS$OPEN
                                     0586       	.ENDC
                                     0586       	
                                     0586       	
                         03 50   E8  0586  1294 	blbs	r0,10$			; no error, go on
                          15CC   31  0589  1295 	brw	_error_exit		; quit on error
                                     058C  1296 10$:
                                     058C  1297 	$connect rab=v_blkrab		; connect to block file
                                     058C       		$RMSCALL	CONNECT,v_blkrab,,
                                     058C       	.GLOBL	SYS$CONNECT
                                     058C       	.IF	B <v_blkrab>
                                     058C       	CALLG	(AP),G^SYS$CONNECT
                                     058C       	$$.TMP=0
                                     058C       	.IF	NB <>
                                     058C       	$$.TMP=1
                                     058C       	.ENDC
                                     058C       	.IF	NB <>
                                     058C       	$$.TMP=1
                                     058C       	.ENDC
                                     058C       	.IF	NE $$.TMP
                                     058C       	.ERROR				; v_blkrab= parameter missing;
                                     058C       	.ENDC
                                     058C       	.ENDC
                                     058C       	.IF	NB <v_blkrab>
                           00000001  058C       	$$.TMP1=1
                                     058C       	.IF	NB <>
                                     058C       	PUSHAL	
                                     058C       	$$.TMP1=3
                                     058C       	.ENDC
                                     058C       	.IF	NB <>
                                     058C       	PUSHAL	
                                     058C       	.IF	EQ <$$.TMP1-1>
                                     058C       	$$.TMP1=2
                                     058C       	.ENDC
                                     058C       	.IFF
                           FFFFFFFE  058C       	.IF	EQ <$$.TMP1-3>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  70
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     058C       	PUSHL	#0
                                     058C       	.ENDC
                                     058C       	.ENDC
                           000000CF  058C       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  058C       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     058C       	PUSHL	v_blkrab
                                     058C       	.IFF
                           000000B0  058C       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     058C       	PUSHL	v_blkrab
                                     058C       	.IFF
                   00001B30'EF   DF  058C       	PUSHAL	v_blkrab
                                     0592       	.ENDC
                                     0592       	.ENDC
              00000000'GF   01   FB  0592       	CALLS	#$$.TMP1,G^SYS$CONNECT
                                     0599       	.ENDC
                                     0599       	
                                     0599       	
                         03 50   E8  0599  1298 	blbs	 r0,20$			; no error, go on
                          15B9   31  059C  1299 	brw	 _error_exit		; quit on error
                                     059F  1300 20$:
           00001B78'EF   FF 8F   90  059F  1301 	movb	#c_true,v_blockio	; yes, we are using the block file
                                     05A7  1302 100$:
                                 05  05A7  1303 	rsb				; end of block-open
                                     05A8  1304 
                                     05A8  1305 
                                     05A8  1306 ;+++
                                     05A8  1307 ;k> block-read -- ( l a -- ) Read block `l' from buffer at address `a'.
                                     05A8  1308 ;---
                                     05A8  1309 	header	i_block_read,<block-read>
                           00000562' 05A8       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000005A8  05AC       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000A  05AC       	.nchr  nchr, ^\block-read\	; nchr = length( block-read )
                           0000000A  05AC       	.if    le, nchr		; nchr <= 0
                                     05AC       	   .ascic \i_block_read\	; no auxillary block-read, use principle one
                                     05AC       	.if_false		; else
   64 61 65 72 2D 6B 63 6F 6C 62 00' 05AC       	  .ascic \block-read\		; use auxillary block-read
                                 0A  05AC       
                                     05B7       	.endc			; end if
                                     05B7       i_block_read:			; use block-read of word as vl_kernel label
                                     05B7       	
                            8B   D0  05B7  1310 	movl	(r11)+,-		; get address of buffer
                   00001B54'EF       05B9  1311 		v_blkrab+rab$l_ubf	;   into  rab
                            8B   D0  05BE  1312 	movl	(r11)+,-		; get VTIL block (rms record) number
                   00001B74'EF       05C0  1313 		v_blkkey		;   into rab's key
                                     05C5  1314 	$get	rab=v_blkrab		; read the block
                                     05C5       		$RMSCALL	GET,v_blkrab,,
                                     05C5       	.GLOBL	SYS$GET
                                     05C5       	.IF	B <v_blkrab>
                                     05C5       	CALLG	(AP),G^SYS$GET
                                     05C5       	$$.TMP=0
                                     05C5       	.IF	NB <>
                                     05C5       	$$.TMP=1
                                     05C5       	.ENDC
                                     05C5       	.IF	NB <>
                                     05C5       	$$.TMP=1
                                     05C5       	.ENDC
                                     05C5       	.IF	NE $$.TMP
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  71
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     05C5       	.ERROR				; v_blkrab= parameter missing;
                                     05C5       	.ENDC
                                     05C5       	.ENDC
                                     05C5       	.IF	NB <v_blkrab>
                           00000001  05C5       	$$.TMP1=1
                                     05C5       	.IF	NB <>
                                     05C5       	PUSHAL	
                                     05C5       	$$.TMP1=3
                                     05C5       	.ENDC
                                     05C5       	.IF	NB <>
                                     05C5       	PUSHAL	
                                     05C5       	.IF	EQ <$$.TMP1-1>
                                     05C5       	$$.TMP1=2
                                     05C5       	.ENDC
                                     05C5       	.IFF
                           FFFFFFFE  05C5       	.IF	EQ <$$.TMP1-3>
                                     05C5       	PUSHL	#0
                                     05C5       	.ENDC
                                     05C5       	.ENDC
                           000000CF  05C5       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  05C5       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     05C5       	PUSHL	v_blkrab
                                     05C5       	.IFF
                           000000B0  05C5       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     05C5       	PUSHL	v_blkrab
                                     05C5       	.IFF
                   00001B30'EF   DF  05C5       	PUSHAL	v_blkrab
                                     05CB       	.ENDC
                                     05CB       	.ENDC
              00000000'GF   01   FB  05CB       	CALLS	#$$.TMP1,G^SYS$GET
                                     05D2       	.ENDC
                                     05D2       	
                                     05D2       	
                         03 50   E8  05D2  1315 	blbs	r0,100$			; no errors, go on
                          1580   31  05D5  1316 	brw	_error_exit		; exit and signal error
                                     05D8  1317 100$:
                                 05  05D8  1318 	rsb				; end of block-read
                                     05D9  1319 
                                     05D9  1320 
                                     05D9  1321 ;+++
                                     05D9  1322 ;k> block-write -- ( l a -- ) Write block `l' from buffer at address `a'.
                                     05D9  1323 ;---
                                     05D9  1324 	header	i_block_write,<block-write>
                           000005A8' 05D9       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000005D9  05DD       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000B  05DD       	.nchr  nchr, ^\block-write\	; nchr = length( block-write )
                           0000000B  05DD       	.if    le, nchr		; nchr <= 0
                                     05DD       	   .ascic \i_block_write\	; no auxillary block-write, use principle one
                                     05DD       	.if_false		; else
65 74 69 72 77 2D 6B 63 6F 6C 62 00' 05DD       	  .ascic \block-write\		; use auxillary block-write
                                 0B  05DD       
                                     05E9       	.endc			; end if
                                     05E9       i_block_write:			; use block-write of word as vl_kernel label
                                     05E9       	
                            8B   D0  05E9  1325 	movl	(r11)+,-		; get buffer address
                   00001B58'EF       05EB  1326 		v_blkrab+rab$l_rbf	;   into rab
                            8B   D0  05F0  1327 	movl	(r11)+,-		; get VTIL block (rms record) number
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  72
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                   00001B74'EF       05F2  1328 		v_blkkey		;   into key buffer
                       0400 8F   B0  05F7  1329 	movw	#c_block_size,-		; get proper VTIL block (rms record)
                   00001B52'EF       05FB  1330 		v_blkrab+rab$w_rsz	;   size into fab
                                     0600  1331 	$find	rab=v_blkrab		; find the correct block
                                     0600       		$RMSCALL	FIND,v_blkrab,,
                                     0600       	.GLOBL	SYS$FIND
                                     0600       	.IF	B <v_blkrab>
                                     0600       	CALLG	(AP),G^SYS$FIND
                                     0600       	$$.TMP=0
                                     0600       	.IF	NB <>
                                     0600       	$$.TMP=1
                                     0600       	.ENDC
                                     0600       	.IF	NB <>
                                     0600       	$$.TMP=1
                                     0600       	.ENDC
                                     0600       	.IF	NE $$.TMP
                                     0600       	.ERROR				; v_blkrab= parameter missing;
                                     0600       	.ENDC
                                     0600       	.ENDC
                                     0600       	.IF	NB <v_blkrab>
                           00000001  0600       	$$.TMP1=1
                                     0600       	.IF	NB <>
                                     0600       	PUSHAL	
                                     0600       	$$.TMP1=3
                                     0600       	.ENDC
                                     0600       	.IF	NB <>
                                     0600       	PUSHAL	
                                     0600       	.IF	EQ <$$.TMP1-1>
                                     0600       	$$.TMP1=2
                                     0600       	.ENDC
                                     0600       	.IFF
                           FFFFFFFE  0600       	.IF	EQ <$$.TMP1-3>
                                     0600       	PUSHL	#0
                                     0600       	.ENDC
                                     0600       	.ENDC
                           000000CF  0600       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  0600       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0600       	PUSHL	v_blkrab
                                     0600       	.IFF
                           000000B0  0600       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0600       	PUSHL	v_blkrab
                                     0600       	.IFF
                   00001B30'EF   DF  0600       	PUSHAL	v_blkrab
                                     0606       	.ENDC
                                     0606       	.ENDC
              00000000'GF   01   FB  0606       	CALLS	#$$.TMP1,G^SYS$FIND
                                     060D       	.ENDC
                                     060D       	
                                     060D       	
                                     060D  1332 	$update	rab=v_blkrab		; write the block
                                     060D       		$RMSCALL	UPDATE,v_blkrab,,
                                     060D       	.GLOBL	SYS$UPDATE
                                     060D       	.IF	B <v_blkrab>
                                     060D       	CALLG	(AP),G^SYS$UPDATE
                                     060D       	$$.TMP=0
                                     060D       	.IF	NB <>
                                     060D       	$$.TMP=1
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  73
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     060D       	.ENDC
                                     060D       	.IF	NB <>
                                     060D       	$$.TMP=1
                                     060D       	.ENDC
                                     060D       	.IF	NE $$.TMP
                                     060D       	.ERROR				; v_blkrab= parameter missing;
                                     060D       	.ENDC
                                     060D       	.ENDC
                                     060D       	.IF	NB <v_blkrab>
                           00000001  060D       	$$.TMP1=1
                                     060D       	.IF	NB <>
                                     060D       	PUSHAL	
                                     060D       	$$.TMP1=3
                                     060D       	.ENDC
                                     060D       	.IF	NB <>
                                     060D       	PUSHAL	
                                     060D       	.IF	EQ <$$.TMP1-1>
                                     060D       	$$.TMP1=2
                                     060D       	.ENDC
                                     060D       	.IFF
                           FFFFFFFE  060D       	.IF	EQ <$$.TMP1-3>
                                     060D       	PUSHL	#0
                                     060D       	.ENDC
                                     060D       	.ENDC
                           000000CF  060D       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  060D       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     060D       	PUSHL	v_blkrab
                                     060D       	.IFF
                           000000B0  060D       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     060D       	PUSHL	v_blkrab
                                     060D       	.IFF
                   00001B30'EF   DF  060D       	PUSHAL	v_blkrab
                                     0613       	.ENDC
                                     0613       	.ENDC
              00000000'GF   01   FB  0613       	CALLS	#$$.TMP1,G^SYS$UPDATE
                                     061A       	.ENDC
                                     061A       	
                                     061A       	
                         03 50   E8  061A  1333 	blbs	r0,100$			; no errors, go on
                          1538   31  061D  1334 	brw	_error_exit		; exit and signal error
                                     0620  1335 100$:
                                 05  0620  1336 	rsb				; end of block-write
                                     0621  1337 
                                     0621  1338 
                                     0621  1339 ;+++
                                     0621  1340 ;k> break -- ( -- ) Breakpoint!	 For use in debugging kernel and compiler.
                                     0621  1341 ;	This word should only be executed when running in the VAX/VMS Debugger.
                                     0621  1342 ;---
                                     0621  1343 	header	break
                           000005D9' 0621       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000621  0625       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0625       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0625       	.if    le, nchr		; nchr <= 0
                  6B 61 65 72 62 00' 0625       	   .ascic \break\	; no auxillary , use principle one
                                 05  0625       
                                     062B       	.if_false		; else
                                     062B       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  74
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     062B       	.endc			; end if
                                     062B       break:			; use  of word as vl_kernel label
                                     062B       	
                                 03  062B  1344 	bpt				; breakpoint
                                 05  062C  1345 	rsb				; end of break
                                     062D  1346 
                                     062D  1347 
                                     062D  1348 ;+++
                                     062D  1349 ;k> bs@ -- ( a -- l ) Fetch byte at `a' and sign extend it to longword on stack.
                                     062D  1350 ;---
                                     062D  1351 	header	i_bs_fetch,<bs@>
                           00000621' 062D       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000062D  0631       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  0631       	.nchr  nchr, ^\bs@\	; nchr = length( bs@ )
                           00000003  0631       	.if    le, nchr		; nchr <= 0
                                     0631       	   .ascic \i_bs_fetch\	; no auxillary bs@, use principle one
                                     0631       	.if_false		; else
                        40 73 62 00' 0631       	  .ascic \bs@\		; use auxillary bs@
                                 03  0631       
                                     0635       	.endc			; end if
                                     0635       i_bs_fetch:			; use bs@ of word as vl_kernel label
                                     0635       	
                    6B   00 BB   98  0635  1352 	cvtbl	@(r11),(r11)		; sign extend it
                                 05  0639  1353 	rsb				; end of bs@
                                     063A  1354 
                                     063A  1355 
                                     063A  1356 ;+++
                                     063A  1357 ;k> buffer -- ( l -- a ) Get buffer at `a' that will be written to block `l'.
                                     063A  1358 ;---
                                     063A  1359 	header	buffer
                           0000062D' 063A       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000063A  063E       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  063E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  063E       	.if    le, nchr		; nchr <= 0
               72 65 66 66 75 62 00' 063E       	   .ascic \buffer\	; no auxillary , use principle one
                                 06  063E       
                                     0645       	.if_false		; else
                                     0645       	  .ascic \\		; use auxillary 
                                     0645       	.endc			; end if
                                     0645       buffer:			; use  of word as vl_kernel label
                                     0645       	
                                     0645  1360 ; Is the block already in memory?
                            50   D4  0645  1361 	clrl   r0			; start with buffer 0
                                     0647  1362 10$:
                            6B   D1  0647  1363 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       0649  1364 		v_buf_blk_nums[r0]	;   block we are looking for?
                            44   13  064F  1365 	beql	100$			; yes, go on
                    F2 50   03   F2  0651  1366 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     0655  1367 ;
                                     0655  1368 ; not in memory, so we have to get it in
                                     0655  1369 ;
                                     0655  1370 ; Are there unused buffers?
                            50   D4  0655  1371 	clrl	r0			; start with buffer 0
                                     0657  1372 20$:
                 00001B7D'EF40   95  0657  1373 	tstb	v_buf_inuse[r0]		; Is it in use?
                            25   13  065E  1374 	beql	90$			; no, read block into it
                    F3 50   03   F2  0660  1375 	aoblss	#c_max_blocks,r0,20$	; move to the next buffer, if any
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  75
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0664  1376 ; Are there any unmodified buffers?
                            50   D4  0664  1377 	clrl	r0
                                     0666  1378 30$:
                            02   91  0666  1379 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       0668  1380 		v_buf_inuse[r0]		;   been modified?
                            15   12  066E  1381 	bneq	90$			; no, read block into it
                    F2 50   03   F2  0670  1382 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     0674  1383 ; all buffers are modified, so we must write one out and use it.
                            50   D4  0674  1384 	clrl	r0			; for now, always use zero'th one
                       7A   50   D0  0676  1385 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  0679  1386 	movl	r0,-(r11)		; set up for buffer-write
                   000006F8'EF   16  067C  1387 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0682  1388 	movl	(r10)+,r0		; get the buffer number back
                                     0685  1389 ;
                                     0685  1390 ; come here with bloc## on stack and buffer# in r0.
                                     0685  1391 ;
                                     0685  1392 90$:
                                     0685  1393 ; save block info
                            6B   D0  0685  1394 	movl	(r11),-			; Save the new block number in
                 00001B80'EF40       0687  1395 		v_buf_blk_nums[r0]	;   buffer
                            01   90  068D  1396 	movb	#c_inuse,-		; Flag that buffer is in use
                 00001B7D'EF40       068F  1397 		v_buf_inuse[r0]
                                     0695  1398 
                                     0695  1399 100$:
                                     0695  1400 ; leave address of buffer on stack
         6B   00000400 8F   50   C5  0695  1401 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  069D  1402 	addl2	#v_blkbuff,(r11)	; calculate address of `r0'th buffer
              00001B79'EF   50   D0  06A4  1403 	movl	r0,v_current_buff	; mark this as most current block
                                 05  06AB  1404 	rsb				; end of buffer
                                     06AC  1405 
                                     06AC  1406 
                                     06AC  1407 ;+++
                                     06AC  1408 ;k> buffer-read -- ( n -- a ) read into a block into buffer `n'.  The block
                                     06AC  1409 ;	number is already in the buffer.  Leave `a', the address of the
                                     06AC  1410 ;	block buffer.  This word assumes that buffer is correctly set up
                                     06AC  1411 ;	(block number, etc).
                                     06AC  1412 ;---
                                     06AC  1413 	header	i_buffer_read,<buffer-read>
                           0000063A' 06AC       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000006AC  06B0       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000B  06B0       	.nchr  nchr, ^\buffer-read\	; nchr = length( buffer-read )
                           0000000B  06B0       	.if    le, nchr		; nchr <= 0
                                     06B0       	   .ascic \i_buffer_read\	; no auxillary buffer-read, use principle one
                                     06B0       	.if_false		; else
64 61 65 72 2D 72 65 66 66 75 62 00' 06B0       	  .ascic \buffer-read\		; use auxillary buffer-read
                                 0B  06B0       
                                     06BC       	.endc			; end if
                                     06BC       i_buffer_read:			; use buffer-read of word as vl_kernel label
                                     06BC       	
                       50   8B   D0  06BC  1414 	movl	(r11)+,r0		; get buffer number
              00001B79'EF   50   D0  06BF  1415 	movl	r0,v_current_buff	; save buffer number as most current
         51   00000400 8F   50   C5  06C6  1416 	mull3	r0,#c_block_size,r1	; offset to `r0'th buffer
         7B   00004000'8F   51   C1  06CE  1417 	addl3	r1,#v_blkbuff,-(r11)	; put address of buffer on stack
                                     06D6  1418 					; this is left after exit
            7B   00001B80'EF40   D0  06D6  1419 	movl	v_buf_blk_nums[r0],-	; number of block
                                     06DE  1420 		-(r11)			;   to read
                    7B   04 AB   D0  06DE  1421 	movl	4(r11),-(r11)		; get another copy of the buffer address
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  76
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       FED1 CF   16  06E2  1422 	jsb	i_block_read		; read the block
                                 05  06E6  1423 	rsb				; end of buffer-read
                                     06E7  1424 
                                     06E7  1425 
                                     06E7  1426 ;+++
                                     06E7  1427 ;k> buffer-write -- ( n -- ) write block in buffer number n to file.
                                     06E7  1428 ;	Note that the block number is in the buffer already.
                                     06E7  1429 ;---
                                     06E7  1430 	header	i_buffer_write,<buffer-write>
                           000006AC' 06E7       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000006E7  06EB       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000C  06EB       	.nchr  nchr, ^\buffer-write\	; nchr = length( buffer-write )
                           0000000C  06EB       	.if    le, nchr		; nchr <= 0
                                     06EB       	   .ascic \i_buffer_write\	; no auxillary buffer-write, use principle one
                                     06EB       	.if_false		; else
74 69 72 77 2D 72 65 66 66 75 62 00' 06EB       	  .ascic \buffer-write\		; use auxillary buffer-write
                                 65  06F7       
                                 0C  06EB       
                                     06F8       	.endc			; end if
                                     06F8       i_buffer_write:			; use buffer-write of word as vl_kernel label
                                     06F8       	
                       50   8B   D0  06F8  1431 	movl	(r11)+,r0		; get buffer number
            7B   00001B80'EF40   D0  06FB  1432 	movl	v_buf_blk_nums[r0],-	; number of block
                                     0703  1433 		-(r11)			;   to write
         51   00000400 8F   50   C5  0703  1434 	mull3	r0,#c_block_size,r1	; offset into the buffer buffer
         7B   00004000'8F   51   C1  070B  1435 	addl3	r1,#v_blkbuff,-(r11)	; address of buffer to write
                                     0713  1436 					; this is left after exit
                       FED2 CF   16  0713  1437 	jsb	i_block_write		; write the block
                                 05  0717  1438 	rsb				; end of buffer-write
                                     0718  1439 
                                     0718  1440 
                                     0718  1441 ;+++
                                     0718  1442 ;k> byte -- ( n -- ) Creates word that pushes address of byte on stack.
                                     0718  1443 ;---
                                     0718  1444 	header	byte,<byte>
                           000006E7' 0718       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000718  071C       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  071C       	.nchr  nchr, ^\byte\	; nchr = length( byte )
                           00000004  071C       	.if    le, nchr		; nchr <= 0
                                     071C       	   .ascic \byte\	; no auxillary byte, use principle one
                                     071C       	.if_false		; else
                     65 74 79 62 00' 071C       	  .ascic \byte\		; use auxillary byte
                                 04  071C       
                                     0721       	.endc			; end if
                                     0721       byte:			; use byte of word as vl_kernel label
                                     0721       	
                   00000842'EF   16  0721  1445 	jsb	create			; enclose next token in dictionary
                    89   9E 8F   90  0727  1446 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  072B  1447 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  072F  1448 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0732  1449 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0736  1450 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  0739  1451 	movb	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  073C  1452 	addl2	#4,r11			; pop argument
                                 05  073F  1453 	rsb				; end of byte
                                     0740  1454 
                                     0740  1455 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  77
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0740  1456 ;+++t
                                     0740  1457 ;k> cfa -- ( a -- a ) given addrss of header of word, return the address of
                                     0740  1458 ;	the code for that word (i.e., the Code Field Address).
                                     0740  1459 ;---
                                     0740  1460 ;??? the smudge bit makes this one a little harder.
                                     0740  1461 	header	cfa
                           00000718' 0740       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000740  0744       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0744       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0744       	.if    le, nchr		; nchr <= 0
                        61 66 63 00' 0744       	   .ascic \cfa\	; no auxillary , use principle one
                                 03  0744       
                                     0748       	.if_false		; else
                                     0748       	  .ascic \\		; use auxillary 
                                     0748       	.endc			; end if
                                     0748       cfa:			; use  of word as vl_kernel label
                                     0748       	
                       6B   04   C0  0748  1462 	addl2	#4,(r11)		; skip over link field
                    50   00 BB   9A  074B  1463 	movzbl	@(r11),r0		; get unsigned byte-count of name
                    50   80 8F   8A  074F  1464 	bicb2	#^b10000000,r0		; clear smudge bit of count
                            6B   D6  0753  1465 	incl	(r11)			; skip over count byte
                       6B   50   C0  0755  1466 	addl2	r0,(r11)		; skip over name field
                                 05  0758  1467 	rsb				; end of cfa
                                     0759  1468 
                                     0759  1469 
                                     0759  1470 ;+++
                                     0759  1471 ;k> clist -- ( -- ) list compiler vocabulary.
                                     0759  1472 ;---
                                     0759  1473 	header	clist
                           00000740' 0759       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000759  075D       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  075D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  075D       	.if    le, nchr		; nchr <= 0
                  74 73 69 6C 63 00' 075D       	   .ascic \clist\	; no auxillary , use principle one
                                 05  075D       
                                     0763       	.if_false		; else
                                     0763       	  .ascic \\		; use auxillary 
                                     0763       	.endc			; end if
                                     0763       clist:			; use  of word as vl_kernel label
                                     0763       	
              7B   00001D3F'EF   D0  0763  1474 	movl	v_compiler,-(r11)	; get address of most recent word
                                     076A  1475 					;   in compiler vocabulary
                                     076A  1476 10$:
                            6B   D5  076A  1477 	tstl	(r11)			; nil pointer?
                            24   13  076C  1478 	beql	100$			; yes, exit loop
                  7B   04   6B   C1  076E  1479 	addl3	(r11),#4,-(r11)		; get address of name field
                       FCFF CF   16  0772  1480 	jsb	bcount			; set up for write
                       7B   6B   D0  0776  1481 	movl	(r11),-(r11)		; set up for ?cr
                       FB88 CF   16  0779  1482 	jsb	q_n_cr			; start new line if word is too long
                   00001450'EF   16  077D  1483 	jsb	write			; tell user
                       71   20   D0  0783  1484 	movl	#c_blank,-(r1)		; blank to separate words
                   00000DEE'EF   16  0786  1485 	jsb	putc			; output it
                    6B   00 BB   D0  078C  1486 	movl	@(r11),(r11)		; get previous word's lfa
                            D8   11  0790  1487 	brb	10$			; try it again
                                     0792  1488 100$:
                       5B   04   C0  0792  1489 	addl2	#4,r11			; pop pointer off stack
                                 05  0795  1490 	rsb				; end of clist
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  78
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0796  1491 
                                     0796  1492 
                                     0796  1493 ;+++t
                                     0796  1494 ;k> compile-jsb ( a -- ) compile a jump to subroutine to location `a'.
                                     0796  1495 ;---
                                     0796  1496 ;??? At the moment this uses absolute mode.  Should it use displacment
                                     0796  1497 ; off a register so that it can be ?relocatable (like stoic)?  Or should it
                                     0796  1498 ; use a brw (which I'm not sure would work in { defer< ... >defer }.
                                     0796  1499 	header	   i_compile_jsb,<compile-jsb>
                           00000759' 0796       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000796  079A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000B  079A       	.nchr  nchr, ^\compile-jsb\	; nchr = length( compile-jsb )
                           0000000B  079A       	.if    le, nchr		; nchr <= 0
                                     079A       	   .ascic \i_compile_jsb\	; no auxillary compile-jsb, use principle one
                                     079A       	.if_false		; else
62 73 6A 2D 65 6C 69 70 6D 6F 63 00' 079A       	  .ascic \compile-jsb\		; use auxillary compile-jsb
                                 0B  079A       
                                     07A6       	.endc			; end if
                                     07A6       i_compile_jsb:			; use compile-jsb of word as vl_kernel label
                                     07A6       	
                       89   16   90  07A6  1500 	movb	   #op_jsb,(r9)+	; `jsb'
                    69   9F 8F   90  07A9  1501 	movb	   #adm_absolute,(r9)	; absolute mode
                       89   8B   D0  07AD  1502 	movl	   (r11)+,(r9)+		; save place to jump to in dictionary
                                 05  07B0  1503 	rsb				; end of compile-jsb
                                     07B1  1504 
                                     07B1  1505 
                                     07B1  1506 ;+++
                                     07B1  1507 ;k> compiletime -- ( -- ) move word defined to the compiler vocabulary.
                                     07B1  1508 ;	This word unlinks the last word in the current vocabulary and
                                     07B1  1509 ;	links it to the compiler vocabulary.  Compiiler words are *never*
                                     07B1  1510 ;	executed during execute mode.
                                     07B1  1511 ;---
                                     07B1  1512 	header	compiletime
                           00000796' 07B1       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000007B1  07B5       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  07B5       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07B5       	.if    le, nchr		; nchr <= 0
65 6D 69 74 65 6C 69 70 6D 6F 63 00' 07B5       	   .ascic \compiletime\	; no auxillary , use principle one
                                 0B  07B5       
                                     07C1       	.if_false		; else
                                     07C1       	  .ascic \\		; use auxillary 
                                     07C1       	.endc			; end if
                                     07C1       compiletime:			; use  of word as vl_kernel label
                                     07C1       	
              50   00001D3B'FF   D0  07C1  1513 	movl	@v_current,r0		; save pointer to word we a unlinking
              00001D3B'FF   60   D0  07C8  1514 	movl	(r0),@v_current		; make current previous word in vocab
              60   00001D3F'EF   D0  07CF  1515 	movl	v_compiler,(r0)		; link word to prev in compiler vocab
              00001D3F'EF   50   D0  07D6  1516 	movl	r0,v_compiler		; make v_compiler point to new word
                                 05  07DD  1517 	rsb				; end of compiletime
                                     07DE  1518 ;??? Should I also have immediate words, that execute in *both* compile
                                     07DE  1519 ; mode and execute mode?  This would require some sort of attribute flag,
                                     07DE  1520 ; which would have to be checked during compilation.  It would allow
                                     07DE  1521 ; considerably more flexibility (remember how % started out a word and ended
                                     07DE  1522 ; up part of _interpreter because it was either compiletime or runtime?).
                                     07DE  1523 ;??? Much beter idea.  Have a compile buffer like STOIC and have only
                                     07DE  1524 ; compiletime and runtime words, both of which are in the same vocabulary.
                                     07DE  1525 ; If not inside a { : ... ; }, do a jsb at the end of the line? if in colon
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  79
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     07DE  1526 ; definition, copy it to the dictionary and update dictionary links.
                                     07DE  1527 ; Have to think about this.
                                     07DE  1528 
                                     07DE  1529 
                                     07DE  1530 ;+++
                                     07DE  1531 ;k> context -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     07DE  1532 ;	vocabulary in which we currently search for words (the `context').
                                     07DE  1533 ;---
                                     07DE  1534 	header	context
                           000007B1' 07DE       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000007DE  07E2       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  07E2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07E2       	.if    le, nchr		; nchr <= 0
            74 78 65 74 6E 6F 63 00' 07E2       	   .ascic \context\	; no auxillary , use principle one
                                 07  07E2       
                                     07EA       	.if_false		; else
                                     07EA       	  .ascic \\		; use auxillary 
                                     07EA       	.endc			; end if
                                     07EA       context:			; use  of word as vl_kernel label
                                     07EA       	
              7B   00001D37'EF   DE  07EA  1535 	moval	v_context,-(r11)	; move address of pointer to vocab
                                     07F1  1536 					; that is searched when defining
                                     07F1  1537 					; to stack
                                 05  07F1  1538 	rsb				; end of context
                                     07F2  1539 
                                     07F2  1540 
                                     07F2  1541 ;+++
                                     07F2  1542 ;k> count -- ( a1 -- a2 n ) Given word-counted string at `a' returns
                                     07F2  1543 ;	address of characters in string and string's length on top of stack.
                                     07F2  1544 ;---
                                     07F2  1545 	header	count
                           000007DE' 07F2       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000007F2  07F6       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  07F6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07F6       	.if    le, nchr		; nchr <= 0
                  74 6E 75 6F 63 00' 07F6       	   .ascic \count\	; no auxillary , use principle one
                                 05  07F6       
                                     07FC       	.if_false		; else
                                     07FC       	  .ascic \\		; use auxillary 
                                     07FC       	.endc			; end if
                                     07FC       count:			; use  of word as vl_kernel label
                                     07FC       	
                    50   00 BB   3C  07FC  1546 	movzwl	@(r11),r0		; get length of string
                       6B   02   C0  0800  1547 	addl2	#2,(r11)		; move pointer to first character
                       7B   50   D0  0803  1548 	movl	r0,-(r11)		; put count on top of stack
                                 05  0806  1549 	rsb				; end of count
                                     0807  1550 
                                     0807  1551 
                                     0807  1552 ;+++
                                     0807  1553 ;k> cr -- ( -- )  Start new output line (C_arriage R_eturn).
                                     0807  1554 ;---
                                     0807  1555 	header	cr
                           000007F2' 0807       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000807  080B       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  080B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  080B       	.if    le, nchr		; nchr <= 0
                           72 63 00' 080B       	   .ascic \cr\	; no auxillary , use principle one
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  80
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 02  080B       
                                     080E       	.if_false		; else
                                     080E       	  .ascic \\		; use auxillary 
                                     080E       	.endc			; end if
                                     080E       cr:			; use  of word as vl_kernel label
                                     080E       	
              7B   00001B9A'EF   9E  080E  1556 	movab	v_outbuf,-(r11)		; move address of output buffer on stack
              7B   00001B98'EF   3C  0815  1557 	movzwl	v_outlen,-(r11)		; put count on stack
           02 AB   00001B96'EF   B0  081C  1558 	movw	v_static_dsc,2(r11)	; put middle of descriptor on ~~~ Is this correct?
                            5B   DD  0824  1559 	pushl	r11			; push address of output descriptor
              00000000'GF   01   FB  0826  1560 	calls	#1,g^lib$put_output	; output it~~~ Really should check the return value!!!
                       5B   08   C0  082D  1561 	addl2	#8,r11			; pop descriptor off stack
                   00001B98'EF   B4  0830  1562 	clrw	v_outlen		; clear output length
                                 05  0836  1563 	rsb				; end of cr
                                     0837  1564 
                                     0837  1565 
                                     0837  1566 ;+++t
                                     0837  1567 ;k> create -- ( -- ) Enclose next token in input stream in the dictionary,
                                     0837  1568 ;	truncating it if it is too long.
                                     0837  1569 ;---
                                     0837  1570 	header	create
                           00000807' 0837       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000837  083B       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  083B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  083B       	.if    le, nchr		; nchr <= 0
               65 74 61 65 72 63 00' 083B       	   .ascic \create\	; no auxillary , use principle one
                                 06  083B       
                                     0842       	.if_false		; else
                                     0842       	  .ascic \\		; use auxillary 
                                     0842       	.endc			; end if
                                     0842       create:			; use  of word as vl_kernel label
                                     0842       	
              69   00001D3B'FF   D0  0842  1571 	movl	@v_current,(r9)		; make link field
              00001D3B'FF   59   D0  0849  1572 	movl	r9,@v_current		; make vocab point to here, newest word
                       59   04   C0  0850  1573 	addl2	#4,r9			; move eodp over link field
                       7B   20   D0  0853  1574 	movl	#c_blank,-(r11)		; set up to get blank separated token
                   000012E2'EF   16  0856  1575 	jsb	token			; get token
              69   00000050 8F   D1  085C  1576 	cmpl	#c_max_name_len,(r9)	; is the name over the maximum length?
                            46   12  0863  1577 	bneq	10$			; no, go on
              7B   000018D8'EF   9E  0865  1578 	movab	v_nametoolong,-(r11)	; address of error message on stack
                       FC05 CF   16  086C  1579 	jsb	bcount			; get ( addr count )
                   00001450'EF   16  0870  1580 	jsb	write			; write out message
                  7B   59   01   C1  0876  1581 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9E  087A  1582 	movab	(r9),-(r11)		; count of name
                   00001450'EF   16  087D  1583 	jsb	write			; write out untruncated name
                         88 AF   16  0883  1584 	jsb	cr			; start new line
              69   00000050 8F   D0  0886  1585 	movl	#c_max_name_len,(r9)	; truncate name
              7B   000018E8'EF   9E  088D  1586 	movab	v_nametrunc,-(r11)	; get address of stack
                       FBDD CF   16  0894  1587 	jsb	bcount			; get ( addr count )
                   00001450'EF   16  0898  1588 	jsb	write			; write out message
                  7B   59   01   C1  089E  1589 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9A  08A2  1590 	movzbl	(r9),-(r11)		; count of name
                   00001450'EF   16  08A5  1591 	jsb	write			; write out truncated name
                                     08AB  1592 10$:
                       50   89   9A  08AB  1593 	movzbl	(r9)+,r0		; get byte length and move over it
                       59   50   C0  08AE  1594 	addl2	r0,r9			; move over string
                       69   05   90  08B1  1595 	movb	#op_rsb,(r9)		; stick a `rsb' in just in case
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  81
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 05  08B4  1596 	rsb				; end of create
                                     08B5  1597 
                                     08B5  1598 
                                     08B5  1599 ;+++
                                     08B5  1600 ;k> current -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     08B5  1601 ;	vocabulary we link new words into.
                                     08B5  1602 ;---
                                     08B5  1603 	header	current
                           00000837' 08B5       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000008B5  08B9       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  08B9       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08B9       	.if    le, nchr		; nchr <= 0
            74 6E 65 72 72 75 63 00' 08B9       	   .ascic \current\	; no auxillary , use principle one
                                 07  08B9       
                                     08C1       	.if_false		; else
                                     08C1       	  .ascic \\		; use auxillary 
                                     08C1       	.endc			; end if
                                     08C1       current:			; use  of word as vl_kernel label
                                     08C1       	
              7B   00001D3B'EF   DE  08C1  1604 	moval	v_current,-(r11)	; move address (of pointer to vocab
                                     08C8  1605 					; that new words are linked to when
                                     08C8  1606 					; defining) to stack
                                 05  08C8  1607 	rsb				; end of current
                                     08C9  1608 
                                     08C9  1609 
                                     08C9  1610 ;+++
                                     08C9  1611 ;k> decimal -- ( -- ) Set base to decimal.
                                     08C9  1612 ;---
                                     08C9  1613 	header	decimal
                           000008B5' 08C9       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000008C9  08CD       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  08CD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08CD       	.if    le, nchr		; nchr <= 0
            6C 61 6D 69 63 65 64 00' 08CD       	   .ascic \decimal\	; no auxillary , use principle one
                                 07  08CD       
                                     08D5       	.if_false		; else
                                     08D5       	  .ascic \\		; use auxillary 
                                     08D5       	.endc			; end if
                                     08D5       decimal:			; use  of word as vl_kernel label
                                     08D5       	
              00001D4E'EF   0A   D0  08D5  1614 	movl	#10,v_radix		; switch to base 10
                                 05  08DC  1615 	rsb				; end of decimal
                                     08DD  1616 
                                     08DD  1617 
                                     08DD  1618 ;+++
                                     08DD  1619 ;k> definitions -- ( -- )  Sets curren to context. { <name> definitions }
                                     08DD  1620 ;	makes all new words link into vocabulary { <name> }
                                     08DD  1621 ;	(i.e., new operators will be linked dictionary currently being searched).
                                     08DD  1622 ;---
                                     08DD  1623 	header	definitions
                           000008C9' 08DD       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000008DD  08E1       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  08E1       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08E1       	.if    le, nchr		; nchr <= 0
73 6E 6F 69 74 69 6E 69 66 65 64 00' 08E1       	   .ascic \definitions\	; no auxillary , use principle one
                                 0B  08E1       
                                     08ED       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  82
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     08ED       	  .ascic \\		; use auxillary 
                                     08ED       	.endc			; end if
                                     08ED       definitions:			; use  of word as vl_kernel label
                                     08ED       	
     00001D3B'EF   00001D37'EF   D0  08ED  1624 	movl	v_context, v_current
                                 05  08F8  1625 	rsb				; end of definitions
                                     08F9  1626 
                                     08F9  1627 
                                     08F9  1628 ;+++
                                     08F9  1629 ;k> drop -- ( n -- ) Drop the top stack item.
                                     08F9  1630 ;---
                                     08F9  1631 	header	drop
                           000008DD' 08F9       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000008F9  08FD       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  08FD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08FD       	.if    le, nchr		; nchr <= 0
                     70 6F 72 64 00' 08FD       	   .ascic \drop\	; no auxillary , use principle one
                                 04  08FD       
                                     0902       	.if_false		; else
                                     0902       	  .ascic \\		; use auxillary 
                                     0902       	.endc			; end if
                                     0902       drop:			; use  of word as vl_kernel label
                                     0902       	
                       5B   04   C0  0902  1632 	addl2	#4,r11			; pop argument, dropping top item
                                 05  0905  1633 	rsb				; end of drop
                                     0906  1634 
                                     0906  1635 
                                     0906  1636 ;+++
                                     0906  1637 ;k> ds>ls -- ( n -- ) move `n' to loop stack.
                                     0906  1638 ;---
                                     0906  1639 	header	i_ds_to_ls,^/ds>ls/
                           000008F9' 0906       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000906  090A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  090A       	.nchr  nchr, ^\ds>ls\	; nchr = length( ds>ls )
                           00000005  090A       	.if    le, nchr		; nchr <= 0
                                     090A       	   .ascic \i_ds_to_ls\	; no auxillary ds>ls, use principle one
                                     090A       	.if_false		; else
                  73 6C 3E 73 64 00' 090A       	  .ascic \ds>ls\		; use auxillary ds>ls
                                 05  090A       
                                     0910       	.endc			; end if
                                     0910       i_ds_to_ls:			; use ds>ls of word as vl_kernel label
                                     0910       	
                       7A   8B   D0  0910  1640 	movl	(r11)+,-(r10)		; pop from dstack, move to lstack.
                                 05  0913  1641 	rsb				; end of ds>ls
                                     0914  1642 
                                     0914  1643 
                                     0914  1644 ;+++
                                     0914  1645 ;k> dup -- ( n -- n n ) Duplicated the top stack entry.
                                     0914  1646 ;---
                                     0914  1647 	header	dup
                           00000906' 0914       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000914  0918       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0918       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0918       	.if    le, nchr		; nchr <= 0
                        70 75 64 00' 0918       	   .ascic \dup\	; no auxillary , use principle one
                                 03  0918       
                                     091C       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  83
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     091C       	  .ascic \\		; use auxillary 
                                     091C       	.endc			; end if
                                     091C       dup:			; use  of word as vl_kernel label
                                     091C       	
                       7B   6B   D0  091C  1648 	movl	(r11),-(r11)
                                 05  091F  1649 	rsb				; end of dup
                                     0920  1650 
                                     0920  1651 
                                     0920  1652 ;+++
                                     0920  1653 ;k> empty-buffers -- ( -- ) Mark all buffers unmodified without writing.
                                     0920  1654 ;---
                                     0920  1655 	header	i_empty_buffers,<empty-buffers>
                           00000914' 0920       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000920  0924       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000D  0924       	.nchr  nchr, ^\empty-buffers\	; nchr = length( empty-buffers )
                           0000000D  0924       	.if    le, nchr		; nchr <= 0
                                     0924       	   .ascic \i_empty_buffers\	; no auxillary empty-buffers, use principle one
                                     0924       	.if_false		; else
65 66 66 75 62 2D 79 74 70 6D 65 00' 0924       	  .ascic \empty-buffers\		; use auxillary empty-buffers
                              73 72  0930       
                                 0D  0924       
                                     0932       	.endc			; end if
                                     0932       i_empty_buffers:			; use empty-buffers of word as vl_kernel label
                                     0932       	
                            50   D4  0932  1656 	clrl	r0			; buffer number
                                     0934  1657 10$:
                            00   90  0934  1658 	movb	#c_false,-		; mark with c_false to show
                 00001B7D'EF40       0936  1659 		v_buf_inuse[r0]		;   emptied, not in use
                            00   D0  093C  1660 	movl	#c_false,-		; mark with c_false to show
                 00001B80'EF40       093E  1661 		v_buf_blk_nums[r0]	;  holds no block number
                            02   F1  0944  1662 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFEA 50   01       0946  1663 		#1,r0,10$		; move to next buffer number, if any
                                 05  094A  1664 	rsb				; end of empty buffers
                                     094B  1665 
                                     094B  1666 
                                     094B  1667 ;
                                     094B  1668 ;??? Note: the `eodp' words are supplied so that the user can work with the
                                     094B  1669 ;	dictionary without having to know if eodp is a register or a variable.
                                     094B  1670 ;
                                     094B  1671 
                                     094B  1672 
                                     094B  1673 ;+++
                                     094B  1674 ;k> eodp -- ( -- a ) Return address of next free byte in dictionary.
                                     094B  1675 ;	Means "end of dictinary pointer".
                                     094B  1676 ;---
                                     094B  1677 	header	eodp
                           00000920' 094B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000094B  094F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  094F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  094F       	.if    le, nchr		; nchr <= 0
                     70 64 6F 65 00' 094F       	   .ascic \eodp\	; no auxillary , use principle one
                                 04  094F       
                                     0954       	.if_false		; else
                                     0954       	  .ascic \\		; use auxillary 
                                     0954       	.endc			; end if
                                     0954       eodp:			; use  of word as vl_kernel label
                                     0954       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  84
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       7B   59   D0  0954  1678 	movl	r9,-(r11)		; get
                                 05  0957  1679 	rsb				; end of eodp
                                     0958  1680 
                                     0958  1681 
                                     0958  1682 ;+++
                                     0958  1683 ;k> eodp! -- ( a -- ) Make `a' new value of end of dictionary  pointer.
                                     0958  1684 ;---
                                     0958  1685 	header	i_eod_store,<eodp!>
                           0000094B' 0958       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000958  095C       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  095C       	.nchr  nchr, ^\eodp!\	; nchr = length( eodp! )
                           00000005  095C       	.if    le, nchr		; nchr <= 0
                                     095C       	   .ascic \i_eod_store\	; no auxillary eodp!, use principle one
                                     095C       	.if_false		; else
                  21 70 64 6F 65 00' 095C       	  .ascic \eodp!\		; use auxillary eodp!
                                 05  095C       
                                     0962       	.endc			; end if
                                     0962       i_eod_store:			; use eodp! of word as vl_kernel label
                                     0962       	
                       59   8B   D0  0962  1686 	movl	(r11)+,r9		; make eodp = top of stack
                                 05  0965  1687 	rsb				; end of edop!
                                     0966  1688 
                                     0966  1689 
                                     0966  1690 ;+++
                                     0966  1691 ;k> eodp+! -- ( n -- ) Add `n' to end of dictionary pointer.
                                     0966  1692 ;---
                                     0966  1693 	header	i_eodp_plus_store,<eodp+!>
                           00000958' 0966       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000966  096A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000006  096A       	.nchr  nchr, ^\eodp+!\	; nchr = length( eodp+! )
                           00000006  096A       	.if    le, nchr		; nchr <= 0
                                     096A       	   .ascic \i_eodp_plus_store\	; no auxillary eodp+!, use principle one
                                     096A       	.if_false		; else
               21 2B 70 64 6F 65 00' 096A       	  .ascic \eodp+!\		; use auxillary eodp+!
                                 06  096A       
                                     0971       	.endc			; end if
                                     0971       i_eodp_plus_store:			; use eodp+! of word as vl_kernel label
                                     0971       	
                       59   8B   C0  0971  1694 	addl2	(r11)+,r9		; add top of stack to eodp
                                 05  0974  1695 	rsb				; end of eodp+!
                                     0975  1696 
                                     0975  1697 
                                     0975  1698 ;+++
                                     0975  1699 ;k> eve -- call up eve editor.	Format: { eve filename }.
                                     0975  1700 ;---
                                     0975  1701 	header	eve
                           00000966' 0975       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000975  0979       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0979       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0979       	.if    le, nchr		; nchr <= 0
                        65 76 65 00' 0979       	   .ascic \eve\	; no auxillary , use principle one
                                 03  0979       
                                     097D       	.if_false		; else
                                     097D       	  .ascic \\		; use auxillary 
                                     097D       	.endc			; end if
                                     097D       eve:			; use  of word as vl_kernel label
                                     097D       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  85
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       7B   20   D0  097D  1702 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012E2'EF   16  0980  1703 	jsb	token			; get the token
                       56   69   9A  0986  1704 	movzbl	(r9),r6			; save length
                  57   59   01   C1  0989  1705 	addl3	#1,r9,r7		; start of string
         00001C56'EF   67   56   28  098D  1706 	movc3	r6,(r7),v_tpu_com2	; move string into buffer
         00001CF6'EF   56   1C   A1  0995  1707 	addw3	#c_tpu_com_len,r6,-	; put length in descriptor
                                     099D  1708 		v_tpu_dsc
                   00001CF6'EF   7F  099D  1709 	pushaq	v_tpu_dsc		; push address of command
              00000000'GF   01   FB  09A3  1710 	calls	#1,g^tpu$tpu		; call tpu
                         01 50   E9  09AA  1711 	blbc	r0,10$			; ?error
                                 05  09AD  1712 	rsb				; no, exit
                                     09AE  1713 10$:					; yes, signal and patch
                            50   DD  09AE  1714 	pushl	r0			; set up for signal
              00000000'GF   01   FB  09B0  1715 	calls	#1,g^lib$signal		; signal it
                          1018   31  09B7  1716 	brw	r_warm_start		; patch VTIL to run
                                     09BA  1717 					; end of eve
                                     09BA  1718 
                                     09BA  1719 
                                     09BA  1720 ;+++
                                     09BA  1721 ;k> exit -- ( -- ) Exit VTIL.  Never returns.
                                     09BA  1722 ;---
                                     09BA  1723 	header	i_exit,<exit>
                           00000975' 09BA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000009BA  09BE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  09BE       	.nchr  nchr, ^\exit\	; nchr = length( exit )
                           00000004  09BE       	.if    le, nchr		; nchr <= 0
                                     09BE       	   .ascic \i_exit\	; no auxillary exit, use principle one
                                     09BE       	.if_false		; else
                     74 69 78 65 00' 09BE       	  .ascic \exit\		; use auxillary exit
                                 04  09BE       
                                     09C3       	.endc			; end if
                                     09C3       i_exit:			; use exit of word as vl_kernel label
                                     09C3       	
                          11C5   31  09C3  1724 	brw	_exit			; exit silently
                                     09C6  1725 
                                     09C6  1726 
                                     09C6  1727 ;+++
                                     09C6  1728 ;k> fill -- ( a w c -- l ) Fill `w' bytes from `a' with character `c'.
                                     09C6  1729 ;---
                                     09C6  1730 	header	fill
                           000009BA' 09C6       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000009C6  09CA       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  09CA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  09CA       	.if    le, nchr		; nchr <= 0
                     6C 6C 69 66 00' 09CA       	   .ascic \fill\	; no auxillary , use principle one
                                 04  09CA       
                                     09CF       	.if_false		; else
                                     09CF       	  .ascic \\		; use auxillary 
                                     09CF       	.endc			; end if
                                     09CF       fill:			; use  of word as vl_kernel label
                                     09CF       	
                       69   00   2C  09CF  1731 	movc5	#0,(r9),-		; srclen,src (use eodp just to be safe)
                            6B       09D2  1732 		(r11),-			; fill character
                 08 BB   04 AB       09D3  1733 		4(r11),@8(r11)		; destlen, dest
                       5B   0C   C0  09D7  1734 	addl2	#12,r11			; pop arguments
                                 05  09DA  1735 	rsb				; end of fill
                                     09DB  1736 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  86
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     09DB  1737 
                                     09DB  1738 ;+++
                                     09DB  1739 ;k> flush-buffers -- ( -- ) wite all modified buffers and mark them unmodified.
                                     09DB  1740 ;---
                                     09DB  1741 	header	i_flush_buffers,<flush-buffers>
                           000009C6' 09DB       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000009DB  09DF       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000D  09DF       	.nchr  nchr, ^\flush-buffers\	; nchr = length( flush-buffers )
                           0000000D  09DF       	.if    le, nchr		; nchr <= 0
                                     09DF       	   .ascic \i_flush_buffers\	; no auxillary flush-buffers, use principle one
                                     09DF       	.if_false		; else
65 66 66 75 62 2D 68 73 75 6C 66 00' 09DF       	  .ascic \flush-buffers\		; use auxillary flush-buffers
                              73 72  09EB       
                                 0D  09DF       
                                     09ED       	.endc			; end if
                                     09ED       i_flush_buffers:			; use flush-buffers of word as vl_kernel label
                                     09ED       	
                            50   D4  09ED  1742 	clrl	r0			; bufffer number
                                     09EF  1743 10$:
                            02   91  09EF  1744 	cmpb	#c_modified,-		; Has the buffer
                 00001B7D'EF40       09F1  1745 		v_buf_inuse[r0]		;   been modified?
                            15   12  09F7  1746 	bneq	20$			; no, skip it
                       7A   50   D0  09F9  1747 	movl	r0,-(r10)		; save the buffer name
                       7B   50   D0  09FC  1748 	movl	r0,-(r11)		; set up for buffer-write
                       FCF5 CF   16  09FF  1749 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0A03  1750 	movl	(r10)+,r0		; get the buffer number back
                            00   90  0A06  1751 	movb	#c_false,-		; mark the buffer as
                 00001B7D'EF40       0A08  1752 		v_buf_inuse[r0]		;   flushed, not in use
                                     0A0E  1753 20$:
                            02   F1  0A0E  1754 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFDB 50   01       0A10  1755 		#1,r0,10$		; move to next buffer number, if any
                                 05  0A14  1756 	rsb				; end of flush-buffers
                                     0A15  1757 
                                     0A15  1758 
                                     0A15  1759 ;+++
                                     0A15  1760 ;k> forget -- ( -- ) reset content vocab back to word before word forgotten.
                                     0A15  1761 ;	Note that while this makes the forgotten word and any words
                                     0A15  1762 ;	defined after it unavailale, it does not reclaim an space,
                                     0A15  1763 ;	since the other vocabularies can be threaded through in the
                                     0A15  1764 ;	dictionary between words of this vocabulary.
                                     0A15  1765 ;---
                                     0A15  1766 ;??? Should I make { forget } = { forget/erase }?  Why did I make both
                                     0A15  1767 ; in the first place?
                                     0A15  1768 	header	forget
                           000009DB' 0A15       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000A15  0A19       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0A19       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0A19       	.if    le, nchr		; nchr <= 0
               74 65 67 72 6F 66 00' 0A19       	   .ascic \forget\	; no auxillary , use principle one
                                 06  0A19       
                                     0A20       	.if_false		; else
                                     0A20       	  .ascic \\		; use auxillary 
                                     0A20       	.endc			; end if
                                     0A20       forget:			; use  of word as vl_kernel label
                                     0A20       	
                       7B   20   D0  0A20  1769 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012E2'EF   16  0A23  1770 	jsb	token			; get token
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  87
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

              7B   00001D37'FF   D0  0A29  1771 	movl	@v_context,-(r11)	; start search at context
                   00000F86'EF   16  0A30  1772 	jsb	search			; search it
                            8B   D5  0A36  1773 	tstl	(r11)+			; Was it found?
                            0C   13  0A38  1774 	beql	100$			; No, tell user
                                     0A3A  1775 ; make vocab point to word before the forgotten one.
           00001D37'FF   00 BB   D0  0A3A  1776 	movl	@(r11),@v_context	;
                       5B   04   C0  0A42  1777 	addl2	#4,r11			; pop address of found word
                                 05  0A45  1778 	rsb				; exit
                                     0A46  1779 100$:
              7B   000018C7'EF   9E  0A46  1780 	movab	v_wordnotfound,-(r11)	; put address of error message on stack
                       FA24 CF   16  0A4D  1781 	jsb	bcount			; get address of text and length
                   00001450'EF   16  0A51  1782 	jsb	write			; write error message
                       7B   59   D0  0A57  1783 	movl	r9,-(r11)		; address of token not found in search
                       FA17 CF   16  0A5A  1784 	jsb	bcount			; get address of text and length
                   00001450'EF   16  0A5E  1785 	jsb	write			; write the name of the word
                          0F6B   31  0A64  1786 	brw	r_warm_start		; end of forget
                                     0A67  1787 
                                     0A67  1788 
                                     0A67  1789 ;+++
                                     0A67  1790 ;k> forget/erase -- ( -- ) rset context vocab to word before word forgotten
                                     0A67  1791 ;	and move the dictinary back to header address of word forgotten.
                                     0A67  1792 ;	In other words, dictinary is truncated BEFORE the word forgotten. ~~~Add warning
                                     0A67  1793 ;---
                                     0A67  1794 	header	i_forget_erase,<forget/erase>
                           00000A15' 0A67       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000A67  0A6B       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000C  0A6B       	.nchr  nchr, ^\forget/erase\	; nchr = length( forget/erase )
                           0000000C  0A6B       	.if    le, nchr		; nchr <= 0
                                     0A6B       	   .ascic \i_forget_erase\	; no auxillary forget/erase, use principle one
                                     0A6B       	.if_false		; else
73 61 72 65 2F 74 65 67 72 6F 66 00' 0A6B       	  .ascic \forget/erase\		; use auxillary forget/erase
                                 65  0A77       
                                 0C  0A6B       
                                     0A78       	.endc			; end if
                                     0A78       i_forget_erase:			; use forget/erase of word as vl_kernel label
                                     0A78       	
                       7B   20   D0  0A78  1795 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012E2'EF   16  0A7B  1796 	jsb	token			; get token
              7B   00001D37'FF   D0  0A81  1797 	movl	@v_context,-(r11)	; start search at contxt
                   00000F86'EF   16  0A88  1798 	jsb	search			; search it
                            8B   D5  0A8E  1799 	tstl	(r11)+			; Was it found?
                            0F   13  0A90  1800 	beql	100$			; No, tell user
                                     0A92  1801 ; make vocab point to word before the forgotten one.
           00001D37'FF   00 BB   D0  0A92  1802 	movl	@(r11),@v_context
                       59   6B   D0  0A9A  1803 	movl	(r11),r9		; truncate dictionary
                       6B   04   C0  0A9D  1804 	addl2	#4,(r11)		; pop address of found word
                                 05  0AA0  1805 	rsb				; return
                                     0AA1  1806 100$:
              7B   000018C7'EF   9E  0AA1  1807 	movab	v_wordnotfound,-(r11)	;
                       F9C9 CF   16  0AA8  1808 	jsb	bcount			; get address of text and length
                   00001450'EF   16  0AAC  1809 	jsb	write			; write error message
                       7B   59   D0  0AB2  1810 	movl	r9,-(r11)		; address of token not found in search
                       F9BC CF   16  0AB5  1811 	jsb	bcount			; get addres of text and length
                   00001450'EF   16  0AB9  1812 	jsb	write			; write the name of the word ~~ not found
                          0F10   31  0ABF  1813 	brw	r_warm_start		; end of forget/erase
                                     0AC2  1814 
                                     0AC2  1815 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  88
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0AC2  1816 ;+++
                                     0AC2  1817 ;k> freemem -- ( -- l ) print amount of memory left in dictionary
                                     0AC2  1818 ;--- ~~~ does it really leave a longword on the stack?
                                     0AC2  1819 	header	freemem
                           00000A67' 0AC2       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000AC2  0AC6       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0AC6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0AC6       	.if    le, nchr		; nchr <= 0
            6D 65 6D 65 65 72 66 00' 0AC6       	   .ascic \freemem\	; no auxillary , use principle one
                                 07  0AC6       
                                     0ACE       	.if_false		; else
                                     0ACE       	  .ascic \\		; use auxillary 
                                     0ACE       	.endc			; end if
                                     0ACE       freemem:			; use  of word as vl_kernel label
                                     0ACE       	
         7B   00004000'8F   59   C3  0ACE  1820 	subl3	r9,#c_dict_end,-(r11)	; put free space on stack
                       F649 CF   16  0AD6  1821 	jsb	i_dot			; print it
                                 05  0ADA  1822 	rsb				; end of freemem
                                     0ADB  1823 
                                     0ADB  1824 
                                     0ADB  1825 ;+++
                                     0ADB  1826 ;k> halt -- ( l -- ) halt VTIL, use `l' as returned value.  Never returns. ~~~ Change "returned value" to "exit status?
                                     0ADB  1827 ;---
                                     0ADB  1828 	header	i_halt,<halt>
                           00000AC2' 0ADB       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000ADB  0ADF       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  0ADF       	.nchr  nchr, ^\halt\	; nchr = length( halt )
                           00000004  0ADF       	.if    le, nchr		; nchr <= 0
                                     0ADF       	   .ascic \i_halt\	; no auxillary halt, use principle one
                                     0ADF       	.if_false		; else
                     74 6C 61 68 00' 0ADF       	  .ascic \halt\		; use auxillary halt
                                 04  0ADF       
                                     0AE4       	.endc			; end if
                                     0AE4       i_halt:			; use halt of word as vl_kernel label
                                     0AE4       	
                       50   8B   D0  0AE4  1829 	movl	(r11)+,r0		; put error number in right place
                          106E   31  0AE7  1830 	brw	_error_exit		; go to error exit routine
                                     0AEA  1831 					; end of halt
                                     0AEA  1832 
                                     0AEA  1833 
                                     0AEA  1834 ;+++
                                     0AEA  1835 ;k> hex -- ( -- ) Set the base to hexidecimal.
                                     0AEA  1836 ;---
                                     0AEA  1837 	header	hex
                           00000ADB' 0AEA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000AEA  0AEE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0AEE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0AEE       	.if    le, nchr		; nchr <= 0
                        78 65 68 00' 0AEE       	   .ascic \hex\	; no auxillary , use principle one
                                 03  0AEE       
                                     0AF2       	.if_false		; else
                                     0AF2       	  .ascic \\		; use auxillary 
                                     0AF2       	.endc			; end if
                                     0AF2       hex:			; use  of word as vl_kernel label
                                     0AF2       	
              00001D4E'EF   10   D0  0AF2  1838 	movl	#16,v_radix		; switch to base 16 (hexadecimal)
                                 05  0AF9  1839 	rsb				; end of hex
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  89
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0AFA  1840 
                                     0AFA  1841 
                                     0AFA  1842 ;+++
                                     0AFA  1843 ;k> hld -- ( -- a ) Variable hld, return address of hld.
                                     0AFA  1844 ;---
                                     0AFA  1845 	header	hld
                           00000AEA' 0AFA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000AFA  0AFE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0AFE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0AFE       	.if    le, nchr		; nchr <= 0
                        64 6C 68 00' 0AFE       	   .ascic \hld\	; no auxillary , use principle one
                                 03  0AFE       
                                     0B02       	.if_false		; else
                                     0B02       	  .ascic \\		; use auxillary 
                                     0B02       	.endc			; end if
                                     0B02       hld:			; use  of word as vl_kernel label
                                     0B02       	
              7B   00001D52'EF   DE  0B02  1846 	moval	v_hld,-(r11)		; leave address on stack
                                 05  0B09  1847 	rsb				; end of hld
                                     0B0A  1848 
                                     0B0A  1849 
                                     0B0A  1850 ;+++
                                     0B0A  1851 ;k> hold -- ( c -- ) Insert `c' in current numeric output string.
                                     0B0A  1852 ;---
                                     0B0A  1853 	header	hold
                           00000AFA' 0B0A       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000B0A  0B0E       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0B0E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B0E       	.if    le, nchr		; nchr <= 0
                     64 6C 6F 68 00' 0B0E       	   .ascic \hold\	; no auxillary , use principle one
                                 04  0B0E       
                                     0B13       	.if_false		; else
                                     0B13       	  .ascic \\		; use auxillary 
                                     0B13       	.endc			; end if
                                     0B13       hold:			; use  of word as vl_kernel label
                                     0B13       	
                   00001D52'EF   D7  0B13  1854 	decl	v_hld			; move pointer down one char
              00001D52'FF   6B   90  0B19  1855 	movb	(r11),@v_hld		; fill new char w/top of stack
                       5B   04   C0  0B20  1856 	addl2	#4,r11			; pop char off stack
                                 05  0B23  1857 	rsb				; end of hold
                                     0B24  1858 
                                     0B24  1859 
                                     0B24  1860 ;+++
                                     0B24  1861 ;k> i> -- ( -- ) Copy the top of the loop stack to the data stack.
                                     0B24  1862 ;	This word is used inside of { do ... loop }'s to get the index
                                     0B24  1863 ;	of the innermost loop onto the top of the stack.
                                     0B24  1864 ;---
                                     0B24  1865 	header	i_i_to,^\i>\
                           00000B0A' 0B24       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000B24  0B28       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0B28       	.nchr  nchr, ^\i>\	; nchr = length( i> )
                           00000002  0B28       	.if    le, nchr		; nchr <= 0
                                     0B28       	   .ascic \i_i_to\	; no auxillary i>, use principle one
                                     0B28       	.if_false		; else
                           3E 69 00' 0B28       	  .ascic \i>\		; use auxillary i>
                                 02  0B28       
                                     0B2B       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  90
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0B2B       i_i_to:			; use i> of word as vl_kernel label
                                     0B2B       	
                       7B   6A   D0  0B2B  1866 	movl	(r10),-(r11)		; copy w/o consuming ~~~ from loop stack.
                                 05  0B2E  1867 	rsb				; end of i>
                                     0B2F  1868 
                                     0B2F  1869 
                                     0B2F  1870 ;+++
                                     0B2F  1871 ;k> kernel -- ( -- ) Set context to kernel vocabulary.
                                     0B2F  1872 ;---
                                     0B2F  1873 	header	kernel
                           00000B24' 0B2F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000B2F  0B33       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0B33       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B33       	.if    le, nchr		; nchr <= 0
               6C 65 6E 72 65 6B 00' 0B33       	   .ascic \kernel\	; no auxillary , use principle one
                                 06  0B33       
                                     0B3A       	.if_false		; else
                                     0B3A       	  .ascic \\		; use auxillary 
                                     0B3A       	.endc			; end if
                                     0B3A       kernel:			; use  of word as vl_kernel label
                                     0B3A       	
     00001D37'EF   00001D43'EF   DE  0B3A  1874 	moval	v_kernel,v_context
                                 05  0B45  1875 	rsb				; end of kernel
                                     0B46  1876 
                                     0B46  1877 
                                     0B46  1878 ;+++
                                     0B46  1879 ;k> leave -- ( -- ) Leave a { do } loop at end of this iteration.
                                     0B46  1880 ;---
                                     0B46  1881 	header	leave
                           00000B2F' 0B46       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000B46  0B4A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0B4A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B4A       	.if    le, nchr		; nchr <= 0
                  65 76 61 65 6C 00' 0B4A       	   .ascic \leave\	; no auxillary , use principle one
                                 05  0B4A       
                                     0B50       	.if_false		; else
                                     0B50       	  .ascic \\		; use auxillary 
                                     0B50       	.endc			; end if
                                     0B50       leave:			; use  of word as vl_kernel label
                                     0B50       	
                    04 AA   6A   D0  0B50  1882 	movl	(r10),4(r10)		; make limit = index so loop will exit
                                 05  0B54  1883 	rsb				; end of leave
                                     0B55  1884 
                                     0B55  1885 
                                     0B55  1886 ;+++
                                     0B55  1887 ;k> load -- ( -- ) Take input from file instead of the terminal.
                                     0B55  1888 ;	Format: { load filename }
                                     0B55  1889 ;---
                                     0B55  1890 	header	load
                           00000B46' 0B55       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000B55  0B59       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0B59       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B59       	.if    le, nchr		; nchr <= 0
                     64 61 6F 6C 00' 0B59       	   .ascic \load\	; no auxillary , use principle one
                                 04  0B59       
                                     0B5E       	.if_false		; else
                                     0B5E       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  91
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0B5E       	.endc			; end if
                                     0B5E       load:			; use  of word as vl_kernel label
                                     0B5E       	
                       7B   20   D0  0B5E  1891 	movl	#c_blank,-(r11)		; set up for blank terminated file name
                   000012E2'EF   16  0B61  1892 	jsb	token			; get v_fname
                       56   69   9A  0B67  1893 	movzbl	(r9),r6			; get count of v_fname
      00001A3D'EF   01 A9   56   28  0B6A  1894 	movc3	r6,1(r9),v_fname	; move to name buffer
              00001A3C'EF   56   90  0B73  1895 	movb	r6,v_fnamelen		; save length
                   00001A3D'EF   DE  0B7A  1896 	moval	v_fname,-
                   000019D4'EF       0B80  1897 		v_infab+fab$l_fna	; tell it where filespec is
                   00001A3C'EF   90  0B85  1898 	movb	v_fnamelen,-
                   000019DC'EF       0B8B  1899 		v_infab+fab$b_fns	; tell it what size filespec is
                                     0B90  1900 	$open	fab=v_infab		; open input file
                                     0B90       		$RMSCALL	OPEN,v_infab,,
                                     0B90       	.GLOBL	SYS$OPEN
                                     0B90       	.IF	B <v_infab>
                                     0B90       	CALLG	(AP),G^SYS$OPEN
                                     0B90       	$$.TMP=0
                                     0B90       	.IF	NB <>
                                     0B90       	$$.TMP=1
                                     0B90       	.ENDC
                                     0B90       	.IF	NB <>
                                     0B90       	$$.TMP=1
                                     0B90       	.ENDC
                                     0B90       	.IF	NE $$.TMP
                                     0B90       	.ERROR				; v_infab= parameter missing;
                                     0B90       	.ENDC
                                     0B90       	.ENDC
                                     0B90       	.IF	NB <v_infab>
                           00000001  0B90       	$$.TMP1=1
                                     0B90       	.IF	NB <>
                                     0B90       	PUSHAL	
                                     0B90       	$$.TMP1=3
                                     0B90       	.ENDC
                                     0B90       	.IF	NB <>
                                     0B90       	PUSHAL	
                                     0B90       	.IF	EQ <$$.TMP1-1>
                                     0B90       	$$.TMP1=2
                                     0B90       	.ENDC
                                     0B90       	.IFF
                           FFFFFFFE  0B90       	.IF	EQ <$$.TMP1-3>
                                     0B90       	PUSHL	#0
                                     0B90       	.ENDC
                                     0B90       	.ENDC
                           000000CF  0B90       	.NTYPE	$$.TMP2,v_infab
                           00000070  0B90       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0B90       	PUSHL	v_infab
                                     0B90       	.IFF
                           000000B0  0B90       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0B90       	PUSHL	v_infab
                                     0B90       	.IFF
                   000019A8'EF   DF  0B90       	PUSHAL	v_infab
                                     0B96       	.ENDC
                                     0B96       	.ENDC
              00000000'GF   01   FB  0B96       	CALLS	#$$.TMP1,G^SYS$OPEN
                                     0B9D       	.ENDC
                                     0B9D       	
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  92
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0B9D       	
                         12 50   E9  0B9D  1901 	blbc	r0,10$			; Quit on error
                                     0BA0  1902 	$connect rab=v_inrab		; connect to input
                                     0BA0       		$RMSCALL	CONNECT,v_inrab,,
                                     0BA0       	.GLOBL	SYS$CONNECT
                                     0BA0       	.IF	B <v_inrab>
                                     0BA0       	CALLG	(AP),G^SYS$CONNECT
                                     0BA0       	$$.TMP=0
                                     0BA0       	.IF	NB <>
                                     0BA0       	$$.TMP=1
                                     0BA0       	.ENDC
                                     0BA0       	.IF	NB <>
                                     0BA0       	$$.TMP=1
                                     0BA0       	.ENDC
                                     0BA0       	.IF	NE $$.TMP
                                     0BA0       	.ERROR				; v_inrab= parameter missing;
                                     0BA0       	.ENDC
                                     0BA0       	.ENDC
                                     0BA0       	.IF	NB <v_inrab>
                           00000001  0BA0       	$$.TMP1=1
                                     0BA0       	.IF	NB <>
                                     0BA0       	PUSHAL	
                                     0BA0       	$$.TMP1=3
                                     0BA0       	.ENDC
                                     0BA0       	.IF	NB <>
                                     0BA0       	PUSHAL	
                                     0BA0       	.IF	EQ <$$.TMP1-1>
                                     0BA0       	$$.TMP1=2
                                     0BA0       	.ENDC
                                     0BA0       	.IFF
                           FFFFFFFE  0BA0       	.IF	EQ <$$.TMP1-3>
                                     0BA0       	PUSHL	#0
                                     0BA0       	.ENDC
                                     0BA0       	.ENDC
                           000000CF  0BA0       	.NTYPE	$$.TMP2,v_inrab
                           00000070  0BA0       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0BA0       	PUSHL	v_inrab
                                     0BA0       	.IFF
                           000000B0  0BA0       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0BA0       	PUSHL	v_inrab
                                     0BA0       	.IFF
                   000019F8'EF   DF  0BA0       	PUSHAL	v_inrab
                                     0BA6       	.ENDC
                                     0BA6       	.ENDC
              00000000'GF   01   FB  0BA6       	CALLS	#$$.TMP1,G^SYS$CONNECT
                                     0BAD       	.ENDC
                                     0BAD       	
                                     0BAD       	
                         23 50   E9  0BAD  1903 	blbc	r0,20$			; Quit on error
                            2B   11  0BB0  1904 	brb	40$			; branch to read loop
                                     0BB2  1905 10$:
              00000000'8F   50   D1  0BB2  1906 	cmpl	r0,#rms$_fnf		; is it file not found?
                            0E   12  0BB9  1907 	bneq	15$			; no
                   0000189A'EF   7F  0BBB  1908 	pushaq	v_filenotfound		;
              00000000'GF   01   FB  0BC1  1909 	calls	#1,g^lib$put_output	; Tell user file not found
                                 05  0BC8  1910 	rsb				; return
                                     0BC9  1911 15$:
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  93
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

              56   000019A8'EF   DE  0BC9  1912 	moval	v_infab,r6		; error: keep fab address
                          0F8F   31  0BD0  1913 	brw	_f_err			; signal file error
                                     0BD3  1914 20$:
              56   000019F8'EF   DE  0BD3  1915 	moval	v_inrab,r6		; keep rab address
                          0F94   31  0BDA  1916 	brw	_r_err			; signal record error
                                     0BDD  1917 40$:
           00001D47'EF   FF 8F   90  0BDD  1918 	movb	#c_true,v_infile	; set input from file flag
              00001D48'EF   00   D0  0BE5  1919 	movl	#0,v_filelinenum	; reinitialize number of lines read
                                 05  0BEC  1920 	rsb				; end of load
                                     0BED  1921 
                                     0BED  1922 
                                     0BED  1923 ;+++t
                                     0BED  1924 ;k> long -- ( n -- ) Create a word that pushed address of longword on stack,
                                     0BED  1925 ;	save space in dictionary, and initialize to `n'.
                                     0BED  1926 ;---
                                     0BED  1927 	header	i_long,<long>
                           00000B55' 0BED       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000BED  0BF1       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000004  0BF1       	.nchr  nchr, ^\long\	; nchr = length( long )
                           00000004  0BF1       	.if    le, nchr		; nchr <= 0
                                     0BF1       	   .ascic \i_long\	; no auxillary long, use principle one
                                     0BF1       	.if_false		; else
                     67 6E 6F 6C 00' 0BF1       	  .ascic \long\		; use auxillary long
                                 04  0BF1       
                                     0BF6       	.endc			; end if
                                     0BF6       i_long:			; use long of word as vl_kernel label
                                     0BF6       	
                       FC48 CF   16  0BF6  1928 	jsb	create			; enclose next token in dictionary
                    89   DE 8F   90  0BFA  1929 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  0BFE  1930 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0C02  1931 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0C05  1932 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0C09  1933 	movb	#op_rsb,(r9)+		; `rsb'
                       89   8B   D0  0C0C  1934 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                                 05  0C0F  1935 	rsb				; end of long
                                     0C10  1936 
                                     0C10  1937 
                                     0C10  1938 ;+++t
                                     0C10  1939 ;k> longconst -- ( n -- ) Create a word that pushed a `n' to the stack.
                                     0C10  1940 ;---
                                     0C10  1941 	header	longconst
                           00000BED' 0C10       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000C10  0C14       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0C14       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C14       	.if    le, nchr		; nchr <= 0
      74 73 6E 6F 63 67 6E 6F 6C 00' 0C14       	   .ascic \longconst\	; no auxillary , use principle one
                                 09  0C14       
                                     0C1E       	.if_false		; else
                                     0C1E       	  .ascic \\		; use auxillary 
                                     0C1E       	.endc			; end if
                                     0C1E       longconst:			; use  of word as vl_kernel label
                                     0C1E       	
                       FC20 CF   16  0C1E  1942 	jsb	create			; enclose next token in dictionary
                   0000179F'EF   16  0C22  1943 	jsb	literal			; enclose code in dictionary
                       89   05   90  0C28  1944 	movb	#op_rsb,(r9)+		; stick `rsb' into dictionary to
                                     0C2B  1945 					;   end constant word
                                 05  0C2B  1946 	rsb				; end of longconst
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  94
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0C2C  1947 
                                     0C2C  1948 
                                     0C2C  1949 ;+++
                                     0C2C  1950 ;k> ls>ds -- ( -- n ) Remove `n' from loop stack.
                                     0C2C  1951 ;---
                                     0C2C  1952 	header	i_ls_to_ds,^/ls>ds/
                           00000C10' 0C2C       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000C2C  0C30       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  0C30       	.nchr  nchr, ^\ls>ds\	; nchr = length( ls>ds )
                           00000005  0C30       	.if    le, nchr		; nchr <= 0
                                     0C30       	   .ascic \i_ls_to_ds\	; no auxillary ls>ds, use principle one
                                     0C30       	.if_false		; else
                  73 64 3E 73 6C 00' 0C30       	  .ascic \ls>ds\		; use auxillary ls>ds
                                 05  0C30       
                                     0C36       	.endc			; end if
                                     0C36       i_ls_to_ds:			; use ls>ds of word as vl_kernel label
                                     0C36       	
                       7B   8A   D0  0C36  1953 	movl	(r10)+,-(r11)		; pop from loop stack, move to dstack
                                 05  0C39  1954 	rsb				; end of ls>ds
                                     0C3A  1955 
                                     0C3A  1956 
                                     0C3A  1957 ;+++
                                     0C3A  1958 ;k> match -- ( a1 n1 a2 n2 -- a3 ? f ) Search for string of length `n2' at
                                     0C3A  1959 ;	`a2' in string of length `n' at `a'.
                                     0C3A  1960 ;---
                                     0C3A  1961 	header	i_match,<match>
                           00000C2C' 0C3A       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000C3A  0C3E       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  0C3E       	.nchr  nchr, ^\match\	; nchr = length( match )
                           00000005  0C3E       	.if    le, nchr		; nchr <= 0
                                     0C3E       	   .ascic \i_match\	; no auxillary match, use principle one
                                     0C3E       	.if_false		; else
                  68 63 74 61 6D 00' 0C3E       	  .ascic \match\		; use auxillary match
                                 05  0C3E       
                                     0C44       	.endc			; end if
                                     0C44       i_match:			; use match of word as vl_kernel label
                                     0C44       	
                    04 BB   6B   39  0C44  1962 	matchc	(r11),@4(r11),-		; object string (one we're looking for)
                 0C BB   08 AB       0C48  1963 		8(r11),@12(r11)		; source string (one we're looking in)
                            12   12  0C4C  1964 	bneq	100$			; no match found
                                     0C4E  1965 ; match found, calcualte its address.  matchc leaves in r3 the address of the
                                     0C4E  1966 ; byte after last byte matched in the source string, so address of matched
                                     0C4E  1967 ; string is r3 - objectlen.
                  50   53   61   C3  0C4E  1968 	subl3  (r1),r3,r0		; calculate address of matched string
                       5B   10   C0  0C52  1969 	addl2  #16,r11			; pop arguments
                       7B   50   D0  0C55  1970 	movl   r0,-(r11)		; put address of matched string on stack
              7B   FFFFFFFF 8F   D0  0C58  1971 	movl   #c_true,-(r11)		; leave true on top of stack
                                 05  0C5F  1972 	rsb				; return
                                     0C60  1973 100$:
                                     0C60  1974 ; no match found
                       5B   10   C0  0C60  1975 	addl2	#16,r11			; pop arguments
                       7B   00   D0  0C63  1976 	movl	#c_false,-(r11)		; leave a false ~~~ on top of stack
                                 05  0C66  1977 	rsb				; end of match
                                     0C67  1978 
                                     0C67  1979 
                                     0C67  1980 ;+++
                                     0C67  1981 ;k> max -- ( n1 n2 -- n2 ) Leave larger of n1 and n2 on stack.
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  95
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0C67  1982 ;---
                                     0C67  1983 	header	max
                           00000C3A' 0C67       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000C67  0C6B       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0C6B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C6B       	.if    le, nchr		; nchr <= 0
                        78 61 6D 00' 0C6B       	   .ascic \max\	; no auxillary , use principle one
                                 03  0C6B       
                                     0C6F       	.if_false		; else
                                     0C6F       	  .ascic \\		; use auxillary 
                                     0C6F       	.endc			; end if
                                     0C6F       max:			; use  of word as vl_kernel label
                                     0C6F       	
                    04 AB   6B   D1  0C6F  1984 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   15  0C73  1985 	bleq	10$			; Top less than under item?
                                     0C75  1986 ; no, top greater
                    04 AB   6B   D0  0C75  1987 	movl	(r11),4(r11)		; move greater down stack
                                     0C79  1988 10$:
                       5B   04   C0  0C79  1989 	addl2	#4,r11			; pop first argument, since
                                     0C7C  1990 					;   great is in second item now
                                 05  0C7C  1991 	rsb				; end of max
                                     0C7D  1992 
                                     0C7D  1993 
                                     0C7D  1994 ;+++
                                     0C7D  1995 ;k> message -- ( a -- ) writes word-counted string at `a' to terminal.
                                     0C7D  1996 ;---
                                     0C7D  1997 	header	message
                           00000C67' 0C7D       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000C7D  0C81       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0C81       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C81       	.if    le, nchr		; nchr <= 0
            65 67 61 73 73 65 6D 00' 0C81       	   .ascic \message\	; no auxillary , use principle one
                                 07  0C81       
                                     0C89       	.if_false		; else
                                     0C89       	  .ascic \\		; use auxillary 
                                     0C89       	.endc			; end if
                                     0C89       message:			; use  of word as vl_kernel label
                                     0C89       	
                       FB6F CF   16  0C89  1998 	jsb	count			; set up for write
                   00001450'EF   16  0C8D  1999 	jsb	write			; write it out
                                 05  0C93  2000 	rsb				; end of message
                                     0C94  2001 
                                     0C94  2002 
                                     0C94  2003 ;+++
                                     0C94  2004 ;k> min -- ( n1 n2 -- n2 ) Leaves small or n1 and n2 on stack.
                                     0C94  2005 ;---
                                     0C94  2006 	header	min
                           00000C7D' 0C94       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000C94  0C98       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0C98       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C98       	.if    le, nchr		; nchr <= 0
                        6E 69 6D 00' 0C98       	   .ascic \min\	; no auxillary , use principle one
                                 03  0C98       
                                     0C9C       	.if_false		; else
                                     0C9C       	  .ascic \\		; use auxillary 
                                     0C9C       	.endc			; end if
                                     0C9C       min:			; use  of word as vl_kernel label
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  96
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0C9C       	
                    04 AB   6B   D1  0C9C  2007 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   18  0CA0  2008 	bgeq	10$			; Top is greater than under item
                    04 AB   6B   D0  0CA2  2009 	movl	(r11),4(r11)		;
                                     0CA6  2010 10$:
                       5B   04   C0  0CA6  2011 	addl2	#4,r11			; pop top stack item since lesser is
                                     0CA9  2012 					;   in second line.
                                 05  0CA9  2013 	rsb				; end of min
                                     0CAA  2014 
                                     0CAA  2015 
                                     0CAA  2016 ;+++
                                     0CAA  2017 ;k> mod -- ( n1 n2 -- n3 ) Leave remainder of n1 / n2 on stack.
                                     0CAA  2018 ;---
                                     0CAA  2019 	header	mod
                           00000C94' 0CAA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000CAA  0CAE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0CAE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CAE       	.if    le, nchr		; nchr <= 0
                        64 6F 6D 00' 0CAE       	   .ascic \mod\	; no auxillary , use principle one
                                 03  0CAE       
                                     0CB2       	.if_false		; else
                                     0CB2       	  .ascic \\		; use auxillary 
                                     0CB2       	.endc			; end if
                                     0CB2       mod:			; use  of word as vl_kernel label
                                     0CB2       	
               50   04 AB   6B   C7  0CB2  2020 	divl3	(r11),4(r11),r0		; r0 = n1 / n2
                  51   8B   50   C5  0CB7  2021 	mull3	r0,(r11)+,r1		; temp = n2 * n3
                       6B   51   C2  0CBB  2022 	subl2	r1,(r11)		; n3 = n1 - quotient
                                 05  0CBE  2023 	rsb				; end of mod
                                     0CBF  2024 
                                     0CBF  2025 
                                     0CBF  2026 ;+++
                                     0CBF  2027 ;k> move -- ( a1 a2 w -- ) Copies `w' bytes from `a1' to `a2'.
                                     0CBF  2028 ;---
                                     0CBF  2029 	header	move
                           00000CAA' 0CBF       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000CBF  0CC3       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0CC3       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CC3       	.if    le, nchr		; nchr <= 0
                     65 76 6F 6D 00' 0CC3       	   .ascic \move\	; no auxillary , use principle one
                                 04  0CC3       
                                     0CC8       	.if_false		; else
                                     0CC8       	  .ascic \\		; use auxillary 
                                     0CC8       	.endc			; end if
                                     0CC8       move:			; use  of word as vl_kernel label
                                     0CC8       	
            04 BB   08 BB   6B   28  0CC8  2030 	movc3	(r11),@8(r11),@4(r11)	;
                       5B   0C   C0  0CCE  2031 	addl2	#12,r11			; pop arguments
                                 05  0CD1  2032 	rsb				; end of move
                                     0CD2  2033 
                                     0CD2  2034 
                                     0CD2  2035 ;+++
                                     0CD2  2036 ;k> move&fill -- ( a1 w1 a2 w2 c -- ) copies bytes from `a1' to `a2'.
                                     0CD2  2037 ;	If `w2' > `wl', fill with c.  If `w2' < `w1', truncate.
                                     0CD2  2038 ;---
                                     0CD2  2039 	header	i_move_fill,<move&fill>
                           00000CBF' 0CD2       	.long	vl_kernel		; back link to the previous word in this vl_kernel
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  97
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000CD2  0CD6       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000009  0CD6       	.nchr  nchr, ^\move&fill\	; nchr = length( move&fill )
                           00000009  0CD6       	.if    le, nchr		; nchr <= 0
                                     0CD6       	   .ascic \i_move_fill\	; no auxillary move&fill, use principle one
                                     0CD6       	.if_false		; else
      6C 6C 69 66 26 65 76 6F 6D 00' 0CD6       	  .ascic \move&fill\		; use auxillary move&fill
                                 09  0CD6       
                                     0CE0       	.endc			; end if
                                     0CE0       i_move_fill:			; use move&fill of word as vl_kernel label
                                     0CE0       	
                 10 BB   0C AB   2C  0CE0  2040 	movc5	12(r11),@16(r11),-	; sourcelen, source
                            6B       0CE5  2041 		(r11),-			; fill character
                 08 BB   04 AB       0CE6  2042 		4(r11),@8(r11)		; destlen, destination
                       5B   14   C0  0CEA  2043 	addl2	#20,r11			; pop arguments
                                 05  0CED  2044 	rsb				; end of move/fill
                                     0CEE  2045 
                                     0CEE  2046 
                                     0CEE  2047 ;+++
                                     0CEE  2048 ;k> negate -- ( n -- -n )  Leave two's complement of top stack item on stack.
                                     0CEE  2049 ;---
                                     0CEE  2050 	header	negage
                           00000CD2' 0CEE       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000CEE  0CF2       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0CF2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CF2       	.if    le, nchr		; nchr <= 0
               65 67 61 67 65 6E 00' 0CF2       	   .ascic \negage\	; no auxillary , use principle one
                                 06  0CF2       
                                     0CF9       	.if_false		; else
                                     0CF9       	  .ascic \\		; use auxillary 
                                     0CF9       	.endc			; end if
                                     0CF9       negage:			; use  of word as vl_kernel label
                                     0CF9       	
                       6B   6B   CE  0CF9  2051 	mnegl	(r11),(r11)		; negate it
                                 05  0CFC  2052 	rsb				; end of negate
                                     0CFD  2053 
                                     0CFD  2054 
                                     0CFD  2055 ;+++
                                     0CFD  2056 ;k> not -- ( f1 -- f2 ) Logical not of top  of stack; not f1.
                                     0CFD  2057 ;---
                                     0CFD  2058 	header	not
                           00000CEE' 0CFD       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000CFD  0D01       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0D01       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D01       	.if    le, nchr		; nchr <= 0
                        74 6F 6E 00' 0D01       	   .ascic \not\	; no auxillary , use principle one
                                 03  0D01       
                                     0D05       	.if_false		; else
                                     0D05       	  .ascic \\		; use auxillary 
                                     0D05       	.endc			; end if
                                     0D05       not:			; use  of word as vl_kernel label
                                     0D05       	
                            8B   D5  0D05  2059 	tstl	(r11)+			; Is it false?
                            04   13  0D07  2060 	beql	10$			; yes
                       7B   00   D0  0D09  2061 	movl	#c_false,-(r11)		; no, leave with false on stack
                                 05  0D0C  2062 	rsb				; return
                                     0D0D  2063 10$:
              7B   FFFFFFFF 8F   D0  0D0D  2064 	movl	#c_true,-(r11)		; it is false, leave with true on stack
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  98
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 05  0D14  2065 	rsb				; end of not
                                     0D15  2066 
                                     0D15  2067 
                                     0D15  2068 ;+++t
                                     0D15  2069 ;k> number -- ( -- n ? f ) Try to turn token at eodp into a number.  If
                                     0D15  2070 ;	it is a number, leave ( number true ) on stack.  If it is not a number
                                     0D15  2071 ;	leave ( false ) on stack.
                                     0D15  2072 ;---
                                     0D15  2073 	header	number
                           00000CFD' 0D15       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000D15  0D19       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0D19       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D19       	.if    le, nchr		; nchr <= 0
               72 65 62 6D 75 6E 00' 0D19       	   .ascic \number\	; no auxillary , use principle one
                                 06  0D19       
                                     0D20       	.if_false		; else
                                     0D20       	  .ascic \\		; use auxillary 
                                     0D20       	.endc			; end if
                                     0D20       number:			; use  of word as vl_kernel label
                                     0D20       	
                            50   D4  0D20  2074 	clrl	r0			; clear result
                            51   D4  0D22  2075 	clrl	r1			; clear sign
                       56   59   D0  0D24  2076 	movl	r9, r6			; get pointer to token
                       57   86   9A  0D27  2077 	movzbl	(r6)+,r7		; get byte count
                       66   2D   91  0D2A  2078 	cmpb	#^a/-/,(r6)		; does it have a leading minus sign?
                            07   12  0D2D  2079 	bneq	_number_top		; no, go on
                       51   01   D0  0D2F  2080 	movl	#1,r1			; yes, set flag
                            56   D6  0D32  2081 	incl	r6			; advance over sign
                            57   D7  0D34  2082 	decl	r7			; length = length - 1
                                     0D36  2083 _number_top:
                       52   66   9A  0D36  2084 	movzbl	(r6),r2			; get byte
                       52   30   C2  0D39  2085 	subl2	#^x30,r2			; check in range 0...9
                            52   D5  0D3C  2086 	tstl	r2			; Is it negative?
                            52   19  0D3E  2087 	blss	_invalid_number		; yes, leave with false
                       09   52   D1  0D40  2088 	cmpl	r2,#9			; r2 <= 9
                            20   15  0D43  2089 	bleq	_check_base		; yes, continue
                       11   52   D1  0D45  2090 	cmpl	r2,#^x11		; Is it A or greater?
                            48   19  0D48  2091 	blss	_invalid_number		; no, leave with false
                       2A   52   D1  0D4A  2092 	cmpl	r2,#^x2a		; is it Z or less
                            05   14  0D4D  2093 	bgtr	_check_lowercase	; no, go check if lower case
                       52   07   C2  0D4F  2094 	subl2	#7,r2			; convert to ^xA...^xZ
                            11   11  0D52  2095 	brb	_check_base		; now check if it is valid in current
                                     0D54  2096 					; base
                                     0D54  2097 _check_lowercase:
                       31   52   D1  0D54  2098 	cmpl	r2,#^x31		; Is it a or greater?
                            39   19  0D57  2099 	blss	_invalid_number		; no, leave with false
              0000004A 8F   52   D1  0D59  2100 	cmpl	r2,#^x4a		; Is it z or less?
                            30   14  0D60  2101 	bgtr	_invalid_number		; no, leave with false.
                       52   27   C2  0D62  2102 	subl2	#^x27,r2		; convert to ^xA...^xZ
                                     0D65  2103 _check_base:
              00001D4E'EF   52   D1  0D65  2104 	cmpl	r2,v_radix		; is it in set 0... base-1?
                            24   18  0D6C  2105 	bgeq	_invalid_number		; no, leave w/false
              50   00001D4E'EF   C4  0D6E  2106 	mull2	v_radix,r0		; result = result * base
                       50   52   C0  0D75  2107 	addl2	r2,r0			; result = result + num
                            57   D7  0D78  2108 	decl	r7			; count = count - 1
                            56   D6  0D7A  2109 	incl	r6			; move to next byte in number
                            57   D5  0D7C  2110 	tstl	r7			; count = 0?
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page  99
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                            B6   14  0D7E  2111 	bgtr	_number_top		; no, do it again
                            51   D5  0D80  2112 	tstl	r1			; negative?
                            03   13  0D82  2113 	beql	20$			; no
                       50   50   CE  0D84  2114 	mnegl	r0,r0			; yes, negate it.
                                     0D87  2115 20$:
                       7B   50   D0  0D87  2116 	movl	r0,-(r11)		; put result on stack
              7B   FFFFFFFF 8F   D0  0D8A  2117 	movl	#c_true,-(r11)		; put true on stack
                                 05  0D91  2118 	rsb				; exit with ( number true ) on dstack
                                     0D92  2119 _invalid_number:
                       7B   00   D0  0D92  2120 	movl	#c_false,-(r11)		; exit with ( false ) on dstack
                                 05  0D95  2121 	rsb				; end of number
                                     0D96  2122 
                                     0D96  2123 
                                     0D96  2124 ;+++
                                     0D96  2125 ;,> octal -- ( -- ) Set the base to octal.
                                     0D96  2126 ;---
                                     0D96  2127 	header	octal
                           00000D15' 0D96       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000D96  0D9A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0D9A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D9A       	.if    le, nchr		; nchr <= 0
                  6C 61 74 63 6F 00' 0D9A       	   .ascic \octal\	; no auxillary , use principle one
                                 05  0D9A       
                                     0DA0       	.if_false		; else
                                     0DA0       	  .ascic \\		; use auxillary 
                                     0DA0       	.endc			; end if
                                     0DA0       octal:			; use  of word as vl_kernel label
                                     0DA0       	
              00001D4E'EF   08   D0  0DA0  2128 	movl	#8,v_radix		; Switch to base 8
                                 05  0DA7  2129 	rsb				; end of octal
                                     0DA8  2130 
                                     0DA8  2131 
                                     0DA8  2132 ;+++t
                                     0DA8  2133 ;k> or -- ( f1 f2 -- f ) Logical or, f1 or f2.
                                     0DA8  2134 ;---
                                     0DA8  2135 	header	or
                           00000D96' 0DA8       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000DA8  0DAC       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0DAC       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DAC       	.if    le, nchr		; nchr <= 0
                           72 6F 00' 0DAC       	   .ascic \or\	; no auxillary , use principle one
                                 02  0DAC       
                                     0DAF       	.if_false		; else
                                     0DAF       	  .ascic \\		; use auxillary 
                                     0DAF       	.endc			; end if
                                     0DAF       or:			; use  of word as vl_kernel label
                                     0DAF       	
                            8B   D5  0DAF  2136 	tstl	(r11)+			; is first true?
                            08   12  0DB1  2137 	bneq	10$			; Yes
                            8B   D5  0DB3  2138 	tstl	(r11)+			; Is seconed true?
                            07   12  0DB5  2139 	bneq	20$			; Yes
                       7B   00   D0  0DB7  2140 	movl	#c_false,-(r11)		; Both false, leave with false on stack
                                 05  0DBA  2141 	rsb				; return
                                     0DBB  2142 10$:
                       5B   04   C0  0DBB  2143 	addl2	#4,r11			; pop second item off, don't need
                                     0DBE  2144 					;   to check
                                     0DBE  2145 20$:
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 100
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

              7B   FFFFFFFF 8F   D0  0DBE  2146 	movl	#c_true,-(r11)		; Yes, one or both true.  Leave with
                                     0DC5  2147 					;   true on stack.
                                 05  0DC5  2148 	rsb				; end of or
                                     0DC6  2149 
                                     0DC6  2150 
                                     0DC6  2151 ;+++
                                     0DC6  2152 ;k> over -- ( n1 n2 -- n1 n2 n1 ) Leave a copy of the second item on the stack.
                                     0DC6  2153 ;+++
                                     0DC6  2154 	header	over			; push copy of n1 on top of stack
                           00000DA8' 0DC6       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000DC6  0DCA       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0DCA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DCA       	.if    le, nchr		; nchr <= 0
                     72 65 76 6F 00' 0DCA       	   .ascic \over\	; no auxillary , use principle one
                                 04  0DCA       
                                     0DCF       	.if_false		; else
                                     0DCF       	  .ascic \\		; use auxillary 
                                     0DCF       	.endc			; end if
                                     0DCF       over:			; use  of word as vl_kernel label
                                     0DCF       	
                    7B   04 AB   D0  0DCF  2155 	movl	4(r11),-(r11)
                                 05  0DD3  2156 	rsb				; end of over
                                     0DD4  2157 
                                     0DD4  2158 
                                     0DD4  2159 ;+++
                                     0DD4  2160 ;k> pad -- ( -- a ) Leave address of (edop + c_pad_moat) on stack.
                                     0DD4  2161 ;	This is a good area to use for temporary storage of such things
                                     0DD4  2162 ;	as strings.
                                     0DD4  2163 ;---
                                     0DD4  2164 	header	pad
                           00000DC6' 0DD4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000DD4  0DD8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0DD8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DD8       	.if    le, nchr		; nchr <= 0
                        64 61 70 00' 0DD8       	   .ascic \pad\	; no auxillary , use principle one
                                 03  0DD8       
                                     0DDC       	.if_false		; else
                                     0DDC       	  .ascic \\		; use auxillary 
                                     0DDC       	.endc			; end if
                                     0DDC       pad:			; use  of word as vl_kernel label
                                     0DDC       	
         7B   00000109 8F   59   C1  0DDC  2165 	addl3	r9,#c_pad_moat,-(r11)	;
                                 05  0DE4  2166 	rsb				; end of pad
                                     0DE5  2167 
                                     0DE5  2168 
                                     0DE5  2169 ;+++
                                     0DE5  2170 ;k> putc -- ( c -- ) Output character `c'.
                                     0DE5  2171 ;---
                                     0DE5  2172 	header	putc
                           00000DD4' 0DE5       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000DE5  0DE9       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0DE9       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DE9       	.if    le, nchr		; nchr <= 0
                     63 74 75 70 00' 0DE9       	   .ascic \putc\	; no auxillary , use principle one
                                 04  0DE9       
                                     0DEE       	.if_false		; else
                                     0DEE       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 101
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0DEE       	.endc			; end if
                                     0DEE       putc:			; use  of word as vl_kernel label
                                     0DEE       	
         00A0 8F   00001B98'EF   B1  0DEE  2173 	cmpw	v_outlen,#c_max_len	; is output buffer full?
                            04   19  0DF7  2174 	blss	10$			; no, go on
                       FA11 CF   16  0DF9  2175 	jsb	cr			; yes output it
                                     0DFD  2176 10$:
              50   00001B9A'EF   9E  0DFD  2177 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  0E04  2178 	movzwl	v_outlen,r1		; index into buffer
                       50   51   C0  0E0B  2179 	addl2	r1,r0			; pointer to next available char
                       60   6B   90  0E0E  2180 	movb	(r11),(r0)		; move char into buffer
                       5B   04   C0  0E11  2181 	addl2	#4,r11			; pop char off stack
                   00001B98'EF   B6  0E14  2182 	incw	v_outlen		; increment index (or length)
                                 05  0E1A  2183 	rsb				; end of putc
                                     0E1B  2184 
                                     0E1B  2185 
                                     0E1B  2186 ;+++
                                     0E1B  2187 ;k> radix ( -- a ) leave address of system radix longword on stack.
                                     0E1B  2188 ;---
                                     0E1B  2189 	header	radix
                           00000DE5' 0E1B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000E1B  0E1F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0E1F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E1F       	.if    le, nchr		; nchr <= 0
                  78 69 64 61 72 00' 0E1F       	   .ascic \radix\	; no auxillary , use principle one
                                 05  0E1F       
                                     0E25       	.if_false		; else
                                     0E25       	  .ascic \\		; use auxillary 
                                     0E25       	.endc			; end if
                                     0E25       radix:			; use  of word as vl_kernel label
                                     0E25       	
              7B   00001D4E'EF   DE  0E25  2190 	moval	v_radix,-(r11)		; leave address on dstack
                                 05  0E2C  2191 	rsb				; end of radix
                                     0E2D  2192 
                                     0E2D  2193 
                                     0E2D  2194 ;+++
                                     0E2D  2195 ;k> read ( a -- ) return a byte-counted string from terminal at `a'
                                     0E2D  2196 ;---
                                     0E2D  2197 	header	read
                           00000E1B' 0E2D       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000E2D  0E31       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0E31       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E31       	.if    le, nchr		; nchr <= 0
                     64 61 65 72 00' 0E31       	   .ascic \read\	; no auxillary , use principle one
                                 04  0E31       
                                     0E36       	.if_false		; else
                                     0E36       	  .ascic \\		; use auxillary 
                                     0E36       	.endc			; end if
                                     0E36       read:			; use  of word as vl_kernel label
                                     0E36       	
              00001B92'EF   6B   D0  0E36  2198 	movl	(r11),v_readaddr	; v_readaddr = address to write to
                   00001B92'EF   D6  0E3D  2199 	incl	v_readaddr		; allow for byte count before string
                   00001B8C'EF   3F  0E43  2200 	pushaw	v_readlen		; where to put returned length
                                     0E49  2201 ; Is there any outstanding output?
                   00001B98'EF   B5  0E49  2202 	tstw   v_outlen			;
                            04   12  0E4F  2203 	bneq   10$			; yes~~~, branch to output prompt
                            00   DD  0E51  2204 	pushl  #0			; omit prompt since no output
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 102
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                            1B   11  0E53  2205 	brb    20$			; skip over prompting
                                     0E55  2206 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0E55  2207 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0E5C  2208 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0E63  2209 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                            5B   DD  0E6B  2210 	pushl	r11			; put address of descriptor on rstack
                       5B   08   C0  0E6D  2211 	addl2	#8,r11			; move stack ptr back over descriptor
                                     0E70  2212 20$:
                   00001B8E'EF   7F  0E70  2213 	pushaq	v_readdsc		; push address of descriptor
              00000000'GF   03   FB  0E76  2214 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0E7D  2215 	isstrerr
              50   00000000'8F   D1  0E7D       	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                            06   13  0E84       	beql	30000$		; yes, ignore and go on
                         03 50   E8  0E86       	blbs	r0,30000$		; no error, go on
                          0CCC   31  0E89       	brw	_error_exit		; error, branch to error handler
                                     0E8C       30000$:
                                     0E8C       	
                                     0E8C  2216 30$:
                   00001B98'EF   B4  0E8C  2217 	clrw	v_outlen		; clean output length, since any
                                     0E92  2218 					;   outstanding was just output
           00 BB   00001B8C'EF   33  0E92  2219 	cvtwb	v_readlen,@(r11)	; save byte-count at address on stack
                       5B   04   C0  0E9A  2220 	addl2	#4,r11			; pop address off stack
                                 05  0E9D  2221 	rsb				; end of read
                                     0E9E  2222 
                                     0E9E  2223 
                                     0E9E  2224 ;+++t
                                     0E9E  2225 ;k> readstr ( a n -- ) Read line from terminal into word-counted string.
                                     0E9E  2226 ;	`a' is address of word-counted string.
                                     0E9E  2227 ;	'n' is maximum length.
                                     0E9E  2228 ;---
                                     0E9E  2229 	header	readstr
                           00000E2D' 0E9E       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000E9E  0EA2       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0EA2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0EA2       	.if    le, nchr		; nchr <= 0
            72 74 73 64 61 65 72 00' 0EA2       	   .ascic \readstr\	; no auxillary , use principle one
                                 07  0EA2       
                                     0EAA       	.if_false		; else
                                     0EAA       	  .ascic \\		; use auxillary 
                                     0EAA       	.endc			; end if
                                     0EAA       readstr:			; use  of word as vl_kernel label
                                     0EAA       	
                         04 AB   DD  0EAA  2230 	pushl	4(r11)			; where to put returned length
                    04 AB   02   C0  0EAD  2231 	addl2	#2,4(r11)		; move pointer over length word
           02 AB   00001B96'EF   B0  0EB1  2232 	movw	v_static_dsc,2(r11)	; move middle of descriptor on dstack
                   00001B98'EF   B5  0EB9  2233 	tstw	v_outlen		; Is there any outstanding output?
                            04   12  0EBF  2234 	bneq	10$			; yes
                            00   DD  0EC1  2235 	pushl	#0			; omit prompt since no output
                            21   11  0EC3  2236 	brb	20$			; skip over prompting
                                     0EC5  2237 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0EC5  2238 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0ECC  2239 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0ED3  2240 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                   00001B98'EF   B4  0EDB  2241 	clrw	v_outlen		; clear output length, since any
                                     0EE1  2242 					;   outstanding will be saved.
                            5B   DD  0EE1  2243 	pushl	r11			; put addrss of descriptor on rstack
                       5B   08   C0  0EE3  2244 	addl2	#8,r11			; move stack ptr back over descriptor
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 103
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0EE6  2245 20$:
                            5B   DD  0EE6  2246 	pushl	r11			; push address of descriptor
              00000000'GF   03   FB  0EE8  2247 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0EEF  2248 	isstrerr
              50   00000000'8F   D1  0EEF       	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                            06   13  0EF6       	beql	30001$		; yes, ignore and go on
                         03 50   E8  0EF8       	blbs	r0,30001$		; no error, go on
                          0C5A   31  0EFB       	brw	_error_exit		; error, branch to error handler
                                     0EFE       30001$:
                                     0EFE       	
                       5B   08   C0  0EFE  2249 	addl2	#8,r11			; pop arguments
                                 05  0F01  2250 	rsb				; end of readstr
                                     0F02  2251 
                                     0F02  2252 
                                     0F02  2253 ;+++
                                     0F02  2254 ;k> restart -- ( -- ) Restart VTIL, patching it to run again.
                                     0F02  2255 ;	Used in cases of error.  Never RETURNs.
                                     0F02  2256 ;---
                                     0F02  2257 	header	restart
                           00000E9E' 0F02       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F02  0F06       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0F06       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F06       	.if    le, nchr		; nchr <= 0
            74 72 61 74 73 65 72 00' 0F06       	   .ascic \restart\	; no auxillary , use principle one
                                 07  0F06       
                                     0F0E       	.if_false		; else
                                     0F0E       	  .ascic \\		; use auxillary 
                                     0F0E       	.endc			; end if
                                     0F0E       restart:			; use  of word as vl_kernel label
                                     0F0E       	
                          0AC1   31  0F0E  2258 	brw	r_warm_start		; patch it
                                     0F11  2259 					; end of restart
                                     0F11  2260 
                                     0F11  2261 
                                     0F11  2262 ;+++
                                     0F11  2263 ;k> s! -- ( n a -- ) Store a short integer (first 16 bits of `n' at `a'.~~~ `n' should be a `s'.
                                     0F11  2264 ;---
                                     0F11  2265 	header	i_word_store,<s!>
                           00000F02' 0F11       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F11  0F15       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0F15       	.nchr  nchr, ^\s!\	; nchr = length( s! )
                           00000002  0F15       	.if    le, nchr		; nchr <= 0
                                     0F15       	   .ascic \i_word_store\	; no auxillary s!, use principle one
                                     0F15       	.if_false		; else
                           21 73 00' 0F15       	  .ascic \s!\		; use auxillary s!
                                 02  0F15       
                                     0F18       	.endc			; end if
                                     0F18       i_word_store:			; use s! of word as vl_kernel label
                                     0F18       	
                 00 BB   04 AB   B0  0F18  2266 	movw	4(r11),@(r11)		; store the first 16 bits
                       5B   08   C0  0F1D  2267 	addl2	#8,r11			; pop arguments
                                 05  0F20  2268 	rsb				; end of s!
                                     0F21  2269 
                                     0F21  2270 
                                     0F21  2271 ;+++
                                     0F21  2272 ;k> s, -- ( s -- ) Store low word of `s' in dictinary.
                                     0F21  2273 ;---
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 104
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0F21  2274 	header	i_w_comma,<s,>
                           00000F11' 0F21       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F21  0F25       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0F25       	.nchr  nchr, ^\s,\	; nchr = length( s, )
                           00000002  0F25       	.if    le, nchr		; nchr <= 0
                                     0F25       	   .ascic \i_w_comma\	; no auxillary s,, use principle one
                                     0F25       	.if_false		; else
                           2C 73 00' 0F25       	  .ascic \s,\		; use auxillary s,
                                 02  0F25       
                                     0F28       	.endc			; end if
                                     0F28       i_w_comma:			; use s, of word as vl_kernel label
                                     0F28       	
                       89   6B   B0  0F28  2275 	movw	(r11),(r9)+		; store short in dictinary
                       5B   08   C0  0F2B  2276 	addl2	#8,r11			; pop arguments
                                 05  0F2E  2277 	rsb				; end of s,
                                     0F2F  2278 
                                     0F2F  2279 
                                     0F2F  2280 ;+++
                                     0F2F  2281 ;k> s@ -- ( a -- n ) Fetch 16 bits from `a' and zero-extend to longword.
                                     0F2F  2282 ;---
                                     0F2F  2283 	header	i_word_fetch,<s@>
                           00000F21' 0F2F       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F2F  0F33       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000002  0F33       	.nchr  nchr, ^\s@\	; nchr = length( s@ )
                           00000002  0F33       	.if    le, nchr		; nchr <= 0
                                     0F33       	   .ascic \i_word_fetch\	; no auxillary s@, use principle one
                                     0F33       	.if_false		; else
                           40 73 00' 0F33       	  .ascic \s@\		; use auxillary s@
                                 02  0F33       
                                     0F36       	.endc			; end if
                                     0F36       i_word_fetch:			; use s@ of word as vl_kernel label
                                     0F36       	
                    6B   00 BB   3C  0F36  2284 	movzwl	@(r11),(r11)		; get contents
                                 05  0F3A  2285 	rsb				; end of s@
                                     0F3B  2286 
                                     0F3B  2287 
                                     0F3B  2288 ;+++
                                     0F3B  2289 ;k> ss@ -- ( a -- n ) Fetch short at `a' and sign extend it to longword.
                                     0F3B  2290 ;---
                                     0F3B  2291 	header	i_ws_fetch,<ss@>
                           00000F2F' 0F3B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F3B  0F3F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  0F3F       	.nchr  nchr, ^\ss@\	; nchr = length( ss@ )
                           00000003  0F3F       	.if    le, nchr		; nchr <= 0
                                     0F3F       	   .ascic \i_ws_fetch\	; no auxillary ss@, use principle one
                                     0F3F       	.if_false		; else
                        40 73 73 00' 0F3F       	  .ascic \ss@\		; use auxillary ss@
                                 03  0F3F       
                                     0F43       	.endc			; end if
                                     0F43       i_ws_fetch:			; use ss@ of word as vl_kernel label
                                     0F43       	
                    6B   00 BB   32  0F43  2292 	cvtwl	@(r11),(r11)		; get contents, sign extend it
                                 05  0F47  2293 	rsb				; end of ss@
                                     0F48  2294 
                                     0F48  2295 
                                     0F48  2296 ;+++
                                     0F48  2297 ;k> save-buffers -- ( -- ) Write all modified buffers and mark them unmodified.
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 105
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     0F48  2298 ;---
                                     0F48  2299 	header	i_save_buffers,<save-buffers>
                           00000F3B' 0F48       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F48  0F4C       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           0000000C  0F4C       	.nchr  nchr, ^\save-buffers\	; nchr = length( save-buffers )
                           0000000C  0F4C       	.if    le, nchr		; nchr <= 0
                                     0F4C       	   .ascic \i_save_buffers\	; no auxillary save-buffers, use principle one
                                     0F4C       	.if_false		; else
72 65 66 66 75 62 2D 65 76 61 73 00' 0F4C       	  .ascic \save-buffers\		; use auxillary save-buffers
                                 73  0F58       
                                 0C  0F4C       
                                     0F59       	.endc			; end if
                                     0F59       i_save_buffers:			; use save-buffers of word as vl_kernel label
                                     0F59       	
                            50   D4  0F59  2300 	clrl	r0			; buffer number
                                     0F5B  2301 10$:
                            02   91  0F5B  2302 	cmpb	#c_modified,-		; Has the buffer
                       1B7D'C0       0F5D  2303 		v_buf_inuse(r0)		;   been modified? ~~~ Why not [r0]?
                            12   12  0F60  2304 	bneq	20$			; no, skip it
                       7A   50   D0  0F62  2305 	movl	r0,-(r10)		; save the buffer number
                       7B   50   D0  0F65  2306 	movl	r0,-(r11)		; set up for buffer-write
                       F78C CF   16  0F68  2307 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0F6C  2308 	movl	(r10)+,r0		; get the buffer number back
                            01   90  0F6F  2309 	movb	#c_inuse,-		; mark the buffer as
                       1B7D'C0       0F71  2310 		v_buf_inuse(r0)		;   in use, but not modified.
                                     0F74  2311 20$:
                            02   F1  0F74  2312 	acbl	#c_max_blocks-1,-	; buffer # is in [0 .. c_max_blocks-1]
                  FFE1 50   01       0F76  2313 		#1,r0,10$		; move to next buffer number, if any
                                 05  0F7A  2314 	rsb				; end of save-buffers
                                     0F7B  2315 
                                     0F7B  2316 
                                     0F7B  2317 ;+++t
                                     0F7B  2318 ;k> search -- ( a1 -- a2 ? f )  Search vocabulary at `a1' for a match with
                                     0F7B  2319 ;	byte-counted string at eodp.  Return  ( false ) if not found, or
                                     0F7B  2320 ;	( addr true ) if found.
                                     0F7B  2321 ;---
                                     0F7B  2322 	header	search
                           00000F48' 0F7B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000F7B  0F7F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0F7F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F7F       	.if    le, nchr		; nchr <= 0
               68 63 72 61 65 73 00' 0F7F       	   .ascic \search\	; no auxillary , use principle one
                                 06  0F7F       
                                     0F86       	.if_false		; else
                                     0F86       	  .ascic \\		; use auxillary 
                                     0F86       	.endc			; end if
                                     0F86       search:			; use  of word as vl_kernel label
                                     0F86       	
                            6B   D5  0F86  2323 	tstl	(r11)			; Is it nil pointer on top of stack?
                            29   13  0F88  2324 	beql	10$			; yes, stop search, leave false on stack
                  56   6B   04   C1  0F8A  2325 	addl3	#4,(r11),r6		; r6 = Address of byte-count
                       69   66   91  0F8E  2326 	cmpb	(r6),(r9)		; no, ?equal length
                            1A   12  0F91  2327 	bneq	20$			; no
                       56   69   99  0F93  2328 	cvtbw	(r9),r6			; yes, get string length
                  57   6B   05   C1  0F96  2329 	addl3	#5,(r11),r7		; get address of word name
                  58   59   01   C1  0F9A  2330 	addl3	#1,r9,r8		; get address of token
                  68   67   56   29  0F9E  2331 	cmpc3	r6,(r7),(r8)		; compare strings
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 106
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                            09   12  0FA2  2332 	bneq	20$			; strings don't match
                                     0FA4  2333 ; string match
              7B   FFFFFFFF 8F   D0  0FA4  2334 	movl	#c_true,-(r11)		; move true to top of stack
                            06   11  0FAB  2335 	brb	10$			; exit leaving ( addr true ) on dstack.
                                     0FAD  2336 20$:
                    6B   00 BB   D0  0FAD  2337 	movl	@(r11),(r11)		; get address of next word
                            D3   11  0FB1  2338 	brb	search			; try it again
                                     0FB3  2339 10$:
                                 05  0FB3  2340 	rsb				; end of search
                                     0FB4  2341 
                                     0FB4  2342 
                                     0FB4  2343 ;+++
                                     0FB4  2344 ;k> short -- ( n -- ) Create a word that pushed the address of two bytes
                                     0FB4  2345 ;	(a VAX memory `word') on the stack, reserves space in the dictionary
                                     0FB4  2346 ;	for those two bytes, and initializes it to the value of `n'.
                                     0FB4  2347 ;---
                                     0FB4  2348 	header	i_short,<short>
                           00000F7B' 0FB4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000FB4  0FB8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000005  0FB8       	.nchr  nchr, ^\short\	; nchr = length( short )
                           00000005  0FB8       	.if    le, nchr		; nchr <= 0
                                     0FB8       	   .ascic \i_short\	; no auxillary short, use principle one
                                     0FB8       	.if_false		; else
                  74 72 6F 68 73 00' 0FB8       	  .ascic \short\		; use auxillary short
                                 05  0FB8       
                                     0FBE       	.endc			; end if
                                     0FBE       i_short:			; use short of word as vl_kernel label
                                     0FBE       	
                       F880 CF   16  0FBE  2349 	jsb	create			; enclose next token in dictionary
                       89   3E   90  0FC2  2350 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  0FC5  2351 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0FC9  2352 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0FCC  2353 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0FD0  2354 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  0FD3  2355 	movw	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  0FD6  2356 	addl2	#4,r11			; pop aruments
                                 05  0FD9  2357 	rsb				; end of short
                                     0FDA  2358 
                                     0FDA  2359 
                                     0FDA  2360 ;+++
                                     0FDA  2361 ;k> sign -- ( n -- ) Output minus in pictured numeric if top of stack is < 0.
                                     0FDA  2362 ;---
                                     0FDA  2363 	header	sign
                           00000FB4' 0FDA       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000FDA  0FDE       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0FDE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0FDE       	.if    le, nchr		; nchr <= 0
                     6E 67 69 73 00' 0FDE       	   .ascic \sign\	; no auxillary , use principle one
                                 04  0FDE       
                                     0FE3       	.if_false		; else
                                     0FE3       	  .ascic \\		; use auxillary 
                                     0FE3       	.endc			; end if
                                     0FE3       sign:			; use  of word as vl_kernel label
                                     0FE3       	
                            8B   D5  0FE3  2364 	tstl	(r11)+			; tos < 0?
                            07   18  0FE5  2365 	bgeq	10$			; no, exit
                       7B   2D   D0  0FE7  2366 	movl	#^a\-\,-(r11)		; put ascii for minus sign on stack
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 107
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       FB25 CF   16  0FEA  2367 	jsb	hold			; put it in output string
                                     0FEE  2368 10$:
                                 05  0FEE  2369 	rsb				; end of sign
                                     0FEF  2370 
                                     0FEF  2371 
                                     0FEF  2372 ;+++
                                     0FEF  2373 ;k> smudge -- ( -- ) Sets the smudge (high) bit in the length byte as the word
                                     0FEF  2374 ;	that is currently being defined won't be found in itself.
                                     0FEF  2375 ;---
                                     0FEF  2376 	header	smudge
                           00000FDA' 0FEF       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00000FEF  0FF3       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  0FF3       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0FF3       	.if    le, nchr		; nchr <= 0
               65 67 64 75 6D 73 00' 0FF3       	   .ascic \smudge\	; no auxillary , use principle one
                                 06  0FF3       
                                     0FFA       	.if_false		; else
                                     0FFA       	  .ascic \\		; use auxillary 
                                     0FFA       	.endc			; end if
                                     0FFA       smudge:			; use  of word as vl_kernel label
                                     0FFA       	
              50   00001D3B'FF   D0  0FFA  2377 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  1001  2378 	addl2	#4,r0			; move over link field
                    60   40 8F   88  1004  2379 	bisb2	#^b1000000,(r0)		; set smudge bit
                                 05  1008  2380 	rsb				; end of smudge
                                     1009  2381 
                                     1009  2382 
                                     1009  2383 ;+++
                                     1009  2384 ;k> sp@ -- ( -- l ) Returns the address of the top fo the data stack before
                                     1009  2385 ;	{ sp@ } is executed.
                                     1009  2386 ;---
                                     1009  2387 	header	i_sp_fetch,<sp@>
                           00000FEF' 1009       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001009  100D       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  100D       	.nchr  nchr, ^\sp@\	; nchr = length( sp@ )
                           00000003  100D       	.if    le, nchr		; nchr <= 0
                                     100D       	   .ascic \i_sp_fetch\	; no auxillary sp@, use principle one
                                     100D       	.if_false		; else
                        40 70 73 00' 100D       	  .ascic \sp@\		; use auxillary sp@
                                 03  100D       
                                     1011       	.endc			; end if
                                     1011       i_sp_fetch:			; use sp@ of word as vl_kernel label
                                     1011       	
                       7B   5B   D0  1011  2388 	movl	r11,-(r11)		; put address of top of stack on stack
                                 05  1014  2389 	rsb				; end of sp@
                                     1015  2390 
                                     1015  2391 
                                     1015  2392 ;+++
                                     1015  2393 ;k> sp0 -- ( -- l ) Returns the address of the bottom of the data stack.
                                     1015  2394 ;	Note that the stack grows downward, so this is actually the
                                     1015  2395 ;	top in memory of the data-stack structure's space.
                                     1015  2396 ;___
                                     1015  2397 	header	i_sp_0,<sp0>
                           00001009' 1015       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001015  1019       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000003  1019       	.nchr  nchr, ^\sp0\	; nchr = length( sp0 )
                           00000003  1019       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 108
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1019       	   .ascic \i_sp_0\	; no auxillary sp0, use principle one
                                     1019       	.if_false		; else
                        30 70 73 00' 1019       	  .ascic \sp0\		; use auxillary sp0
                                 03  1019       
                                     101D       	.endc			; end if
                                     101D       i_sp_0:			; use sp0 of word as vl_kernel label
                                     101D       	
              7B   00001000'EF   DE  101D  2398 	moval	c_ds_start,-(r11)	; put address on stack
                                 05  1024  2399 	rsb				; end of sp0
                                     1025  2400 
                                     1025  2401 
                                     1025  2402 ;+++
                                     1025  2403 ;k> space -- ( -- ) Output a space to terminal.
                                     1025  2404 ;---
                                     1025  2405 	header	space
                           00001015' 1025       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001025  1029       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  1029       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1029       	.if    le, nchr		; nchr <= 0
                  65 63 61 70 73 00' 1029       	   .ascic \space\	; no auxillary , use principle one
                                 05  1029       
                                     102F       	.if_false		; else
                                     102F       	  .ascic \\		; use auxillary 
                                     102F       	.endc			; end if
                                     102F       space:			; use  of word as vl_kernel label
                                     102F       	
         00A0 8F   00001B98'EF   B1  102F  2406 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            04   19  1038  2407 	blss	10$			; no, go on
                       F7D0 CF   16  103A  2408 	jsb	cr			; yes, output it
                                     103E  2409 10$:
              50   00001B9A'EF   9E  103E  2410 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  1045  2411 	movzwl	v_outlen,r1		; index into buffer
              00000028'EF   51   C0  104C  2412 	addl2	r1,40			; pointer to next available buffer
                       60   20   90  1053  2413 	movb	#c_blank,(r0)		; move char into buffer
                   00001B98'EF   B6  1056  2414 	incw	v_outlen		; increment index (or length)
                                 05  105C  2415 	rsb				; end of space
                                     105D  2416 
                                     105D  2417 
                                     105D  2418 ;+++
                                     105D  2419 ;,> spaces -- ( n -- ) Output `n' spaces to terminal
                                     105D  2420 ;---
                                     105D  2421 	header	spaces
                           00001025' 105D       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000105D  1061       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  1061       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1061       	.if    le, nchr		; nchr <= 0
               73 65 63 61 70 73 00' 1061       	   .ascic \spaces\	; no auxillary , use principle one
                                 06  1061       
                                     1068       	.if_false		; else
                                     1068       	  .ascic \\		; use auxillary 
                                     1068       	.endc			; end if
                                     1068       spaces:			; use  of word as vl_kernel label
                                     1068       	
                            6B   D5  1068  2422 	tstl	(r11)			; Is it less than or equal to zero?
                            0E   15  106A  2423 	bleq	100$			; yes, exit
                       7B   01   D0  106C  2424 	movl	#1,-(r11)		; no, save space on stack for index
                                     106F  2425 10$:
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 109
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                         BD AF   16  106F  2426 	jsb	space			; output one space
                 F8 6B   04 AB   F2  1072  2427 	aoblss	4(r11),(r11),10$	; (r11) += 1, repeat if (r11) < 4(r11)
                       5B   04   C0  1077  2428 	addl2	#4,r11			; pop index
                                     107A  2429 100$:
                       5B   04   C0  107A  2430 	addl2	#4,r11			; pop argument
                                 05  107D  2431 	rsb				; end of spaces
                                     107E  2432 
                                     107E  2433 
                                     107E  2434 ;+++t
                                     107E  2435 ;k> sread ( -- ) Read a line from terminal or file into input stream,
                                     107E  2436 ;	depending on value of { infile }.  if { infile } is true, read
                                     107E  2437 ;	from file; otherwise, read from terminal.
                                     107E  2438 ;---
                                     107E  2439 	header	sread
                           0000105D' 107E       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000107E  1082       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  1082       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1082       	.if    le, nchr		; nchr <= 0
                  64 61 65 72 73 00' 1082       	   .ascic \sread\	; no auxillary , use principle one
                                 05  1082       
                                     1088       	.if_false		; else
                                     1088       	  .ascic \\		; use auxillary 
                                     1088       	.endc			; end if
                                     1088       sread:			; use  of word as vl_kernel label
                                     1088       	
                   00001B98'EF   B5  1088  2440 	tstw	v_outlen		; Is there any outstanding output?
                            04   13  108E  2441 	beql	5$			; no
                       F77A CF   16  1090  2442 	jsb	cr			; yes, output it
                                     1094  2443 5$:
     0000199B'EF   000018F7'EF   DE  1094  2444 	moval	v_inbuf,v_inptr		; start at beginning of line
                   00001D47'EF   95  109F  2445 	tstb	v_infile		; getting input from file?
                            37   12  10A5  2446 	bneq	10$			; yes, go do it
                                     10A7  2447 ; no, get from terminal
                   00001999'EF   3F  10A7  2448 	pushaw	v_inlen			; save returned length
                   0000182A'EF   7F  10AD  2449 	pushaq	v_vtilprompt		; use vtil prompt
                   0000199F'EF   7F  10B3  2450 	pushaq	v_in_dsc		; address of input descriptor
              00000000'GF   03   FB  10B9  2451 	calls	#3,g^lib$get_input	; get a line from terminal
                         0F 50   E8  10C0  2452 	blbs	r0,8$			; no error, go on
              50   00000000'8F   D1  10C3  2453 	cmpl	#rms$_eof,r0		; Is it eof from terminal?
                            03   12  10CA  2454 	bneq	7$			; no, go die messily
                          0ABC   31  10CC  2455 	brw	_exit			; yes, exit silently
                                     10CF  2456 7$:
                          0A86   31  10CF  2457 	brw	_error_exit		; die messily
                                     10D2  2458 8$:
     00001997'EF   00001999'EF   B0  10D2  2459 	movw	v_inlen,v_org_inlen	; save original length
                                 05  10DD  2460 	rsb				; success read from terminal, return
                                     10DE  2461 10$:
                                     10DE  2462 	$get	rab=v_inrab		; get a record
                                     10DE       		$RMSCALL	GET,v_inrab,,
                                     10DE       	.GLOBL	SYS$GET
                                     10DE       	.IF	B <v_inrab>
                                     10DE       	CALLG	(AP),G^SYS$GET
                                     10DE       	$$.TMP=0
                                     10DE       	.IF	NB <>
                                     10DE       	$$.TMP=1
                                     10DE       	.ENDC
                                     10DE       	.IF	NB <>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 110
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     10DE       	$$.TMP=1
                                     10DE       	.ENDC
                                     10DE       	.IF	NE $$.TMP
                                     10DE       	.ERROR				; v_inrab= parameter missing;
                                     10DE       	.ENDC
                                     10DE       	.ENDC
                                     10DE       	.IF	NB <v_inrab>
                           00000001  10DE       	$$.TMP1=1
                                     10DE       	.IF	NB <>
                                     10DE       	PUSHAL	
                                     10DE       	$$.TMP1=3
                                     10DE       	.ENDC
                                     10DE       	.IF	NB <>
                                     10DE       	PUSHAL	
                                     10DE       	.IF	EQ <$$.TMP1-1>
                                     10DE       	$$.TMP1=2
                                     10DE       	.ENDC
                                     10DE       	.IFF
                           FFFFFFFE  10DE       	.IF	EQ <$$.TMP1-3>
                                     10DE       	PUSHL	#0
                                     10DE       	.ENDC
                                     10DE       	.ENDC
                           000000CF  10DE       	.NTYPE	$$.TMP2,v_inrab
                           00000070  10DE       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     10DE       	PUSHL	v_inrab
                                     10DE       	.IFF
                           000000B0  10DE       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     10DE       	PUSHL	v_inrab
                                     10DE       	.IFF
                   000019F8'EF   DF  10DE       	PUSHAL	v_inrab
                                     10E4       	.ENDC
                                     10E4       	.ENDC
              00000000'GF   01   FB  10E4       	CALLS	#$$.TMP1,G^SYS$GET
                                     10EB       	.ENDC
                                     10EB       	
                                     10EB       	
                         13 50   E8  10EB  2463 	blbs	r0,20$			; write the record
              00000000'8F   50   D1  10EE  2464 	cmpl	r0,#rms$_eof		; was error end-of-file
                            27   13  10F5  2465 	beql	30$			; successful completion
                                     10F7  2466 ; error otherwize
              56   000019F8'EF   DE  10F7  2467 	moval	v_inrab,r6		; keep rab address
                          0A70   31  10FE  2468 	brw	_r_err			; signal record error
                                     1101  2469 20$:
                   00001A1A'EF   B0  1101  2470 	movw	v_inrab+rab$w_rsz,-	; input rab set record size
                   00001999'EF       1107  2471 		v_inlen
                   00001A1A'EF   B0  110C  2472 	movw	v_inrab+rab$w_rsz,-
                   00001997'EF       1112  2473 		v_org_inlen
                   00001D48'EF   D6  1117  2474 	incl	v_filelinenum		; increment line number in file
                                 05  111D  2475 	rsb				; success read from file, return
                                     111E  2476 30$:
                                     111E  2477 	$close	fab=v_infab		; close input
                                     111E       		$RMSCALL	CLOSE,v_infab,,
                                     111E       	.GLOBL	SYS$CLOSE
                                     111E       	.IF	B <v_infab>
                                     111E       	CALLG	(AP),G^SYS$CLOSE
                                     111E       	$$.TMP=0
                                     111E       	.IF	NB <>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 111
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     111E       	$$.TMP=1
                                     111E       	.ENDC
                                     111E       	.IF	NB <>
                                     111E       	$$.TMP=1
                                     111E       	.ENDC
                                     111E       	.IF	NE $$.TMP
                                     111E       	.ERROR				; v_infab= parameter missing;
                                     111E       	.ENDC
                                     111E       	.ENDC
                                     111E       	.IF	NB <v_infab>
                           00000001  111E       	$$.TMP1=1
                                     111E       	.IF	NB <>
                                     111E       	PUSHAL	
                                     111E       	$$.TMP1=3
                                     111E       	.ENDC
                                     111E       	.IF	NB <>
                                     111E       	PUSHAL	
                                     111E       	.IF	EQ <$$.TMP1-1>
                                     111E       	$$.TMP1=2
                                     111E       	.ENDC
                                     111E       	.IFF
                           FFFFFFFE  111E       	.IF	EQ <$$.TMP1-3>
                                     111E       	PUSHL	#0
                                     111E       	.ENDC
                                     111E       	.ENDC
                           000000CF  111E       	.NTYPE	$$.TMP2,v_infab
                           00000070  111E       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     111E       	PUSHL	v_infab
                                     111E       	.IFF
                           000000B0  111E       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     111E       	PUSHL	v_infab
                                     111E       	.IFF
                   000019A8'EF   DF  111E       	PUSHAL	v_infab
                                     1124       	.ENDC
                                     1124       	.ENDC
              00000000'GF   01   FB  1124       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     112B       	.ENDC
                                     112B       	
                                     112B       	
              00001D47'EF   00   90  112B  2478 	movb	#c_false,v_infile	; set v_infile flag false
              00001D48'EF   00   D0  1132  2479 	movl	#0,v_filelinenum	; zero file line as well
                                 05  1139  2480 	rsb				; end of sread
                                     113A  2481 
                                     113A  2482 
                                     113A  2483 ;+++
                                     113A  2484 ;k> strcat -- ( a1 a2 -- ) Catenate string at `a`' to string at `a2'.
                                     113A  2485 ;	Works only with strings defined by { string } or { string" }
                                     113A  2486 ;	since it uses maxlen of string at `a2'.
                                     113A  2487 ;---
                                     113A  2488 	header	strcat
                           0000107E' 113A       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000113A  113E       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  113E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  113E       	.if    le, nchr		; nchr <= 0
               74 61 63 72 74 73 00' 113E       	   .ascic \strcat\	; no auxillary , use principle one
                                 06  113E       
                                     1145       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 112
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1145       	  .ascic \\		; use auxillary 
                                     1145       	.endc			; end if
                                     1145       strcat:			; use  of word as vl_kernel label
                                     1145       	
                    50   04 BB   3C  1145  2489 	movzwl	@4(r11),r0		; length of src
                    57   00 BB   3C  1149  2490 	movzwl	@(r11),r7		; length of dest
               53   04 AB   02   C1  114D  2491 	addl3	#2,4(r11),r3		; address of src characters
                       52   6B   D0  1152  2492 	movl	(r11),r2		; address of dest
                  54   52   02   C3  1155  2493 	subl3	#2,r2,r4		; address of maxlen of dest
                  52   52   02   C1  1159  2494 	addl3	#2,r2,r2		; address of dest char
                       55   64   3C  115D  2495 	movzwl	(r4),r5			; maxlen of dest
                  56   55   57   C3  1160  2496 	subl3	r7,r5,r6		; space available in dest
                       50   56   D1  1164  2497 	cmpl	r6,r0			; less space available than to copy
                            03   15  1167  2498 	bleq	10$			; yes, use space available in dest as len
                       56   50   D0  1169  2499 	movl	r0,r6			; no, move all characters in src
                                     116C  2500 10$:
                       52   57   C0  116C  2501 	addl2	r7,r2			; start at end of dest chars
                  62   63   56   28  116F  2502 	movc3	r6,(r3),(r2)		; copy the string
                    00 BB   56   A0  1173  2503 	addw2	r6,@(r11)		; store the new length
                       5B   08   C0  1177  2504 	addl2	#8,r11			; pop arguments
                                 05  117A  2505 	rsb				; end of strcat
                                     117B  2506 
                                     117B  2507 
                                     117B  2508 ;+++
                                     117B  2509 ;k> strcmp -- ( a1 a2 -- n ) Compare word-counted strings.
                                     117B  2510 ;	Return 0 if string at `a`' = string at `a2'.
                                     117B  2511 ;	Return >0 if string at `a`' > string at `a2'.
                                     117B  2512 ;	Return <0 if string at `a1' < string at `a2'.
                                     117B  2513 ;---
                                     117B  2514 	header	strcmp
                           0000113A' 117B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000117B  117F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  117F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  117F       	.if    le, nchr		; nchr <= 0
               70 6D 63 72 74 73 00' 117F       	   .ascic \strcmp\	; no auxillary , use principle one
                                 06  117F       
                                     1186       	.if_false		; else
                                     1186       	  .ascic \\		; use auxillary 
                                     1186       	.endc			; end if
                                     1186       strcmp:			; use  of word as vl_kernel label
                                     1186       	
                    50   04 BB   3C  1186  2515 	movzwl	@4(r11),r0		; length of str1
               51   04 AB   02   C1  118A  2516 	addl3	#2,4(r11),r1		; address of chars in str1
                    52   00 BB   3C  118F  2517 	movzwl	@(r11),r2		; length of str2
                  53   6B   02   C1  1193  2518 	addl3	#2,(r11),r3		; address of chars in str2
                       5B   08   C0  1197  2519 	addl2	#8,r11			; pop top two stack items
        63   52   00   61   50   2D  119A  2520 	cmpc5	r0,(r1),#0,r2,(r3)	; compare chars with 0 fill
                            0A   13  11A0  2521 	beql	10$			; str1 = str2
                            0C   14  11A2  2522 	bgtr	20$			; str1 > str2
              7B   FFFFFFFF 8F   D0  11A4  2523 	movl	#-1,-(r11)		; str1 < str2
                                 05  11AB  2524 	rsb				; exit
                                     11AC  2525 10$:
                       7B   00   D0  11AC  2526 	movl	#0,-(r11)		; str1 = str2
                                 05  11AF  2527 	rsb				; exit
                                     11B0  2528 20$:
                       7B   01   D0  11B0  2529 	movl	#1,-(r11)		; str1 > str2
                                 05  11B3  2530 	rsb				; end of strcmp
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 113
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     11B4  2531 
                                     11B4  2532 
                                     11B4  2533 ;+++
                                     11B4  2534 ;k> strcpy -- ( a1 a2 -- ) copy word counted string at `a1' to w-string at `a2'.
                                     11B4  2535 ;	Both must be word-counted, and string at `a2' must have maxlen 2bytes
                                     11B4  2536 ;	(i.e., defined by { string } or { string" }).
                                     11B4  2537 ;---
                                     11B4  2538 	header	strcpy
                           0000117B' 11B4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000011B4  11B8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  11B8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  11B8       	.if    le, nchr		; nchr <= 0
               79 70 63 72 74 73 00' 11B8       	   .ascic \strcpy\	; no auxillary , use principle one
                                 06  11B8       
                                     11BF       	.if_false		; else
                                     11BF       	  .ascic \\		; use auxillary 
                                     11BF       	.endc			; end if
                                     11BF       strcpy:			; use  of word as vl_kernel label
                                     11BF       	
                       50   6B   D0  11BF  2539 	movl	(r11),r0		; get address of destination
                    51   04 AB   D0  11C2  2540 	movl	4(r11),r1		; get address of source
                       56   61   3C  11C6  2541 	movzwl	(r1),r6			; length of source
                  52   50   02   C3  11C9  2542 	subl3	#2,r0,r2		; address of destination max len
                       52   62   3C  11CD  2543 	movzwl	(r2),r2			; dest max len
                       56   52   D1  11D0  2544 	cmpl	r2,r6			; max len < source len?
                            03   18  11D3  2545 	bgeq	10$			; no
                       56   52   D0  11D5  2546 	movl	r2,r6			; yes, use max len for src len
                                     11D8  2547 10$:
            02 A0   02 AB   56   28  11D8  2548 	movc3	r6,2(r11),2(r0)		; move the strings
                    00 BB   56   B0  11DE  2549 	movw	r6,@(r11)		; save the new length of dest
                       5B   08   C0  11E2  2550 	addl2	#8,r11			; pop arguments
                                 05  11E5  2551 	rsb				; end of strcpy
                                     11E6  2552 
                                     11E6  2553 
                                     11E6  2554 ;+++
                                     11E6  2555 ;k> string -- ( n -- ) Create a string variable with maximum length of `n'.
                                     11E6  2556 ;	The first 2 bytes of the string contains its length.
                                     11E6  2557 ;	The 2 bytes previous to the string contains its maximum length.
                                     11E6  2558 ;---
                                     11E6  2559 	header	string,<string>
                           000011B4' 11E6       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000011E6  11EA       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000006  11EA       	.nchr  nchr, ^\string\	; nchr = length( string )
                           00000006  11EA       	.if    le, nchr		; nchr <= 0
                                     11EA       	   .ascic \string\	; no auxillary string, use principle one
                                     11EA       	.if_false		; else
               67 6E 69 72 74 73 00' 11EA       	  .ascic \string\		; use auxillary string
                                 06  11EA       
                                     11F1       	.endc			; end if
                                     11F1       string:			; use string of word as vl_kernel label
                                     11F1       	
                       F64D CF   16  11F1  2560 	jsb	create			; make the header
                       89   3E   90  11F5  2561 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  11F8  2562 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  11FC  2563 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  11FF  2564 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  1203  2565 	movb	#op_rsb,(r9)+		; rsb
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 114
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       89   6B   B0  1206  2566 	movw	(r11),(r9)+		; maximum length
                       89   00   B0  1209  2567 	movw	#0,(r9)+		; make high byte of current count
                       59   8B   C0  120C  2568 	addl2	(r11)+,r9		; save space for characters
                                 05  120F  2569 	rsb				; end of string
                                     1210  2570 
                                     1210  2571 
                                     1210  2572 ;+++
                                     1210  2573 ;k> string" -- ( n -- ) Create a string variable with maximum length of `n',
                                     1210  2574 ;	and initialize with string from input stream up until next `"'.
                                     1210  2575 ;	The first 2 bytes of the string contain its length.
                                     1210  2576 ;	The 2 bytes previous to the string contains its maximum length.
                                     1210  2577 ;---
                                     1210  2578 	header	i_string_quote,<string">
                           000011E6' 1210       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001210  1214       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000007  1214       	.nchr  nchr, ^\string"\	; nchr = length( string" )
                           00000007  1214       	.if    le, nchr		; nchr <= 0
                                     1214       	   .ascic \i_string_quote\	; no auxillary string", use principle one
                                     1214       	.if_false		; else
            22 67 6E 69 72 74 73 00' 1214       	  .ascic \string"\		; use auxillary string"
                                 07  1214       
                                     121C       	.endc			; end if
                                     121C       i_string_quote:			; use string" of word as vl_kernel label
                                     121C       	
                       F622 CF   16  121C  2579 	jsb	create			; make the header
                       89   3E   90  1220  2580 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  1223  2581 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  1227  2582 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  122A  2583 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  122E  2584 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  1231  2585 	movw	(r11),(r9)+		; maximum length
                       7A   59   D0  1234  2586 	movl	r9,-(r10)		; save address of current length on lstack
                       89   00   90  1237  2587 	movb	#0,(r9)+		; make high byte of current count
                                     123A  2588 					;   zero since token returns a b-counted
                                     123A  2589 					;   string
                       7B   22   D0  123A  2590 	movl	#^a\"\,-(r11)		; set up for quote terminated token
                   000012E2'EF   16  123D  2591 	jsb	token			; get the token
                       50   89   9A  1243  2592 	movzbl	(r9)+,r0		; get count and move over to first char
                       50   6B   B1  1246  2593 	cmpw	(r11),r0		; is max length < token length
                            03   18  1249  2594 	bgeq	10$			; no
                       50   6B   D0  124B  2595 	movl	(r11),r0		; yes, only allow maxlen chars from
                                     124E  2596 					;   token
                                     124E  2597 10$:
                    00 BA   50   B0  124E  2598 	movw	r0,@(r10)		; save current length
                       5A   04   C0  1252  2599 	addl2	#4,r10			; pop temp storage from loop stack.
                       59   8B   C0  1255  2600 	addl2	(r11)+,r9		; save space for characters
                                 05  1258  2601 	rsb				; end of string"
                                     1259  2602 
                                     1259  2603 
                                     1259  2604 ;+++
                                     1259  2605 ;k> strmax -- ( -- ) Return maximum length of string at `a'.
                                     1259  2606 ;---
                                     1259  2607 	header	strmax
                           00001210' 1259       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001259  125D       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  125D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  125D       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 115
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

               78 61 6D 72 74 73 00' 125D       	   .ascic \strmax\	; no auxillary , use principle one
                                 06  125D       
                                     1264       	.if_false		; else
                                     1264       	  .ascic \\		; use auxillary 
                                     1264       	.endc			; end if
                                     1264       strmax:			; use  of word as vl_kernel label
                                     1264       	
                       6B   02   C2  1264  2608 	subl2	#2,(r11)		; get address of max len
                    6B   00 BB   3C  1267  2609 	movzwl	@(r11),(r11)		; get maximum length
                                 05  126B  2610 	rsb				; end of strmax
                                     126C  2611 
                                     126C  2612 
                                     126C  2613 ;+++
                                     126C  2614 ;k> strpos -- ( a1 n1 a2 n2 -- a3 n3 ? f ) Find pos and len of substring in str.
                                     126C  2615 ;	Searches string whose text is at `a2' and length is `n2' for substring
                                     126C  2616 ;	whose text is at `a`' and whose length is `n1'.  Returns true on top of
                                     126C  2617 ;	stack if found and under that { a3 n3 }, address and length of located
                                     126C  2618 ;	substring.  Otherwise returns false.
                                     126C  2619 ;---
                                     126C  2620 	header	strpos
                           00001259' 126C       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000126C  1270       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  1270       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1270       	.if    le, nchr		; nchr <= 0
               73 6F 70 72 74 73 00' 1270       	   .ascic \strpos\	; no auxillary , use principle one
                                 06  1270       
                                     1277       	.if_false		; else
                                     1277       	  .ascic \\		; use auxillary 
                                     1277       	.endc			; end if
                                     1277       strpos:			; use  of word as vl_kernel label
                                     1277       	
                         08 AB   39  1277  2621 	matchc	8(r11),-		; length of object string (to find)
                         0C BB       127A  2622 		@12(r11),-		; address of object string
                            6B       127C  2623 		(r11),-			; length of source string (to search in)
                         04 BB       127D  2624 		@4(r11)			; address of source string
                            19   12  127F  2625 	bneq	10$			; match not found
                    50   08 AB   D0  1281  2626 	movl	8(r11),r0		; save length of object string
                  51   53   50   C3  1285  2627 	subl3	r0,r3,r1		; calculate start addr of found string
                       5B   10   C0  1289  2628 	addl2	#16,r11			; pop arguments
                       7B   51   D0  128C  2629 	movl	r1,-(r11)		; put address of found string on stack
                       7B   50   D0  128F  2630 	movl	r0,-(r11)		; put length of found string on stack
              7B   FFFFFFFF 8F   D0  1292  2631 	movl	#c_true,-(r11)		; put true on stack
                                 05  1299  2632 	rsb				; rturn
                                     129A  2633 10$:
                       5B   10   C0  129A  2634 	addl2	#16,r11			; pop arguments
                       7B   00   D0  129D  2635 	movl	#c_false,-(r11)
                                 05  12A0  2636 	rsb				; end of strpos
                                     12A1  2637 
                                     12A1  2638 
                                     12A1  2639 ;+++
                                     12A1  2640 ;k> swap -- ( n1 n2 -- n2 n1 ) exchange the top two items on the stack.
                                     12A1  2641 ;---
                                     12A1  2642 	header	swap
                           0000126C' 12A1       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000012A1  12A5       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  12A5       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12A5       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 116
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                     70 61 77 73 00' 12A5       	   .ascic \swap\	; no auxillary , use principle one
                                 04  12A5       
                                     12AA       	.if_false		; else
                                     12AA       	  .ascic \\		; use auxillary 
                                     12AA       	.endc			; end if
                                     12AA       swap:			; use  of word as vl_kernel label
                                     12AA       	
                       50   6B   D0  12AA  2643 	movl	(r11),r0		; temp = n2
                    6B   04 AB   D0  12AD  2644 	movl	4(r11),(r11)		; n2 = n1
                    04 AB   50   D0  12B1  2645 	movl	r0,4(r11)		; n1 = saved n2
                                 05  12B5  2646 	rsb				; end of swap
                                     12B6  2647 
                                     12B6  2648 
                                     12B6  2649 ;+++
                                     12B6  2650 ;k> tochar -- convert top fo stack from 0..9, A..Z to '0'..'9','A'..'Z'
                                     12B6  2651 ;	( n -- c ) where n is a number and c is a char.
                                     12B6  2652 ;	If not in rnage leave alow.
                                     12B6  2653 ;---
                                     12B6  2654 	header	tochar
                           000012A1' 12B6       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000012B6  12BA       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  12BA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12BA       	.if    le, nchr		; nchr <= 0
               72 61 68 63 6F 74 00' 12BA       	   .ascic \tochar\	; no auxillary , use principle one
                                 06  12BA       
                                     12C1       	.if_false		; else
                                     12C1       	  .ascic \\		; use auxillary 
                                     12C1       	.endc			; end if
                                     12C1       tochar:			; use  of word as vl_kernel label
                                     12C1       	
                                     12C1  2655 ; with 10 numbers and 26 letters, largest base is 36.
                                     12C1  2656 ; didgits go from 0 to 35.
                            6B   D5  12C1  2657 	tstl	(r11)			; n < 0?
                            12   19  12C3  2658 	blss	100$			; yes, exit
                       23   6B   D1  12C5  2659 	cmpl	(r11),#35		; n > 35
                            0D   14  12C8  2660 	bgtr	100$			; yes, exit
                       09   6B   D1  12CA  2661 	cmpl	(r11),#9		; n > 9 (not a `number') ~~~base 10 digit
                            05   14  12CD  2662 	bgtr	10$			; yes, make it 'A' .. 'Z'
                       6B   30   C0  12CF  2663 	addl2	#48,(r11)		; no, make it a '1' .. '9'
                            03   11  12D2  2664 	brb	100$			; exit
                                     12D4  2665 10$:
                       6B   37   C0  12D4  2666 	addl2	#55,(r11)		; make it 'A' .. 'Z'
                                     12D7  2667 100$:
                                 05  12D7  2668 	rsb				; end of tochar.
                                     12D8  2669 
                                     12D8  2670 
                                     12D8  2671 ;+++t
                                     12D8  2672 ;k> token -- ( c -- ) Get next token from input stream and put it in dictionary.
                                     12D8  2673 ;	Note that this dos NOT increment the dictionary pointer!
                                     12D8  2674 ;---
                                     12D8  2675 	header	token
                           000012B6' 12D8       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000012D8  12DC       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  12DC       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12DC       	.if    le, nchr		; nchr <= 0
                  6E 65 6B 6F 74 00' 12DC       	   .ascic \token\	; no auxillary , use principle one
                                 05  12DC       
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 117
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     12E2       	.if_false		; else
                                     12E2       	  .ascic \\		; use auxillary 
                                     12E2       	.endc			; end if
                                     12E2       token:			; use  of word as vl_kernel label
                                     12E2       	
                       6B   20   91  12E2  2676 	cmpb	#c_blank,(r11)		; ?c = ' '~~~, an ascii blank
                            22   12  12E5  2677 	bneq	_gettoken		; if anything but space, don't skip
                                     12E7  2678 _skipwhitespace:
0000199B'FF   00001999'EF   6B   3B  12E7  2679 	skpc	(r11),v_inlen,@v_inptr	; skip whitespace
                            06   12  12F3  2680 	bneq	_startfound		; if something other than whitespace
                                     12F5  2681 					; found
                       FD8F CF   16  12F5  2682 	jsb     sread                   ; get a new line, only whitespace found
                            EC   11  12F9  2683 	brb	_skipwhitespace		; do it over
                                     12FB  2684 _startfound:
              0000199B'EF   51   D0  12FB  2685 	movl	r1,v_inptr		; where non-whitespcae found
              00001999'EF   50   B0  1302  2686 	movw	r0,v_inlen		; bytes remaining in string
                                     1309  2687 _gettoken:
                            56   D4  1309  2688 	clrl	r6
                            57   D4  130B  2689 	clrl	r7
0000199B'FF   00001999'EF   6B   3A  130D  2690 	locc	(r11),v_inlen,@v_inptr	; locate character
         56   00001999'EF   50   A3  1319  2691 	subw3	r0,v_inlen,r6		; (v_inlen = r0) = number of chars
                                     1321  2692 					;   to copy
              00001999'EF   50   B0  1321  2693 	movw    r0,v_inlen              ; these are only bytes left (including one
                                     1328  2694 					; located~~~close paren?
                       57   51   D0  1328  2695 	movl	r1,r7			; save address of found char
                       69   56   33  132B  2696 	cvtwb	r6,(r9)			; store byte length
                  58   59   01   C1  132E  2697 	addl3	#1,r9,r8		; where to put in dictinary
         68   0000199B'FF   56   28  1332  2698 	movc3	r6,@v_inptr,(r8)	; move string to dictinary
              0000199B'EF   57   D0  133A  2699 	movl	r7,v_inptr		; v_inptr points into string
                   00001999'EF   B5  1341  2700 	tstw	v_inlen			; Are any more char?  (including
                                     1347  2701 					;   located one)
                            0E   13  1347  2702 	beql	10$			; no, exit
              00001999'EF   01   A2  1349  2703 	subw2	#1,v_inlen		; yes, move over terminator
                                     1350  2704 					;   (located char)
              0000199B'EF   01   C0  1350  2705 	addl2	#1,v_inptr
                                     1357  2706 10$:
                       5B   04   C0  1357  2707 	addl2	#4,r11			; pop terminator off stack
                                 05  135A  2708 	rsb				; end of token
                                     135B  2709 
                                     135B  2710 
                                     135B  2711 ;+++t
                                     135B  2712 ;k> unlink -- ( -- ) Unlink the most current word from the current vocab.  Used
                                     135B  2713 ;	when a definition is aborted by an unknown token.
                                     135B  2714 ;---
                                     135B  2715 	header	unlink
                           000012D8' 135B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000135B  135F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  135F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  135F       	.if    le, nchr		; nchr <= 0
               6B 6E 69 6C 6E 75 00' 135F       	   .ascic \unlink\	; no auxillary , use principle one
                                 06  135F       
                                     1366       	.if_false		; else
                                     1366       	  .ascic \\		; use auxillary 
                                     1366       	.endc			; end if
                                     1366       unlink:			; use  of word as vl_kernel label
                                     1366       	
              58   00001D3B'FF   D0  1366  2716 	movl	@v_current,r8		; reclaim directory space
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 118
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

              00001D3B'FF   69   D0  136D  2717 	movl	(r9),@v_current		; get pointer to last word in current
                                     1374  2718 					; vocab from link field of word
                                     1374  2719 					; we just deleted
                                 05  1374  2720 	rsb				; end of unlink
                                     1375  2721 
                                     1375  2722 
                                     1375  2723 ;+++
                                     1375  2724 ;k> unsmudge -- clear the smudge (high) bit in the word being defined, so
                                     1375  2725 ;	that it can be found again.
                                     1375  2726 ;---
                                     1375  2727 	header	unsmudge
                           0000135B' 1375       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001375  1379       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  1379       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1379       	.if    le, nchr		; nchr <= 0
         65 67 64 75 6D 73 6E 75 00' 1379       	   .ascic \unsmudge\	; no auxillary , use principle one
                                 08  1379       
                                     1382       	.if_false		; else
                                     1382       	  .ascic \\		; use auxillary 
                                     1382       	.endc			; end if
                                     1382       unsmudge:			; use  of word as vl_kernel label
                                     1382       	
              50   00001D3B'FF   D0  1382  2728 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  1389  2729 	addl2	#4,r0			; move over link field
                    60   80 8F   8A  138C  2730 	bicb2	#^b10000000,(r0)	; clear smudge bit
                                 05  1390  2731 	rsb				; end of unsmudge
                                     1391  2732 
                                     1391  2733 
                                     1391  2734 ;+++
                                     1391  2735 ;k> update -- ( -- ) Mark the most recent block as updated.
                                     1391  2736 ;---
                                     1391  2737 	header	update
                           00001375' 1391       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001391  1395       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  1395       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1395       	.if    le, nchr		; nchr <= 0
               65 74 61 64 70 75 00' 1395       	   .ascic \update\	; no auxillary , use principle one
                                 06  1395       
                                     139C       	.if_false		; else
                                     139C       	  .ascic \\		; use auxillary 
                                     139C       	.endc			; end if
                                     139C       update:			; use  of word as vl_kernel label
                                     139C       	
              50   00001B79'EF   D0  139C  2738 	movl	v_current_buff,r0	; get buffer number of current block
                            02   90  13A3  2739 	movb	#c_modified,-		;
                       1B7D'C0       13A5  2740 		v_buf_inuse(r0)		; mark buffer as updated
                                 05  13A8  2741 	rsb				; end of update
                                     13A9  2742 
                                     13A9  2743 
                                     13A9  2744 ;+++
                                     13A9  2745 ;k> variable -- ( -- ) Create a word that pushed its PFA on the stack.
                                     13A9  2746 ;	Doesn't reserve any space.  Use for making initialized arrays.
                                     13A9  2747 ;	PF = parameter field address = address of data following end
                                     13A9  2748 ;	of code body of work.
                                     13A9  2749 ;---
                                     13A9  2750 ;??? This concept is fuzzy.  Work on it.
                                     13A9  2751 	header	  variable
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 119
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00001391' 13A9       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000013A9  13AD       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  13AD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13AD       	.if    le, nchr		; nchr <= 0
         65 6C 62 61 69 72 61 76 00' 13AD       	   .ascic \variable\	; no auxillary , use principle one
                                 08  13AD       
                                     13B6       	.if_false		; else
                                     13B6       	  .ascic \\		; use auxillary 
                                     13B6       	.endc			; end if
                                     13B6       variable:			; use  of word as vl_kernel label
                                     13B6       	
                       F488 CF   16  13B6  2752 	jsb	  create		; enclose next token in dictionary
                    89   90 8F   90  13BA  2753 	movb	  #op_movb,(r9)+	; `movb'
                    89   AF 8F   90  13BE  2754 	movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  13C2  2755 	movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  13C5  2756 	movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  13C9  2757 	movb	  #op_rsb,(r9)+		; `rsb'
                                 05  13CC  2758 	rsb				; end of variable
                                     13CD  2759 
                                     13CD  2760 
                                     13CD  2761 ;+++
                                     13CD  2762 ;k> vlist -- ( -- ) List context vocabulary
                                     13CD  2763 ;---
                                     13CD  2764 	header	vlist
                           000013A9' 13CD       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000013CD  13D1       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  13D1       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13D1       	.if    le, nchr		; nchr <= 0
                  74 73 69 6C 76 00' 13D1       	   .ascic \vlist\	; no auxillary , use principle one
                                 05  13D1       
                                     13D7       	.if_false		; else
                                     13D7       	  .ascic \\		; use auxillary 
                                     13D7       	.endc			; end if
                                     13D7       vlist:			; use  of word as vl_kernel label
                                     13D7       	
              50   00001D37'FF   D0  13D7  2765 	movl	@v_context,r0		; get address of context vocabulary
                       7B   50   D0  13DE  2766 	movl	r0,-(r11)		; get address of most recent word
                                     13E1  2767 10$:
                            6B   D5  13E1  2768 	tstl	(r11)			; nil pointer?
                            22   13  13E3  2769 	beql	100$			; yes, exit
                  7B   04   6B   C1  13E5  2770 	addl3	(r11),#4,-(r11)		; get address of name field
                       F088 CF   16  13E9  2771 	jsb	bcount			; set up for write
                       7B   6B   D0  13ED  2772 	movl	(r11),-(r11)		; set up for ?cr
                       EF11 CF   16  13F0  2773 	jsb	q_n_cr			; start new line if word too long
                   00001450'EF   16  13F4  2774 	jsb	write			; tell user
                       7B   20   D0  13FA  2775 	movl	#c_blank,-(r11)		; blank to separate words
                       F9ED CF   16  13FD  2776 	jsb	putc			; output it
                    6B   00 BB   D0  1401  2777 	movl	@(r11),(r11)		; get previous word's LFA
                            DA   11  1405  2778 	brb	10$			; try it again
                                     1407  2779 100$:
                       5A   04   C0  1407  2780 	addl2	#4,r10			; pop pointer off stack
                                 05  140A  2781 	rsb				; end of vlist
                                     140B  2782 
                                     140B  2783 
                                     140B  2784 ;+++
                                     140B  2785 ;k> vocabulary -- ( -- ) Defining word.  Creates a new vocabulary. When the word
                                     140B  2786 ;	defined by this is executed, context is set to the new vocabulary.
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 120
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     140B  2787 ;---
                                     140B  2788 	header	vocabulary
                           000013CD' 140B       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           0000140B  140F       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  140F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  140F       	.if    le, nchr		; nchr <= 0
   79 72 61 6C 75 62 61 63 6F 76 00' 140F       	   .ascic \vocabulary\	; no auxillary , use principle one
                                 0A  140F       
                                     141A       	.if_false		; else
                                     141A       	  .ascic \\		; use auxillary 
                                     141A       	.endc			; end if
                                     141A       vocabulary:			; use  of word as vl_kernel label
                                     141A       	
              7A   00001D37'FF   D0  141A  2789 	movl	@v_context,-(r10)	; save LFA of word to link to
                       F41D CF   16  1421  2790 	jsb	create			;   make header for new vocab~~~ word
                    89   DE 8F   90  1425  2791 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  1429  2792 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   06   90  142D  2793 	movb	#6,(r9)+		; (pc+2) ~~~ isn't this (pc+6)?
              89   0000009F'EF   90  1430  2794 	movb	adm_absolute,(r9)+	; absolute mode (address in next lword)
              89   00001D37'EF   DE  1437  2795 	moval	v_context,(r9)+		; context
                    89   05 8F   9E  143E  2796 	movab	#op_rsb,(r9)+		; rsb
                       89   8A   D0  1442  2797 	movl	(r10)+,(r9)+		; initialize link
                                 05  1445  2798 	rsb				; end of vocabulary
                                     1446  2799 
                                     1446  2800 
                                     1446  2801 ;+++t
                                     1446  2802 ;k> write -- ( a w -- ) Write string of length `w' at address `a' out to  terminal.
                                     1446  2803 ;---
                                     1446  2804 	header	write
                           0000140B' 1446       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001446  144A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  144A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  144A       	.if    le, nchr		; nchr <= 0
                  65 74 69 72 77 00' 144A       	   .ascic \write\	; no auxillary , use principle one
                                 05  144A       
                                     1450       	.if_false		; else
                                     1450       	  .ascic \\		; use auxillary 
                                     1450       	.endc			; end if
                                     1450       write:			; use  of word as vl_kernel label
                                     1450       	
         00A0 8F   00001B98'EF   B1  1450  2805 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            28   19  1459  2806 	blss	10$			; no, go get some
                                     145B  2807 ; yes, output it
              7B   00001B9A'EF   DE  145B  2808 	moval	v_outbuf,-(r11)		; put address on stack
              7B   00001B98'EF   3C  1462  2809 	movzwl	v_outlen,-(r11)		; put length on stack
           02 AB   00001B96'EF   B0  1469  2810 	movw	v_static_dsc,2(r11)	; put rest of descriptor in
                            5B   DD  1471  2811 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  1473  2812 	calls	#1,g^lib$put_output	; output it
                       5B   08   C0  147A  2813 	addl2	#8,r11			; pop top two entries (descriptor)
                   00001B98'EF   B4  147D  2814 	clrw	v_outlen		; nothing left in buffer
                                     1483  2815 10$:
              56   00001B98'EF   3C  1483  2816 	movzwl	v_outlen,r6		; get length
         57   000000A0 8F   56   C3  148A  2817 	subl3	r6,#c_max_len,r7	; space available in output buffer
              50   00001B9A'EF   9E  1492  2818 	movab	v_outbuf,r0		; pointer into buffer
                       50   56   C0  1499  2819 	addl2	r6,r0			; next available byte
                       57   6B   D1  149C  2820 	cmpl	(r11),r7		; chars to output <= available
                            10   14  149F  2821 	bgtr	20$			; no, do a part
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 121
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

               60   04 BB   6B   28  14A1  2822 	movc3	(r11),@4(r11),(r0)	; move the string into the output buffer
              00001B98'EF   6B   A0  14A6  2823 	addw2	(r11),v_outlen		; save the new # of chars in buffer
                       5B   08   C0  14AD  2824 	addl2	#8,r11			; pop top two entries off stack
                                 05  14B0  2825 	rsb				; return
                                     14B1  2826 20$:					; more chars to output than buffer space
               60   04 BB   57   28  14B1  2827 	movc3	r7,@4(r11),(r0)		; move some into buffer
                       6B   57   C2  14B6  2828 	subl2	r7,(r11)		; new length to output
                    04 AB   57   C0  14B9  2829 	addl2	r7,4(r11)		; new place to start in chars to output
              00001B98'EF   57   A0  14BD  2830 	addw2	r7,v_outlen		; new # of chars in buffer
              7B   00001B9A'EF   9E  14C4  2831 	movab	v_outbuf,-(r11)		; address of buffer on stack
              7B   00001B98'EF   9A  14CB  2832 	movzbl	v_outlen,-(r11)		; count on stack
           02 AB   00001B96'EF   B0  14D2  2833 	movw	v_static_dsc,2(r11)	; put middle of descriptor in
                            5B   DD  14DA  2834 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  14DC  2835 	calls	#1,g^lib$put_output	; display it
                   00001B98'EF   B4  14E3  2836 	clrw	v_outlen		; nothing in buffer now
                       5B   08   C0  14E9  2837 	addl2	#8,r11			; pop descriptor off stack
                            6B   D5  14EC  2838 	tstl	(r11)			; Are there any remaining characters?
                            93   14  14EE  2839 	bgtr	10$			; yes, try it again
                       5B   08   C0  14F0  2840 	addl2	#8,r11			; pop arguments
                                 05  14F3  2841 	rsb				; end of write
                                     14F4  2842 
                                     14F4  2843 
                                     14F4  2844 ;+++
                                     14F4  2845 ;k> xor -- ( f1 f2 -- f ) logical xor; f1 xor f2.
                                     14F4  2846 ;---
                                     14F4  2847 	header	xor
                           00001446' 14F4       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           000014F4  14F8       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000000  14F8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  14F8       	.if    le, nchr		; nchr <= 0
                        72 6F 78 00' 14F8       	   .ascic \xor\	; no auxillary , use principle one
                                 03  14F8       
                                     14FC       	.if_false		; else
                                     14FC       	  .ascic \\		; use auxillary 
                                     14FC       	.endc			; end if
                                     14FC       xor:			; use  of word as vl_kernel label
                                     14FC       	
                            8B   D5  14FC  2848 	tstl	(r11)+			; is the first one false?
                            06   13  14FE  2849 	beql	10$			; yes
                            8B   D5  1500  2850 	tstl	(r11)+			; no, is the second one false?
                            0A   13  1502  2851 	beql	30$			; yes, leave with true
                            04   11  1504  2852 	brb	20$			; no leave with false
                                     1506  2853 10$:					; first one false
                            8B   D5  1506  2854 	tstl	(r11)+			; Is the second one true?
                            04   12  1508  2855 	bneq	30$			; yes, leave with true
                                     150A  2856 20$:					; leave with false
                       7B   00   D0  150A  2857 	movl	#c_false,-(r11)		; leave with false
                                 05  150D  2858 	rsb				; return
                                     150E  2859 30$:
              7B   FFFFFFFF 8F   D0  150E  2860 	movl	#c_true,-(r11)		; leave with true
                                 05  1515  2861 	rsb				; end of xor
                                     1516  2862 
                                     1516  2863 
                                     1516  2864 ;+++
                                     1516  2865 ;k> ] -- ( -- ) enter compile mode.  Used with { [ } in definitions.
                                     1516  2866 ;---
                                     1516  2867 	header i_right_back,<]>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 122
V1.01                           Kernel Built-ins                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           000014F4' 1516       	.long	vl_kernel		; back link to the previous word in this vl_kernel
                           00001516  151A       	vl_kernel = . - 4		; where to link the next word to in this vl_kernel
                           00000001  151A       	.nchr  nchr, ^\]\	; nchr = length( ] )
                           00000001  151A       	.if    le, nchr		; nchr <= 0
                                     151A       	   .ascic \i_right_back\	; no auxillary ], use principle one
                                     151A       	.if_false		; else
                              5D 00' 151A       	  .ascic \]\		; use auxillary ]
                                 01  151A       
                                     151C       	.endc			; end if
                                     151C       i_right_back:			; use ] of word as vl_kernel label
                                     151C       	
           00001D4D'EF   FF 8F   90  151C  2868 	movb   #c_true,v_mode		; enter compile mode
                                 05  1524  2869 	rsb				; end of l
                                     1525  2870 
                                     1525  2871 
                                     1525  2872 _kernel_end:
                                     1525  2873 	newpage <cCompiler Built-ins>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 123
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1525       	.sbttl	cCompiler Built-ins
                                     1525       	
                                     1525  2874 ;*******************************************************************************
                                     1525  2875 ;
                                     1525  2876 ; Compiler Built-ins -- a new word is unlinked from the current vocabulary
                                     1525  2877 ;	and linked into the compilier vocabulary by the word { compiletime }.
                                     1525  2878 ;	Computer (or compiletime} words are only search for during the
                                     1525  2879 ;	definition of new words, which prevents them from mucking about with
                                     1525  2880 ;	the stacks and the dictionary when we are interpreting the user's
                                     1525  2881 ;	commands.
                                     1525  2882 ;
                                     1525  2883 ;*******************************************************************************
                                     1525  2884 compiler_begin:
                                     1525  2885 
                                     1525  2886 
                                     1525  2887 ;+++
                                     1525  2888 ;c> (variable) - ( -- ) compiles the code body of a word that pushes the
                                     1525  2889 ;	address of its parameter field on the stack.  Must be the last word
                                     1525  2890 ;	in the word...
                                     1525  2891 ;---
                                     1525  2892 ;??? This concept is fuzzy.  Work on it.
                                     1525  2893      header	  i_variable,<(variable)>,vl_compiler
                           00000000  1525       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001525  1529       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           0000000A  1529       	.nchr  nchr, ^\(variable)\	; nchr = length( (variable) )
                           0000000A  1529       	.if    le, nchr		; nchr <= 0
                                     1529       	   .ascic \i_variable\	; no auxillary (variable), use principle one
                                     1529       	.if_false		; else
   29 65 6C 62 61 69 72 61 76 28 00' 1529       	  .ascic \(variable)\		; use auxillary (variable)
                                 0A  1529       
                                     1534       	.endc			; end if
                                     1534       i_variable:			; use (variable) of word as vl_compiler label
                                     1534       	
                    89   9E 8F   90  1534  2894      movb	  #op_movab,(r9)+	; `movab'
                    89   AF 8F   90  1538  2895      movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  153C  2896      movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  153F  2897      movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  1543  2898      movb	  #op_rsb,(r9)+		; `rsb'
                                 05  1546  2899      rsb				; end of (variable)
                                     1547  2900 
                                     1547  2901 
                                     1547  2902 ;+++
                                     1547  2903 ;c> +loop -- ( n -- ) where n is an increment.  Edns { do .. +loop }.  Adds top
                                     1547  2904 ;	of stack to loop index and branches to { do } if ((index > 0) and
                                     1547  2905 ;	(index < limit)), or if ((index < 0) and (index > limit)).~~~ WTF: and should be or???
                                     1547  2906 ;	In other words, { +loop } with a positive argument is like Pascal's
                                     1547  2907 ;	{ for index := start to finish do ... } and with a negative argument
                                     1547  2908 ;	it is like { for index := start downto finish do }.
                                     1547  2909 ;---
                                     1547  2910 	header	i_plus_loop,<+loop>,vl_compiler
                           00001525' 1547       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001547  154B       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000005  154B       	.nchr  nchr, ^\+loop\	; nchr = length( +loop )
                           00000005  154B       	.if    le, nchr		; nchr <= 0
                                     154B       	   .ascic \i_plus_loop\	; no auxillary +loop, use principle one
                                     154B       	.if_false		; else
                  70 6F 6F 6C 2B 00' 154B       	  .ascic \+loop\		; use auxillary +loop
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 124
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 05  154B       
                                     1551       	.endc			; end if
                                     1551       i_plus_loop:			; use +loop of word as vl_compiler label
                                     1551       	
                    89   F1 8F   90  1551  2911 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  1555  2912 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  1559  2913 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8B 8F   90  155C  2914 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   6A 8F   90  1560  2915 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  1564  2916 	movl	r9,r0			; save address of branch word
                       89   00   B0  1567  2917 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  156A  2918 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  156E  2919 	movw	r1,(r0)			; save displacement
                  89   00C0 8F   B0  1571  2920 	movw	#op_addl2,(r9)+		; `addl2'	pop index&limit from ls
                       89   08   90  1576  2921 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  1579  2922 	movb	#adm_r10,(r9)+		; r10
                                 05  157D  2923 	rsb				; end of +loop
                                     157E  2924 
                                     157E  2925 
                                     157E  2926 ;+++
                                     157E  2927 ;c> ." -- ( -- ) compile text until netx `"' into dictinary to be printed when
                                     157E  2928 ;	the current word is executed.
                                     157E  2929 ;---
                                     157E  2930 	header	i_dot_quote,<.">,vl_compiler
                           00001547' 157E       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000157E  1582       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1582       	.nchr  nchr, ^\."\	; nchr = length( ." )
                           00000002  1582       	.if    le, nchr		; nchr <= 0
                                     1582       	   .ascic \i_dot_quote\	; no auxillary .", use principle one
                                     1582       	.if_false		; else
                           22 2E 00' 1582       	  .ascic \."\		; use auxillary ."
                                 02  1582       
                                     1585       	.endc			; end if
                                     1585       i_dot_quote:			; use ." of word as vl_compiler label
                                     1585       	
                    89   9E 8F   90  1585  2931 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  1589  2932 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   05   90  158D  2933 	movb	#5,(r9)+		; (pc+5)	skip length byte too
                    89   7B 8F   90  1590  2934 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   31   90  1594  2935 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1597  2936 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  159A  2937 	movw	#0,(r9)+		; save space for displacement
                       7B   22   D0  159D  2938 	movl	#^a\"\,-(r11)		; set up for `"' delimited tokens
                       FD3E CF   16  15A0  2939 	jsb	token			; get token
                       50   69   9A  15A4  2940 	movzbl	(r9),r0			; get length of token
                  51   50   01   C1  15A7  2941 	addl3	#1,r0,r1		; calc displacement (count length too)
                    00 B1   51   B0  15AB  2942 	movw	r1,@(r1)		; fill in displacement
                       5A   04   C0  15AF  2943 	addl2	#4,r10			; pop item off loop stack
                       59   51   C0  15B2  2944 	addl2	r1,r9			; save string in dictionary
                    89   D0 8F   90  15B5  2945 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  15B9  2946 	movb	#adm_immediate,(r9)+	; immeidate mode
                       89   50   D0  15BD  2947 	movl	r0,(r9)+		; length of string
                    89   7B 8F   90  15C0  2948 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                     15C4  2949 ; we now have ( address count ) on stack (when new word executed)
                       89   16   90  15C4  2950 	movb	#op_jsb,(r9)+		; `jsb'
                    89   9F 8F   90  15C7  2951 	movb	#adm_absolute,(r9)+	; absolute mode
                  89   FE81 CF   DE  15CB  2952 	moval	write,(r9)+		; address of subroutine to jsb to
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 125
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 05  15D0  2953 	rsb				; end of ."
                                     15D1  2954 
                                     15D1  2955 
                                     15D1  2956 ;+++
                                     15D1  2957 ;c> ; (semicolon) -- ( -- ) Terminate a definition started by { : }.
                                     15D1  2958 ;	Sets { mode } to false and adds an rsb to the definition.
                                     15D1  2959 ;---
                                     15D1  2960 	header	i_semicolon,<;>,vl_compiler
                           0000157E' 15D1       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000015D1  15D5       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000001  15D5       	.nchr  nchr, ^\;\	; nchr = length( ; )
                           00000001  15D5       	.if    le, nchr		; nchr <= 0
                                     15D5       	   .ascic \i_semicolon\	; no auxillary ;, use principle one
                                     15D5       	.if_false		; else
                              3B 00' 15D5       	  .ascic \;\		; use auxillary ;
                                 01  15D5       
                                     15D7       	.endc			; end if
                                     15D7       i_semicolon:			; use ; of word as vl_compiler label
                                     15D7       	
                       89   05   90  15D7  2961 	movb	#op_rsb,(r9)+		; put an rsb in to end word
              00001D4D'EF   00   90  15DA  2962 	movb	#c_false,v_mode		; switch off compiler v_mode
                                     15E1  2963 ;??? might need to unset high bit in count of name (smudge) bit
                       FD9D CF   16  15E1  2964 	jsb	unsmudge      	     	; clear smudge bit so word is found
                                 05  15E5  2965 	rsb				; end of ;
                                     15E6  2966 
                                     15E6  2967 
                                     15E6  2968 ;+++
                                     15E6  2969 ;c> >defer -- ( -- ) ends a section of code that is to copied to the
                                     15E6  2970 ;	dictionary whenever this word is executed (i.e., { >defer } ends code
                                     15E6  2971 ;	to be executed by all words defined by the word we are now compiling).
                                     15E6  2972 ;	{ >defer } is used to define words that define words.
                                     15E6  2973 ;---
                                     15E6  2974 ;???  This concept is fuzzy.  Work on it.  May be fuzzy, but it works...
                                     15E6  2975 	header	   i_defer_end,^\>defer\,vl_compiler
                           000015D1' 15E6       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000015E6  15EA       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000006  15EA       	.nchr  nchr, ^\>defer\	; nchr = length( >defer )
                           00000006  15EA       	.if    le, nchr		; nchr <= 0
                                     15EA       	   .ascic \i_defer_end\	; no auxillary >defer, use principle one
                                     15EA       	.if_false		; else
               72 65 66 65 64 3E 00' 15EA       	  .ascic \>defer\		; use auxillary >defer
                                 06  15EA       
                                     15F1       	.endc			; end if
                                     15F1       i_defer_end:			; use >defer of word as vl_compiler label
                                     15F1       	
                  50   59   8A   C3  15F1  2976 	subl3	   (r10)+,r9,r0		; calculate length and displacement
                       9A   50   B0  15F5  2977 	movw	   r0,@(r10)+		; store displacement
                       9A   50   B0  15F8  2978 	movw	   r0,@(r10)+		; store length
                                     15FB  2979 ; make new word advance dictionary pointer over just added code
                    89   C0 8F   90  15FB  2980 	movb	#op_addl2,(r9)+		; `addl2'
                    89   8F 8F   90  15FF  2981 	movb	#adm_immediate,(r9)+	; i^#
                       80   50   D0  1603  2982 	movl	r0,(r0)+		; amount to advance
                    89   59 8F   90  1606  2983 	movb	#adm_r9,(r9)+		; r9
                                 05  160A  2984 	rsb				; end of >defer
                                     160B  2985 
                                     160B  2986 
                                     160B  2987 ;+++
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 126
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     160B  2988 ;c> again -- ( -- ) Terminate a { repeat ... if ... again } loop.  { agin }
                                     160B  2989 ;	unconditionally branches back to the { repeat }.
                                     160B  2990 ;---
                                     160B  2991 	header	again,,vl_compiler
                           000015E6' 160B       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000160B  160F       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  160F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  160F       	.if    le, nchr		; nchr <= 0
                  6E 69 61 67 61 00' 160F       	   .ascic \again\	; no auxillary , use principle one
                                 05  160F       
                                     1615       	.if_false		; else
                                     1615       	  .ascic \\		; use auxillary 
                                     1615       	.endc			; end if
                                     1615       again:			; use  of word as vl_compiler label
                                     1615       	
                                     1615  2992 ; save values for calculating displacement in if.
                       50   8A   D0  1615  2993 	movl  (r10)+,r0			; save address to displace from if
                       51   8A   D0  1618  2994 	movl  (r10)+,r1			; save address for displacement
                                     161B  2995 ; construct negative branch from { again } to { repeat }
                       89   31   90  161B  2996 	movb	#op_brw,(r9)+		; `brw'
                       52   59   D0  161E  2997 	movl	r9,r2			; save address for negative displacement
                       89   00   B0  1621  2998 	movw	#0,(r9)+		; save space for displacement
                  53   8A   59   C3  1624  2999 	subl3	r9,(r10)+,r3		; calculate negative displacment
                       62   53   B0  1628  3000 	movw	r3,(r2)			; save negative displacement
                                     162B  3001 ; construct forward branch from { if } to after { again }
                  54   59   50   C3  162B  3002 	subl3	r0,r9,r4		; calculate { if }'s displacment
                       61   54   B0  162F  3003 	movw	r4,(r1)			; save displacement
                                 05  1632  3004 	rsb				; end of again
                                     1633  3005 
                                     1633  3006 
                                     1633  3007 ;+++
                                     1633  3008 ;c> b^ -- ( -- ) Convert next token to number and enclose low byte in dictionary.~~~ byte immediate???
                                     1633  3009 ;---
                                     1633  3010 	header	i_b_up,<b^>,vl_compiler
                           0000160B' 1633       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001633  1637       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1637       	.nchr  nchr, ^\b^\	; nchr = length( b^ )
                           00000002  1637       	.if    le, nchr		; nchr <= 0
                                     1637       	   .ascic \i_b_up\	; no auxillary b^, use principle one
                                     1637       	.if_false		; else
                           5E 62 00' 1637       	  .ascic \b^\		; use auxillary b^
                                 02  1637       
                                     163A       	.endc			; end if
                                     163A       i_b_up:			; use b^ of word as vl_compiler label
                                     163A       	
                       7B   20   D0  163A  3011 	movl	#c_blank,-(r11)		; set up for blank delimeted token
                       FCA1 CF   16  163D  3012 	jsb	token			; get it
                       F6DB CF   16  1641  3013 	jsb	number			; try to make it a number
                            8B   D5  1645  3014 	tstl	(r11)+			; is it a number?
                            01   12  1647  3015 	bneq	10$			; yes
                                 05  1649  3016 	rsb				; no, for now just exit~~~??? FIXME!
                                     164A  3017 10$:
                       89   6B   90  164A  3018 	movb	(r11),(r9)+		; save byte in dictionary
                       5B   04   C0  164D  3019 	addl2	#4,r11			; pop value from dstack
                                 05  1650  3020 	rsb				; end of b^
                                     1651  3021 
                                     1651  3022 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 127
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1651  3023 ;+++
                                     1651  3024 ;c> defer< -- ( -- ) start a section of code that is to be copied to dictionary
                                     1651  3025 ;	whenever this word is executed (i.e., { defer< } starts code to be
                                     1651  3026 ;	executed by all words defined by the word we are now compiling).
                                     1651  3027 ;	Used in defining words that are to define words.
                                     1651  3028 ;---
                                     1651  3029 ;??? This concept is fuzzy.  Work on it.
                                     1651  3030 	header	i_defer_begin,^\defer<\,vl_compiler
                           00001633' 1651       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001651  1655       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000006  1655       	.nchr  nchr, ^\defer<\	; nchr = length( defer< )
                           00000006  1655       	.if    le, nchr		; nchr <= 0
                                     1655       	   .ascic \i_defer_begin\	; no auxillary defer<, use principle one
                                     1655       	.if_false		; else
               3C 72 65 66 65 64 00' 1655       	  .ascic \defer<\		; use auxillary defer<
                                 06  1655       
                                     165C       	.endc			; end if
                                     165C       i_defer_begin:			; use defer< of word as vl_compiler label
                                     165C       	
                       89   28   90  165C  3031 	movb	#op_movc3,(r9)+		; `movc3'
                    89   8F 8F   90  165F  3032 	movb	#adm_immediate,(r9)+	; I^x immediate mode
                       7A   59   D0  1663  3033 	movl	r9,-(r10)		; save address to put length in on
                                     1666  3034 					;   the loop stack
                       89   00   B0  1666  3035 	movw	#0,(r9)+		; save space for length
                    89   AF 8F   90  1669  3036 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  166D  3037 	movb	#4,(r9)+		; (pc+4)
                    89   69 8F   90  1670  3038 	movb	#adm_def_r9,(r9)+	; (r9)
                       89   31   90  1674  3039 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1677  3040 	movl	r9,-(r10)		; save address to put branch
                                     167A  3041 					;   displacement at on loop stack
                       89   00   B0  167A  3042 	movw	#0,(r9)+		; save space for the displacement
                       7A   59   D0  167D  3043 	movl	r9,-(r10)		; save address of data start on loop
                                     1680  3044 					;   stack to calculate data length
                                 05  1680  3045 	rsb				; end of defer<
                                     1681  3046 
                                     1681  3047 
                                     1681  3048 ;+++
                                     1681  3049 ;c> do -- ( n1 n2 -- ) Program control structure; starts { do ... +loop },
                                     1681  3050 ;	{ do ... downloop }, and { do ... loop }.  Note that all do
                                     1681  3051 ;	loops execute at least once.  `n1' is the limit and `n2' is the
                                     1681  3052 ;	number to start the index at.
                                     1681  3053 ;---
                                     1681  3054 	header	i_do,<do>,vl_compiler	; VAX/VMS debug thinks do is a command
                           00001651' 1681       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001681  1685       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1685       	.nchr  nchr, ^\do\	; nchr = length( do )
                           00000002  1685       	.if    le, nchr		; nchr <= 0
                                     1685       	   .ascic \i_do\	; no auxillary do, use principle one
                                     1685       	.if_false		; else
                           6F 64 00' 1685       	  .ascic \do\		; use auxillary do
                                 02  1685       
                                     1688       	.endc			; end if
                                     1688       i_do:			; use do of word as vl_compiler label
                                     1688       	
                    89   D0 8F   90  1688  3055 	movb	#op_movl,(r9)+		; `movl'	save index
                    89   8B 8F   90  168C  3056 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   50 8F   90  1690  3057 	movb	#adm_r0,(r9)+		; r0
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 128
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                    89   D0 8F   90  1694  3058 	movb	#op_movl,(r9)+		; `movl'	put limit on lstack
                    89   8B 8F   90  1698  3059 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   7A 8F   90  169C  3060 	movb	#adm_adec_r10,(r9)+	; -(r10)
                    89   D0 8F   90  16A0  3061 	movb	#op_movl,(r9)+		; `movl'	put index on lstack
                    89   50 8F   90  16A4  3062 	movb	#adm_r0,(r9)+		; r0
                    89   7A 8F   90  16A8  3063 	movb	#adm_adec_r10,(r9)+	; -(r10)
                       7A   59   D0  16AC  3064 	movl	r9,-(r10)		; save address to branch to
                                 05  16AF  3065 	rsb				; end of do
                                     16B0  3066 
                                     16B0  3067 
                                     16B0  3068 ;+++
                                     16B0  3069 ;c> downloop -- ( -- ) Ends a { do ... downloop }.  Adds -1 to the loop index
                                     16B0  3070 ;	and branches to { do } if ((index < 0) and (index > limit)).~~~ inverted?
                                     16B0  3071 ;	In other words, { downloop } is like Pascal's
                                     16B0  3072 ;	{ for index := start downto finish do }.
                                     16B0  3073 ;---
                                     16B0  3074 	header	downloop,,vl_compiler
                           00001681' 16B0       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000016B0  16B4       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  16B4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  16B4       	.if    le, nchr		; nchr <= 0
         70 6F 6F 6C 6E 77 6F 64 00' 16B4       	   .ascic \downloop\	; no auxillary , use principle one
                                 08  16B4       
                                     16BD       	.if_false		; else
                                     16BD       	  .ascic \\		; use auxillary 
                                     16BD       	.endc			; end if
                                     16BD       downloop:			; use  of word as vl_compiler label
                                     16BD       	
                    89   F1 8F   90  16BD  3075 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  16C1  3076 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  16C5  3077 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8F 8F   90  16C8  3078 	movb	#adm_immediate,(r9)+	; immediate mode
              89   FFFFFFFF 8F   D0  16CC  3079 	movl	#-1,(r9)+		; -1 is addend
                    89   6A 8F   90  16D3  3080 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  16D7  3081 	movl	r9,r0			; save address of branch word
                       89   00   B0  16DA  3082 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  16DD  3083 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  16E1  3084 	movw	r1,(r0)			; save displacement
                    89   C0 8F   90  16E4  3085 	movb	#op_addl2,(r9)+		; `addl2'	pop index&limit from lstack
                       89   08   90  16E8  3086 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  16EB  3087 	movb	#adm_r10,(r9)+		; r10
                                 05  16EF  3088 	rsb				; end of downloop
                                     16F0  3089 
                                     16F0  3090 
                                     16F0  3091 ;+++
                                     16F0  3092 ;c> else -- ( -- ) In control structure { if ... else ... endif } { else }
                                     16F0  3093 ;	else ends the true branch and starts the false branch.
                                     16F0  3094 ;---
                                     16F0  3095 	header	else,,vl_compiler
                           000016B0' 16F0       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000016F0  16F4       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  16F4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  16F4       	.if    le, nchr		; nchr <= 0
                     65 73 6C 65 00' 16F4       	   .ascic \else\	; no auxillary , use principle one
                                 04  16F4       
                                     16F9       	.if_false		; else
                                     16F9       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 129
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     16F9       	.endc			; end if
                                     16F9       else:			; use  of word as vl_compiler label
                                     16F9       	
                       89   31   90  16F9  3096 	movb	#op_brw,(r9)+		; branch over false part
                       50   59   D0  16FC  3097 	movl	r9,r0			; save address of displacement
                       89   00   B0  16FF  3098 	movw	#0,(r9)+		; save space for displacement
                       51   59   D0  1702  3099 	movl	r9,r1			; save address to calculate
                                     1705  3100 					;   displacement from
                                     1705  3101 ; make branch to false part (fill in displacement in if)
                  52   59   8A   C3  1705  3102 	subl3	(r10)+,r9,r2		; calculate displacement
                    00 BA   52   B0  1709  3103 	movw	r2,@(r10)		; save displacment
                       5A   04   C0  170D  3104 	addl2	#4,r10			; pop address of displacement off lstack
                       7A   50   D0  1710  3105 	movl	r0,-(r10)		; save address of displacement
                       7A   51   D0  1713  3106 	movl	r1,-(r10)		; save address to displace from
                                 05  1716  3107 	rsb				; end of else
                                     1717  3108 
                                     1717  3109 
                                     1717  3110 ;+++
                                     1717  3111 ;c> endif -- ( -- ) { endif } ends either of { if } or { else } branches.
                                     1717  3112 ;	{ if ... else ... endif } and { if ... endif } are both legal.
                                     1717  3113 ;---
                                     1717  3114 	header	endif,,vl_compiler
                           000016F0' 1717       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001717  171B       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  171B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  171B       	.if    le, nchr		; nchr <= 0
                  66 69 64 6E 65 00' 171B       	   .ascic \endif\	; no auxillary , use principle one
                                 05  171B       
                                     1721       	.if_false		; else
                                     1721       	  .ascic \\		; use auxillary 
                                     1721       	.endc			; end if
                                     1721       endif:			; use  of word as vl_compiler label
                                     1721       	
                  50   59   8A   C3  1721  3115 	subl3	(r10)+,r9,r0		; calculate displacement
                    00 BA   50   B0  1725  3116 	movw	r0,@(r10)		; save displacement
                       5A   04   C0  1729  3117 	addl2	#4,r10			; pop address of displacement off lstack
                                 05  172C  3118 	rsb				; end of endif
                                     172D  3119 
                                     172D  3120 
                                     172D  3121 ;+++
                                     172D  3122 ;c> endwhile -- ( -- ) ends a { while ... endwhile }.  Unconditionally branches
                                     172D  3123 ;	back to { while }.
                                     172D  3124 ;---
                                     172D  3125 	header	endwhile,,vl_compiler
                           00001717' 172D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000172D  1731       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1731       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1731       	.if    le, nchr		; nchr <= 0
         65 6C 69 68 77 64 6E 65 00' 1731       	   .ascic \endwhile\	; no auxillary , use principle one
                                 08  1731       
                                     173A       	.if_false		; else
                                     173A       	  .ascic \\		; use auxillary 
                                     173A       	.endc			; end if
                                     173A       endwhile:			; use  of word as vl_compiler label
                                     173A       	
                       89   31   90  173A  3126 	movb	#op_brw,(r9)+		; brw back to test
                       50   59   D0  173D  3127 	movl	r9,r0			; address to put displacement in
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 130
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       89   00   B0  1740  3128 	movw	#0,(r9)+		; save space for displacement
                  51   59   8A   C3  1743  3129 	subl3	(r10)+,r9,r1		; displacement to after loop
                    00 BA   51   B0  1747  3130 	movw	r1,@(r10)		; fill in displacement to after loop
                       5A   04   C0  174B  3131 	addl2	#4,r10			; pop off address of displacement
                  51   8A   59   C3  174E  3132 	subl3	r9,(r10)+,r1		; displacement back to beginning
                       60   51   B0  1752  3133 	movw	r1,(r0)			; save displacement
                                 05  1755  3134 	rsb				; end of endwhile
                                     1756  3135 
                                     1756  3136 
                                     1756  3137 ;+++
                                     1756  3138 ;c> if -- ( n -- ) In { if ... else ... endif } or { if ... endif },
                                     1756  3139 ;	if the top of the stack is true, execute the code following
                                     1756  3140 ;	the { if } until an { endif } or an { else }.  At an { else } skip to
                                     1756  3141 ;	the code after the { endif }.  If the top of the stack
                                     1756  3142 ;	is false, skip to the { endif } or { else }.
                                     1756  3143 ;	In the { repeat ... if ... again } if the top fo the stack is true the
                                     1756  3144 ;	code up to the { again } is executed and then a branch back to
                                     1756  3145 ;	{ repeat } is done.  If the top of the stack is false, execution jumps
                                     1756  3146 ;	to the code after the { again }.
                                     1756  3147 ;---
                                     1756  3148 	header	if,,vl_compiler
                           0000172D' 1756       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001756  175A       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  175A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  175A       	.if    le, nchr		; nchr <= 0
                           66 69 00' 175A       	   .ascic \if\	; no auxillary , use principle one
                                 02  175A       
                                     175D       	.if_false		; else
                                     175D       	  .ascic \\		; use auxillary 
                                     175D       	.endc			; end if
                                     175D       if:			; use  of word as vl_compiler label
                                     175D       	
                    89   D5 8F   90  175D  3149 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  1761  3150 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  1765  3151 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  1768  3152 	movb	#^x03,(r9)+		; to (pc+3)
                       89   31   90  176B  3153 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  176E  3154 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  1771  3155 	movw	#0,(r9)+		; save space for displacmnent
                       7A   59   D0  1774  3156 	movl	r9,-(r10)		; save address to calculate
                                     1777  3157 					;   displacement from
                                 05  1777  3158 	rsb				; end of if
                                     1778  3159 
                                     1778  3160 
                                     1778  3161 ;+++
                                     1778  3162 ;c> l^ -- ( -- ) Convert next token to number and enclose in dictionary.
                                     1778  3163 ;---
                                     1778  3164 	header	i_l_up,<l^>,vl_compiler
                           00001756' 1778       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001778  177C       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  177C       	.nchr  nchr, ^\l^\	; nchr = length( l^ )
                           00000002  177C       	.if    le, nchr		; nchr <= 0
                                     177C       	   .ascic \i_l_up\	; no auxillary l^, use principle one
                                     177C       	.if_false		; else
                           5E 6C 00' 177C       	  .ascic \l^\		; use auxillary l^
                                 02  177C       
                                     177F       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 131
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     177F       i_l_up:			; use l^ of word as vl_compiler label
                                     177F       	
                       7B   20   D0  177F  3165 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FB5C CF   16  1782  3166 	jsb	token			; get it
                       F596 CF   16  1786  3167 	jsb	number			; try to make it a number
                            8B   D5  178A  3168 	tstl	(r11)+			; Is it a number>
                            01   12  178C  3169 	bneq	10$			; yes
                                 05  178E  3170 	rsb				; no, for now just exit~~~ WTF, no error?
                                     178F  3171 10$:
                       89   8B   D0  178F  3172 	movl	(r11)+,(r9)+		; save long in dictionary
                                 05  1792  3173 	rsb				; end of l^
                                     1793  3174 
                                     1793  3175 
                                     1793  3176 ;+++
                                     1793  3177 ;c> literal -- ( n -- ) convert top of stack to a literal in current word.
                                     1793  3178 ;---
                                     1793  3179 	header	literal,,vl_compiler
                           00001778' 1793       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001793  1797       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1797       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1797       	.if    le, nchr		; nchr <= 0
            6C 61 72 65 74 69 6C 00' 1797       	   .ascic \literal\	; no auxillary , use principle one
                                 07  1797       
                                     179F       	.if_false		; else
                                     179F       	  .ascic \\		; use auxillary 
                                     179F       	.endc			; end if
                                     179F       literal:			; use  of word as vl_compiler label
                                     179F       	
                    89   D0 8F   90  179F  3180 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  17A3  3181 	movb	#adm_immediate,(r9)+	; immediate mode
                       89   8B   D0  17A7  3182 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                    89   7B 8F   90  17AA  3183 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                 05  17AE  3184 	rsb				; end of literal
                                     17AF  3185 
                                     17AF  3186 
                                     17AF  3187 ;+++
                                     17AF  3188 ;c> loop -- ( -- ) Ends a { do ... loop }.  Adds 1 to loop index and branches
                                     17AF  3189 ;	to { do } if ((index >= 0) and (index < limit)).  In other words,
                                     17AF  3190 ;	{ loop } is like Pascal's { for index := start to finish do ... }.
                                     17AF  3191 ;---
                                     17AF  3192 	header	i_loop,<loop>,vl_compiler ; VAX/VMS debuffer thinks loop is a a command
                           00001793' 17AF       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000017AF  17B3       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000004  17B3       	.nchr  nchr, ^\loop\	; nchr = length( loop )
                           00000004  17B3       	.if    le, nchr		; nchr <= 0
                                     17B3       	   .ascic \i_loop\	; no auxillary loop, use principle one
                                     17B3       	.if_false		; else
                     70 6F 6F 6C 00' 17B3       	  .ascic \loop\		; use auxillary loop
                                 04  17B3       
                                     17B8       	.endc			; end if
                                     17B8       i_loop:			; use loop of word as vl_compiler label
                                     17B8       	
                    89   F1 8F   90  17B8  3193 	movb	#op_acbl,(r9)+		  ; `acbl'
                    89   AA 8F   90  17BC  3194 	movb	#adm_b_dis_r10,(r9)+	  ; b^(r10)
                       89   04   90  17C0  3195 	movb	#4,(r9)+		  ; 4 byte displacement for previous adm
                       89   01   90  17C3  3196 	movb	#^x01,(r9)+		  ; s^#1
                    89   6A 8F   90  17C6  3197 	movb	#adm_def_r10,(r9)+	  ; (r10)
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 132
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                       50   59   D0  17CA  3198 	movl	r9,r0			  ; save address of branch word
                       89   00   B0  17CD  3199 	movw	#0,(r9)+		  ; save space for branch displacement
                  51   8A   59   C3  17D0  3200 	subl3	r9,(r10)+,r1		  ; calculate displacement
                       60   51   B0  17D4  3201 	movw	r1,(r0)			  ; save displacement
                    89   C0 8F   90  17D7  3202 	movb	#op_addl2,(r9)+		  ; `addl2'	pop index&limit from lstack
                       89   08   90  17DB  3203 	movb	#^x08,(r9)+		  ; s^#8
                    89   5A 8F   90  17DE  3204 	movb	#adm_r10,(r9)+		  ; r10
                                 05  17E2  3205 	rsb				  ; end of loop
                                     17E3  3206 
                                     17E3  3207 
                                     17E3  3208 ;+++
                                     17E3  3209 ;c> recurse -- ( -- ) Compile a jsb to the word that is currently being defined,
                                     17E3  3210 ;	allowing recursion.
                                     17E3  3211 ;---
                                     17E3  3212 	header	recurse,,vl_compiler
                           000017AF' 17E3       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000017E3  17E7       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  17E7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  17E7       	.if    le, nchr		; nchr <= 0
            65 73 72 75 63 65 72 00' 17E7       	   .ascic \recurse\	; no auxillary , use principle one
                                 07  17E7       
                                     17EF       	.if_false		; else
                                     17EF       	  .ascic \\		; use auxillary 
                                     17EF       	.endc			; end if
                                     17EF       recurse:			; use  of word as vl_compiler label
                                     17EF       	
              7B   00001D37'FF   D0  17EF  3213 	movl	@v_context,-(r11)	; get address of current word
                       EF4E CF   16  17F6  3214 	jsb	cfa			; get the code field address
                       EFA8 CF   16  17FA  3215 	jsb	i_compile_jsb		; compile it into current word
                                 05  17FE  3216 	rsb				; end of recurse
                                     17FF  3217 
                                     17FF  3218 
                                     17FF  3219 ;+++
                                     17FF  3220 ;c> repeat -- ( -- ) Start { repeat ... until } and { repeat ... if ... again }
                                     17FF  3221 ;	loops.
                                     17FF  3222 ;---
                                     17FF  3223 	header	repeat,,vl_compiler
                           000017E3' 17FF       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000017FF  1803       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1803       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1803       	.if    le, nchr		; nchr <= 0
               74 61 65 70 65 72 00' 1803       	   .ascic \repeat\	; no auxillary , use principle one
                                 06  1803       
                                     180A       	.if_false		; else
                                     180A       	  .ascic \\		; use auxillary 
                                     180A       	.endc			; end if
                                     180A       repeat:			; use  of word as vl_compiler label
                                     180A       	
                       7A   59   D0  180A  3224 	movl	r9,-(r10)		; save address to branch to
                                 05  180D  3225 	rsb				; end of repeat
                                     180E  3226 
                                     180E  3227 
                                     180E  3228 ;+++
                                     180E  3229 ;c> w^ -- ( -- ) Convert next token to number, enclose low 16 bits in dictionary.
                                     180E  3230 ;	This is used with the assembler, mainly, which is why it is w^ instead
                                     180E  3231 ;	of  s^.
                                     180E  3232 ;---
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 133
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     180E  3233 	header	i_s_up,<w^>,vl_compiler
                           000017FF' 180E       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000180E  1812       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1812       	.nchr  nchr, ^\w^\	; nchr = length( w^ )
                           00000002  1812       	.if    le, nchr		; nchr <= 0
                                     1812       	   .ascic \i_s_up\	; no auxillary w^, use principle one
                                     1812       	.if_false		; else
                           5E 77 00' 1812       	  .ascic \w^\		; use auxillary w^
                                 02  1812       
                                     1815       	.endc			; end if
                                     1815       i_s_up:			; use w^ of word as vl_compiler label
                                     1815       	
                       7B   20   D0  1815  3234 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FAC6 CF   16  1818  3235 	jsb	token			; get it
                       F500 CF   16  181C  3236 	jsb	number			; try to make it a number
                            8B   D5  1820  3237 	tstl	(r11)+			; Is it a number?
                            01   12  1822  3238 	bneq	10$			; yes
                                 05  1824  3239 	rsb				; no, for now just exit~~~ WTF, no error?
                                     1825  3240 10$:
                       89   6B   B0  1825  3241 	movw	(r11),(r9)+		; save word in dictionary
                       5B   04   C0  1828  3242 	addl2	#4,r11			; pop value from dstack
                                 05  182B  3243 	rsb				; end of w^
                                     182C  3244 
                                     182C  3245 
                                     182C  3246 ;+++
                                     182C  3247 ;c> until -- ( f -- ) End a { repeat ... until } loop.  If top of stack is
                                     182C  3248 ;	false, branch back to the { repeat }, else fall out of loop.
                                     182C  3249 ;---
                                     182C  3250 	header	until,,v1_compiler
                           0000182C' 182C       	.long	v1_compiler		; back link to the previous word in this v1_compiler
                           0000182C  1830       	v1_compiler = . - 4		; where to link the next word to in this v1_compiler
                           00000000  1830       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1830       	.if    le, nchr		; nchr <= 0
                  6C 69 74 6E 75 00' 1830       	   .ascic \until\	; no auxillary , use principle one
                                 05  1830       
                                     1836       	.if_false		; else
                                     1836       	  .ascic \\		; use auxillary 
                                     1836       	.endc			; end if
                                     1836       until:			; use  of word as v1_compiler label
                                     1836       	
                    89   D5 8F   90  1836  3251 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  183A  3252 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  183E  3253 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  1841  3254 	movb	#3,(r9)+		; (pc+3)
                       89   31   90  1844  3255 	movb	#op_brw,(r9)+		; `brw'
                       50   59   D0  1847  3256 	movl	r9,r0			; save address of displacement
                       89   00   B0  184A  3257 	movw	#0,(r9)+		; save space for displacement
                  51   8A   59   C3  184D  3258 	subl3	r9,(r10)+,r1		; calcualte negative displacement
                       6A   51   B0  1851  3259 	movw	r1,(r10)		; save negative displacement
                                 05  1854  3260 	rsb				; end of until
                                     1855  3261 
                                     1855  3262 
                                     1855  3263 ;+++
                                     1855  3264 ;c> while -- ( f -- ) Start a { while ... endwhile } loop.  If top of stack
                                     1855  3265 ;	is true, execute code to { endwhile }, which loops back to { while }.
                                     1855  3266 ;	If false, skip to after the { endwhile }.
                                     1855  3267 ;---
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 134
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1855  3268 	header	while,,vl_compiler
                           0000180E' 1855       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001855  1859       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1859       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1859       	.if    le, nchr		; nchr <= 0
                  65 6C 69 68 77 00' 1859       	   .ascic \while\	; no auxillary , use principle one
                                 05  1859       
                                     185F       	.if_false		; else
                                     185F       	  .ascic \\		; use auxillary 
                                     185F       	.endc			; end if
                                     185F       while:			; use  of word as vl_compiler label
                                     185F       	
                       7A   59   D0  185F  3269 	movl	r9,-(r10)		; save address to branch to at endwhile
                    89   D5 8F   90  1862  3270 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  1866  3271 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  186A  3272 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  186D  3273 	movb	#3,(r9)+		; over brw false_part
                       89   31   90  1870  3274 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1873  3275 	movl	r9,-(r10)		; save address of displacement to
                                     1876  3276 					;   statements after loop
                       89   00   B0  1876  3277 	movw	#0,(r9)+		; save space for displacement
                       7A   59   D0  1879  3278 	movl	r9,-(r10)		; address to make diplacement to
                                     187C  3279 					;   after loop from~~~ awkward phrasing
                                 05  187C  3280 	rsb				; end of while
                                     187D  3281 
                                     187D  3282 
                                     187D  3283 ;+++
                                     187D  3284 ;c> [ -- ( -- ) leave compile mode without terminating definition.
                                     187D  3285 ;	Must be followed by { ] }.
                                     187D  3286 ;---
                                     187D  3287 	header	i_left_brack,<[>,vl_compiler
                           00001855' 187D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000187D  1881       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000001  1881       	.nchr  nchr, ^\[\	; nchr = length( [ )
                           00000001  1881       	.if    le, nchr		; nchr <= 0
                                     1881       	   .ascic \i_left_brack\	; no auxillary [, use principle one
                                     1881       	.if_false		; else
                              5B 00' 1881       	  .ascic \[\		; use auxillary [
                                 01  1881       
                                     1883       	.endc			; end if
                                     1883       i_left_brack:			; use [ of word as vl_compiler label
                                     1883       	
              00001D4D'EF   00   90  1883  3288 	movb	#c_false,v_mode
                                 05  188A  3289 	rsb				; end of [
                                     188B  3290 
                                     188B  3291 
                                     188B  3292 ;+++
                                     188B  3293 ;c> [ascii] -- ( -- ) compile ascii value of 1st char of next token into word.
                                     188B  3294 ;---
                                     188B  3295 	header	i_compile_ascii,<[ascii]>,vl_compiler
                           0000187D' 188B       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000188B  188F       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000007  188F       	.nchr  nchr, ^\[ascii]\	; nchr = length( [ascii] )
                           00000007  188F       	.if    le, nchr		; nchr <= 0
                                     188F       	   .ascic \i_compile_ascii\	; no auxillary [ascii], use principle one
                                     188F       	.if_false		; else
            5D 69 69 63 73 61 5B 00' 188F       	  .ascic \[ascii]\		; use auxillary [ascii]
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 135
V1.01                           cCompiler Built-ins                      31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                 07  188F       
                                     1897       	.endc			; end if
                                     1897       i_compile_ascii:			; use [ascii] of word as vl_compiler label
                                     1897       	
                       7B   20   D0  1897  3296 	movl	#c_blank,-(r11)		; set up for blank separated token
                       FA44 CF   16  189A  3297 	jsb	token			; get it
                    7B   01 A9   9A  189E  3298 	movzbl	1(r9),-(r11)		; put ascii value of 1st char of token on stack
                       FEF9 CF   16  18A2  3299 	jsb	literal			; compile it into the dictionary
                                 05  18A6  3300 	rsb				; end of ascii
                                     18A7  3301 
                                     18A7  3302 
                                     18A7  3303 _compiler_end:
                                     18A7  3304 	newpage <Enter VTIL>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 136
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     18A7       	.sbttl	Enter VTIL
                                     18A7       	
                                     18A7  3305 ;*******************************************************************************
                                     18A7  3306 ;
                                     18A7  3307 ; Enter VTIL -- Set up condition handler and call main program.
                                     18A7  3308 ;
                                     18A7  3309 ;*******************************************************************************
                                     18A7  3310 
                                     18A7  3311 
                                     18A7  3312 ;+++
                                     18A7  3313 ;s> vtil -- entry procedure of vtil
                                     18A7  3314 ;---
                               0FC0  18A7  3315 	.entry	vtil,^m<r6,r7,r8,r9,r10,r11>
                                     18A9  3316     .if defined ca_trapping
                                     18A9  3317         .print ; Trapping is enabled
                                     18A9  3318 	moval	s_trap,(fp)		; set up condition handler
                                     18A9  3319     .if_false
                                     18A9  3320         .print ; Trapping is not enabled

                                     18A9  3321     .endc
                                     18A9  3322     .if defined ca_controlc
                                     18A9  3323         .print ; Control/C Trapping is enabled
                                     18A9  3324 ; If a terminal, set up control/c trap
                                     18A9  3325 	$assign_s chan=v_input_chan,-	; connect to sys$command
                                     18A9  3326 		devnam=v_input_name
                                     18A9  3327 	blbs	r0,1$			; exit on error~~~Success, so branch over error exit
                                     18A9  3328 	brw	vtil_exit		; exit vtil
                                     18A9  3329 1$:
                                     18A9  3330 	$getchn_s chan=v_input_chan,-	; find out if it is a terminal
                                     18A9  3331 		prilen=v_getchn_ret_len,- ; where to put length
                                     18A9  3332 		pribuf=v_getchn_in_buf  ; where to find input buffer
                                     18A9  3333 
                                     18A9  3334 	cmpb	#dc$_term,v_getchn_buf+4 ; is it a terminal?
                                     18A9  3335 	bneq	5$			; not a terminal, so don't enable ctr-c
                                     18A9  3336 ; enable control-c trapping
                                     18A9  3337 	.show	   meb,me
                                     18A9  3338 	$qio_s	chan=v_input_chan,-
                                     18A9  3339 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     18A9  3340 		p1=enable_ctrlc,-
                                     18A9  3341 		p3=#3
                                     18A9  3342 	blbs	r0,6$			; no error, go on, don't deassign channel
                                     18A9  3343 	brw	vtil_exit
                                     18A9  3344 5$:
                                     18A9  3345 ;	$dassign_s chan=v_input_chan    ; channel not a terminal, deassign it.
                                     18A9  3346 6$:
                                     18A9  3347     .if_false
                                     18A9  3348         .print ; Control/c trapping not enabled

                                     18A9  3349     .endc
                                     18A9  3350 
              00001961'EF   00   FB  18A9  3351 	calls	#0,s_cold_start		; call subroutine to start from scratch
                                     18B0  3352 ; If we have returned from cold start there was an error caught by the
                                     18B0  3353 ; trap subroutine and we want to a warm start.
                                     18B0  3354 10$:
              000019AD'EF   00   FB  18B0  3355 	calls	#0,s_warm_start		; call subroutine to do warm start.
                                     18B7  3356 ; If we have returned from warm start there was an error caught by the
                                     18B7  3357 ; trap subroutine and we want to do another warm start.
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 137
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                            F7   11  18B7  3358 	brb	10$
                                     18B9  3359 
                                     18B9  3360 ;+++
                                     18B9  3361 ;r> vtil_exit -- exit if errors in setting up control-c ast or traps
                                     18B9  3362 ;---
                                     18B9  3363 vtil_exit:
                            50   DD  18B9  3364 	pushl	r0
              00000000'GF   01   FB  18BB  3365 	calls	#1,g^lib$signal
                                 04  18C2  3366 	ret				; this is return from main program.
                                     18C3  3367 
                                     18C3  3368 
                                     18C3  3369 ;+++
                                     18C3  3370 ;s> enable_ctrlc -- enable controlc trapping.
                                     18C3  3371 ;---
                               0000  18C3  3372 	.entry	enable_ctrlc,^m<>
                                     18C5  3373 ; reenable ctrlc handler...
                                     18C5  3374 	$qio_s	chan=v_input_chan,-
                                     18C5  3375 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     18C5  3376 		p1=enable_ctrlc,-
                                     18C5  3377 		p3=#3
                                     18C5       		.GLOBL	SYS$QIO
                                     18C5       		$PUSHTWO #0,#0
                           00000000  18C5       		$$T1 = 0
                                     18C5       		.IF	IDN,<#0>,<#0>
                                     18C5       		.IF	IDN,<#0>,<#0>
                           00000001  18C5       		$$T1 = 1
                                     18C5       		.ENDC
                                     18C5       		.ENDC
                           00000001  18C5       		.IF	NE	$$T1
                            7E   7C  18C5       		CLRQ	-(SP)
                                     18C7       		.IFF
                                     18C7       		PUSHL	#0
                                     18C7       		PUSHL	#0
                                     18C7       		.ENDC
                                     18C7       	
                                     18C7       		$PUSHTWO #0,#3
                           00000000  18C7       		$$T1 = 0
                                     18C7       		.IF	IDN,<#0>,<#0>
                                     18C7       		.IF	IDN,<#0>,<#3>
                                     18C7       		$$T1 = 1
                                     18C7       		.ENDC
                                     18C7       		.ENDC
                           00000000  18C7       		.IF	NE	$$T1
                                     18C7       		CLRQ	-(SP)
                                     18C7       		.IFF
                            00   DD  18C7       		PUSHL	#0
                            03   DD  18C9       		PUSHL	#3
                                     18CB       		.ENDC
                                     18CB       	
                            00   DD  18CB       		PUSHL	#0
                                     18CD       		$PUSHADR enable_ctrlc
                                     18CD       		.IF	IDN,0,enable_ctrlc
                                     18CD       		PUSHL	#0
                                     18CD       		.IFF
                           00000000  18CD       		.IF EQ	12-12
                           00000000  18CD       		.IF NE	12-12
                                     18CD       		PUSHAL	enable_ctrlc
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 138
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     18CD       		.MEXIT
                                     18CD       		.ENDC
                                     18CD       		.ENDC
                           000000AF  18CD       		.NTYPE	$$$ADR, enable_ctrlc
                           000000A0  18CD       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFA1  18CD       		.IF GT	$$$ADR - ^XFF
                                     18CD       		PUSHAL	enable_ctrlc
                                     18CD       		.MEXIT
                                     18CD       		.ENDC
                           00000020  18CD       		.IF EQ	$$$ADR - ^X80
                                     18CD       		PUSHAL	enable_ctrlc
                                     18CD       		.MEXIT
                                     18CD       		.ENDC
                           00000030  18CD       		.IF EQ	$$$ADR - ^X70
                                     18CD       		PUSHAL	enable_ctrlc
                                     18CD       		.MEXIT
                                     18CD       		.ENDC
                         F3 AF   9F  18CD       		PUSHAB	enable_ctrlc
                                     18D0       		.ENDC
                                     18D0       	
                                     18D0       		$QIOPUSH #0,0
                           00000000  18D0       		$$T1 = 0
                                     18D0       		.IF	IDN,<#0>,<#0>
                                     18D0       		.IF	IDN,<0>,<0>
                           00000001  18D0       		$$T1 = 1
                                     18D0       		.ENDC
                                     18D0       		.ENDC
                           00000001  18D0       		.IF	NE $$T1
                            7E   7C  18D0       		CLRQ	-(SP)
                                     18D2       		.IFF
                                     18D2       		PUSHL	#0
                                     18D2       		$PUSHADR 0
                                     18D2       		.ENDC
                                     18D2       	
                                     18D2       		$PUSHADR 0,CONTEXT=Q
                                     18D2       		.IF	IDN,0,0
                            00   DD  18D2       		PUSHL	#0
                                     18D4       		.IFF
                                     18D4       		.IF EQ	1-1
                                     18D4       		.IF NE	1-1
                                     18D4       		PUSHAQ	0
                                     18D4       		.MEXIT
                                     18D4       		.ENDC
                                     18D4       		.ENDC
                                     18D4       		.NTYPE	$$$ADR, 0
                                     18D4       $$$ADR	=	$$$ADR & ^XFFF0
                                     18D4       		.IF GT	$$$ADR - ^XFF
                                     18D4       		PUSHAQ	0
                                     18D4       		.MEXIT
                                     18D4       		.ENDC
                                     18D4       		.IF EQ	$$$ADR - ^X80
                                     18D4       		PUSHAQ	0
                                     18D4       		.MEXIT
                                     18D4       		.ENDC
                                     18D4       		.IF EQ	$$$ADR - ^X70
                                     18D4       		PUSHAQ	0
                                     18D4       		.MEXIT
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 139
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     18D4       		.ENDC
                                     18D4       		PUSHAB	0
                                     18D4       		.ENDC
                                     18D4       	
                  7E   0000'8F   3C  18D4       		MOVZWL	#IO$_SETMODE!IO$M_CTRLCAST,-(SP)
              7E   00001D11'EF   3C  18D9       		MOVZWL	v_input_chan,-(SP)
                            00   DD  18E0       		PUSHL	#0
              00000000'GF   0C   FB  18E2       		CALLS	#12,G^SYS$QIO
                                     18E9       	
                   00000000'8F   DD  18E9  3378 	pushl	#vtil_ctrlc
              00000000'GF   01   FB  18EF  3379 	calls	#1,g^lib$signal		; this should NOT return!
                                 05  18F6  3380 	rsb				; end of enable_ctrlc
                                     18F7  3381 
                                     18F7  3382 
                                     18F7  3383 ;+++
                                     18F7  3384 ;s> trap --  trap routine.  Don't exit VTIL unless maximum number of errors
                                     18F7  3385 ;	has been exceeded.
                                     18F7  3386 ;---
                               0000  18F7  3387 	.entry	s_trap,^m<>
                                     18F9  3388 ; output some sort of error message
                    51   04 AC   D0  18F9  3389 	movl	chf$l_sigarglst(ap),r1
                            01   DD  18FD  3390 	pushl	#1
                         04 A1   DD  18FF  3391 	pushl	chf$l_sig_name(r1)
                                     1902  3392 	$putmsg_s msgvec=(r1)
                                     1902       		.GLOBL	SYS$PUTMSG
                            00   DD  1902       		PUSHL	#0
                                     1904       		$PUSHADR 0,CONTEXT=Q
                                     1904       		.IF	IDN,0,0
                            00   DD  1904       		PUSHL	#0
                                     1906       		.IFF
                                     1906       		.IF EQ	1-1
                                     1906       		.IF NE	1-1
                                     1906       		PUSHAQ	0
                                     1906       		.MEXIT
                                     1906       		.ENDC
                                     1906       		.ENDC
                                     1906       		.NTYPE	$$$ADR, 0
                                     1906       $$$ADR	=	$$$ADR & ^XFFF0
                                     1906       		.IF GT	$$$ADR - ^XFF
                                     1906       		PUSHAQ	0
                                     1906       		.MEXIT
                                     1906       		.ENDC
                                     1906       		.IF EQ	$$$ADR - ^X80
                                     1906       		PUSHAQ	0
                                     1906       		.MEXIT
                                     1906       		.ENDC
                                     1906       		.IF EQ	$$$ADR - ^X70
                                     1906       		PUSHAQ	0
                                     1906       		.MEXIT
                                     1906       		.ENDC
                                     1906       		PUSHAB	0
                                     1906       		.ENDC
                                     1906       	
                                     1906       		$PUSHADR 0
                                     1906       		.IF	IDN,0,0
                            00   DD  1906       		PUSHL	#0
                                     1908       		.IFF
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 140
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1908       		.IF EQ	1-1
                                     1908       		.IF NE	1-1
                                     1908       		PUSHAL	0
                                     1908       		.MEXIT
                                     1908       		.ENDC
                                     1908       		.ENDC
                                     1908       		.NTYPE	$$$ADR, 0
                                     1908       $$$ADR	=	$$$ADR & ^XFFF0
                                     1908       		.IF GT	$$$ADR - ^XFF
                                     1908       		PUSHAL	0
                                     1908       		.MEXIT
                                     1908       		.ENDC
                                     1908       		.IF EQ	$$$ADR - ^X80
                                     1908       		PUSHAL	0
                                     1908       		.MEXIT
                                     1908       		.ENDC
                                     1908       		.IF EQ	$$$ADR - ^X70
                                     1908       		PUSHAL	0
                                     1908       		.MEXIT
                                     1908       		.ENDC
                                     1908       		PUSHAB	0
                                     1908       		.ENDC
                                     1908       	
                                     1908       		$PUSHADR (r1)
                                     1908       		.IF	IDN,0,(r1)
                                     1908       		PUSHL	#0
                                     1908       		.IFF
                           00000000  1908       		.IF EQ	4-4
                           00000000  1908       		.IF NE	4-4
                                     1908       		PUSHAL	(r1)
                                     1908       		.MEXIT
                                     1908       		.ENDC
                                     1908       		.ENDC
                           00000061  1908       		.NTYPE	$$$ADR, (r1)
                           00000060  1908       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFF61  1908       		.IF GT	$$$ADR - ^XFF
                                     1908       		PUSHAL	(r1)
                                     1908       		.MEXIT
                                     1908       		.ENDC
                           FFFFFFE0  1908       		.IF EQ	$$$ADR - ^X80
                                     1908       		PUSHAL	(r1)
                                     1908       		.MEXIT
                                     1908       		.ENDC
                           FFFFFFF0  1908       		.IF EQ	$$$ADR - ^X70
                                     1908       		PUSHAL	(r1)
                                     1908       		.MEXIT
                                     1908       		.ENDC
                            61   9F  1908       		PUSHAB	(r1)
                                     190A       		.ENDC
                                     190A       	
              00000000'GF   04   FB  190A       		CALLS	#4,G^SYS$PUTMSG
                                     1911       	
                                     1911  3393 ; somewhere we need to figure out how to message this as well
                   00001D2F'EF   D6  1911  3394 	incl	v_errors		; increment number of errors
              14   00001D2F'EF   D1  1917  3395 	cmpl	v_errors,#c_max_errs	; the max number of errors exceeded?
                            1C   14  191E  3396 	bgtr	10$			; yes, go exit
                    50   08 AC   D0  1920  3397 	movl	chf$l_mcharglst(ap),r0	; get address of mechanism array
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 141
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                         08 A0   D0  1924  3398 	movl	chf$l_mch_depth(r0),-	; get depth, so we will unwind to
                   00001D27'EF       1927  3399 		v_trap_depth		;   the main program
                                     192C  3400 	$unwind_s depadr=v_trap_depth	; unwind stack
                                     192C       		.GLOBL	SYS$UNWIND
                                     192C       		$PUSHADR 0
                                     192C       		.IF	IDN,0,0
                            00   DD  192C       		PUSHL	#0
                                     192E       		.IFF
                                     192E       		.IF EQ	1-1
                                     192E       		.IF NE	1-1
                                     192E       		PUSHAL	0
                                     192E       		.MEXIT
                                     192E       		.ENDC
                                     192E       		.ENDC
                                     192E       		.NTYPE	$$$ADR, 0
                                     192E       $$$ADR	=	$$$ADR & ^XFFF0
                                     192E       		.IF GT	$$$ADR - ^XFF
                                     192E       		PUSHAL	0
                                     192E       		.MEXIT
                                     192E       		.ENDC
                                     192E       		.IF EQ	$$$ADR - ^X80
                                     192E       		PUSHAL	0
                                     192E       		.MEXIT
                                     192E       		.ENDC
                                     192E       		.IF EQ	$$$ADR - ^X70
                                     192E       		PUSHAL	0
                                     192E       		.MEXIT
                                     192E       		.ENDC
                                     192E       		PUSHAB	0
                                     192E       		.ENDC
                                     192E       	
                                     192E       		$PUSHADR v_trap_depth
                                     192E       		.IF	IDN,0,v_trap_depth
                                     192E       		PUSHL	#0
                                     192E       		.IFF
                           00000000  192E       		.IF EQ	12-12
                           00000000  192E       		.IF NE	12-12
                                     192E       		PUSHAL	v_trap_depth
                                     192E       		.MEXIT
                                     192E       		.ENDC
                                     192E       		.ENDC
                           000000CF  192E       		.NTYPE	$$$ADR, v_trap_depth
                           000000C0  192E       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  192E       		.IF GT	$$$ADR - ^XFF
                                     192E       		PUSHAL	v_trap_depth
                                     192E       		.MEXIT
                                     192E       		.ENDC
                           00000040  192E       		.IF EQ	$$$ADR - ^X80
                                     192E       		PUSHAL	v_trap_depth
                                     192E       		.MEXIT
                                     192E       		.ENDC
                           00000050  192E       		.IF EQ	$$$ADR - ^X70
                                     192E       		PUSHAL	v_trap_depth
                                     192E       		.MEXIT
                                     192E       		.ENDC
                   00001D27'EF   9F  192E       		PUSHAB	v_trap_depth
                                     1934       		.ENDC
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 142
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1934       	
              00000000'GF   02   FB  1934       		CALLS	#2,G^SYS$UNWIND
                                     193B       	
                                 04  193B  3401 	ret				; return to main progam
                                     193C  3402 10$:
                            00   DD  193C  3403 	pushl	#0			; number of fao parameters
                   00000000'8F   DD  193E  3404 	pushl	#vtil_maxerrors		; message number
                            02   DD  1944  3405 	pushl	#2			; number of longs in message vecor,
                                     1946  3406 					; not including this one.
                       50   5E   D0  1946  3407 	movl	sp,r0			; save address of buffer
                                     1949  3408 	$putmsg_s msgvec=(r0)		; write message
                                     1949       		.GLOBL	SYS$PUTMSG
                            00   DD  1949       		PUSHL	#0
                                     194B       		$PUSHADR 0,CONTEXT=Q
                                     194B       		.IF	IDN,0,0
                            00   DD  194B       		PUSHL	#0
                                     194D       		.IFF
                                     194D       		.IF EQ	1-1
                                     194D       		.IF NE	1-1
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		.ENDC
                                     194D       		.NTYPE	$$$ADR, 0
                                     194D       $$$ADR	=	$$$ADR & ^XFFF0
                                     194D       		.IF GT	$$$ADR - ^XFF
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		.IF EQ	$$$ADR - ^X80
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		.IF EQ	$$$ADR - ^X70
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		PUSHAB	0
                                     194D       		.ENDC
                                     194D       	
                                     194D       		$PUSHADR 0
                                     194D       		.IF	IDN,0,0
                            00   DD  194D       		PUSHL	#0
                                     194F       		.IFF
                                     194F       		.IF EQ	1-1
                                     194F       		.IF NE	1-1
                                     194F       		PUSHAL	0
                                     194F       		.MEXIT
                                     194F       		.ENDC
                                     194F       		.ENDC
                                     194F       		.NTYPE	$$$ADR, 0
                                     194F       $$$ADR	=	$$$ADR & ^XFFF0
                                     194F       		.IF GT	$$$ADR - ^XFF
                                     194F       		PUSHAL	0
                                     194F       		.MEXIT
                                     194F       		.ENDC
                                     194F       		.IF EQ	$$$ADR - ^X80
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 143
V1.01                           Enter VTIL                               31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     194F       		PUSHAL	0
                                     194F       		.MEXIT
                                     194F       		.ENDC
                                     194F       		.IF EQ	$$$ADR - ^X70
                                     194F       		PUSHAL	0
                                     194F       		.MEXIT
                                     194F       		.ENDC
                                     194F       		PUSHAB	0
                                     194F       		.ENDC
                                     194F       	
                                     194F       		$PUSHADR (r0)
                                     194F       		.IF	IDN,0,(r0)
                                     194F       		PUSHL	#0
                                     194F       		.IFF
                           00000000  194F       		.IF EQ	4-4
                           00000000  194F       		.IF NE	4-4
                                     194F       		PUSHAL	(r0)
                                     194F       		.MEXIT
                                     194F       		.ENDC
                                     194F       		.ENDC
                           00000060  194F       		.NTYPE	$$$ADR, (r0)
                           00000060  194F       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFF61  194F       		.IF GT	$$$ADR - ^XFF
                                     194F       		PUSHAL	(r0)
                                     194F       		.MEXIT
                                     194F       		.ENDC
                           FFFFFFE0  194F       		.IF EQ	$$$ADR - ^X80
                                     194F       		PUSHAL	(r0)
                                     194F       		.MEXIT
                                     194F       		.ENDC
                           FFFFFFF0  194F       		.IF EQ	$$$ADR - ^X70
                                     194F       		PUSHAL	(r0)
                                     194F       		.MEXIT
                                     194F       		.ENDC
                            60   9F  194F       		PUSHAB	(r0)
                                     1951       		.ENDC
                                     1951       	
              00000000'GF   04   FB  1951       		CALLS	#4,G^SYS$PUTMSG
                                     1958       	
                                     1958  3409 	$exit_s				; exit
                                     1958       		.GLOBL	SYS$EXIT
                            01   DD  1958       		PUSHL	#1
              00000000'GF   01   FB  195A       		CALLS	#1,G^SYS$EXIT
                                     1961       	
                                     1961  3410 					; end of trap
                                     1961  3411 
                                     1961  3412 	newpage <Initialization>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 144
V1.01                           Initialization                           31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1961       	.sbttl	Initialization
                                     1961       	
                                     1961  3413 ;*******************************************************************************
                                     1961  3414 ;
                                     1961  3415 ; Initialization
                                     1961  3416 ;
                                     1961  3417 ;*******************************************************************************
                                     1961  3418 
                                     1961  3419 ;+++
                                     1961  3420 ;s> cold_start -- do all initial setup
                                     1961  3421 ;+++
                               0000  1961  3422 	.entry	s_cold_start,^m<>
              00001D33'EF   5E   D0  1963  3423 	movl	sp,v_returnstack	; save original return stack pointer
              59   00000000'8F   D0  196A  3424 	movl	#c_dict_begin,r9	; initialize dictionary pointer
                                     1971  3425 ; vl_compiler and vl_kernel are symbols that contain location of last word in
                                     1971  3426 ; these vocabularies, which are built-in.
     00001D3F'EF   0000188B'8F   D0  1971  3427 	movl	#vl_compiler,v_compiler	; Initialize compiler vocabulary
     00001D43'EF   00001516'8F   D0  197C  3428 	movl	#vl_kernel,v_kernel	; Initialize kernel vocabulary
                                     1987  3429 ; greet user
                   00001800'EF   7F  1987  3430 	pushaq	v_greeting
              00000000'GF   01   FB  198D  3431 	calls	#1,g^lib$put_output	; greet user
     00001D37'EF   00001D43'EF   DE  1994  3432 	moval	v_kernel,v_context	; Initialize context
     00001D3B'EF   00001D43'EF   DE  199F  3433 	moval	v_kernel,v_current	; Initialize current
                          009C   31  19AA  3434 	brw	_initialize		; skip patching stuff
                                     19AD  3435 
                                     19AD  3436 
                                     19AD  3437 ;+++
                                     19AD  3438 ;s> warm_start -- do a warm start.  Called from main program.  Branched to
                                     19AD  3439 ;	internally.
                                     19AD  3440 ;---
                               0000  19AD  3441 	.entry	s_warm_start,^m<>
                                     19AF  3442 ; only greet user if entered from main program.  Otherwise we are recovering
                                     19AF  3443 ; from an internal error and are only patching, not recovering from a trap.
                   00001800'EF   7F  19AF  3444 	pushaq	v_greeting
              00000000'GF   01   FB  19B5  3445 	calls	#1,g^lib$put_output	; greet user
     00001D37'EF   00001D43'EF   DE  19BC  3446 	moval	v_kernel,v_context	; Initialize context
     00001D3B'EF   00001D43'EF   DE  19C7  3447 	moval	v_kernel,v_current	; Initialize current
                                     19D2  3448 ;+++
                                     19D2  3449 ;r> warm_start -- so we can brw to it as well as call it
                                     19D2  3450 ;---
                                     19D2  3451 r_warm_start:
                                     19D2  3452 
                                     19D2  3453 ; The following patches system variables and delivers error messages to the user
                                     19D2  3454 ; about the cause of the boom.
                   00001D4D'EF   95  19D2  3455 	tstb	v_mode		        ; were we compiling before error?
                            04   13  19D8  3456 	beql	10$			; no
                       F988 CF   16  19DA  3457 	jsb	unlink			; yes, unlink unfinished word
                                     19DE  3458 10$:
              00001D4D'EF   00   90  19DE  3459 	movb	#c_false,v_mode		; put in execute mode
              00001D4C'EF   00   90  19E5  3460 	movb	#c_false,v_state	;   just in case
              00001999'EF   00   B0  19EC  3461 	movw	#0,v_inlen		; so start with new line
              00001997'EF   00   B0  19F3  3462 	movw	#0,v_org_inlen		;   just in case
                   00001D47'EF   95  19FA  3463 	tstb	v_infile		; Are we getting from file?
                            3C   13  1A00  3464 	beql	20$			; no
                                     1A02  3465 	$close	fab=v_infab		; yes, close file
                                     1A02       		$RMSCALL	CLOSE,v_infab,,
                                     1A02       	.GLOBL	SYS$CLOSE
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 145
V1.01                           Initialization                           31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1A02       	.IF	B <v_infab>
                                     1A02       	CALLG	(AP),G^SYS$CLOSE
                                     1A02       	$$.TMP=0
                                     1A02       	.IF	NB <>
                                     1A02       	$$.TMP=1
                                     1A02       	.ENDC
                                     1A02       	.IF	NB <>
                                     1A02       	$$.TMP=1
                                     1A02       	.ENDC
                                     1A02       	.IF	NE $$.TMP
                                     1A02       	.ERROR				; v_infab= parameter missing;
                                     1A02       	.ENDC
                                     1A02       	.ENDC
                                     1A02       	.IF	NB <v_infab>
                           00000001  1A02       	$$.TMP1=1
                                     1A02       	.IF	NB <>
                                     1A02       	PUSHAL	
                                     1A02       	$$.TMP1=3
                                     1A02       	.ENDC
                                     1A02       	.IF	NB <>
                                     1A02       	PUSHAL	
                                     1A02       	.IF	EQ <$$.TMP1-1>
                                     1A02       	$$.TMP1=2
                                     1A02       	.ENDC
                                     1A02       	.IFF
                           FFFFFFFE  1A02       	.IF	EQ <$$.TMP1-3>
                                     1A02       	PUSHL	#0
                                     1A02       	.ENDC
                                     1A02       	.ENDC
                           000000AF  1A02       	.NTYPE	$$.TMP2,v_infab
                           00000050  1A02       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     1A02       	PUSHL	v_infab
                                     1A02       	.IFF
                           00000090  1A02       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     1A02       	PUSHL	v_infab
                                     1A02       	.IFF
                   000019A8'EF   DF  1A02       	PUSHAL	v_infab
                                     1A08       	.ENDC
                                     1A08       	.ENDC
              00000000'GF   01   FB  1A08       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     1A0F       	.ENDC
                                     1A0F       	
                                     1A0F       	
              00001D47'EF   00   90  1A0F  3466 	movb	#c_false,v_infile	; set infile flag false
              00001D48'EF   00   D0  1A16  3467 	movl	#0,v_filelinenum	; zero file line as well
              7B   00001890'EF   9E  1A1D  3468 	movab	v_infilemess,-(r11)	; put address of 'In file:' on stack
                       EA4D CF   16  1A24  3469 	jsb 	bcount			; convert from ascic to write format ( address count )
                       FA24 CF   16  1A28  3470 	jsb	write			; put in output
              7B   00001A3D'EF   DE  1A2C  3471 	moval	v_fname,-(r11)		; put address of filename on stack
              7B   00001A3C'EF   9A  1A33  3472 	movzbl	v_fnamelen,-(r11)	; put count of filename on stack
                       FA12 CF   16  1A3A  3473 	jsb	write			; write filename out to terminal
                                     1A3E  3474 20$:
                       E899 CF   16  1A3E  3475 	jsb	q_cr			; finish off outstanding input, if any
              5E   00001D33'EF   D0  1A42  3476 	movl	v_returnstack,sp	; restore original return stack pointer
                                     1A49  3477 
                                     1A49  3478 ;
                                     1A49  3479 ; The following is also done during a cold start.
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 146
V1.01                           Initialization                           31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1A49  3480 ;
                                     1A49  3481 _initialize:
                                     1A49  3482 	; Initialize stacks.
              5B   00001000'EF   DE  1A49  3483 	moval	c_ds_start,r11 		; move address of data stack to ds pointer
              5A   00001800'EF   DE  1A50  3484 	moval	c_ls_start,r10		; move address of loop stack to ls pointer
                                     1A57  3485 
                                     1A57  3486 
                                     1A57  3487 	newpage <Interpreter>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 147
V1.01                           Interpreter                              31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1A57       	.sbttl	Interpreter
                                     1A57       	
                                     1A57  3488 ;*******************************************************************************
                                     1A57  3489 ;
                                     1A57  3490 ; Interpreter -- Take commands from the user (or a file) and execute them.
                                     1A57  3491 ;
                                     1A57  3492 ;*******************************************************************************
                                     1A57  3493 _interpreter:
                       7B   20   D0  1A57  3494 	movl	#c_blank,-(r11)		; set up for space delimeted token
                       F884 CF   16  1A5A  3495 	jsb	token			; get the next token
                                     1A5E  3496 ; is it a comment?
                       69   01   91  1A5E  3497 	cmpb	#1,(r9)			; token only one byte long?
                            0D   12  1A61  3498 	bneq	10$			; no
                 01 A9   5C 8F   91  1A63  3499 	cmpb	#c_com1_begin,1(r9)	; is it a \
                            1B   13  1A68  3500 	beql	_strip_comment		; yes, strip comment
                    01 A9   28   91  1A6A  3501 	cmpb	#c_com2_begin,1(r9)	; Is it a (
                            1F   13  1A6E  3502 	beql	_strip_comment2		; yes, strip second type of comment
                                     1A70  3503 10$:
                       E8E7 CF   16  1A70  3504 	jsb	q_search		; search for the word
                            8B   D5  1A74  3505 	tstl	(r11)+			; was it found?
                            02   13  1A76  3506 	beql	30$			; no, go see if number
                            1F   11  1A78  3507 	brb	_q_execute		; yes, go see if execute or compile
                                     1A7A  3508 30$:
                       E8AE CF   16  1A7A  3509 	jsb	q_number		; see if it is a number
                            8B   D5  1A7E  3510 	tstl	(r11)+			; was it valid?
                            D5   12  1A80  3511 	bneq	_interpreter		; yes, leave with number on the stack
                          0079   31  1A82  3512 	brw	_unknowntoken		; no, tell user bad token
                                     1A85  3513 
                                     1A85  3514 
                                     1A85  3515 _strip_comment:
                       7B   00   D0  1A85  3516 	movl	#c_com1_end,-(r11)	; end of first type of comment
                       F856 CF   16  1A88  3517 	jsb	token			; get the token
                          FFC8   31  1A8C  3518 	brw	_interpreter		; end of strip comment
                                     1A8F  3519 
                                     1A8F  3520 
                                     1A8F  3521 _strip_comment2:
                       7B   29   D0  1A8F  3522 	movl	#c_com2_end,-(r11)	; end of second type of comment
                       F84C CF   16  1A92  3523 	jsb	token			; get the token
                          FFBE   31  1A96  3524 	brw	_interpreter		; end of strip comment2
                                     1A99  3525 
                                     1A99  3526 
                                     1A99  3527 _q_execute:
                       ECAB CF   16  1A99  3528 	jsb	cfa			; get the code field address of
                                     1A9D  3529 					;   the word
     00001D4C'EF   00001D4D'EF   91  1A9D  3530 	cmpb	v_mode,v_state		; v_mode = v_state?~~~ what does this tell us???
                            1E   12  1AA8  3531 	bneq	10$			; no, go compile it
              00001D4C'EF   00   90  1AAA  3532 	movb	#c_false,v_state	; set v_state false~~~ Why???
                            9B   16  1AB1  3533 	jsb	@(r11)+			; yes, execute it
              00000000'8F   5A   D1  1AB3  3534 	cmpl	r10,#c_ds_end		; stack overflow?
                            2E   19  1ABA  3535 	blss	_overflow		; yes, go announce it
              00001000'8F   5B   D1  1ABC  3536 	cmpl	r11,#c_ds_start		; stack underflow?
                            11   14  1AC3  3537 	bgtr	_underflow		; yes, go announce it
                          FF8F   31  1AC5  3538 	brw	_interpreter		; everything ok, do it again
                                     1AC8  3539 10$:
              00001D4C'EF   00   90  1AC8  3540 	movb	#c_false,v_state	; set v_state false~~~ what does this tell us???
                       ECD3 CF   16  1ACF  3541 	jsb	i_compile_jsb		; compile a jump to the word whose
                                     1AD3  3542 					;   cfa addressis at the top of stack
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 148
V1.01                           Interpreter                              31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                          FF81   31  1AD3  3543 	brw	_interpreter		; everthing ok, do it again
                                     1AD6  3544 
                                     1AD6  3545 
                                     1AD6  3546 _underflow:
                       ED34 CF   16  1AD6  3547 	jsb	cr			; make sure everything is output
                   00001842'EF   7F  1ADA  3548 	pushaq	v_undermess		; push address of underflow message
              00000000'GF   01   FB  1AE0  3549 	calls	#1,g^lib$put_output	; tell user
                          FEE8   31  1AE7  3550 	brw	r_warm_start			; clean up VTIL
                                     1AEA  3551 
                                     1AEA  3552 
                                     1AEA  3553 _overflow:
                       ED20 CF   16  1AEA  3554 	jsb	cr			; make sure everything is output
                   0000185A'EF   7F  1AEE  3555 	pushaq	v_overmess		; make sure everything is output
              00000000'GF   01   FB  1AF4  3556 	calls	#1,g^lib$put_output	; tell user
                          FED4   31  1AFB  3557 	brw	r_warm_start			; clean up VTIL
                                     1AFE  3558 
                                     1AFE  3559 
                                     1AFE  3560 _unknowntoken:
              7B   00001871'EF   9E  1AFE  3561 	movab	v_unknown,-(r11)	; push address of unknown token message
                       E96C CF   16  1B05  3562 	jsb	bcount			; convert it to ( address count )
                       F943 CF   16  1B09  3563 	jsb	write			; tell user
                       7B   59   D0  1B0D  3564 	movl	r9,-(r11)		; get address of token
                            6B   D6  1B10  3565 	incl	(r11)			; move address over byte-count
                       7B   69   9A  1B12  3566 	movzbl	(r9),-(r11)		; get byte count of string on stack
                       F937 CF   16  1B15  3567 	jsb	write			; show user bad token
              7B   00001883'EF   9E  1B19  3568 	movab	v_unknown2,-(r11)	; Put address of 'In line:' on stack
                       E951 CF   16  1B20  3569 	jsb	bcount			; convert it to ( address count )
                       F928 CF   16  1B24  3570 	jsb	write			; tell user
                   00001D47'EF   95  1B28  3571 	tstb	v_infile		; In a file?
                            0B   13  1B2E  3572 	beql	10$			; no
              7B   00001D48'EF   D0  1B30  3573 	movl	v_filelinenum,-(r11)	; yes, print line number
                       E5E8 CF   16  1B37  3574 	jsb	i_dot			; put number in output buffer
                                     1B3B  3575 10$:
                       ECCF CF   16  1B3B  3576 	jsb	cr			; end line
              7B   000018F7'EF   DE  1B3F  3577 	moval	v_inbuf,-(r11)		; get address of original line
              7B   00001997'EF   32  1B46  3578 	cvtwl	v_org_inlen,-(r11)	; length of original line
                       F8FF CF   16  1B4D  3579 	jsb	write			; show user
                       ECB9 CF   16  1B51  3580 	jsb	cr			; end line
                          FE7A   31  1B55  3581 	brw	r_warm_start		; go clean up VTIL
                                     1B58  3582 
                                     1B58  3583 
                                     1B58  3584 	newpage <Exit Routines>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 149
V1.01                           Exit Routines                            31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1B58       	.sbttl	Exit Routines
                                     1B58       	
                                     1B58  3585 ;*******************************************************************************
                                     1B58  3586 ;
                                     1B58  3587 ; Exit Routines -- Routines to handle successful and unsuccessful  exits
                                     1B58  3588 ;
                                     1B58  3589 ;*******************************************************************************
                                     1B58  3590 _error_exit:				; die messily
                            50   DD  1B58  3591 	pushl	r0			; put error message number on stack
              00000000'GF   01   FB  1B5A  3592 	calls	#1,g^lib$signal		; signal error
                                 04  1B61  3593 	ret				; return
                                     1B62  3594 
                                     1B62  3595 
                         0C A6   DD  1B62  3596 _f_err:	pushl	fab$l_stv(r6)		; push stv and sts of fab
                         08 A6   DD  1B65  3597 	pushl	fab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1B68  3598 	calls	#2,g^lib$signal		; signal error
                            1A   11  1B6F  3599 	brb	_exit
                                     1B71  3600 
                                     1B71  3601 
                         0C A6   DD  1B71  3602 _r_err:	pushl	rab$l_stv(r6)		; push stv and sts of rab
                         08 A6   DD  1B74  3603 	pushl	rab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1B77  3604 	calls	#2,g^lib$signal		; signal error
                                     1B7E  3605 
                                     1B7E  3606 
                                     1B7E  3607 _done:	$close	fab=v_infile		; close input
                                     1B7E       		$RMSCALL	CLOSE,v_infile,,
                                     1B7E       	.GLOBL	SYS$CLOSE
                                     1B7E       	.IF	B <v_infile>
                                     1B7E       	CALLG	(AP),G^SYS$CLOSE
                                     1B7E       	$$.TMP=0
                                     1B7E       	.IF	NB <>
                                     1B7E       	$$.TMP=1
                                     1B7E       	.ENDC
                                     1B7E       	.IF	NB <>
                                     1B7E       	$$.TMP=1
                                     1B7E       	.ENDC
                                     1B7E       	.IF	NE $$.TMP
                                     1B7E       	.ERROR				; v_infile= parameter missing;
                                     1B7E       	.ENDC
                                     1B7E       	.ENDC
                                     1B7E       	.IF	NB <v_infile>
                           00000001  1B7E       	$$.TMP1=1
                                     1B7E       	.IF	NB <>
                                     1B7E       	PUSHAL	
                                     1B7E       	$$.TMP1=3
                                     1B7E       	.ENDC
                                     1B7E       	.IF	NB <>
                                     1B7E       	PUSHAL	
                                     1B7E       	.IF	EQ <$$.TMP1-1>
                                     1B7E       	$$.TMP1=2
                                     1B7E       	.ENDC
                                     1B7E       	.IFF
                           FFFFFFFE  1B7E       	.IF	EQ <$$.TMP1-3>
                                     1B7E       	PUSHL	#0
                                     1B7E       	.ENDC
                                     1B7E       	.ENDC
                           000000CF  1B7E       	.NTYPE	$$.TMP2,v_infile
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 150
V1.01                           Exit Routines                            31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                           00000070  1B7E       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     1B7E       	PUSHL	v_infile
                                     1B7E       	.IFF
                           000000B0  1B7E       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     1B7E       	PUSHL	v_infile
                                     1B7E       	.IFF
                   00001D47'EF   DF  1B7E       	PUSHAL	v_infile
                                     1B84       	.ENDC
                                     1B84       	.ENDC
              00000000'GF   01   FB  1B84       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     1B8B       	.ENDC
                                     1B8B       	
                                     1B8B       	
                                     1B8B  3608 
                                     1B8B  3609 
                                     1B8B  3610 _exit:
                       50   01   D0  1B8B  3611 	movl	#1,r0			; successful completion
                                     1B8E  3612 	$exit_s	r0			; exit with status
                                     1B8E       		.GLOBL	SYS$EXIT
                            50   DD  1B8E       		PUSHL	r0
              00000000'GF   01   FB  1B90       		CALLS	#1,G^SYS$EXIT
                                     1B97       	
                                     1B97  3613 
                                     1B97  3614 
                                     1B97  3615 	newpage <Dictionary Space>
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 151
V1.01                           Dictionary Space                         31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                     1B97       	.sbttl	Dictionary Space
                                     1B97       	
                                     1B97  3616 ;*******************************************************************************
                                     1B97  3617 ;
                                     1B97  3618 ; Dictionary
                                     1B97  3619 ;
                                     1B97  3620 ;*******************************************************************************
                                 00000000  3621 	.psect	vtildict
                                     0000  3622 c_dict_begin:
                           00004000  0000  3623 	. = .+<16 * 1024>		; reserve space for dictinary~~~ why not a constant???
                                     4000  3624 c_dict_end:
                                     4000  3625 
                                     4000  3626 
                                     4000  3627 ;
                                     4000  3628 ; Block i/o buffers -- Here because that is the safest place for them.
                                     4000  3629 ;
                                     4000  3630 v_blkbuff:
                           00004C00  4000  3631 	.blkb	c_max_blocks * c_block_size ; buffers for block i/o
                                     4C00  3632 
                                     4C00  3633 
                                     4C00  3634 ;*******************************************************************************
                                     4C00  3635 ;
                                     4C00  3636 ; End of VTIL, and transfer address
                                     4C00  3637 ;
                                     4C00  3638 ;*******************************************************************************
                                     4C00  3639 	.end	vtil
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 152
Symbol table                                                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

$$$ADR                         = 00000060    D            C_DICT_END                       00004000 R  D  05        
$$.TAB                         = 00001B30 R  D  02        C_DS_END                         00000000 R  D  02        
$$.TABEND                      = 00001B74 R  D  02        C_DS_SIZE                      = 00001000    D            
$$.TMP                         = 00000000    D            C_DS_START                       00001000 R  D  02        
$$.TMP1                        = 00000001    D            C_D_BLKS_IN_BLK                = 00000002    D            
$$.TMP2                        = 000000CF                 C_FALSE                        = 00000000    D            
$$.TMPX                        = 0000000A R  D  03        C_INUSE                        = 00000001    D            
$$.TMPX1                       = 0000000E    D            C_KEYSIZE                      = 00000004    D            
$$T1                           = 00000001    D            C_LS_END                         00001000 R  D  02        
ABORT                            000003A3 R  D  04        C_LS_SIZE                      = 00000800    D            
ABS                              000003AE R  D  04        C_LS_START                       00001800 R  D  02        
ADM_ABSOLUTE                   = 0000009F    D            C_MAX_BLOCKS                   = 00000003    D            
ADM_ADEC_R10                   = 0000007A    D            C_MAX_ERRS                     = 00000014    D            
ADM_ADEC_R11                   = 0000007B    D            C_MAX_LEN                      = 000000A0    D            
ADM_AINC_R10                   = 0000008A    D            C_MAX_NAME_LEN                 = 00000050    D            
ADM_AINC_R11                   = 0000008B    D            C_MODIFIED                     = 00000002    D            
ADM_AINC_R9                    = 00000089    D            C_PAD_MOAT                     = 00000109    D            
ADM_B_DIS_R10                  = 000000AA    D            C_SCREEN_LEN                   = 00000050    D            
ADM_B_REL                      = 000000AF    D            C_TPU_COM_LEN                  = 0000001C    D            
ADM_DEF_R10                    = 0000006A    D            C_TRUE                         = FFFFFFFF    D            
ADM_DEF_R11                    = 0000006B    D            DC$_TERM                         ********   X   00        
ADM_DEF_R9                     = 00000069    D            DECIMAL                          000008D5 R  D  04        
ADM_IMMEDIATE                  = 0000008F    D            DEFINITIONS                      000008ED R  D  04        
ADM_R0                         = 00000050    D            DOWNLOOP                         000016BD R  D  04        
ADM_R10                        = 0000005A    D            DROP                             00000902 R  D  04        
ADM_R9                         = 00000059    D            DSC$K_CLASS_S                    ********   X   00        
AGAIN                            00001615 R  D  04        DSC$K_DTYPE_T                    ********   X   00        
AND                              000003EB R  D  04        DUP                              0000091C R  D  04        
ARRAY                            0000040C R  D  04        ELSE                             000016F9 R  D  04        
ASCII                            00000432 R  D  04        ENABLE_CTRLC                     000018C3 RG D  04        
BCOUNT                           00000475 R  D  04        ENDIF                            00001721 R  D  04        
BINARY                           0000048A R  D  04        ENDWHILE                         0000173A R  D  04        
BLANK                            000004A9 R  D  04        EODP                             00000954 R  D  04        
BLOCK                            000004BE R  D  04        EVE                              0000097D R  D  04        
BREAK                            0000062B R  D  04        FAB$B_DNS                      = 00000035    D            
BUFFER                           00000645 R  D  04        FAB$B_FNS                      = 00000034    D            
BYTE                             00000721 R  D  04        FAB$C_BID                      = 00000003    D            
CFA                              00000748 R  D  04        FAB$C_BLN                      = 00000050    D            
CHF$L_MCHARGLST                = 00000008    D            FAB$C_FIX                      = 00000001    D            
CHF$L_MCH_DEPTH                = 00000008    D            FAB$C_SEQ                      = 00000000    D            
CHF$L_SIGARGLST                = 00000004    D            FAB$C_VAR                      = 00000002    D            
CHF$L_SIG_NAME                 = 00000004    D            FAB$L_ALQ                      = 00000010    D            
CLIST                            00000763 R  D  04        FAB$L_DNA                      = 00000030    D            
COMPILER_BEGIN                   00001525 R  D  04        FAB$L_FNA                      = 0000002C    D            
COMPILETIME                      000007C1 R  D  04        FAB$L_FOP                      = 00000004    D            
CONTEXT                          000007EA R  D  04        FAB$L_STS                      = 00000008    D            
COUNT                            000007FC R  D  04        FAB$L_STV                      = 0000000C    D            
CR                               0000080E R  D  04        FAB$V_CHAN_MODE                = 00000002    D            
CREATE                           00000842 R  D  04        FAB$V_FILE_MODE                = 00000004    D            
CURRENT                          000008C1 R  D  04        FAB$V_GET                      = 00000001    D            
C_BLANK                        = 00000020    D            FAB$V_LNM_MODE                 = 00000000    D            
C_BLOCK_SIZE                   = 00000400    D            FAB$V_UPD                      = 00000003    D            
C_COM1_BEGIN                   = 0000005C    D            FAB$W_GBC                      = 00000048    D            
C_COM1_END                     = 00000000    D            FILL                             000009CF R  D  04        
C_COM2_BEGIN                   = 00000028    D            FORGET                           00000A20 R  D  04        
C_COM2_END                     = 00000029    D            FREEMEM                          00000ACE R  D  04        
C_DICT_BEGIN                     00000000 R  D  05        HEX                              00000AF2 R  D  04        
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 153
Symbol table                                                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

HLD                              00000B02 R  D  04        I_LONG                           00000BF6 R  D  04        
HOLD                             00000B13 R  D  04        I_LOOP                           000017B8 R  D  04        
IF                               0000175D R  D  04        I_LS_TO_DS                       00000C36 R  D  04        
IO$M_CTRLCAST                    ********   X   00        I_L_UP                           0000177F R  D  04        
IO$_SETMODE                      ********   X   00        I_MATCH                          00000C44 R  D  04        
I_AC_COLON                       000003BE R  D  04        I_MINUS_ROT                      0000010C R  D  04        
I_ADD                            000000C1 R  D  04        I_MOVE_FILL                      00000CE0 R  D  04        
I_BIT_AND                        00000072 R  D  04        I_MULTIPLY                       000000A8 R  D  04        
I_BIT_NOT                        00000083 R  D  04        I_ONE_MINUS                      000001F2 R  D  04        
I_BIT_OR                         00000090 R  D  04        I_ONE_PLUS                       000001E8 R  D  04        
I_BIT_XOR                        0000009E R  D  04        I_PLUS_LOOP                      00001551 R  D  04        
I_BL                             0000049B R  D  04        I_PLUS_ROT                       000000DE R  D  04        
I_BLOCK_CLOSE                    0000053F R  D  04        I_PLUS_STORE                     000000CC R  D  04        
I_BLOCK_OPEN                     00000571 R  D  04        I_QUESTION                       000002CA R  D  04        
I_BLOCK_READ                     000005B7 R  D  04        I_RIGHT_BACK                     0000151C R  D  04        
I_BLOCK_WRITE                    000005E9 R  D  04        I_SAVE_BUFFERS                   00000F59 R  D  04        
I_BS_FETCH                       00000635 R  D  04        I_SEMICOLON                      000015D7 R  D  04        
I_BUFFER_READ                    000006BC R  D  04        I_SHARP                          00000015 R  D  04        
I_BUFFER_WRITE                   000006F8 R  D  04        I_SHARP_GREATER                  00000036 R  D  04        
I_B_COMMA                        00000457 R  D  04        I_SHARP_S                        00000055 R  D  04        
I_B_FETCH                        00000465 R  D  04        I_SHORT                          00000FBE R  D  04        
I_B_STORE                        00000447 R  D  04        I_SP_0                           0000101D R  D  04        
I_B_UP                           0000163A R  D  04        I_SP_FETCH                       00001011 R  D  04        
I_COLON                          000001FB R  D  04        I_STORE                          00000006 R  D  04        
I_COMMA                          000000F5 R  D  04        I_STRING_QUOTE                   0000121C R  D  04        
I_COMPILE_ASCII                  00001897 R  D  04        I_SUBTRACT                       000000FF R  D  04        
I_COMPILE_JSB                    000007A6 R  D  04        I_S_UP                           00001815 R  D  04        
I_COUNT_BEGIN                    00000064 R  D  04        I_VARIABLE                       00001534 R  D  04        
I_COUNT_END                      000000B3 R  D  04        I_WORD_FETCH                     00000F36 R  D  04        
I_DEFER_BEGIN                    0000165C R  D  04        I_WORD_STORE                     00000F18 R  D  04        
I_DEFER_END                      000015F1 R  D  04        I_WS_FETCH                       00000F43 R  D  04        
I_DIVIDE                         000001C0 R  D  04        I_W_COMMA                        00000F28 R  D  04        
I_DIV_MOD                        000001CD R  D  04        KERNEL                           00000B3A R  D  04        
I_DO                             00001688 R  D  04        LEAVE                            00000B50 R  D  04        
I_DOT                            00000123 R  D  04        LIB$GET_INPUT                    ********   X   00        
I_DOT_LPAREN                     0000015A R  D  04        LIB$PUT_OUTPUT                   ********   X   00        
I_DOT_QUOTE                      00001585 R  D  04        LIB$SIGNAL                       ********   X   00        
I_DOT_SB                         00000179 R  D  04        LIB$_INPSTRTRU                   ********   X   00        
I_DOT_ST                         0000019D R  D  04        LITERAL                          0000179F R  D  04        
I_DS_TO_LS                       00000910 R  D  04        LOAD                             00000B5E R  D  04        
I_EMPTY_BUFFERS                  00000932 R  D  04        LONGCONST                        00000C1E R  D  04        
I_EODP_PLUS_STORE                00000971 R  D  04        MAX                              00000C6F R  D  04        
I_EOD_STORE                      00000962 R  D  04        MESSAGE                          00000C89 R  D  04        
I_EQUAL                          00000264 R  D  04        MIN                              00000C9C R  D  04        
I_EQUAL_TEXT                     0000027F R  D  04        MOD                              00000CB2 R  D  04        
I_EXIT                           000009C3 R  D  04        MOVE                             00000CC8 R  D  04        
I_FETCH                          00000394 R  D  04        NCHR                           = 00000007                 
I_FLUSH_BUFFERS                  000009ED R  D  04        NEGAGE                           00000CF9 R  D  04        
I_FORGET_ERASE                   00000A78 R  D  04        NOT                              00000D05 R  D  04        
I_GREATER_EQUAL                  000002B3 R  D  04        NUMBER                           00000D20 R  D  04        
I_GRETER                         0000029F R  D  04        OCTAL                            00000DA0 R  D  04        
I_HALT                           00000AE4 R  D  04        OP_ACBL                        = 000000F1    D            
I_I_TO                           00000B2B R  D  04        OP_ADDL2                       = 000000C0    D            
I_LEFT_BRACK                     00001883 R  D  04        OP_BNEQ                        = 00000012    D            
I_LESS                           00000221 R  D  04        OP_BRW                         = 00000031    D            
I_LESS_EQUAL                     0000024D R  D  04        OP_JSB                         = 00000016    D            
I_LESS_SHARP                     00000239 R  D  04        OP_MOVAB                       = 0000009E    D            
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 154
Symbol table                                                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

OP_MOVAL                       = 000000DE    D            SYS$OPEN                         ********  G    04        
OP_MOVAW                       = 0000003E    D            SYS$PUTMSG                       ********  G    04        
OP_MOVB                        = 00000090    D            SYS$QIO                          ********  G    04        
OP_MOVC3                       = 00000028    D            SYS$UNWIND                       ********  G    04        
OP_MOVL                        = 000000D0    D            SYS$UPDATE                       ********  G    04        
OP_RSB                         = 00000005    D            S_COLD_START                     00001961 RG D  04        
OP_TSTL                        = 000000D5    D            S_TRAP                           000018F7 RG D  04        
OR                               00000DAF R  D  04        S_WARM_START                     000019AD RG D  04        
OTS$CVT_L_TI                     ********   X   00        TOCHAR                           000012C1 R  D  04        
OVER                             00000DCF R  D  04        TOKEN                            000012E2 R  D  04        
PAD                              00000DDC R  D  04        TPU$TPU                          ********   X   00        
PUTC                             00000DEE R  D  04        UNLINK                           00001366 R  D  04        
Q_CR                             000002DB R  D  04        UNSMUDGE                         00001382 R  D  04        
Q_DUP                            000002F3 R  D  04        UNTIL                            00001836 R  D  04        
Q_NUMBER                         0000032C R  D  04        UPDATE                           0000139C R  D  04        
Q_N_CR                           00000305 R  D  04        V1_COMPILER                    = 0000182C R  D  04        
Q_SEARCH                         0000035B R  D  04        VARIABLE                         000013B6 R  D  04        
RAB$B_RAC                      = 0000001E    D            VLIST                            000013D7 R  D  04        
RAB$C_BID                      = 00000001    D            VL_COMPILER                    = 0000188B R  D  04        
RAB$C_BLN                      = 00000044    D            VL_KERNEL                      = 00001516 R  D  04        
RAB$C_KEY                      = 00000001    D            VOCABULARY                       0000141A R  D  04        
RAB$C_SEQ                      = 00000000    D            VTIL                             000018A7 RG D  04        
RAB$L_CTX                      = 00000018    D            VTIL_CTRLC                       ********   X   00        
RAB$L_RBF                      = 00000028    D            VTIL_EXIT                        000018B9 R  D  04        
RAB$L_ROP                      = 00000004    D            VTIL_MAXERRORS                   ********   X   00        
RAB$L_STS                      = 00000008    D            V_BLKBUFF                        00004000 R  D  05        
RAB$L_STV                      = 0000000C    D            V_BLKFAB                         00001AE0 R  D  02        
RAB$L_UBF                      = 00000024    D            V_BLKKEY                         00001B74 R  D  02        
RAB$V_RAH                      = 00000009    D            V_BLKRAB                         00001B30 R  D  02        
RAB$W_RSZ                      = 00000022    D            V_BLOCKIO                        00001B78 R  D  02        
RADIX                            00000E25 R  D  04        V_BUF_BLK_NUMS                   00001B80 R  D  02        
READ                             00000E36 R  D  04        V_BUF_INUSE                      00001B7D R  D  02        
READSTR                          00000EAA R  D  04        V_COMPILER                       00001D3F R  D  02        
RECURSE                          000017EF R  D  04        V_CONTEXT                        00001D37 R  D  02        
REPEAT                           0000180A R  D  04        V_CTRLC_DEPTH                    00001D2B R  D  02        
RESTART                          00000F0E R  D  04        V_CURRENT                        00001D3B R  D  02        
RMS$_EOF                         ********   X   00        V_CURRENT_BUFF                   00001B79 R  D  02        
RMS$_FNF                         ********   X   00        V_ERRORS                         00001D2F R  D  02        
R_WARM_START                     000019D2 R  D  04        V_FILELINENUM                    00001D48 R  D  02        
SEARCH                           00000F86 R  D  04        V_FILENOTFOUND                   0000189A R  D  02        
SIGN                             00000FE3 R  D  04        V_FNAME                          00001A3D R  D  02        
SMUDGE                           00000FFA R  D  04        V_FNAMELEN                       00001A3C R  D  02        
SPACE                            0000102F R  D  04        V_GETCHN_BUF                     00001D1F R  D  02        
SPACES                           00001068 R  D  04        V_GETCHN_BUF_ADR                 00001D1B R  D  02        
SREAD                            00001088 R  D  04        V_GETCHN_IN_BUF                  00001D17 R  D  02        
STRCAT                           00001145 R  D  04        V_GETCHN_RET_LEN                 00001D13 R  D  02        
STRCMP                           00001186 R  D  04        V_GREETING                       00001800 R  D  02        
STRCPY                           000011BF R  D  04        V_HLD                            00001D52 R  D  02        
STRING                           000011F1 R  D  04        V_INBUF                          000018F7 R  D  02        
STRMAX                           00001264 R  D  04        V_INFAB                          000019A8 R  D  02        
STRPOS                           00001277 R  D  04        V_INFILE                         00001D47 R  D  02        
SWAP                             000012AA R  D  04        V_INFILEMESS                     00001890 R  D  02        
SYS$CLOSE                        ********  G    04        V_INLEN                          00001999 R  D  02        
SYS$CONNECT                      ********  G    04        V_INPTR                          0000199B R  D  02        
SYS$EXIT                         ********  G    04        V_INPUT_CHAN                     00001D11 R  D  02        
SYS$FIND                         ********  G    04        V_INPUT_NAME                     00001CFE R  D  02        
SYS$GET                          ********  G    04        V_INRAB                          000019F8 R  D  02        
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 155
Symbol table                                                             31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

V_IN_DSC                         0000199F R  D  02        
V_KERNEL                         00001D43 R  D  02        
V_MODE                           00001D4D R  D  02        
V_NAMETOOLONG                    000018D8 R  D  02        
V_NAMETRUNC                      000018E8 R  D  02        
V_ORG_INLEN                      00001997 R  D  02        
V_OUTBUF                         00001B9A R  D  02        
V_OUTLEN                         00001B98 R  D  02        
V_OVERMESS                       0000185A R  D  02        
V_RADIX                          00001D4E R  D  02        
V_READADDR                       00001B92 R  D  02        
V_READDSC                        00001B8E R  D  02        
V_READLEN                        00001B8C R  D  02        
V_RETURNSTACK                    00001D33 R  D  02        
V_STATE                          00001D4C R  D  02        
V_STATIC_DSC                     00001B96 R  D  02        
V_TPU_COM                        00001C3A R  D  02        
V_TPU_COM2                       00001C56 R  D  02        
V_TPU_DSC                        00001CF6 R  D  02        
V_TRAP_DEPTH                     00001D27 R  D  02        
V_UNDERMESS                      00001842 R  D  02        
V_UNKNOWN                        00001871 R  D  02        
V_UNKNOWN2                       00001883 R  D  02        
V_UNKN_BLK_MESS                  000018B1 R  D  02        
V_USRPROMPT                      00001838 R  D  02        
V_VTILPROMPT                     0000182A R  D  02        
V_WORDNOTFOUND                   000018C7 R  D  02        
WHILE                            0000185F R  D  04        
WRITE                            00001450 R  D  04        
XOR                              000014FC R  D  04        
_CHECK_BASE                      00000D65 R  D  04        
_CHECK_LOWERCASE                 00000D54 R  D  04        
_COMPILER_END                    000018A7 R  D  04        
_DONE                            00001B7E R  D  04        
_ERROR_EXIT                      00001B58 R  D  04        
_EXIT                            00001B8B R  D  04        
_F_ERR                           00001B62 R  D  04        
_GETTOKEN                        00001309 R  D  04        
_INITIALIZE                      00001A49 R  D  04        
_INTERPRETER                     00001A57 R  D  04        
_INVALID_NUMBER                  00000D92 R  D  04        
_KERNEL_BEGIN                    00000000 R  D  04        
_KERNEL_END                      00001525 R  D  04        
_NUMBER_TOP                      00000D36 R  D  04        
_OVERFLOW                        00001AEA R  D  04        
_Q_EXECUTE                       00001A99 R  D  04        
_R_ERR                           00001B71 R  D  04        
_SKIPWHITESPACE                  000012E7 R  D  04        
_STARTFOUND                      000012FB R  D  04        
_STRIP_COMMENT                   00001A85 R  D  04        
_STRIP_COMMENT2                  00001A8F R  D  04        
_UNDERFLOW                       00001AD6 R  D  04        
_UNKNOWNTOKEN                    00001AFE R  D  04        
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 156
Psect synopsis                                                           31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)


                                                +----------------+
                                                ! Psect synopsis !
                                                +----------------+

PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          ---------  ----------     
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE  
$ABS$                           00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILDATA                        00001D56  ( 7510.)  02 (  2.)  NOPIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT NOVEC LONG  
$RMSNAM                         00000018  (   24.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILCODE                        00001B97  ( 7063.)  04 (  4.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE  
VTILDICT                        00004C00  (19456.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 157
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)


                                             +------------------------+
                                             ! Symbol Cross Reference !
                                             +------------------------+

SYMBOL                          VALUE        DEFINITION      REFERENCES... 
------                          -----        ----------      ------------- 
$$$ADR                         =00000060     3408   (1)      3377   (1)      3392   (1)      3400   (1)      3408   (1)    
$$.TAB                         =00001B30-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TABEND                      =00001B74-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP                         =00000000     442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP1                        =00000001     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMP2                        =000000CF     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMPX                        =0000000A-R   435    (1)      435    (1)    
$$.TMPX1                       =0000000E     435    (1)      435    (1)    
$$T1                           =00000001     3377   (1)      3377   (1)    
ABORT                           000003A3-R   1072   (1)    
ABS                             000003AE-R   1079   (1)      735    (1)    
ADM_ABSOLUTE                   =0000009F     268    (1)    #-1501   (1)    #-2794   (1)    #-2951   (1)    
ADM_ADEC_R10                   =0000007A     261    (1)    #-3060   (1)    #-3063   (1)    
ADM_ADEC_R11                   =0000007B     265    (1)    #-1134   (1)    #-1449   (1)    #-1932   (1)    #-2353   (1)    
                                                           #-2564   (1)    #-2583   (1)    #-2756   (1)    #-2897   (1)    
                                                           #-2934   (1)    #-2948   (1)    #-3183   (1)    
ADM_AINC_R10                   =0000008A     262    (1)    
ADM_AINC_R11                   =0000008B     266    (1)    #-2914   (1)    #-3056   (1)    #-3059   (1)    #-3150   (1)    
                                                           #-3252   (1)    #-3271   (1)    
ADM_AINC_R9                    =00000089     258    (1)    #-1097   (1)    
ADM_B_DIS_R10                  =000000AA     263    (1)    #-2912   (1)    #-3076   (1)    #-3194   (1)    
ADM_B_REL                      =000000AF     269    (1)    #-1095   (1)    #-1132   (1)    #-1447   (1)    #-1930   (1)    
                                                           #-2351   (1)    #-2562   (1)    #-2581   (1)    #-2754   (1)    
                                                           #-2792   (1)    #-2895   (1)    #-2932   (1)    #-3036   (1)    
ADM_DEF_R10                    =0000006A     260    (1)    #-2915   (1)    #-3080   (1)    #-3197   (1)    
ADM_DEF_R11                    =0000006B     264    (1)    
ADM_DEF_R9                     =00000069     257    (1)    #-3038   (1)    
ADM_IMMEDIATE                  =0000008F     267    (1)    #-2946   (1)    #-2981   (1)    #-3032   (1)    #-3078   (1)    
                                                           #-3181   (1)    
ADM_R0                         =00000050     255    (1)    #-3057   (1)    #-3062   (1)    
ADM_R10                        =0000005A     259    (1)    #-2922   (1)    #-3087   (1)    #-3204   (1)    
ADM_R9                         =00000059     256    (1)    #-2983   (1)    
AGAIN                           00001615-R   2991   (1)    
AND                             000003EB-R   1110   (1)    
ARRAY                           0000040C-R   1129   (1)    
ASCII                           00000432-R   1144   (1)    
BCOUNT                          00000475-R   1183   (1)      1480   (1)      1579   (1)      1587   (1)      1781   (1)    
                                                             1784   (1)      1808   (1)      1811   (1)      2771   (1)    
                                                             3469   (1)      3562   (1)      3569   (1)    
BINARY                          0000048A-R   1193   (1)    
BLANK                           000004A9-R   1209   (1)    
BLOCK                           000004BE-R   1220   (1)    
BREAK                           0000062B-R   1343   (1)    
BUFFER                          00000645-R   1359   (1)    
BYTE                            00000721-R   1444   (1)    
CFA                             00000748-R   1461   (1)      3214   (1)      3528   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 158
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

CHF$L_MCHARGLST                =00000008                   #-3397   (1)    
CHF$L_MCH_DEPTH                =00000008                   #-3398   (1)    
CHF$L_SIGARGLST                =00000004                   #-3389   (1)    
CHF$L_SIG_NAME                 =00000004                   #-3391   (1)    
CLIST                           00000763-R   1473   (1)    
COMPILER_BEGIN                  00001525-R   2884   (1)    
COMPILETIME                     000007C1-R   1512   (1)      1103   (1)    
CONTEXT                         000007EA-R   1534   (1)    
COUNT                           000007FC-R   1545   (1)      1998   (1)    
CR                              0000080E-R   1555   (1)      1584   (1)      2175   (1)      2408   (1)      2442   (1)    
                                                             3547   (1)      3554   (1)      3576   (1)      3580   (1)    
                                                             956    (1)      982    (1)    
CREATE                          00000842-R   1570   (1)      1093   (1)      1130   (1)      1445   (1)      1928   (1)    
                                                             1942   (1)      2349   (1)      2560   (1)      2579   (1)    
                                                             2752   (1)      2790   (1)      842    (1)    
CURRENT                         000008C1-R   1603   (1)    
C_BLANK                        =00000020     216    (1)    #-1145   (1)    #-1202   (1)    #-1211   (1)    #-1484   (1)    
                                                           #-1574   (1)    #-1702   (1)    #-1769   (1)    #-1795   (1)    
                                                           #-1891   (1)    #-2413   (1)    #-2676   (1)    #-2775   (1)    
                                                           #-3011   (1)    #-3165   (1)    #-3234   (1)    #-3296   (1)    
                                                           #-3494   (1)    #-742    (1)    
C_BLOCK_SIZE                   =00000400     225    (1)    #-1264   (1)    #-1329   (1)    #-1401   (1)    #-1416   (1)    
                                                           #-1434   (1)      227    (1)      3631   (1)      435    (1)    
                                                             442    (1)    
C_COM1_BEGIN                   =0000005C     217    (1)    #-3499   (1)    
C_COM1_END                     =00000000     218    (1)    #-3516   (1)    
C_COM2_BEGIN                   =00000028     220    (1)    #-3501   (1)    
C_COM2_END                     =00000029     221    (1)    #-3522   (1)    
C_DICT_BEGIN                    00000000-R   3622   (1)    #-3424   (1)    
C_DICT_END                      00004000-R   3624   (1)    #-1820   (1)    
C_DS_END                        00000000-R   345    (1)    #-3534   (1)    
C_DS_SIZE                      =00001000     231    (1)      346    (1)    
C_DS_START                      00001000-R   347    (1)      2398   (1)      3483   (1)    #-3536   (1)    #-766    (1)    
                                                           #-786    (1)    
C_D_BLKS_IN_BLK                =00000002     227    (1)    
C_FALSE                        =00000000     213    (1)    #-1121   (1)    #-1281   (1)    #-1658   (1)    #-1660   (1)    
                                                           #-1751   (1)    #-1976   (1)    #-2061   (1)    #-2120   (1)    
                                                           #-2140   (1)    #-2478   (1)    #-2635   (1)    #-2857   (1)    
                                                           #-2962   (1)    #-3288   (1)    #-3459   (1)    #-3460   (1)    
                                                           #-3466   (1)    #-3532   (1)    #-3540   (1)      446    (1)    
                                                             538    (1)      542    (1)      545    (1)    #-856    (1)    
                                                           #-877    (1)    #-890    (1)    #-909    (1)    #-919    (1)    
                                                           #-922    (1)    #-932    (1)    
C_INUSE                        =00000001     222    (1)    #-1254   (1)    #-1396   (1)    #-2309   (1)    
C_KEYSIZE                      =00000004     226    (1)      442    (1)    
C_LS_END                        00001000-R   351    (1)    
C_LS_SIZE                      =00000800     233    (1)      352    (1)    
C_LS_START                      00001800-R   353    (1)      3484   (1)    
C_MAX_BLOCKS                   =00000003     224    (1)    #-1227   (1)    #-1236   (1)    #-1243   (1)    #-1366   (1)    
                                                           #-1375   (1)    #-1382   (1)    #-1662   (1)    #-1754   (1)    
                                                           #-2312   (1)      3631   (1)      451    (1)      453    (1)    
C_MAX_ERRS                     =00000014     214    (1)    #-3395   (1)    
C_MAX_LEN                      =000000A0     228    (1)    #-2173   (1)    #-2406   (1)    #-2805   (1)    #-2817   (1)    
                                                             393    (1)      401    (1)      419    (1)      423    (1)    
                                                             469    (1)      482    (1)      492    (1)    
C_MAX_NAME_LEN                 =00000050     215    (1)    #-1576   (1)    #-1585   (1)    
C_MODIFIED                     =00000002     223    (1)    #-1240   (1)    #-1379   (1)    #-1744   (1)    #-2302   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 159
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                                           #-2739   (1)    
C_PAD_MOAT                     =00000109     230    (1)    #-2165   (1)    #-591    (1)    #-867    (1)    
C_SCREEN_LEN                   =00000050     229    (1)    #-978    (1)    
C_TPU_COM_LEN                  =0000001C     490    (1)    #-1707   (1)    
C_TRUE                         =FFFFFFFF     211    (1)    #-1003   (1)    #-1049   (1)    #-1115   (1)    #-1301   (1)    
                                                           #-1918   (1)    #-1971   (1)    #-2064   (1)    #-2117   (1)    
                                                           #-2146   (1)    #-2334   (1)    #-2631   (1)    #-2860   (1)    
                                                           #-2868   (1)    #-846    (1)    #-859    (1)    #-880    (1)    
                                                           #-893    (1)    #-905    (1)    #-935    (1)    
DC$_TERM                        00000000-XR                  65     (1)    
DECIMAL                         000008D5-R   1613   (1)    
DEFINITIONS                     000008ED-R   1623   (1)    
DOWNLOOP                        000016BD-R   3074   (1)    
DROP                            00000902-R   1631   (1)    
DSC$K_CLASS_S                   00000000-XR                  403    (1)      471    (1)      478    (1)      496    (1)    
                                                             66     (1)    
DSC$K_DTYPE_T                   00000000-XR                  402    (1)      470    (1)      477    (1)      495    (1)    
                                                             66     (1)    
DUP                             0000091C-R   1647   (1)    
ELSE                            000016F9-R   3095   (1)    
ENABLE_CTRLC                    000018C3-R   3372   (1)      3377   (1)    
ENDIF                           00001721-R   3114   (1)    
ENDWHILE                        0000173A-R   3125   (1)    
EODP                            00000954-R   1677   (1)    
EVE                             0000097D-R   1701   (1)    
FAB$B_DNS                      =00000035                     435    (1)    
FAB$B_FNS                      =00000034                   #-1899   (1)      435    (1)    
FAB$C_BID                      =00000003                     412    (1)      435    (1)    
FAB$C_BLN                      =00000050                     412    (1)      435    (1)    
FAB$C_FIX                      =00000001                     435    (1)    
FAB$C_SEQ                      =00000000                     412    (1)      435    (1)    
FAB$C_VAR                      =00000002                     412    (1)    
FAB$L_ALQ                      =00000010                     412    (1)      435    (1)    
FAB$L_DNA                      =00000030                     435    (1)    
FAB$L_FNA                      =0000002C                   #-1897   (1)      435    (1)    
FAB$L_FOP                      =00000004                     412    (1)      435    (1)    
FAB$L_STS                      =00000008                   #-3597   (1)    
FAB$L_STV                      =0000000C                   #-3596   (1)    
FAB$V_CHAN_MODE                =00000002                     412    (1)      435    (1)    
FAB$V_FILE_MODE                =00000004                     412    (1)      435    (1)    
FAB$V_GET                      =00000001                     435    (1)    
FAB$V_LNM_MODE                 =00000000                     412    (1)      435    (1)    
FAB$V_UPD                      =00000003                     435    (1)    
FAB$W_GBC                      =00000048                     412    (1)      435    (1)    
FILL                            000009CF-R   1730   (1)    
FORGET                          00000A20-R   1768   (1)    
FREEMEM                         00000ACE-R   1819   (1)    
HEX                             00000AF2-R   1837   (1)    
HLD                             00000B02-R   1845   (1)    
HOLD                            00000B13-R   1853   (1)      2367   (1)      580    (1)    
IF                              0000175D-R   3148   (1)    
IO$M_CTRLCAST                   00000000-XR                #-3377   (1)      67     (1)    
IO$_SETMODE                     00000000-XR                #-3377   (1)      67     (1)    
I_AC_COLON                      000003BE-R   1092   (1)    
I_ADD                           000000C1-R   675    (1)    
I_BIT_AND                       00000072-R   621    (1)    
I_BIT_NOT                       00000083-R   631    (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 160
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

I_BIT_OR                        00000090-R   639    (1)    
I_BIT_XOR                       0000009E-R   647    (1)    
I_BL                            0000049B-R   1201   (1)    
I_BLOCK_CLOSE                   0000053F-R   1274   (1)    
I_BLOCK_OPEN                    00000571-R   1289   (1)    
I_BLOCK_READ                    000005B7-R   1309   (1)      1422   (1)    
I_BLOCK_WRITE                   000005E9-R   1324   (1)      1437   (1)    
I_BS_FETCH                      00000635-R   1351   (1)    
I_BUFFER_READ                   000006BC-R   1413   (1)      1257   (1)    
I_BUFFER_WRITE                  000006F8-R   1430   (1)      1248   (1)      1387   (1)      1749   (1)      2307   (1)    
I_B_COMMA                       00000457-R   1164   (1)    
I_B_FETCH                       00000465-R   1173   (1)    
I_B_STORE                       00000447-R   1154   (1)    
I_B_UP                          0000163A-R   3010   (1)    
I_COLON                         000001FB-R   840    (1)    
I_COMMA                         000000F5-R   705    (1)    
I_COMPILE_ASCII                 00001897-R   3295   (1)    
I_COMPILE_JSB                   000007A6-R   1499   (1)      3215   (1)      3541   (1)    
I_COUNT_BEGIN                   00000064-R   613    (1)    
I_COUNT_END                     000000B3-R   664    (1)    
I_DEFER_BEGIN                   0000165C-R   3030   (1)    
I_DEFER_END                     000015F1-R   2975   (1)    
I_DIVIDE                        000001C0-R   801    (1)    
I_DIV_MOD                       000001CD-R   810    (1)      578    (1)    
I_DO                            00001688-R   3054   (1)    
I_DOT                           00000123-R   733    (1)      1821   (1)      3574   (1)      772    (1)      789    (1)    
                                                             946    (1)    
I_DOT_LPAREN                    0000015A-R   752    (1)    
I_DOT_QUOTE                     00001585-R   2930   (1)    
I_DOT_SB                        00000179-R   765    (1)    
I_DOT_ST                        0000019D-R   783    (1)    
I_DS_TO_LS                      00000910-R   1639   (1)    
I_EMPTY_BUFFERS                 00000932-R   1655   (1)    
I_EODP_PLUS_STORE               00000971-R   1693   (1)    
I_EOD_STORE                     00000962-R   1685   (1)    
I_EQUAL                         00000264-R   887    (1)    
I_EQUAL_TEXT                    0000027F-R   901    (1)    
I_EXIT                          000009C3-R   1723   (1)    
I_FETCH                         00000394-R   1064   (1)    
I_FLUSH_BUFFERS                 000009ED-R   1741   (1)    
I_FORGET_ERASE                  00000A78-R   1794   (1)    
I_GREATER_EQUAL                 000002B3-R   929    (1)    
I_GRETER                        0000029F-R   916    (1)    
I_HALT                          00000AE4-R   1828   (1)    
I_I_TO                          00000B2B-R   1865   (1)    
I_LEFT_BRACK                    00001883-R   3287   (1)    
I_LESS                          00000221-R   853    (1)    
I_LESS_EQUAL                    0000024D-R   874    (1)    
I_LESS_SHARP                    00000239-R   866    (1)      736    (1)    
I_LONG                          00000BF6-R   1927   (1)    
I_LOOP                          000017B8-R   3192   (1)    
I_LS_TO_DS                      00000C36-R   1952   (1)    
I_L_UP                          0000177F-R   3164   (1)    
I_MATCH                         00000C44-R   1961   (1)    
I_MINUS_ROT                     0000010C-R   722    (1)    
I_MOVE_FILL                     00000CE0-R   2039   (1)    
I_MULTIPLY                      000000A8-R   655    (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 161
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

I_ONE_MINUS                     000001F2-R   830    (1)    
I_ONE_PLUS                      000001E8-R   822    (1)    
I_PLUS_LOOP                     00001551-R   2910   (1)    
I_PLUS_ROT                      000000DE-R   694    (1)    
I_PLUS_STORE                    000000CC-R   683    (1)    
I_QUESTION                      000002CA-R   944    (1)    
I_RIGHT_BACK                    0000151C-R   2867   (1)    
I_SAVE_BUFFERS                  00000F59-R   2299   (1)    
I_SEMICOLON                     000015D7-R   2960   (1)    
I_SHARP                         00000015-R   576    (1)      602    (1)    
I_SHARP_GREATER                 00000036-R   588    (1)      740    (1)    
I_SHARP_S                       00000055-R   601    (1)    #-604    (1)      737    (1)    
I_SHORT                         00000FBE-R   2348   (1)    
I_SP_0                          0000101D-R   2397   (1)    
I_SP_FETCH                      00001011-R   2387   (1)    
I_STORE                         00000006-R   565    (1)    
I_STRING_QUOTE                  0000121C-R   2578   (1)    
I_SUBTRACT                      000000FF-R   713    (1)    
I_S_UP                          00001815-R   3233   (1)    
I_VARIABLE                      00001534-R   2893   (1)    
I_WORD_FETCH                    00000F36-R   2283   (1)    
I_WORD_STORE                    00000F18-R   2265   (1)    
I_WS_FETCH                      00000F43-R   2291   (1)    
I_W_COMMA                       00000F28-R   2274   (1)    
KERNEL                          00000B3A-R   1873   (1)    
LEAVE                           00000B50-R   1881   (1)    
LIB$GET_INPUT                   00000000-XR                  2214   (1)      2247   (1)      2451   (1)      69     (1)    
LIB$PUT_OUTPUT                  00000000-XR                  1560   (1)      1909   (1)      2812   (1)      2835   (1)    
                                                             3431   (1)      3445   (1)      3549   (1)      3556   (1)    
                                                             69     (1)    
LIB$SIGNAL                      00000000-XR                  1715   (1)      3365   (1)      3379   (1)      3592   (1)    
                                                             3598   (1)      3604   (1)      69     (1)    
LIB$_INPSTRTRU                  00000000-XR                #-2215   (1)    #-2248   (1)      68     (1)    
LITERAL                         0000179F-R   3179   (1)      1000   (1)      1943   (1)      3299   (1)    
LOAD                            00000B5E-R   1890   (1)    
LONGCONST                       00000C1E-R   1941   (1)    
MAX                             00000C6F-R   1983   (1)    
MESSAGE                         00000C89-R   1997   (1)    
MIN                             00000C9C-R   2006   (1)    
MOD                             00000CB2-R   2019   (1)    
MOVE                            00000CC8-R   2029   (1)    
NCHR                           =00000007     3295   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1173   (1)      1183   (1)    
                                                             1193   (1)      1201   (1)      1209   (1)      1220   (1)    
                                                             1274   (1)      1289   (1)      1309   (1)      1324   (1)    
                                                             1343   (1)      1351   (1)      1359   (1)      1413   (1)    
                                                             1430   (1)      1444   (1)      1461   (1)      1473   (1)    
                                                             1499   (1)      1512   (1)      1534   (1)      1545   (1)    
                                                             1555   (1)      1570   (1)      1603   (1)      1613   (1)    
                                                             1623   (1)      1631   (1)      1639   (1)      1647   (1)    
                                                             1655   (1)      1677   (1)      1685   (1)      1693   (1)    
                                                             1701   (1)      1723   (1)      1730   (1)      1741   (1)    
                                                             1768   (1)      1794   (1)      1819   (1)      1828   (1)    
                                                             1837   (1)      1845   (1)      1853   (1)      1865   (1)    
                                                             1873   (1)      1881   (1)      1890   (1)      1927   (1)    
                                                             1941   (1)      1952   (1)      1961   (1)      1983   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 162
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                                             1997   (1)      2006   (1)      2019   (1)      2029   (1)    
                                                             2039   (1)      2050   (1)      2058   (1)      2073   (1)    
                                                             2127   (1)      2135   (1)      2154   (1)      2164   (1)    
                                                             2172   (1)      2189   (1)      2197   (1)      2229   (1)    
                                                             2257   (1)      2265   (1)      2274   (1)      2283   (1)    
                                                             2291   (1)      2299   (1)      2322   (1)      2348   (1)    
                                                             2363   (1)      2376   (1)      2387   (1)      2397   (1)    
                                                             2405   (1)      2421   (1)      2439   (1)      2488   (1)    
                                                             2514   (1)      2538   (1)      2559   (1)      2578   (1)    
                                                             2607   (1)      2620   (1)      2642   (1)      2654   (1)    
                                                             2675   (1)      2715   (1)      2727   (1)      2737   (1)    
                                                             2751   (1)      2764   (1)      2788   (1)      2804   (1)    
                                                             2847   (1)      2867   (1)      2893   (1)      2910   (1)    
                                                             2930   (1)      2960   (1)      2975   (1)      2991   (1)    
                                                             3010   (1)      3030   (1)      3054   (1)      3074   (1)    
                                                             3095   (1)      3114   (1)      3125   (1)      3148   (1)    
                                                             3164   (1)      3179   (1)      3192   (1)      3212   (1)    
                                                             3223   (1)      3233   (1)      3250   (1)      3268   (1)    
                                                             3287   (1)      3295   (1)      565    (1)      576    (1)    
                                                             588    (1)      601    (1)      613    (1)      621    (1)    
                                                             631    (1)      639    (1)      647    (1)      655    (1)    
                                                             664    (1)      675    (1)      683    (1)      694    (1)    
                                                             705    (1)      713    (1)      722    (1)      733    (1)    
                                                             752    (1)      765    (1)      783    (1)      801    (1)    
                                                             810    (1)      822    (1)      830    (1)      840    (1)    
                                                             853    (1)      866    (1)      874    (1)      887    (1)    
                                                             901    (1)      916    (1)      929    (1)      944    (1)    
                                                             953    (1)      965    (1)      976    (1)      993    (1)    
NEGAGE                          00000CF9-R   2050   (1)    
NOT                             00000D05-R   2058   (1)    
NUMBER                          00000D20-R   2073   (1)      3013   (1)      3167   (1)      3236   (1)      994    (1)    
OCTAL                           00000DA0-R   2127   (1)    
OP_ACBL                        =000000F1     238    (1)    #-2911   (1)    #-3075   (1)    #-3193   (1)    
OP_ADDL2                       =000000C0     239    (1)    #-2920   (1)    #-2980   (1)    #-3085   (1)    #-3202   (1)    
OP_BNEQ                        =00000012     240    (1)    #-3151   (1)    #-3253   (1)    #-3272   (1)    
OP_BRW                         =00000031     241    (1)    #-2935   (1)    #-2996   (1)    #-3039   (1)    #-3096   (1)    
                                                           #-3126   (1)    #-3153   (1)    #-3255   (1)    #-3274   (1)    
OP_JSB                         =00000016     242    (1)    #-1500   (1)    #-2950   (1)    
OP_MOVAB                       =0000009E     243    (1)    #-1131   (1)    #-1446   (1)    #-2894   (1)    #-2931   (1)    
OP_MOVAL                       =000000DE     244    (1)    #-1929   (1)    #-2791   (1)    
OP_MOVAW                       =0000003E     245    (1)    #-2350   (1)    #-2561   (1)    #-2580   (1)    
OP_MOVB                        =00000090     246    (1)    #-1094   (1)    #-2753   (1)    
OP_MOVC3                       =00000028     247    (1)    #-3031   (1)    
OP_MOVL                        =000000D0     248    (1)    #-2945   (1)    #-3055   (1)    #-3058   (1)    #-3061   (1)    
                                                           #-3180   (1)    
OP_RSB                         =00000005     249    (1)    #-1098   (1)    #-1135   (1)    #-1450   (1)    #-1595   (1)    
                                                           #-1933   (1)    #-1944   (1)    #-2354   (1)    #-2565   (1)    
                                                           #-2584   (1)    #-2757   (1)      2796   (1)    #-2898   (1)    
                                                           #-2961   (1)    
OP_TSTL                        =000000D5     250    (1)    #-3149   (1)    #-3251   (1)    #-3270   (1)    
OR                              00000DAF-R   2135   (1)    
OTS$CVT_L_TI                    00000000-XR                  70     (1)    
OVER                            00000DCF-R   2154   (1)    
PAD                             00000DDC-R   2164   (1)    
PUTC                            00000DEE-R   2172   (1)      1485   (1)      2776   (1)      743    (1)    
Q_CR                            000002DB-R   953    (1)      3475   (1)    
Q_DUP                           000002F3-R   965    (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 163
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

Q_NUMBER                        0000032C-R   993    (1)      3509   (1)    
Q_N_CR                          00000305-R   976    (1)      1482   (1)      2773   (1)    
Q_SEARCH                        0000035B-R   1014   (1)      3504   (1)    
RAB$B_RAC                      =0000001E                     419    (1)      442    (1)    
RAB$C_BID                      =00000001                     419    (1)      442    (1)    
RAB$C_BLN                      =00000044                     419    (1)      442    (1)    
RAB$C_KEY                      =00000001                     442    (1)    
RAB$C_SEQ                      =00000000                     419    (1)    
RAB$L_CTX                      =00000018                     419    (1)      442    (1)    
RAB$L_RBF                      =00000028                   #-1326   (1)    
RAB$L_ROP                      =00000004                     419    (1)      442    (1)    
RAB$L_STS                      =00000008                   #-3603   (1)    
RAB$L_STV                      =0000000C                   #-3602   (1)    
RAB$L_UBF                      =00000024                   #-1311   (1)    
RAB$V_RAH                      =00000009                     419    (1)    
RAB$W_RSZ                      =00000022                   #-1330   (1)    #-2470   (1)    #-2472   (1)    
RADIX                           00000E25-R   2189   (1)    
READ                            00000E36-R   2197   (1)    
READSTR                         00000EAA-R   2229   (1)    
RECURSE                         000017EF-R   3212   (1)    
REPEAT                          0000180A-R   3223   (1)    
RESTART                         00000F0E-R   2257   (1)    
RMS$_EOF                        00000000-XR                #-2453   (1)    #-2464   (1)      71     (1)    
RMS$_FNF                        00000000-XR                #-1906   (1)      71     (1)    
R_WARM_START                    000019D2-R   3451   (1)    #-1073   (1)    #-1716   (1)    #-1786   (1)    #-1813   (1)    
                                                           #-2258   (1)    #-3550   (1)    #-3557   (1)    #-3581   (1)    
SEARCH                          00000F86-R   2322   (1)      1040   (1)      1046   (1)      1772   (1)      1798   (1)    
                                                           #-2338   (1)    
SIGN                            00000FE3-R   2363   (1)      739    (1)    
SMUDGE                          00000FFA-R   2376   (1)      845    (1)    
SPACE                           0000102F-R   2405   (1)      2426   (1)    
SPACES                          00001068-R   2421   (1)    
SREAD                           00001088-R   2439   (1)      2682   (1)    
STRCAT                          00001145-R   2488   (1)    
STRCMP                          00001186-R   2514   (1)    
STRCPY                          000011BF-R   2538   (1)    
STRING                          000011F1-R   2559   (1)    
STRMAX                          00001264-R   2607   (1)    
STRPOS                          00001277-R   2620   (1)    
SWAP                            000012AA-R   2642   (1)    
SYS$CLOSE                       00000000-XR                  1277   (1)      2477   (1)      3465   (1)      3607   (1)    
SYS$CONNECT                     00000000-XR                  1297   (1)      1902   (1)    
SYS$EXIT                        00000000-XR                  3409   (1)      3612   (1)    
SYS$FIND                        00000000-XR                  1331   (1)    
SYS$GET                         00000000-XR                  1314   (1)      2462   (1)    
SYS$OPEN                        00000000-XR                  1293   (1)      1900   (1)    
SYS$PUTMSG                      00000000-XR                  3392   (1)      3408   (1)    
SYS$QIO                         00000000-XR                  3377   (1)    
SYS$UNWIND                      00000000-XR                  3400   (1)    
SYS$UPDATE                      00000000-XR                  1332   (1)    
S_COLD_START                    00001961-R   3422   (1)      3351   (1)    
S_TRAP                          000018F7-R   3387   (1)    
S_WARM_START                    000019AD-R   3441   (1)      3355   (1)    
TOCHAR                          000012C1-R   2654   (1)      579    (1)    
TOKEN                           000012E2-R   2675   (1)      1146   (1)      1575   (1)      1703   (1)      1770   (1)    
                                                             1796   (1)      1892   (1)      2591   (1)      2939   (1)    
                                                             3012   (1)      3166   (1)      3235   (1)      3297   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 164
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                                             3495   (1)      3517   (1)      3523   (1)      754    (1)    
TPU$TPU                         00000000-XR                  1710   (1)      72     (1)    
UNLINK                          00001366-R   2715   (1)      3457   (1)    
UNSMUDGE                        00001382-R   2727   (1)      2964   (1)    
UNTIL                           00001836-R   3250   (1)    
UPDATE                          0000139C-R   2737   (1)    
V1_COMPILER                    =0000182C-R   3250   (1)      3250   (1)    
VARIABLE                        000013B6-R   2751   (1)    
VLIST                           000013D7-R   2764   (1)    
VL_COMPILER                    =0000188B-R   3295   (1)      2893   (1)      2910   (1)      2930   (1)      2960   (1)    
                                                             2975   (1)      2991   (1)      3010   (1)      3030   (1)    
                                                             3054   (1)      3074   (1)      3095   (1)      3114   (1)    
                                                             3125   (1)      3148   (1)      3164   (1)      3179   (1)    
                                                             3192   (1)      3212   (1)      3223   (1)      3233   (1)    
                                                             3268   (1)      3287   (1)      3295   (1)    #-3427   (1)    
VL_KERNEL                      =00001516-R   2867   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1173   (1)      1183   (1)    
                                                             1193   (1)      1201   (1)      1209   (1)      1220   (1)    
                                                             1274   (1)      1289   (1)      1309   (1)      1324   (1)    
                                                             1343   (1)      1351   (1)      1359   (1)      1413   (1)    
                                                             1430   (1)      1444   (1)      1461   (1)      1473   (1)    
                                                             1499   (1)      1512   (1)      1534   (1)      1545   (1)    
                                                             1555   (1)      1570   (1)      1603   (1)      1613   (1)    
                                                             1623   (1)      1631   (1)      1639   (1)      1647   (1)    
                                                             1655   (1)      1677   (1)      1685   (1)      1693   (1)    
                                                             1701   (1)      1723   (1)      1730   (1)      1741   (1)    
                                                             1768   (1)      1794   (1)      1819   (1)      1828   (1)    
                                                             1837   (1)      1845   (1)      1853   (1)      1865   (1)    
                                                             1873   (1)      1881   (1)      1890   (1)      1927   (1)    
                                                             1941   (1)      1952   (1)      1961   (1)      1983   (1)    
                                                             1997   (1)      2006   (1)      2019   (1)      2029   (1)    
                                                             2039   (1)      2050   (1)      2058   (1)      2073   (1)    
                                                             2127   (1)      2135   (1)      2154   (1)      2164   (1)    
                                                             2172   (1)      2189   (1)      2197   (1)      2229   (1)    
                                                             2257   (1)      2265   (1)      2274   (1)      2283   (1)    
                                                             2291   (1)      2299   (1)      2322   (1)      2348   (1)    
                                                             2363   (1)      2376   (1)      2387   (1)      2397   (1)    
                                                             2405   (1)      2421   (1)      2439   (1)      2488   (1)    
                                                             2514   (1)      2538   (1)      2559   (1)      2578   (1)    
                                                             2607   (1)      2620   (1)      2642   (1)      2654   (1)    
                                                             2675   (1)      2715   (1)      2727   (1)      2737   (1)    
                                                             2751   (1)      2764   (1)      2788   (1)      2804   (1)    
                                                             2847   (1)      2867   (1)    #-3428   (1)      565    (1)    
                                                             576    (1)      588    (1)      601    (1)      613    (1)    
                                                             621    (1)      631    (1)      639    (1)      647    (1)    
                                                             655    (1)      664    (1)      675    (1)      683    (1)    
                                                             694    (1)      705    (1)      713    (1)      722    (1)    
                                                             733    (1)      752    (1)      765    (1)      783    (1)    
                                                             801    (1)      810    (1)      822    (1)      830    (1)    
                                                             840    (1)      853    (1)      866    (1)      874    (1)    
                                                             887    (1)      901    (1)      916    (1)      929    (1)    
                                                             944    (1)      953    (1)      965    (1)      976    (1)    
                                                             993    (1)    
VOCABULARY                      0000141A-R   2788   (1)    
VTIL                            000018A7-R   3315   (1)    
VTIL_CTRLC                      00000000-XR                #-3378   (1)      73     (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 165
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

VTIL_EXIT                       000018B9-R   3363   (1)    
VTIL_MAXERRORS                  00000000-XR                #-3404   (1)      73     (1)    
V_BLKBUFF                       00004000-R   3630   (1)    #-1265   (1)    #-1402   (1)    #-1417   (1)    #-1435   (1)    
                                                             442    (1)    
V_BLKFAB                        00001AE0-R   430    (1)      1277   (1)      1293   (1)      442    (1)    
V_BLKKEY                        00001B74-R   443    (1)    #-1313   (1)    #-1328   (1)    
V_BLKRAB                        00001B30-R   436    (1)      1297   (1)    #-1311   (1)      1314   (1)    #-1326   (1)    
                                                           #-1330   (1)      1331   (1)      1332   (1)    
V_BLOCKIO                       00001B78-R   445    (1)    #-1275   (1)    #-1281   (1)    #-1290   (1)    #-1301   (1)    
V_BUF_BLK_NUMS                  00001B80-R   452    (1)    #-1225   (1)    #-1253   (1)    #-1364   (1)    #-1395   (1)    
                                                           #-1419   (1)    #-1432   (1)    #-1661   (1)    
V_BUF_INUSE                     00001B7D-R   450    (1)    #-1234   (1)    #-1241   (1)    #-1255   (1)    #-1373   (1)    
                                                           #-1380   (1)    #-1397   (1)    #-1659   (1)    #-1745   (1)    
                                                           #-1752   (1)    #-2303   (1)    #-2310   (1)    #-2740   (1)    
V_COMPILER                      00001D3F-R   533    (1)    #-1045   (1)    #-1474   (1)    #-1515   (1)    #-1516   (1)    
                                                           #-3427   (1)    
V_CONTEXT                       00001D37-R   529    (1)    #-1032   (1)      1535   (1)    #-1624   (1)    #-1771   (1)    
                                                           #-1776   (1)    #-1797   (1)    #-1802   (1)    #-1874   (1)    
                                                           #-2765   (1)    #-2789   (1)      2795   (1)    #-3213   (1)    
                                                           #-3432   (1)    #-3446   (1)    #-841    (1)    
V_CTRLC_DEPTH                   00001D2B-R   523    (1)    
V_CURRENT                       00001D3B-R   531    (1)    #-1513   (1)    #-1514   (1)    #-1571   (1)    #-1572   (1)    
                                                             1604   (1)    #-1624   (1)    #-2377   (1)    #-2716   (1)    
                                                           #-2717   (1)    #-2728   (1)    #-3433   (1)    #-3447   (1)    
                                                           #-841    (1)    
V_CURRENT_BUFF                  00001B79-R   447    (1)    #-1266   (1)    #-1403   (1)    #-1415   (1)    #-2738   (1)    
V_ERRORS                        00001D2F-R   525    (1)    #-3394   (1)    #-3395   (1)    
V_FILELINENUM                   00001D48-R   539    (1)    #-1919   (1)    #-2474   (1)    #-2479   (1)    #-3467   (1)    
                                                           #-3573   (1)    
V_FILENOTFOUND                  0000189A-R   377    (1)      1908   (1)    
V_FNAME                         00001A3D-R   422    (1)      1894   (1)      1896   (1)      3471   (1)    
V_FNAMELEN                      00001A3C-R   420    (1)    #-1895   (1)    #-1898   (1)    #-3472   (1)    
V_GETCHN_BUF                    00001D1F-R   515    (1)      514    (1)    
V_GETCHN_BUF_ADR                00001D1B-R   513    (1)    
V_GETCHN_IN_BUF                 00001D17-R   510    (1)    
V_GETCHN_RET_LEN                00001D13-R   508    (1)    
V_GREETING                      00001800-R   361    (1)      3430   (1)      3444   (1)    
V_HLD                           00001D52-R   548    (1)      1846   (1)    #-1854   (1)    #-1855   (1)    #-589    (1)    
                                                           #-592    (1)    #-867    (1)    
V_INBUF                         000018F7-R   392    (1)      2444   (1)      3577   (1)      399    (1)      404    (1)    
                                                             419    (1)    
V_INFAB                         000019A8-R   411    (1)    #-1897   (1)    #-1899   (1)      1900   (1)      1912   (1)    
                                                             2477   (1)      3465   (1)      419    (1)    
V_INFILE                        00001D47-R   537    (1)    #-1918   (1)    #-2445   (1)    #-2478   (1)    #-3463   (1)    
                                                           #-3466   (1)    #-3571   (1)      3607   (1)    
V_INFILEMESS                    00001890-R   375    (1)      3468   (1)    
V_INLEN                         00001999-R   396    (1)      2448   (1)    #-2459   (1)    #-2471   (1)    #-2679   (1)    
                                                           #-2686   (1)    #-2690   (1)    #-2691   (1)    #-2693   (1)    
                                                           #-2700   (1)    #-2703   (1)    #-3461   (1)    
V_INPTR                         0000199B-R   398    (1)    #-2444   (1)      2679   (1)    #-2685   (1)      2690   (1)    
                                                             2698   (1)    #-2699   (1)    #-2705   (1)    
V_INPUT_CHAN                    00001D11-R   503    (1)    #-3377   (1)    
V_INPUT_NAME                    00001CFE-R   501    (1)    
V_INRAB                         000019F8-R   415    (1)      1902   (1)      1915   (1)      2462   (1)      2467   (1)    
                                                           #-2470   (1)    #-2472   (1)    
V_IN_DSC                        0000199F-R   400    (1)      2450   (1)    
V_KERNEL                        00001D43-R   535    (1)      1874   (1)    #-3428   (1)      3432   (1)      3433   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 166
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                                             3446   (1)      3447   (1)    
V_MODE                          00001D4D-R   544    (1)    #-1043   (1)    #-2868   (1)    #-2962   (1)    #-3288   (1)    
                                                           #-3455   (1)    #-3459   (1)    #-3530   (1)    #-846    (1)    
                                                           #-998    (1)    
V_NAMETOOLONG                   000018D8-R   383    (1)      1578   (1)    
V_NAMETRUNC                     000018E8-R   385    (1)      1586   (1)    
V_ORG_INLEN                     00001997-R   394    (1)    #-2459   (1)    #-2473   (1)    #-3462   (1)    #-3578   (1)    
V_OUTBUF                        00001B9A-R   481    (1)      1556   (1)      2177   (1)      2207   (1)      2238   (1)    
                                                             2410   (1)      2808   (1)      2818   (1)      2831   (1)    
V_OUTLEN                        00001B98-R   479    (1)    #-1557   (1)    #-1562   (1)    #-2173   (1)    #-2178   (1)    
                                                           #-2182   (1)    #-2202   (1)    #-2208   (1)    #-2217   (1)    
                                                           #-2233   (1)    #-2239   (1)    #-2241   (1)    #-2406   (1)    
                                                           #-2411   (1)    #-2414   (1)    #-2440   (1)    #-2805   (1)    
                                                           #-2809   (1)    #-2814   (1)    #-2816   (1)    #-2823   (1)    
                                                           #-2830   (1)    #-2832   (1)    #-2836   (1)    #-954    (1)    
                                                           #-977    (1)    
V_OVERMESS                      0000185A-R   369    (1)      3555   (1)    
V_RADIX                         00001D4E-R   546    (1)    #-1194   (1)    #-1614   (1)    #-1838   (1)    #-2104   (1)    
                                                           #-2106   (1)    #-2128   (1)      2190   (1)    #-577    (1)    
V_READADDR                      00001B92-R   472    (1)    #-2198   (1)    #-2199   (1)    
V_READDSC                       00001B8E-R   468    (1)      2213   (1)    
V_READLEN                       00001B8C-R   466    (1)      2200   (1)    #-2219   (1)    
V_RETURNSTACK                   00001D33-R   527    (1)    #-3423   (1)    #-3476   (1)    
V_STATE                         00001D4C-R   541    (1)    #-1049   (1)    #-3460   (1)    #-3530   (1)    #-3532   (1)    
                                                           #-3540   (1)    
V_STATIC_DSC                    00001B96-R   476    (1)    #-1558   (1)    #-2209   (1)    #-2232   (1)    #-2240   (1)    
                                                           #-2810   (1)    #-2833   (1)    
V_TPU_COM                       00001C3A-R   488    (1)      490    (1)      497    (1)    
V_TPU_COM2                      00001C56-R   491    (1)      1706   (1)    
V_TPU_DSC                       00001CF6-R   493    (1)    #-1708   (1)      1709   (1)    
V_TRAP_DEPTH                    00001D27-R   521    (1)    #-3399   (1)      3400   (1)    
V_UNDERMESS                     00001842-R   367    (1)      3548   (1)    
V_UNKNOWN                       00001871-R   371    (1)      3561   (1)    
V_UNKNOWN2                      00001883-R   373    (1)      3568   (1)    
V_UNKN_BLK_MESS                 000018B1-R   379    (1)    
V_USRPROMPT                     00001838-R   365    (1)    
V_VTILPROMPT                    0000182A-R   363    (1)      2449   (1)    
V_WORDNOTFOUND                  000018C7-R   381    (1)      1780   (1)      1807   (1)    
WHILE                           0000185F-R   3268   (1)    
WRITE                           00001450-R   2804   (1)      1483   (1)      1580   (1)      1583   (1)      1588   (1)    
                                                             1591   (1)      1782   (1)      1785   (1)      1809   (1)    
                                                             1812   (1)      1999   (1)      2774   (1)      2952   (1)    
                                                             3470   (1)      3473   (1)      3563   (1)      3567   (1)    
                                                             3570   (1)      3579   (1)      741    (1)      757    (1)    
XOR                             000014FC-R   2847   (1)    
_CHECK_BASE                     00000D65-R   2103   (1)    #-2089   (1)    #-2095   (1)    
_CHECK_LOWERCASE                00000D54-R   2097   (1)    #-2093   (1)    
_COMPILER_END                   000018A7-R   3303   (1)    
_DONE                           00001B7E-R   3607   (1)    
_ERROR_EXIT                     00001B58-R   3590   (1)    #-1279   (1)    #-1295   (1)    #-1299   (1)    #-1316   (1)    
                                                           #-1334   (1)    #-1830   (1)    #-2215   (1)    #-2248   (1)    
                                                           #-2457   (1)    
_EXIT                           00001B8B-R   3610   (1)    #-1724   (1)    #-2455   (1)    #-3599   (1)    
_F_ERR                          00001B62-R   3596   (1)    #-1913   (1)    
_GETTOKEN                       00001309-R   2687   (1)    #-2677   (1)    
_INITIALIZE                     00001A49-R   3481   (1)    #-3434   (1)    
_INTERPRETER                    00001A57-R   3493   (1)    #-3511   (1)    #-3518   (1)    #-3524   (1)    #-3538   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 167
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                                           #-3543   (1)    
_INVALID_NUMBER                 00000D92-R   2119   (1)    #-2087   (1)    #-2091   (1)    #-2099   (1)    #-2101   (1)    
                                                           #-2105   (1)    
_KERNEL_BEGIN                   00000000-R   559    (1)    
_KERNEL_END                     00001525-R   2872   (1)    
_NUMBER_TOP                     00000D36-R   2083   (1)    #-2079   (1)    #-2111   (1)    
_OVERFLOW                       00001AEA-R   3553   (1)    #-3535   (1)    
_Q_EXECUTE                      00001A99-R   3527   (1)    #-3507   (1)    
_R_ERR                          00001B71-R   3602   (1)    #-1916   (1)    #-2468   (1)    
_SKIPWHITESPACE                 000012E7-R   2678   (1)    #-2683   (1)    
_STARTFOUND                     000012FB-R   2684   (1)    #-2680   (1)    
_STRIP_COMMENT                  00001A85-R   3515   (1)    #-3500   (1)    
_STRIP_COMMENT2                 00001A8F-R   3521   (1)    #-3502   (1)    
_UNDERFLOW                      00001AD6-R   3546   (1)    #-3537   (1)    
_UNKNOWNTOKEN                   00001AFE-R   3560   (1)    #-3512   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 168
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)


                                             +------------------------+
                                             ! Macros Cross Reference !
                                             +------------------------+

MACRO             SIZE          DEFINITION       REFERENCES... 
-----             ----          ----------       ------------- 
$$R_TABINIT       1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$$R_VBFSET        1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$CHFDEF           2             74     (1)       74     (1)    
$CLOSE            1             1277   (1)       1277   (1)       2477   (1)       3465   (1)       3607   (1)    
$CONNECT          1             1297   (1)       1297   (1)       1902   (1)    
$DEFINI           1             74     (1)       412    (1)       419    (1)       74     (1)    
$EXIT_S           1             3409   (1)       3409   (1)       3612   (1)    
$FAB              4             412    (1)       412    (1)       431    (1)    
$FABDEF           1             412    (1)       412    (1)       435    (1)    
$FIND             1             1331   (1)       1331   (1)    
$GET              1             1314   (1)       1314   (1)       2462   (1)    
$OPEN             1             1293   (1)       1293   (1)       1900   (1)    
$PUSHADR          1             3377   (1)       3377   (1)       3392   (1)       3400   (1)       3408   (1)    
$PUSHTWO          1             3377   (1)       3377   (1)    
$PUTMSG_S         1             3392   (1)       3392   (1)       3408   (1)    
$QIOPUSH          1             3377   (1)       3377   (1)    
$QIO_S            1             3374   (1)       3374   (1)    
$RAB              2             416    (1)       416    (1)       437    (1)    
$RABDEF           1             419    (1)       419    (1)       442    (1)    
$RMSCALL          2             1277   (1)       1277   (1)       1293   (1)       1297   (1)       1314   (1)       1331   (1)    
                                                 1332   (1)       1900   (1)       1902   (1)       2462   (1)       2477   (1)    
                                                 3465   (1)       3607   (1)    
$UNWIND_S         1             3400   (1)       3400   (1)    
$UPDATE           1             1332   (1)       1332   (1)    
HEADER            1             298    (1)       1014   (1)       1064   (1)       1072   (1)       1079   (1)       1092   (1)    
                                                 1110   (1)       1129   (1)       1144   (1)       1154   (1)       1164   (1)    
                                                 1173   (1)       1183   (1)       1193   (1)       1201   (1)       1209   (1)    
                                                 1220   (1)       1274   (1)       1289   (1)       1309   (1)       1324   (1)    
                                                 1343   (1)       1351   (1)       1359   (1)       1413   (1)       1430   (1)    
                                                 1444   (1)       1461   (1)       1473   (1)       1499   (1)       1512   (1)    
                                                 1534   (1)       1545   (1)       1555   (1)       1570   (1)       1603   (1)    
                                                 1613   (1)       1623   (1)       1631   (1)       1639   (1)       1647   (1)    
                                                 1655   (1)       1677   (1)       1685   (1)       1693   (1)       1701   (1)    
                                                 1723   (1)       1730   (1)       1741   (1)       1768   (1)       1794   (1)    
                                                 1819   (1)       1828   (1)       1837   (1)       1845   (1)       1853   (1)    
                                                 1865   (1)       1873   (1)       1881   (1)       1890   (1)       1927   (1)    
                                                 1941   (1)       1952   (1)       1961   (1)       1983   (1)       1997   (1)    
                                                 2006   (1)       2019   (1)       2029   (1)       2039   (1)       2050   (1)    
                                                 2058   (1)       2073   (1)       2127   (1)       2135   (1)       2154   (1)    
                                                 2164   (1)       2172   (1)       2189   (1)       2197   (1)       2229   (1)    
                                                 2257   (1)       2265   (1)       2274   (1)       2283   (1)       2291   (1)    
                                                 2299   (1)       2322   (1)       2348   (1)       2363   (1)       2376   (1)    
                                                 2387   (1)       2397   (1)       2405   (1)       2421   (1)       2439   (1)    
                                                 2488   (1)       2514   (1)       2538   (1)       2559   (1)       2578   (1)    
                                                 2607   (1)       2620   (1)       2642   (1)       2654   (1)       2675   (1)    
                                                 2715   (1)       2727   (1)       2737   (1)       2751   (1)       2764   (1)    
                                                 2788   (1)       2804   (1)       2847   (1)       2867   (1)       2893   (1)    
                                                 2910   (1)       2930   (1)       2960   (1)       2975   (1)       2991   (1)    
                                                 3010   (1)       3030   (1)       3054   (1)       3074   (1)       3095   (1)    
                                                 3114   (1)       3125   (1)       3148   (1)       3164   (1)       3179   (1)    
VTIL                            VAX Threaded Interpretive Language       31-AUG-2023 12:40:28  VAX MACRO V5.4-3            Page 169
Cross reference                                                          31-AUG-2023 12:40:23  [MPL.TKB.VTIL]VTIL.MAR;139        (1)

                                                 3192   (1)       3212   (1)       3223   (1)       3233   (1)       3250   (1)    
                                                 3268   (1)       3287   (1)       3295   (1)       565    (1)       576    (1)    
                                                 588    (1)       601    (1)       613    (1)       621    (1)       631    (1)    
                                                 639    (1)       647    (1)       655    (1)       664    (1)       675    (1)    
                                                 683    (1)       694    (1)       705    (1)       713    (1)       722    (1)    
                                                 733    (1)       752    (1)       765    (1)       783    (1)       801    (1)    
                                                 810    (1)       822    (1)       830    (1)       840    (1)       853    (1)    
                                                 866    (1)       874    (1)       887    (1)       901    (1)       916    (1)    
                                                 929    (1)       944    (1)       953    (1)       965    (1)       976    (1)    
                                                 993    (1)    
ISERROR           1             315    (1)    
ISSTRERR          1             326    (1)       2215   (1)       2248   (1)    
NEWPAGE           1             39     (1)       137    (1)       202    (1)       284    (1)       2873   (1)       3304   (1)    
                                                 334    (1)       3412   (1)       3487   (1)       3584   (1)       3615   (1)    
                                                 551    (1)       58     (1)       77     (1)    

                                             +------------------------+
                                             ! Performance indicators !
                                             +------------------------+

Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------------   
Initialization                   34     00:00:00.00    00:00:00.02
Command processing              885     00:00:00.02    00:00:00.02
Pass 1                          772     00:00:00.58    00:00:00.62
Symbol table sort                 0     00:00:00.02    00:00:00.02
Pass 2                           53     00:00:00.32    00:00:00.32
Symbol table output               0     00:00:00.00    00:00:00.00
Psect synopsis output             0     00:00:00.00    00:00:00.00
Cross-reference output            8     00:00:00.08    00:00:00.08
Assembler run totals           1756     00:00:01.02    00:00:01.08

The working set limit was 3350 pages.
225684 bytes (441 pages) of virtual memory were used to buffer the intermediate code.
There were 50 pages of symbol table space allocated to hold 715 non-local and 106 local symbols.
3639 source lines were read in Pass 1, producing 96 object records in Pass 2.
46 pages of virtual memory were used to define 31 macros.

                                            +--------------------------+
                                            ! Macro library statistics !
                                            +--------------------------+

Macro library name                           Macros defined      
------------------                           --------------      
SYS$COMMON:[SYSLIB]STARLET.MLB;2                       24        

720 GETS were required to define 24 macros.

There were no errors, warnings or information messages.

MACRO/DEBUG/LIST/CROSS/OBJECT=VTIL.OBJ/SHOW=EXPANSION VTIL.MAR
