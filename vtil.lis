VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   0
Table of contents

    (1)       58        External Symbols
    (1)       77        General Notes
    (1)      137        Implementation Notes
    (1)      202        Constants
    (1)      284        Macros
    (1)      334        Data Section
    (1)      551        Kernel Built-ins
    (1)     2873        cCompiler Built-ins
    (1)     3304        Enter VTIL
    (1)     3412        Initialization
    (1)     3487        Interpreter
    (1)     3584        Exit Routines
    (1)     3615        Dictionary Space
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   1
V1.01                                                                    10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000     1 ;
                                     0000     2 .title	VTIL VAX Threaded Interpretive Language
                                     0000     3 	.ident	/v1.01/			; version number
                                     0000     4 ;******************************************************************************
                                     0000     5 ;
                                     0000     6 ; VTIL -- VAX Threaded Interpretive Language
                                     0000     7 ;
                                     0000     8 ;	Program:	V T I L . MAR
                                     0000     9 ;	Written By:	Thomas Kurt Bond
                                     0000    10 ;	Version:	v1.01
                                     0000    11 ;	Date:		7 February 1988
                                     0000    12 ;
                                     0000    13 ; Description:
                                     0000    14 ;     This program was written for my Senior Seminar Project at West Virginia
                                     0000    15 ; Wesleyan College in the spring of 1988.
                                     0000    16 ;
                                     0000    17 ;     This program implements a Threaded Interpretive Language (TIL) in
                                     0000    18 ; VAX Macro, using subroutine threading.  Essentially, it is an interactive
                                     0000    19 ; compiler.
                                     0000    20 ;
                                     0000    21 ; History
                                     0000    22 ; Ver	  When	   Who	What
                                     0000    23 ; 1.00	  020788   tkb	Initial version.
                                     0000    24 ; 1.01	  021288   tkb	Uses a smudge bit to prevent word being defined from
                                     0000    25 ;			being found while defining it.	({ recurse } allows
                                     0000    26 ;			recursion.)  Also limits length of names to 80 characters
                                     0000    27 ;			allowing the name-length byte to have the smudge bit
                                     0000    28 ;			in it.
                                     0000    29 ;******************************************************************************
                                     0000    30 ;!> VTIL.MAR -- VAX Threaded Interpretive Langague, an interactive compiler.
                                     0000    31 
                                     0000    32 ;
                                     0000    33 ; Set up source code formatting macros.
                                     0000    34 ;
                                     0000    35 
                                     0000    36 ;+++
                                     0000    37 ;m> newpage -- change the subtitle and move to a new page.
                                     0000    38 ;---
                                     0000    39 	.macro	newpage subtitle
                                     0000    40 	.page
                                     0000    41 	.sbttl	subtitle
                                     0000    42 	.endm
                                     0000    43 
                                     0000    44 ;******************************************************************************
                                     0000    45 ;
                                     0000    46 ; Conditional Assembly Control Symbols
                                     0000    47 ;
                                     0000    48 ;******************************************************************************
                           00000000  0000    49 ca_trapping = 0		; If this is defined, code for a condition handler
                                     0000    50 			; is assembled.	 We don't always want the condition
                                     0000    51 			; handler because it also catched breakpoints in the
                                     0000    52 			; debugger.
                           00000000  0000    53 ca_controlc = 0		; If this is defined, code to trap control/c and
                                     0000    54 			; return to the VTIL interpreter is assembled.
                                     0000    55 			; Note that this uses the trapping so it is useless
                                     0000    56 			; if `ca_trapping' is not defined.
                                     0000    57 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   2
V1.01                                                                    10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000    58 	newpage <External Symbols>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   3
V1.01                           External Symbols                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.sbttl	External Symbols
                                     0000       	
                                     0000    59 ;******************************************************************************
                                     0000    60 ;
                                     0000    61 ; External Symbols
                                     0000    62 ;
                                     0000    63 ;******************************************************************************
                                     0000    64 	.dsabl	global
                                     0000    65 	.extrn	dc$_term
                                     0000    66 	.extrn	dsc$k_dtype_t, dsc$k_class_s
                                     0000    67 	.extrn	io$_setmode, io$m_ctrlcast
                                     0000    68 	.extrn	lib$_inpstrtru
                                     0000    69 	.extrn	lib$get_input, lib$put_output, lib$signal
                                     0000    70 	.extrn	ots$cvt_l_ti
                                     0000    71 	.extrn	rms$_eof, rms$_fnf
                                     0000    72 	.extrn	tpu$tpu
                                     0000    73 	.extrn	vtil_ctrlc, vtil_maxerrors
                                     0000    74 	$chfdef				; condition handling facility
                                     0000       	$DEFINI	CHF,
                                     0000       	.SAVE	LOCAL_BLOCK
                                     0000       	.NOCROSS
                                     0000       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     0000       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   4
V1.01                           External Symbols                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF	12
                           0000000C  0000       	CHF$S_CHFDEF=12
                                     0000       	
                                     0000       $EQU	CHF$L_SIGARGLST	4
                           00000004  0000       	CHF$L_SIGARGLST=4
                                     0000       	
                                     0000       $EQU	CHF$L_MCHARGLST	8
                           00000008  0000       	CHF$L_MCHARGLST=8
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF1	12
                           0000000C  0000       	CHF$S_CHFDEF1=12
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_ARGS	0
                           00000000  0000       	CHF$IS_SIG_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_ARGS	0
                           00000000  0000       	CHF$L_SIG_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_NAME	4
                           00000004  0000       	CHF$IS_SIG_NAME=4
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_NAME	4
                           00000004  0000       	CHF$L_SIG_NAME=4
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_ARG1	8
                           00000008  0000       	CHF$IS_SIG_ARG1=8
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_ARG1	8
                           00000008  0000       	CHF$L_SIG_ARG1=8
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF2	20
                           00000014  0000       	CHF$S_CHFDEF2=20
                                     0000       	
                                     0000       $EQU	CHF$IS_MCH_ARGS	0
                           00000000  0000       	CHF$IS_MCH_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_ARGS	0
                           00000000  0000       	CHF$L_MCH_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$PH_MCH_FRAME	4
                           00000004  0000       	CHF$PH_MCH_FRAME=4
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_FRAME	4
                           00000004  0000       	CHF$L_MCH_FRAME=4
                                     0000       	
                                     0000       $EQU	CHF$IS_MCH_DEPTH	8
                           00000008  0000       	CHF$IS_MCH_DEPTH=8
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_DEPTH	8
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   5
V1.01                           External Symbols                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000008  0000       	CHF$L_MCH_DEPTH=8
                                     0000       	
                                     0000       $EQU	CHF$IH_MCH_SAVR0	12
                           0000000C  0000       	CHF$IH_MCH_SAVR0=12
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_SAVR0	12
                           0000000C  0000       	CHF$L_MCH_SAVR0=12
                                     0000       	
                                     0000       $EQU	CHF$IH_MCH_SAVR1	16
                           00000010  0000       	CHF$IH_MCH_SAVR1=16
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_SAVR1	16
                           00000010  0000       	CHF$L_MCH_SAVR1=16
                                     0000       	
                                     0000       	$DEFEND	CHF,,DEF
                                     0000       	.MACRO	$CHFDEF A
                                     0000       	.ENDM	$CHFDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                     0000       	.RESTORE
                                     0000       	
                                     0000       	
                                     0000    75 
                                     0000    76 
                                     0000    77 newpage <General Notes>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   6
V1.01                           General Notes                            10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.sbttl	General Notes
                                     0000       	
                                     0000    78 ;******************************************************************************
                                     0000    79 ;
                                     0000    80 ; General Notes
                                     0000    81 ;
                                     0000    82 ;******************************************************************************
                                     0000    83 ;
                                     0000    84 ; Word -- A VTIL word is the equivalent of the procedure and/or function of
                                     0000    85 ; Pascal or other langauges.  (Context will have to determine whethere we
                                     0000    86 ; are talking about VTIL words or memory 2-byte words.)	   A word finds any
                                     0000    87 ; parameters it needs on the data stack, and leaves any result on the stack
                                     0000    88 ; also.	 VTIL words (or sequences of words) will be singled out from normal text
                                     0000    89 ; by enclosing them in { } pairs, since many of them include punctuation marks
                                     0000    90 ; that might be otherwise confusing.  Also, the string `...' inside a { }
                                     0000    91 ; pair will indicate a sequence of VTIL words omitted as irrelevent to the
                                     0000    92 ; explaination.
                                     0000    93 ;
                                     0000    94 ; Stack Comments.  A stack comment shows what a word expects to find on the
                                     0000    95 ; stack and what results it leaves on the stack after execution.
                                     0000    96 ; A stack comment looks like the following: ( n1 n2 -- n1 ).  The rightmost
                                     0000    97 ; item on each side of the `--' is the top of the stack, so the items in the
                                     0000    98 ; stack comment are in the same order as they would be if you entered them from
                                     0000    99 ; the terminal.	 The `--' separates the items that word expects to find on
                                     0000   100 ; the stack from the items that it leaves on the stack.	 Ex: After you enter
                                     0000   101 ; { 1 2 3 }, 3 is on the top of the stack.  In ( n1 n2 n3 -- x1 x2 ) n3 is
                                     0000   102 ; on top of the stack before the word executes, and x2 is on top of
                                     0000   103 ; the stack after that word executes.
                                     0000   104 ;
                                     0000   105 ; Items in stack comments:
                                     0000   106 ;	?	-- `?' is not an item on the stack itself.  Instead, it
                                     0000   107 ;		   indicates that items to the left of the `?' (further
                                     0000   108 ;		   down on the stack) may or may not be present, depending
                                     0000   109 ;		   on the value of items to the right of the `?' (which
                                     0000   110 ;		   are on top of the stack).  For instance, a stack comment
                                     0000   111 ;		   of ( a -- a ? f ) indicates that the word leaves a
                                     0000   112 ;		   flag on the top of the stack, and depending on the value
                                     0000   113 ;		   of the flag will also leave an address on the stack.
                                     0000   114 ;	a	-- address
                                     0000   115 ;	b	-- unsigned byte (integer, 1 byte)
                                     0000   116 ;	c	-- unsigned characcter (1 byte)
                                     0000   117 ;	f	-- boolean flag; 0 = false, true <> 0 (usually 1)
                                     0000   118 ;	l	-- long (integer, 4 bytes)
                                     0000   119 ;	n	-- integer (usually meaning number.  A longword)
                                     0000   120 ;	s	-- short (integer, 2 bytes)
                                     0000   121 ;
                                     0000   122 ;	Note that *all* stack items are at least a longword in width.
                                     0000   123 ;	a ( b ) stack item merely says that the programmer should consider
                                     0000   124 ;	the stack as containing a value that will fit in an unsigned
                                     0000   125 ;	byte.  Words that use data types that are smaller than a longword
                                     0000   126 ;	will only use th first part of the longword in their calculations,
                                     0000   127 ;	but will still pop the whole longword containing the smaller data
                                     0000   128 ;	type from the stack, not just the smaller data type.  In other words,
                                     0000   129 ;	the stack pointer can only be manipulated in 4 byte increments or
                                     0000   130 ;	decrements.
                                     0000   131 ;
                                     0000   132 ; Starting Vocabularies -- At the moment, there are only two starting
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   7
V1.01                           General Notes                            10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000   133 ; vocabularies `compiler' and `kernel', which are independent of each other.
                                     0000   134 ; All later vocabularies should be linked into one of thse.  But See v1_*.
                                     0000   135 ;
                                     0000   136 ;******************************************************************************
                                     0000   137 	newpage <Implementation Notes>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   8
V1.01                           Implementation Notes                     10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.sbttl	Implementation Notes
                                     0000       	
                                     0000   138 ;******************************************************************************
                                     0000   139 ;
                                     0000   140 ; Implementation Notes
                                     0000   141 ;
                                     0000   142 ;******************************************************************************
                                     0000   143 ;
                                     0000   144 ; r11, ds	-- data stack pointer
                                     0000   145 ; r10, ls	-- loop stack pointer
                                     0000   146 ; r9, eodp	-- end of dictionary pointer
                                     0000   147 ; r8-r4 are used for temporary storage when using character instructions.
                                     0000   148 ;
                                     0000   149 ; header format for a word
                                     0000   150 ;	long	-- back link to next word in dictionary (hfa, lfa)
                                     0000   151 ;	byte	-- count of name byes (nfa)
                                     0000   152 ;	byte(s) -- bytes of name
                                     0000   153 ;	code	-- executable code for this word (cfa)
                                     0000   154 ;	data	-- optional data for this word (pfa)
                                     0000   155 ;
                                     0000   156 ; Names
                                     0000   157 ; Since none of the VTIL kernel and compiler words contain underscores,
                                     0000   158 ; the following conventions were followed so there would be no conflict
                                     0000   159 ; between names in the MACRO-32 source and in the VTIL.	 For instance,
                                     0000   160 ; { context } is the name of a word in the kernel that pushes the address
                                     0000   161 ; of the current vocabulary variable on the stack.  However, the definition
                                     0000   162 ; of context in the MACRO source makes `context' a label wich jsb'ing to
                                     0000   163 ; executes the word, so `context' can't be used in MACRO as a label for
                                     0000   164 ; the variable as well.
                                     0000   165 ;
                                     0000   166 ;	<name>	   -- label of start of a VTIL word called <name>
                                     0000   167 ;	_<name>	   -- internal branch points
                                     0000   168 ;	adm_<name> -- addressing mode constant value
                                     0000   169 ;	c_<name>   -- constant value
                                     0000   170 ;	ca_<name>  -- conditional assembly control symbols
                                     0000   171 ;	i_<name>   -- label of start of a VTIL word whose <name> doesn't
                                     0000   172 ;		      otherwise fit this naming convention, du to the
                                     0000   173 ;		      character limitations in VAX MACRO symbols.
                                     0000   174 ;		      For eample, i_plus = { + }, i_plus_store = { +! }
                                     0000   175 ;	op_<name>  -- opcode constant value
                                     0000   176 ;	r_<name>   -- internal routine <name> that is readed by branching and
                                     0000   177 ;		      not by jumping to subroutine.
                                     0000   178 ;	s_<name>   --  internal subroutine that is reached by a call.
                                     0000   179 ;	q_<name>   -- label of start of a VTIL word with name `?<name>'.
                                     0000   180 ;	v_<name>   -- internal variable name.
                                     0000   181 ;	vl_<name>  -- internal vocabulary link symbol used by the header macro
                                     0000   182 ;		      to link built-in vocabularies together.
                                     0000   183 ;
                                     0000   184 ;	Names of words other than looping words or branching words that should
                                     0000   185 ;	occur in pairs generally have VTIL names like { name( } and
                                     0000   186 ;	{ )name } or { name< } and { >name } and internal names like
                                     0000   187 ;	i_name_begin and i_name_end.
                                     0000   188 ;
                                     0000   189 ; To make finding words easie, all the words have a header comment
                                     0000   190 ; like this:
                                     0000   191 ;	;+++
                                     0000   192 ;	;s> name -- explanation
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page   9
V1.01                           Implementation Notes                     10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000   193 ;	;---
                                     0000   194 ; where `s' is `c' for the compiler words, `k' for the kernel words,
                                     0000   195 ; `m' for macros, `r' for routines, and `s' for subroutines.
                                     0000   196 ;
                                     0000   197 ; The string `;??? starts an internal note to the programmer.  These notes
                                     0000   198 ; generally comment about an alternate method of doing something or suggest
                                     0000   199 ; areas that should be improved.  ~~~ indicates a note made while typing this back in.
                                     0000   200 ;
                                     0000   201 ;******************************************************************************
                                     0000   202 	newpage <Constants>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  10
V1.01                           Constants                                10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.sbttl	Constants
                                     0000       	
                                     0000   203 ;******************************************************************************
                                     0000   204 ;
                                     0000   205 ; Constants -- Symbol definitions for constant values
                                     0000   206 ;
                                     0000   207 ;******************************************************************************
                                     0000   208 ;
                                     0000   209 ; General constants
                                     0000   210 ;
                           FFFFFFFF  0000   211 c_true		= -1			; true value, actually anything
                                     0000   212 					;  but 0 is true
                           00000000  0000   213 c_false		= 0			; false value
                           00000014  0000   214 c_max_errs	= 20			; Maximum number of fatal errors allowed
                           00000050  0000   215 c_max_name_len	= 80			; Maximum length of word names
                           00000020  0000   216 c_blank		= 32			; ascii blank
                           0000005C  0000   217 c_com1_begin	= ^a/\/			; start first type of comment with `\'
                           00000000  0000   218 c_com1_end	= 0			; end w/something not in a line of text
                                     0000   219 					; so it will skip the whole line
                           00000028  0000   220 c_com2_begin	= ^a/(/			; start second type of comment with `('
                           00000029  0000   221 c_com2_end	= ^a/)/			; end with `)'
                           00000001  0000   222 c_inuse		= 1			; buffer in use flag
                           00000002  0000   223 c_modified	= 2			; bufffer updated flag
                           00000003  0000   224 c_max_blocks	= 3			; number of block i/o buffers
                           00000400  0000   225 c_block_size	= 1024			; size for block i/o buffer
                           00000004  0000   226 c_keysize	= 4			; size of key (longword record number)
                           00000002  0000   227 c_d_blks_in_blk = c_block_size / 512	; number of disk blocks in VTIL block
                           000000A0  0000   228 c_max_len	= 160			; maximum length of input line
                           00000050  0000   229 c_screen_len	= 80			; screen is 80 chars wide
                           00000109  0000   230 c_pad_moat	= 265			; distance of pad from eodp
                           00001000  0000   231 c_ds_size	= 1024 * 4		; data stack size: 1024 items of
                                     0000   232 					; 4 bytes each
                           00000800  0000   233 c_ls_size	= 512 * 4		; loop stack size: 512 items of
                                     0000   234 					; 4 bytes each
                                     0000   235 ;
                                     0000   236 ; opcodes == constants for compiling opcodes into dictionary
                                     0000   237 ;
                           000000F1  0000   238 op_acbl		= ^xf1
                           000000C0  0000   239 op_addl2	= ^xc0
                           00000012  0000   240 op_bneq		= ^x12
                           00000031  0000   241 op_brw		= ^x31
                           00000016  0000   242 op_jsb		= ^x16
                           0000009E  0000   243 op_movab	= ^x9e
                           000000DE  0000   244 op_moval	= ^xde
                           0000003E  0000   245 op_movaw	= ^x3e
                           00000090  0000   246 op_movb		= ^x90
                           00000028  0000   247 op_movc3	= ^x28
                           000000D0  0000   248 op_movl		= ^xd0
                           00000005  0000   249 op_rsb		= ^x05
                           000000D5  0000   250 op_tstl		= ^xd5
                                     0000   251 ;
                                     0000   252 ; addressing modes -- constants for compiling addressing modes into dictionary.
                                     0000   253 ;	In order by register and addressing mode.
                                     0000   254 ;
                           00000050  0000   255 adm_r0		= ^x50			; r0
                           00000059  0000   256 adm_r9		= ^x59			; r9
                           00000069  0000   257 adm_def_r9	= ^x69			; (r9)
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  11
V1.01                           Constants                                10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000089  0000   258 adm_ainc_r9	= ^x89			; (r9)+
                           0000005A  0000   259 adm_r10		= ^x5a			; r10
                           0000006A  0000   260 adm_def_r10	= ^x6a			; (r10)
                           0000007A  0000   261 adm_adec_r10	= ^x7a			; -(r10)
                           0000008A  0000   262 adm_ainc_r10	= ^x8a			; (r10)+
                           000000AA  0000   263 adm_b_dis_r10	= ^xaa			; b^(r10)
                           0000006B  0000   264 adm_def_r11	= ^x6b			; (r11)
                           0000007B  0000   265 adm_adec_r11	= ^x7b			; -(r11)
                           0000008B  0000   266 adm_ainc_r11	= ^x8b			; (r11)+
                           0000008F  0000   267 adm_immediate	= ^x8f			; immediate mode
                           0000009F  0000   268 adm_absolute	= ^x9f			; absolute mode
                           000000AF  0000   269 adm_b_rel	= ^xaf			; byte relative
                                     0000   270 
                                     0000   271 ;
                                     0000   272 ; Assembly-tie vocabulary links -- symbols used during assembly to link
                                     0000   273 ;	the starting vocabularies together.   These start out at 0 so that
                                     0000   274 ;	all vocabularies will end with a null pointer.	During assembly,
                                     0000   275 ;	each link holds the address of the link fields of the most recently
                                     0000   276 ;	defined.  When a word is defined with the `header' macro then
                                     0000   277 ;	link field of the new word is initialized to the valu of the
                                     0000   278 ;	link and the link is changed to the address of the link field of the
                                     0000   279 ;	new word.
                                     0000   280 ;
                           00000000  0000   281 vl_compiler = 0		   ; Links the compiler vocabulary together
                           00000000  0000   282 vl_kernel = 0		   ; Links the kernel vocabulary together
                                     0000   283 ;******************************************************************************
                                     0000   284 	newpage <Macros>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  12
V1.01                           Macros                                   10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.sbttl	Macros
                                     0000       	
                                     0000   285 ;******************************************************************************
                                     0000   286 ;
                                     0000   287 ; Macros -- Macro Definitions
                                     0000   288 ;
                                     0000   289 ;******************************************************************************
                                     0000   290 ;!+++t
                                     0000   291 ;m> header -- macro to start all words in code
                                     0000   292 ;	This macro sets up the header for the VTIL words, and inserts it
                                     0000   293 ;	into the linked vocabulary list.  Because it uses backslash delimited
                                     0000   294 ;	strings, none of the words in the starting vocabularies built in
                                     0000   295 ;	the macro source code should have backslashes in their names.
                                     0000   296 ;
                                     0000   297 ;!---
                                     0000   298 	.macro	header	macname,name=<>,branch=v1_kernel
                                     0000   299 	.long	branch		; back link to the previous word in this branch
                                     0000   300 	branch = -4		; where to link the next word to in this branch
                                     0000   301 	.nchr  nchr, ^\name\	; nchr = length( name )
                                     0000   302 	.if    le, nchr		; nchr <= 0
                                     0000   303 	   .ascic \macname\	; no auxillary name, use principle one
                                     0000   304 	.if_false		; else
                                     0000   305 	  .ascic \name\		; use auxillary name
                                     0000   306 	.endc			; end if
                                     0000   307 macname:			; use name of word as branch label
                                     0000   308 	.endm			; end of macro header
                                     0000   309 
                                     0000   310 
                                     0000   311 ;!+++
                                     0000   312 ;m> iserror -- simplistic error checking routine.  If error code in r0,
                                     0000   313 ;	die messily.
                                     0000   314 ;!---
                                     0000   315 	.macro	iserror badwhere=_error_exit,?goodwhere
                                     0000   316 	blbs	r0,goodwhere	; no error, go on
                                     0000   317 	brw	badwhere	; error, branch to error handler
                                     0000   318 goodwhere:
                                     0000   319 	.endm	iserror
                                     0000   320 
                                     0000   321 
                                     0000   322 ;!+++
                                     0000   323 ;m> isstrerr -- simplistic error checking routine.  If error code in r0,
                                     0000   324 ;	unless lib$_inpstrtru, die messily
                                     0000   325 ;!---
                                     0000   326 	.macro	isstrerr badwhere=_error_exit,?goodwhere
                                     0000   327 	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                                     0000   328 	beql	goodwhere		; yes, ignore and go on
                                     0000   329 	blbs	r0,goodwhere		; no error, go on
                                     0000   330 	brw	badwhere		; error, branch to error handler
                                     0000   331 goodwhere:
                                     0000   332 	.endm	isstrerr
                                     0000   333 
                                     0000   334 	newpage <Data Section>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  13
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.sbttl	Data Section
                                     0000       	
                                     0000   335 ;******************************************************************************
                                     0000   336 ;
                                     0000   337 ; Data Section -- Contains the stacks, i/o buffers, misc buffers,
                                     0000   338 ;	and the system variables.
                                     0000   339 ;
                                     0000   340 ;******************************************************************************
                                 00000000   341 	.psect	vtildata,long,noexe
                                     0000   342 ;
                                     0000   343 ; data stack allocation
                                     0000   344 ;
                                     0000   345 c_ds_end:
                           00001000  0000   346 	.blkb	c_ds_size	; reserve c_ds_size bytes for data stack
                                     1000   347 c_ds_start:
                                     1000   348 ;
                                     1000   349 ; Loop stack allocation
                                     1000   350 ;
                                     1000   351 c_ls_end:
                           00001800  1000   352 	.blkb	c_ls_size	; reserve c_ls_size bytes for loop stack
                                     1800   353 c_ls_start:
                                     1800   354 
                                     1800   355 
                                     1800   356 ;
                                     1800   357 ; message string variables
                                     1800   358 ;	.ascid strings are used by lib$get_input and lib$put_output
                                     1800   359 ;	.ascic strings are used by { write }
                                     1800   360 ;
                                     1800   361 v_greeting:
76 20 4C 49 54 56 00001808'010E0000' 1800   362 	.ascid	/VTIL v1.01 -- Welcome to TIL-land!/	; Greet the user
63 6C 65 57 20 2D 2D 20 31 30 2E 31  180E       
6C 2D 4C 49 54 20 6F 74 20 65 6D 6F  181A       
                        21 64 6E 61  1826       
                                     182A   363 v_vtilprompt:
20 3E 4C 49 54 56 00001832'010E0000' 182A   364 	.ascid	/VTIL> /	; prompt for system input
                                     1838   365 v_usrprompt:
            20 3F 00001840'010E0000' 1838   366 	.ascid	/? /		; prompt for programmer input
                                     1842   367 v_undermess:
20 6B 63 61 74 53 0000184A'010E0000' 1842   368 	.ascid	/Stack Underflow!/
      21 77 6F 6C 66 72 65 64 6E 55  1850       
                                     185A   369 v_overmess:
20 6B 63 61 74 53 00001862'010E0000' 185A   370 	.ascid	/Stack Overflow!/
         21 77 6F 6C 66 72 65 76 4F  1868       
                                     1871   371 v_unknown:
6B 6F 74 20 6E 77 6F 6E 6B 6E 55 00' 1871   372 	.ascic	/Unknown token: { /
                  20 7B 20 3A 6E 65  187D       
                                 11  1871       
                                     1883   373 v_unknown2:
3A 65 6E 69 6C 20 6E 69 20 7D 20 00' 1883   374 	.ascic	/ } in line: /
                                 20  188F       
                                 0C  1883       
                                     1890   375 v_infilemess:
      20 3A 65 6C 69 66 20 6E 49 00' 1890   376 	.ascic	/In file: /
                                 09  1890       
                                     189A   377 v_filenotfound:
6E 20 65 6C 69 46 000018A2'010E0000' 189A   378 	.ascid	/File not found!/
         21 64 6E 75 6F 66 20 74 6F  18A8       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  14
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     18B1   379 v_unkn_blk_mess:
63 6F 6C 42 20 6E 77 6F 6E 6B 55 00' 18B1   380 	.ascic	/Uknown Block Number: /
      20 3A 72 65 62 6D 75 4E 20 6B  18BD       
                                 15  18B1       
                                     18C7   381 v_wordnotfound:
6F 46 20 74 6F 4E 20 64 72 6F 57 00' 18C7   382 	.ascic	/Word Not Found: /
                     20 3A 64 6E 75  18D3       
                                 10  18C7       
                                     18D8   383 v_nametoolong:
6F 6C 20 6F 6F 74 20 65 6D 61 4E 00' 18D8   384 	.ascic	/Name too long: /
                        20 3A 67 6E  18E4       
                                 0F  18D8       
                                     18E8   385 v_nametrunc:
74 20 64 65 74 61 63 6E 75 72 54 00' 18E8   386 	.ascic	/Truncated to: /
                           20 3A 6F  18F4       
                                 0E  18E8       
                                     18F7   387 
                                     18F7   388 
                                     18F7   389 ;
                                     18F7   390 ; variables for system input
                                     18F7   391 ;
                                     18F7   392 v_inbuf:
                           00001997  18F7   393 	.blkb	c_max_len	; buffer for system input
                                     1997   394 v_org_inlen:
                               0000  1997   395 	.word	0		; original length of line
                                     1999   396 v_inlen:			; word to hold length of remaining unprocessed
                               0000  1999   397 	.word	0		; characters
                                     199B   398 v_inptr:
                           000018F7' 199B   399 	.long	v_inbuf		; pointer to current location in string
                                     199F   400 v_in_dsc:
                               00A0  199F   401 	.word	c_max_len	; maximum length for system input
                                 00' 19A1   402 	.byte	dsc$k_dtype_t	; data type text
                                 00' 19A2   403 	.byte	dsc$k_class_s	; descriptor class
                           000018F7' 19A3   404 	.long	v_inbuf		; pointer to input buffer
                                     19A7   405 
                                     19A7   406 
                                     19A7   407 ;
                                     19A7   408 ; rms buffers for loading source from a file instead of keyboard
                                     19A7   409 ;
                                     19A7   410 	.align	long			; so rms macros won't complain
                                     19A8   411 v_infab:
                                     19A8   412 	$fab
                                     19A8       	$FABDEF
                                     19A8       	$DEFINI	FAB,
                                     19A8       	.SAVE	LOCAL_BLOCK
                                     19A8       	.NOCROSS
                                     19A8       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     19A8       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  15
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	FAB$C_BID	3
                           00000003  0000       	FAB$C_BID=3
                                     0000       	
                                     0000       $EQU	FAB$M_PPF_RAT	16320
                           00003FC0  0000       	FAB$M_PPF_RAT=16320
                                     0000       	
                                     0000       $EQU	FAB$M_PPF_IND	16384
                           00004000  0000       	FAB$M_PPF_IND=16384
                                     0000       	
                                     0000       $EQU	FAB$M_PPIFI	32768
                           00008000  0000       	FAB$M_PPIFI=32768
                                     0000       	
                                     0000       $EQU	FAB$M_ASY	1
                           00000001  0000       	FAB$M_ASY=1
                                     0000       	
                                     0000       $EQU	FAB$M_MXV	2
                           00000002  0000       	FAB$M_MXV=2
                                     0000       	
                                     0000       $EQU	FAB$M_SUP	4
                           00000004  0000       	FAB$M_SUP=4
                                     0000       	
                                     0000       $EQU	FAB$M_TMP	8
                           00000008  0000       	FAB$M_TMP=8
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  16
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$M_TMD	16
                           00000010  0000       	FAB$M_TMD=16
                                     0000       	
                                     0000       $EQU	FAB$M_DFW	32
                           00000020  0000       	FAB$M_DFW=32
                                     0000       	
                                     0000       $EQU	FAB$M_SQO	64
                           00000040  0000       	FAB$M_SQO=64
                                     0000       	
                                     0000       $EQU	FAB$M_RWO	128
                           00000080  0000       	FAB$M_RWO=128
                                     0000       	
                                     0000       $EQU	FAB$M_POS	256
                           00000100  0000       	FAB$M_POS=256
                                     0000       	
                                     0000       $EQU	FAB$M_WCK	512
                           00000200  0000       	FAB$M_WCK=512
                                     0000       	
                                     0000       $EQU	FAB$M_NEF	1024
                           00000400  0000       	FAB$M_NEF=1024
                                     0000       	
                                     0000       $EQU	FAB$M_RWC	2048
                           00000800  0000       	FAB$M_RWC=2048
                                     0000       	
                                     0000       $EQU	FAB$M_DMO	4096
                           00001000  0000       	FAB$M_DMO=4096
                                     0000       	
                                     0000       $EQU	FAB$M_SPL	8192
                           00002000  0000       	FAB$M_SPL=8192
                                     0000       	
                                     0000       $EQU	FAB$M_SCF	16384
                           00004000  0000       	FAB$M_SCF=16384
                                     0000       	
                                     0000       $EQU	FAB$M_DLT	32768
                           00008000  0000       	FAB$M_DLT=32768
                                     0000       	
                                     0000       $EQU	FAB$M_NFS	65536
                           00010000  0000       	FAB$M_NFS=65536
                                     0000       	
                                     0000       $EQU	FAB$M_UFO	131072
                           00020000  0000       	FAB$M_UFO=131072
                                     0000       	
                                     0000       $EQU	FAB$M_PPF	262144
                           00040000  0000       	FAB$M_PPF=262144
                                     0000       	
                                     0000       $EQU	FAB$M_INP	524288
                           00080000  0000       	FAB$M_INP=524288
                                     0000       	
                                     0000       $EQU	FAB$M_CTG	1048576
                           00100000  0000       	FAB$M_CTG=1048576
                                     0000       	
                                     0000       $EQU	FAB$M_CBT	2097152
                           00200000  0000       	FAB$M_CBT=2097152
                                     0000       	
                                     0000       $EQU	FAB$M_SYNCSTS	4194304
                           00400000  0000       	FAB$M_SYNCSTS=4194304
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  17
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$M_RCK	8388608
                           00800000  0000       	FAB$M_RCK=8388608
                                     0000       	
                                     0000       $EQU	FAB$M_NAM	16777216
                           01000000  0000       	FAB$M_NAM=16777216
                                     0000       	
                                     0000       $EQU	FAB$M_CIF	33554432
                           02000000  0000       	FAB$M_CIF=33554432
                                     0000       	
                                     0000       $EQU	FAB$M_ESC	134217728
                           08000000  0000       	FAB$M_ESC=134217728
                                     0000       	
                                     0000       $EQU	FAB$M_TEF	268435456
                           10000000  0000       	FAB$M_TEF=268435456
                                     0000       	
                                     0000       $EQU	FAB$M_OFP	536870912
                           20000000  0000       	FAB$M_OFP=536870912
                                     0000       	
                                     0000       $EQU	FAB$M_KFO	1073741824
                           40000000  0000       	FAB$M_KFO=1073741824
                                     0000       	
                                     0000       $EQU	FAB$M_PUT	1
                           00000001  0000       	FAB$M_PUT=1
                                     0000       	
                                     0000       $EQU	FAB$M_GET	2
                           00000002  0000       	FAB$M_GET=2
                                     0000       	
                                     0000       $EQU	FAB$M_DEL	4
                           00000004  0000       	FAB$M_DEL=4
                                     0000       	
                                     0000       $EQU	FAB$M_UPD	8
                           00000008  0000       	FAB$M_UPD=8
                                     0000       	
                                     0000       $EQU	FAB$M_TRN	16
                           00000010  0000       	FAB$M_TRN=16
                                     0000       	
                                     0000       $EQU	FAB$M_BIO	32
                           00000020  0000       	FAB$M_BIO=32
                                     0000       	
                                     0000       $EQU	FAB$M_BRO	64
                           00000040  0000       	FAB$M_BRO=64
                                     0000       	
                                     0000       $EQU	FAB$M_EXE	128
                           00000080  0000       	FAB$M_EXE=128
                                     0000       	
                                     0000       $EQU	FAB$M_SHRPUT	1
                           00000001  0000       	FAB$M_SHRPUT=1
                                     0000       	
                                     0000       $EQU	FAB$M_SHRGET	2
                           00000002  0000       	FAB$M_SHRGET=2
                                     0000       	
                                     0000       $EQU	FAB$M_SHRDEL	4
                           00000004  0000       	FAB$M_SHRDEL=4
                                     0000       	
                                     0000       $EQU	FAB$M_SHRUPD	8
                           00000008  0000       	FAB$M_SHRUPD=8
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  18
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$M_MSE	16
                           00000010  0000       	FAB$M_MSE=16
                                     0000       	
                                     0000       $EQU	FAB$M_NIL	32
                           00000020  0000       	FAB$M_NIL=32
                                     0000       	
                                     0000       $EQU	FAB$M_UPI	64
                           00000040  0000       	FAB$M_UPI=64
                                     0000       	
                                     0000       $EQU	FAB$M_ORG	240
                           000000F0  0000       	FAB$M_ORG=240
                                     0000       	
                                     0000       $EQU	FAB$C_SEQ	0
                           00000000  0000       	FAB$C_SEQ=0
                                     0000       	
                                     0000       $EQU	FAB$C_REL	16
                           00000010  0000       	FAB$C_REL=16
                                     0000       	
                                     0000       $EQU	FAB$C_IDX	32
                           00000020  0000       	FAB$C_IDX=32
                                     0000       	
                                     0000       $EQU	FAB$C_HSH	48
                           00000030  0000       	FAB$C_HSH=48
                                     0000       	
                                     0000       $EQU	FAB$M_FTN	1
                           00000001  0000       	FAB$M_FTN=1
                                     0000       	
                                     0000       $EQU	FAB$M_CR	2
                           00000002  0000       	FAB$M_CR=2
                                     0000       	
                                     0000       $EQU	FAB$M_PRN	4
                           00000004  0000       	FAB$M_PRN=4
                                     0000       	
                                     0000       $EQU	FAB$M_BLK	8
                           00000008  0000       	FAB$M_BLK=8
                                     0000       	
                                     0000       $EQU	FAB$C_RFM_DFLT	2
                           00000002  0000       	FAB$C_RFM_DFLT=2
                                     0000       	
                                     0000       $EQU	FAB$C_UDF	0
                           00000000  0000       	FAB$C_UDF=0
                                     0000       	
                                     0000       $EQU	FAB$C_FIX	1
                           00000001  0000       	FAB$C_FIX=1
                                     0000       	
                                     0000       $EQU	FAB$C_VAR	2
                           00000002  0000       	FAB$C_VAR=2
                                     0000       	
                                     0000       $EQU	FAB$C_VFC	3
                           00000003  0000       	FAB$C_VFC=3
                                     0000       	
                                     0000       $EQU	FAB$C_STM	4
                           00000004  0000       	FAB$C_STM=4
                                     0000       	
                                     0000       $EQU	FAB$C_STMLF	5
                           00000005  0000       	FAB$C_STMLF=5
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  19
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$C_STMCR	6
                           00000006  0000       	FAB$C_STMCR=6
                                     0000       	
                                     0000       $EQU	FAB$C_MAXRFM	6
                           00000006  0000       	FAB$C_MAXRFM=6
                                     0000       	
                                     0000       $EQU	FAB$M_ONLY_RU	1
                           00000001  0000       	FAB$M_ONLY_RU=1
                                     0000       	
                                     0000       $EQU	FAB$M_RU	2
                           00000002  0000       	FAB$M_RU=2
                                     0000       	
                                     0000       $EQU	FAB$M_BI	4
                           00000004  0000       	FAB$M_BI=4
                                     0000       	
                                     0000       $EQU	FAB$M_AI	8
                           00000008  0000       	FAB$M_AI=8
                                     0000       	
                                     0000       $EQU	FAB$M_AT	16
                           00000010  0000       	FAB$M_AT=16
                                     0000       	
                                     0000       $EQU	FAB$M_NEVER_RU	32
                           00000020  0000       	FAB$M_NEVER_RU=32
                                     0000       	
                                     0000       $EQU	FAB$M_JOURNAL_FILE	64
                           00000040  0000       	FAB$M_JOURNAL_FILE=64
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_RU	1
                           00000001  0000       	FAB$M_RCF_RU=1
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_AI	2
                           00000002  0000       	FAB$M_RCF_AI=2
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_BI	4
                           00000004  0000       	FAB$M_RCF_BI=4
                                     0000       	
                                     0000       $EQU	FAB$K_BLN	80
                           00000050  0000       	FAB$K_BLN=80
                                     0000       	
                                     0000       $EQU	FAB$C_BLN	80
                           00000050  0000       	FAB$C_BLN=80
                                     0000       	
                                     0000       $EQU	FAB$S_FABDEF	80
                           00000050  0000       	FAB$S_FABDEF=80
                                     0000       	
                                     0000       $EQU	FAB$B_BID	0
                           00000000  0000       	FAB$B_BID=0
                                     0000       	
                                     0000       $EQU	FAB$B_BLN	1
                           00000001  0000       	FAB$B_BLN=1
                                     0000       	
                                     0000       $EQU	FAB$R_IFI_OVERLAY	2
                           00000002  0000       	FAB$R_IFI_OVERLAY=2
                                     0000       	
                                     0000       $EQU	FAB$W_IFI	2
                           00000002  0000       	FAB$W_IFI=2
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  20
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$R_IFI_BITS	2
                           00000002  0000       	FAB$R_IFI_BITS=2
                                     0000       	
                                     0000       $EQU	FAB$S_PPF_RAT	8
                           00000008  0000       	FAB$S_PPF_RAT=8
                                     0000       	
                                     0000       $EQU	FAB$V_PPF_RAT	6
                           00000006  0000       	FAB$V_PPF_RAT=6
                                     0000       	
                                     0000       $EQU	FAB$V_PPF_IND	14
                           0000000E  0000       	FAB$V_PPF_IND=14
                                     0000       	
                                     0000       $EQU	FAB$V_PPIFI	15
                           0000000F  0000       	FAB$V_PPIFI=15
                                     0000       	
                                     0000       $EQU	FAB$R_FOP_OVERLAY	4
                           00000004  0000       	FAB$R_FOP_OVERLAY=4
                                     0000       	
                                     0000       $EQU	FAB$L_FOP	4
                           00000004  0000       	FAB$L_FOP=4
                                     0000       	
                                     0000       $EQU	FAB$R_FOP_BITS	4
                           00000004  0000       	FAB$R_FOP_BITS=4
                                     0000       	
                                     0000       $EQU	FAB$V_ASY	0
                           00000000  0000       	FAB$V_ASY=0
                                     0000       	
                                     0000       $EQU	FAB$V_MXV	1
                           00000001  0000       	FAB$V_MXV=1
                                     0000       	
                                     0000       $EQU	FAB$V_SUP	2
                           00000002  0000       	FAB$V_SUP=2
                                     0000       	
                                     0000       $EQU	FAB$V_TMP	3
                           00000003  0000       	FAB$V_TMP=3
                                     0000       	
                                     0000       $EQU	FAB$V_TMD	4
                           00000004  0000       	FAB$V_TMD=4
                                     0000       	
                                     0000       $EQU	FAB$V_DFW	5
                           00000005  0000       	FAB$V_DFW=5
                                     0000       	
                                     0000       $EQU	FAB$V_SQO	6
                           00000006  0000       	FAB$V_SQO=6
                                     0000       	
                                     0000       $EQU	FAB$V_RWO	7
                           00000007  0000       	FAB$V_RWO=7
                                     0000       	
                                     0000       $EQU	FAB$V_POS	8
                           00000008  0000       	FAB$V_POS=8
                                     0000       	
                                     0000       $EQU	FAB$V_WCK	9
                           00000009  0000       	FAB$V_WCK=9
                                     0000       	
                                     0000       $EQU	FAB$V_NEF	10
                           0000000A  0000       	FAB$V_NEF=10
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  21
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$V_RWC	11
                           0000000B  0000       	FAB$V_RWC=11
                                     0000       	
                                     0000       $EQU	FAB$V_DMO	12
                           0000000C  0000       	FAB$V_DMO=12
                                     0000       	
                                     0000       $EQU	FAB$V_SPL	13
                           0000000D  0000       	FAB$V_SPL=13
                                     0000       	
                                     0000       $EQU	FAB$V_SCF	14
                           0000000E  0000       	FAB$V_SCF=14
                                     0000       	
                                     0000       $EQU	FAB$V_DLT	15
                           0000000F  0000       	FAB$V_DLT=15
                                     0000       	
                                     0000       $EQU	FAB$V_NFS	16
                           00000010  0000       	FAB$V_NFS=16
                                     0000       	
                                     0000       $EQU	FAB$V_UFO	17
                           00000011  0000       	FAB$V_UFO=17
                                     0000       	
                                     0000       $EQU	FAB$V_PPF	18
                           00000012  0000       	FAB$V_PPF=18
                                     0000       	
                                     0000       $EQU	FAB$V_INP	19
                           00000013  0000       	FAB$V_INP=19
                                     0000       	
                                     0000       $EQU	FAB$V_CTG	20
                           00000014  0000       	FAB$V_CTG=20
                                     0000       	
                                     0000       $EQU	FAB$V_CBT	21
                           00000015  0000       	FAB$V_CBT=21
                                     0000       	
                                     0000       $EQU	FAB$V_SYNCSTS	22
                           00000016  0000       	FAB$V_SYNCSTS=22
                                     0000       	
                                     0000       $EQU	FAB$V_RCK	23
                           00000017  0000       	FAB$V_RCK=23
                                     0000       	
                                     0000       $EQU	FAB$V_NAM	24
                           00000018  0000       	FAB$V_NAM=24
                                     0000       	
                                     0000       $EQU	FAB$V_CIF	25
                           00000019  0000       	FAB$V_CIF=25
                                     0000       	
                                     0000       $EQU	FAB$V_ESC	27
                           0000001B  0000       	FAB$V_ESC=27
                                     0000       	
                                     0000       $EQU	FAB$V_TEF	28
                           0000001C  0000       	FAB$V_TEF=28
                                     0000       	
                                     0000       $EQU	FAB$V_OFP	29
                           0000001D  0000       	FAB$V_OFP=29
                                     0000       	
                                     0000       $EQU	FAB$V_KFO	30
                           0000001E  0000       	FAB$V_KFO=30
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  22
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$L_STS	8
                           00000008  0000       	FAB$L_STS=8
                                     0000       	
                                     0000       $EQU	FAB$L_STV	12
                           0000000C  0000       	FAB$L_STV=12
                                     0000       	
                                     0000       $EQU	FAB$L_ALQ	16
                           00000010  0000       	FAB$L_ALQ=16
                                     0000       	
                                     0000       $EQU	FAB$W_DEQ	20
                           00000014  0000       	FAB$W_DEQ=20
                                     0000       	
                                     0000       $EQU	FAB$R_FAC_OVERLAY	22
                           00000016  0000       	FAB$R_FAC_OVERLAY=22
                                     0000       	
                                     0000       $EQU	FAB$B_FAC	22
                           00000016  0000       	FAB$B_FAC=22
                                     0000       	
                                     0000       $EQU	FAB$R_FAC_BITS	22
                           00000016  0000       	FAB$R_FAC_BITS=22
                                     0000       	
                                     0000       $EQU	FAB$V_PUT	0
                           00000000  0000       	FAB$V_PUT=0
                                     0000       	
                                     0000       $EQU	FAB$V_GET	1
                           00000001  0000       	FAB$V_GET=1
                                     0000       	
                                     0000       $EQU	FAB$V_DEL	2
                           00000002  0000       	FAB$V_DEL=2
                                     0000       	
                                     0000       $EQU	FAB$V_UPD	3
                           00000003  0000       	FAB$V_UPD=3
                                     0000       	
                                     0000       $EQU	FAB$V_TRN	4
                           00000004  0000       	FAB$V_TRN=4
                                     0000       	
                                     0000       $EQU	FAB$V_BIO	5
                           00000005  0000       	FAB$V_BIO=5
                                     0000       	
                                     0000       $EQU	FAB$V_BRO	6
                           00000006  0000       	FAB$V_BRO=6
                                     0000       	
                                     0000       $EQU	FAB$V_EXE	7
                           00000007  0000       	FAB$V_EXE=7
                                     0000       	
                                     0000       $EQU	FAB$R_SHR_OVERLAY	23
                           00000017  0000       	FAB$R_SHR_OVERLAY=23
                                     0000       	
                                     0000       $EQU	FAB$B_SHR	23
                           00000017  0000       	FAB$B_SHR=23
                                     0000       	
                                     0000       $EQU	FAB$R_SHR_BITS	23
                           00000017  0000       	FAB$R_SHR_BITS=23
                                     0000       	
                                     0000       $EQU	FAB$V_SHRPUT	0
                           00000000  0000       	FAB$V_SHRPUT=0
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  23
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$V_SHRGET	1
                           00000001  0000       	FAB$V_SHRGET=1
                                     0000       	
                                     0000       $EQU	FAB$V_SHRDEL	2
                           00000002  0000       	FAB$V_SHRDEL=2
                                     0000       	
                                     0000       $EQU	FAB$V_SHRUPD	3
                           00000003  0000       	FAB$V_SHRUPD=3
                                     0000       	
                                     0000       $EQU	FAB$V_MSE	4
                           00000004  0000       	FAB$V_MSE=4
                                     0000       	
                                     0000       $EQU	FAB$V_NIL	5
                           00000005  0000       	FAB$V_NIL=5
                                     0000       	
                                     0000       $EQU	FAB$V_UPI	6
                           00000006  0000       	FAB$V_UPI=6
                                     0000       	
                                     0000       $EQU	FAB$L_CTX	24
                           00000018  0000       	FAB$L_CTX=24
                                     0000       	
                                     0000       $EQU	FAB$B_RTV	28
                           0000001C  0000       	FAB$B_RTV=28
                                     0000       	
                                     0000       $EQU	FAB$R_ORG_OVERLAY	29
                           0000001D  0000       	FAB$R_ORG_OVERLAY=29
                                     0000       	
                                     0000       $EQU	FAB$B_ORG	29
                           0000001D  0000       	FAB$B_ORG=29
                                     0000       	
                                     0000       $EQU	FAB$R_ORG_BITS	29
                           0000001D  0000       	FAB$R_ORG_BITS=29
                                     0000       	
                                     0000       $EQU	FAB$S_ORG	4
                           00000004  0000       	FAB$S_ORG=4
                                     0000       	
                                     0000       $EQU	FAB$V_ORG	4
                           00000004  0000       	FAB$V_ORG=4
                                     0000       	
                                     0000       $EQU	FAB$R_RAT_OVERLAY	30
                           0000001E  0000       	FAB$R_RAT_OVERLAY=30
                                     0000       	
                                     0000       $EQU	FAB$B_RAT	30
                           0000001E  0000       	FAB$B_RAT=30
                                     0000       	
                                     0000       $EQU	FAB$R_RAT_BITS	30
                           0000001E  0000       	FAB$R_RAT_BITS=30
                                     0000       	
                                     0000       $EQU	FAB$V_FTN	0
                           00000000  0000       	FAB$V_FTN=0
                                     0000       	
                                     0000       $EQU	FAB$V_CR	1
                           00000001  0000       	FAB$V_CR=1
                                     0000       	
                                     0000       $EQU	FAB$V_PRN	2
                           00000002  0000       	FAB$V_PRN=2
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  24
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$V_BLK	3
                           00000003  0000       	FAB$V_BLK=3
                                     0000       	
                                     0000       $EQU	FAB$B_RFM	31
                           0000001F  0000       	FAB$B_RFM=31
                                     0000       	
                                     0000       $EQU	FAB$R_JOURNAL_OVERLAY	32
                           00000020  0000       	FAB$R_JOURNAL_OVERLAY=32
                                     0000       	
                                     0000       $EQU	FAB$B_JOURNAL	32
                           00000020  0000       	FAB$B_JOURNAL=32
                                     0000       	
                                     0000       $EQU	FAB$R_JOURNAL_BITS	32
                           00000020  0000       	FAB$R_JOURNAL_BITS=32
                                     0000       	
                                     0000       $EQU	FAB$V_ONLY_RU	0
                           00000000  0000       	FAB$V_ONLY_RU=0
                                     0000       	
                                     0000       $EQU	FAB$V_RU	1
                           00000001  0000       	FAB$V_RU=1
                                     0000       	
                                     0000       $EQU	FAB$V_BI	2
                           00000002  0000       	FAB$V_BI=2
                                     0000       	
                                     0000       $EQU	FAB$V_AI	3
                           00000003  0000       	FAB$V_AI=3
                                     0000       	
                                     0000       $EQU	FAB$V_AT	4
                           00000004  0000       	FAB$V_AT=4
                                     0000       	
                                     0000       $EQU	FAB$V_NEVER_RU	5
                           00000005  0000       	FAB$V_NEVER_RU=5
                                     0000       	
                                     0000       $EQU	FAB$V_JOURNAL_FILE	6
                           00000006  0000       	FAB$V_JOURNAL_FILE=6
                                     0000       	
                                     0000       $EQU	FAB$B_RU_FACILITY	33
                           00000021  0000       	FAB$B_RU_FACILITY=33
                                     0000       	
                                     0000       $EQU	FAB$L_XAB	36
                           00000024  0000       	FAB$L_XAB=36
                                     0000       	
                                     0000       $EQU	FAB$L_NAM	40
                           00000028  0000       	FAB$L_NAM=40
                                     0000       	
                                     0000       $EQU	FAB$L_FNA	44
                           0000002C  0000       	FAB$L_FNA=44
                                     0000       	
                                     0000       $EQU	FAB$L_DNA	48
                           00000030  0000       	FAB$L_DNA=48
                                     0000       	
                                     0000       $EQU	FAB$B_FNS	52
                           00000034  0000       	FAB$B_FNS=52
                                     0000       	
                                     0000       $EQU	FAB$B_DNS	53
                           00000035  0000       	FAB$B_DNS=53
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  25
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$W_MRS	54
                           00000036  0000       	FAB$W_MRS=54
                                     0000       	
                                     0000       $EQU	FAB$L_MRN	56
                           00000038  0000       	FAB$L_MRN=56
                                     0000       	
                                     0000       $EQU	FAB$W_BLS	60
                           0000003C  0000       	FAB$W_BLS=60
                                     0000       	
                                     0000       $EQU	FAB$B_BKS	62
                           0000003E  0000       	FAB$B_BKS=62
                                     0000       	
                                     0000       $EQU	FAB$B_FSZ	63
                           0000003F  0000       	FAB$B_FSZ=63
                                     0000       	
                                     0000       $EQU	FAB$L_DEV	64
                           00000040  0000       	FAB$L_DEV=64
                                     0000       	
                                     0000       $EQU	FAB$L_SDC	68
                           00000044  0000       	FAB$L_SDC=68
                                     0000       	
                                     0000       $EQU	FAB$W_GBC	72
                           00000048  0000       	FAB$W_GBC=72
                                     0000       	
                                     0000       $EQU	FAB$R_ACMODES_OVERLAY	74
                           0000004A  0000       	FAB$R_ACMODES_OVERLAY=74
                                     0000       	
                                     0000       $EQU	FAB$B_ACMODES	74
                           0000004A  0000       	FAB$B_ACMODES=74
                                     0000       	
                                     0000       $EQU	FAB$R_ACMODES_BITS	74
                           0000004A  0000       	FAB$R_ACMODES_BITS=74
                                     0000       	
                                     0000       $EQU	FAB$S_LNM_MODE	2
                           00000002  0000       	FAB$S_LNM_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_LNM_MODE	0
                           00000000  0000       	FAB$V_LNM_MODE=0
                                     0000       	
                                     0000       $EQU	FAB$S_CHAN_MODE	2
                           00000002  0000       	FAB$S_CHAN_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_CHAN_MODE	2
                           00000002  0000       	FAB$V_CHAN_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$S_FILE_MODE	2
                           00000002  0000       	FAB$S_FILE_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_FILE_MODE	4
                           00000004  0000       	FAB$V_FILE_MODE=4
                                     0000       	
                                     0000       $EQU	FAB$S_CALLERS_MODE	2
                           00000002  0000       	FAB$S_CALLERS_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_CALLERS_MODE	6       ;  ACMODE for user structure probing
                           00000006  0000       	FAB$V_CALLERS_MODE=6
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  26
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       $EQU	FAB$R_RCF_OVERLAY	75
                           0000004B  0000       	FAB$R_RCF_OVERLAY=75
                                     0000       	
                                     0000       $EQU	FAB$B_RCF	75
                           0000004B  0000       	FAB$B_RCF=75
                                     0000       	
                                     0000       $EQU	FAB$R_RCF_BITS	75
                           0000004B  0000       	FAB$R_RCF_BITS=75
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_RU	0
                           00000000  0000       	FAB$V_RCF_RU=0
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_AI	1
                           00000001  0000       	FAB$V_RCF_AI=1
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_BI	2
                           00000002  0000       	FAB$V_RCF_BI=2
                                     0000       	
                                     0000       	$DEFEND	FAB,,DEF
                                     0000       	.MACRO	$FABDEF A
                                     0000       	.ENDM	$FABDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                 000019A8       	.RESTORE
                                     19A8       	
                                     19A8       	
                                     19A8       	$$R_TABINIT	FAB$C_BID, FAB$C_BLN
                                     19A8       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           000019A8  19A8       $$.TAB=.
                                 03  19A8       	.BYTE FAB$C_BID
                                 50  19A9       	.BYTE FAB$C_BLN
                           000019F8  19AA       	.BLKB FAB$C_BLN-2
                           000019F8  19F8       $$.TABEND=.
                                     19F8       
                                     19F8       	$$R_VBFSET	FAB,<>
                           00000000  19F8       $$.TMP=0
                                     19F8       	.IRP X,<>
                                     19F8       	.IF DF FAB$V_'X
                                     19F8       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19F8       	.IFF
                                     19F8       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19F8       	.ENDC
                                     19F8       	.ENDR
                                     19F8       	
                           000019AC  19F8       	.=$$.TAB+FAB$L_FOP
                           00000000' 19AC       	.ADDRESS	$$.TMP
                           000019B8  19B0       	.=$$.TAB+FAB$L_ALQ
                           00000000' 19B8       	.ADDRESS	0
                               0000  19BC       	.WORD	0
                                     19BE       	$$R_VBFSET	FAB,<>
                           00000000  19BE       $$.TMP=0
                                     19BE       	.IRP X,<>
                                     19BE       	.IF DF FAB$V_'X
                                     19BE       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19BE       	.IFF
                                     19BE       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19BE       	.ENDC
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  27
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     19BE       	.ENDR
                                     19BE       	
                                 00  19BE       	.BYTE	$$.TMP
                                     19BF       	$$R_VBFSET	FAB,<>
                           00000000  19BF       $$.TMP=0
                                     19BF       	.IRP X,<>
                                     19BF       	.IF DF FAB$V_'X
                                     19BF       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19BF       	.IFF
                                     19BF       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19BF       	.ENDC
                                     19BF       	.ENDR
                                     19BF       	
                                 00  19BF       	.BYTE	$$.TMP
                           00000000' 19C0       	.ADDRESS	0
                                 00  19C4       	.BYTE	0
                                     19C5       	.IF DF FAB$C_SEQ
                                 00  19C5       	.BYTE	FAB$C_SEQ
                                     19C6       	.IFF
                                     19C6       	.BYTE
                                     19C6       	.ERROR			; UNDEFINED VALUE FOR FIELD : SEQ;
                                     19C6       	.ENDC
                                     19C6       	$$R_VBFSET	FAB,<>
                           00000000  19C6       $$.TMP=0
                                     19C6       	.IRP X,<>
                                     19C6       	.IF DF FAB$V_'X
                                     19C6       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19C6       	.IFF
                                     19C6       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19C6       	.ENDC
                                     19C6       	.ENDR
                                     19C6       	
                                 00  19C6       	.BYTE	$$.TMP
                                     19C7       	.IF DF FAB$C_VAR
                                 02  19C7       	.BYTE	FAB$C_VAR
                                     19C8       	.IFF
                                     19C8       	.BYTE
                                     19C8       	.ERROR			; UNDEFINED VALUE FOR FIELD : VAR;
                                     19C8       	.ENDC
                                     19C8       	$$R_VBFSET	FAB,<>
                           00000000  19C8       $$.TMP=0
                                     19C8       	.IRP X,<>
                                     19C8       	.IF DF FAB$V_'X
                                     19C8       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19C8       	.IFF
                                     19C8       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19C8       	.ENDC
                                     19C8       	.ENDR
                                     19C8       	
                                 00  19C8       	.BYTE	$$.TMP
                                 00  19C9       	.BYTE	0
                               0000  19CA       	.WORD
                           00000000' 19CC       	.ADDRESS	0
                           00000000' 19D0       	.ADDRESS	0
                           00000000' 19D4       	.ADDRESS	0
                           00000000' 19D8       	.ADDRESS	0
                                 00  19DC       	.BYTE	0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  28
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 00  19DD       	.BYTE	0
                               0000  19DE       	.WORD	0
                           00000000' 19E0       	.ADDRESS	0
                               0000  19E4       	.WORD	0
                                 00  19E6       	.BYTE	0
                                 00  19E7       	.BYTE	0
                           000019F0  19E8       	.=$$.TAB+FAB$W_GBC
                               0000  19F0       	.WORD	0
                                 00  19F2       	.BYTE	<<0@FAB$V_LNM_MODE> + <0@FAB$V_CHAN_MODE> + -
                                     19F3       		<0@FAB$V_FILE_MODE>>
                                     19F3       	.IIF NE 8-8, .ERROR	; INVALID BYTE SIZE
                                     19F3       	.IF NB <>
                                     19F3       	.SAVE
                                     19F3       	.PSECT $RMSNAM
                                     19F3       	$$.TMPX=.
                                     19F3       	.ASCII %%
                                     19F3       	$$.TMPX1=.-$$.TMPX
                                     19F3       	.RESTORE
                                     19F3       	.=$$.TAB+FAB$L_FNA
                                     19F3       	.ADDRESS	$$.TMPX
                                     19F3       	.=$$.TAB+FAB$B_FNS
                                     19F3       	.BYTE	$$.TMPX1
                                     19F3       	.ENDC
                                     19F3       	.IF NB <>
                                     19F3       	.SAVE
                                     19F3       	.PSECT $RMSNAM
                                     19F3       	$$.TMPX=.
                                     19F3       	.ASCII %%
                                     19F3       	$$.TMPX1=.-$$.TMPX
                                     19F3       	.RESTORE
                                     19F3       	.=$$.TAB+FAB$L_DNA
                                     19F3       	.ADDRESS	$$.TMPX
                                     19F3       	.=$$.TAB+FAB$B_DNS
                                     19F3       	.BYTE	$$.TMPX1
                                     19F3       	.ENDC
                           000019F8  19F3       	.=$$.TABEND
                                     19F8       	
                                     19F8   413 ;		fnm=<infile>,-		; primary input file name
                                     19F8   414 ;		dnm=<vtil.vtil>		; default input file extension
                                     19F8   415 v_inrab:
                                     19F8   416 	$rab	fab=v_infab,-		; pointer to fab
                                     19F8   417 		rop=rah,-		; read-ahead option
                                     19F8   418 		ubf=v_inbuf,-		; record buffer
                                     19F8   419 		usz=c_max_len		; and size
                                     19F8       $RABDEF
                                     19F8       	$DEFINI	RAB,
                                     19F8       	.SAVE	LOCAL_BLOCK
                                     19F8       	.NOCROSS
                                     19F8       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     19F8       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  29
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	RAB$C_BID	1
                           00000001  0000       	RAB$C_BID=1
                                     0000       	
                                     0000       $EQU	RAB$M_PPF_RAT	16320
                           00003FC0  0000       	RAB$M_PPF_RAT=16320
                                     0000       	
                                     0000       $EQU	RAB$M_PPF_IND	16384
                           00004000  0000       	RAB$M_PPF_IND=16384
                                     0000       	
                                     0000       $EQU	RAB$M_PPISI	32768
                           00008000  0000       	RAB$M_PPISI=32768
                                     0000       	
                                     0000       $EQU	RAB$M_ASY	1
                           00000001  0000       	RAB$M_ASY=1
                                     0000       	
                                     0000       $EQU	RAB$M_TPT	2
                           00000002  0000       	RAB$M_TPT=2
                                     0000       	
                                     0000       $EQU	RAB$M_REA	4
                           00000004  0000       	RAB$M_REA=4
                                     0000       	
                                     0000       $EQU	RAB$M_RRL	8
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  30
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000008  0000       	RAB$M_RRL=8
                                     0000       	
                                     0000       $EQU	RAB$M_UIF	16
                           00000010  0000       	RAB$M_UIF=16
                                     0000       	
                                     0000       $EQU	RAB$M_MAS	32
                           00000020  0000       	RAB$M_MAS=32
                                     0000       	
                                     0000       $EQU	RAB$M_FDL	64
                           00000040  0000       	RAB$M_FDL=64
                                     0000       	
                                     0000       $EQU	RAB$M_HSH	128
                           00000080  0000       	RAB$M_HSH=128
                                     0000       	
                                     0000       $EQU	RAB$M_EOF	256
                           00000100  0000       	RAB$M_EOF=256
                                     0000       	
                                     0000       $EQU	RAB$M_RAH	512
                           00000200  0000       	RAB$M_RAH=512
                                     0000       	
                                     0000       $EQU	RAB$M_WBH	1024
                           00000400  0000       	RAB$M_WBH=1024
                                     0000       	
                                     0000       $EQU	RAB$M_BIO	2048
                           00000800  0000       	RAB$M_BIO=2048
                                     0000       	
                                     0000       $EQU	RAB$M_CDK	4096
                           00001000  0000       	RAB$M_CDK=4096
                                     0000       	
                                     0000       $EQU	RAB$M_LOA	8192
                           00002000  0000       	RAB$M_LOA=8192
                                     0000       	
                                     0000       $EQU	RAB$M_LIM	16384
                           00004000  0000       	RAB$M_LIM=16384
                                     0000       	
                                     0000       $EQU	RAB$M_SYNCSTS	32768
                           00008000  0000       	RAB$M_SYNCSTS=32768
                                     0000       	
                                     0000       $EQU	RAB$M_LOC	65536
                           00010000  0000       	RAB$M_LOC=65536
                                     0000       	
                                     0000       $EQU	RAB$M_WAT	131072
                           00020000  0000       	RAB$M_WAT=131072
                                     0000       	
                                     0000       $EQU	RAB$M_ULK	262144
                           00040000  0000       	RAB$M_ULK=262144
                                     0000       	
                                     0000       $EQU	RAB$M_RLK	524288
                           00080000  0000       	RAB$M_RLK=524288
                                     0000       	
                                     0000       $EQU	RAB$M_NLK	1048576
                           00100000  0000       	RAB$M_NLK=1048576
                                     0000       	
                                     0000       $EQU	RAB$M_KGE	2097152
                           00200000  0000       	RAB$M_KGE=2097152
                                     0000       	
                                     0000       $EQU	RAB$M_KGT	4194304
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  31
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00400000  0000       	RAB$M_KGT=4194304
                                     0000       	
                                     0000       $EQU	RAB$M_NXR	8388608
                           00800000  0000       	RAB$M_NXR=8388608
                                     0000       	
                                     0000       $EQU	RAB$M_RNE	16777216
                           01000000  0000       	RAB$M_RNE=16777216
                                     0000       	
                                     0000       $EQU	RAB$M_TMO	33554432
                           02000000  0000       	RAB$M_TMO=33554432
                                     0000       	
                                     0000       $EQU	RAB$M_CVT	67108864
                           04000000  0000       	RAB$M_CVT=67108864
                                     0000       	
                                     0000       $EQU	RAB$M_RNF	134217728
                           08000000  0000       	RAB$M_RNF=134217728
                                     0000       	
                                     0000       $EQU	RAB$M_ETO	268435456
                           10000000  0000       	RAB$M_ETO=268435456
                                     0000       	
                                     0000       $EQU	RAB$M_PTA	536870912
                           20000000  0000       	RAB$M_PTA=536870912
                                     0000       	
                                     0000       $EQU	RAB$M_PMT	1073741824
                           40000000  0000       	RAB$M_PMT=1073741824
                                     0000       	
                                     0000       $EQU	RAB$M_CCO	-2147483648
                           80000000  0000       	RAB$M_CCO=-2147483648
                                     0000       	
                                     0000       $EQU	RAB$M_EQNXT	2097152
                           00200000  0000       	RAB$M_EQNXT=2097152
                                     0000       	
                                     0000       $EQU	RAB$M_NXT	4194304
                           00400000  0000       	RAB$M_NXT=4194304
                                     0000       	
                                     0000       $EQU	RAB$C_SEQ	0
                           00000000  0000       	RAB$C_SEQ=0
                                     0000       	
                                     0000       $EQU	RAB$C_KEY	1
                           00000001  0000       	RAB$C_KEY=1
                                     0000       	
                                     0000       $EQU	RAB$C_RFA	2
                           00000002  0000       	RAB$C_RFA=2
                                     0000       	
                                     0000       $EQU	RAB$C_STM	3
                           00000003  0000       	RAB$C_STM=3
                                     0000       	
                                     0000       $EQU	RAB$C_MAXRAC	2
                           00000002  0000       	RAB$C_MAXRAC=2
                                     0000       	
                                     0000       $EQU	RAB$K_BLN	68
                           00000044  0000       	RAB$K_BLN=68
                                     0000       	
                                     0000       $EQU	RAB$C_BLN	68
                           00000044  0000       	RAB$C_BLN=68
                                     0000       	
                                     0000       $EQU	RAB$S_RABDEF	68
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  32
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000044  0000       	RAB$S_RABDEF=68
                                     0000       	
                                     0000       $EQU	RAB$B_BID	0
                           00000000  0000       	RAB$B_BID=0
                                     0000       	
                                     0000       $EQU	RAB$B_BLN	1
                           00000001  0000       	RAB$B_BLN=1
                                     0000       	
                                     0000       $EQU	RAB$R_ISI_OVERLAY	2
                           00000002  0000       	RAB$R_ISI_OVERLAY=2
                                     0000       	
                                     0000       $EQU	RAB$W_ISI	2
                           00000002  0000       	RAB$W_ISI=2
                                     0000       	
                                     0000       $EQU	RAB$R_ISI_BITS	2
                           00000002  0000       	RAB$R_ISI_BITS=2
                                     0000       	
                                     0000       $EQU	RAB$S_PPF_RAT	8
                           00000008  0000       	RAB$S_PPF_RAT=8
                                     0000       	
                                     0000       $EQU	RAB$V_PPF_RAT	6
                           00000006  0000       	RAB$V_PPF_RAT=6
                                     0000       	
                                     0000       $EQU	RAB$V_PPF_IND	14
                           0000000E  0000       	RAB$V_PPF_IND=14
                                     0000       	
                                     0000       $EQU	RAB$V_PPISI	15
                           0000000F  0000       	RAB$V_PPISI=15
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_OVERLAY	4
                           00000004  0000       	RAB$R_ROP_OVERLAY=4
                                     0000       	
                                     0000       $EQU	RAB$L_ROP	4
                           00000004  0000       	RAB$L_ROP=4
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_BITS0	4
                           00000004  0000       	RAB$R_ROP_BITS0=4
                                     0000       	
                                     0000       $EQU	RAB$V_ASY	0
                           00000000  0000       	RAB$V_ASY=0
                                     0000       	
                                     0000       $EQU	RAB$V_TPT	1
                           00000001  0000       	RAB$V_TPT=1
                                     0000       	
                                     0000       $EQU	RAB$V_REA	2
                           00000002  0000       	RAB$V_REA=2
                                     0000       	
                                     0000       $EQU	RAB$V_RRL	3
                           00000003  0000       	RAB$V_RRL=3
                                     0000       	
                                     0000       $EQU	RAB$V_UIF	4
                           00000004  0000       	RAB$V_UIF=4
                                     0000       	
                                     0000       $EQU	RAB$V_MAS	5
                           00000005  0000       	RAB$V_MAS=5
                                     0000       	
                                     0000       $EQU	RAB$V_FDL	6
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  33
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000006  0000       	RAB$V_FDL=6
                                     0000       	
                                     0000       $EQU	RAB$V_HSH	7
                           00000007  0000       	RAB$V_HSH=7
                                     0000       	
                                     0000       $EQU	RAB$V_EOF	8
                           00000008  0000       	RAB$V_EOF=8
                                     0000       	
                                     0000       $EQU	RAB$V_RAH	9
                           00000009  0000       	RAB$V_RAH=9
                                     0000       	
                                     0000       $EQU	RAB$V_WBH	10
                           0000000A  0000       	RAB$V_WBH=10
                                     0000       	
                                     0000       $EQU	RAB$V_BIO	11
                           0000000B  0000       	RAB$V_BIO=11
                                     0000       	
                                     0000       $EQU	RAB$V_CDK	12
                           0000000C  0000       	RAB$V_CDK=12
                                     0000       	
                                     0000       $EQU	RAB$V_LOA	13
                           0000000D  0000       	RAB$V_LOA=13
                                     0000       	
                                     0000       $EQU	RAB$V_LIM	14
                           0000000E  0000       	RAB$V_LIM=14
                                     0000       	
                                     0000       $EQU	RAB$V_SYNCSTS	15
                           0000000F  0000       	RAB$V_SYNCSTS=15
                                     0000       	
                                     0000       $EQU	RAB$V_LOC	16
                           00000010  0000       	RAB$V_LOC=16
                                     0000       	
                                     0000       $EQU	RAB$V_WAT	17
                           00000011  0000       	RAB$V_WAT=17
                                     0000       	
                                     0000       $EQU	RAB$V_ULK	18
                           00000012  0000       	RAB$V_ULK=18
                                     0000       	
                                     0000       $EQU	RAB$V_RLK	19
                           00000013  0000       	RAB$V_RLK=19
                                     0000       	
                                     0000       $EQU	RAB$V_NLK	20
                           00000014  0000       	RAB$V_NLK=20
                                     0000       	
                                     0000       $EQU	RAB$V_KGE	21
                           00000015  0000       	RAB$V_KGE=21
                                     0000       	
                                     0000       $EQU	RAB$V_KGT	22
                           00000016  0000       	RAB$V_KGT=22
                                     0000       	
                                     0000       $EQU	RAB$V_NXR	23
                           00000017  0000       	RAB$V_NXR=23
                                     0000       	
                                     0000       $EQU	RAB$V_RNE	24
                           00000018  0000       	RAB$V_RNE=24
                                     0000       	
                                     0000       $EQU	RAB$V_TMO	25
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  34
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000019  0000       	RAB$V_TMO=25
                                     0000       	
                                     0000       $EQU	RAB$V_CVT	26
                           0000001A  0000       	RAB$V_CVT=26
                                     0000       	
                                     0000       $EQU	RAB$V_RNF	27
                           0000001B  0000       	RAB$V_RNF=27
                                     0000       	
                                     0000       $EQU	RAB$V_ETO	28
                           0000001C  0000       	RAB$V_ETO=28
                                     0000       	
                                     0000       $EQU	RAB$V_PTA	29
                           0000001D  0000       	RAB$V_PTA=29
                                     0000       	
                                     0000       $EQU	RAB$V_PMT	30
                           0000001E  0000       	RAB$V_PMT=30
                                     0000       	
                                     0000       $EQU	RAB$V_CCO	31
                           0000001F  0000       	RAB$V_CCO=31
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_BITS1	4
                           00000004  0000       	RAB$R_ROP_BITS1=4
                                     0000       	
                                     0000       $EQU	RAB$V_EQNXT	21
                           00000015  0000       	RAB$V_EQNXT=21
                                     0000       	
                                     0000       $EQU	RAB$V_NXT	22
                           00000016  0000       	RAB$V_NXT=22
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_FIELDS	4
                           00000004  0000       	RAB$R_ROP_FIELDS=4
                                     0000       	
                                     0000       $EQU	RAB$B_ROP1	5
                           00000005  0000       	RAB$B_ROP1=5
                                     0000       	
                                     0000       $EQU	RAB$B_ROP2	6
                           00000006  0000       	RAB$B_ROP2=6
                                     0000       	
                                     0000       $EQU	RAB$B_ROP3	7
                           00000007  0000       	RAB$B_ROP3=7
                                     0000       	
                                     0000       $EQU	RAB$L_STS	8
                           00000008  0000       	RAB$L_STS=8
                                     0000       	
                                     0000       $EQU	RAB$R_STV_OVERLAY	12
                           0000000C  0000       	RAB$R_STV_OVERLAY=12
                                     0000       	
                                     0000       $EQU	RAB$L_STV	12
                           0000000C  0000       	RAB$L_STV=12
                                     0000       	
                                     0000       $EQU	RAB$R_STV_FIELDS	12
                           0000000C  0000       	RAB$R_STV_FIELDS=12
                                     0000       	
                                     0000       $EQU	RAB$W_STV0	12
                           0000000C  0000       	RAB$W_STV0=12
                                     0000       	
                                     0000       $EQU	RAB$W_STV2	14
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  35
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           0000000E  0000       	RAB$W_STV2=14
                                     0000       	
                                     0000       $EQU	RAB$R_RFA_OVERLAY	16
                           00000010  0000       	RAB$R_RFA_OVERLAY=16
                                     0000       	
                                     0000       $EQU	RAB$S_RFA	6
                           00000006  0000       	RAB$S_RFA=6
                                     0000       	
                                     0000       $EQU	RAB$W_RFA	16
                           00000010  0000       	RAB$W_RFA=16
                                     0000       	
                                     0000       $EQU	RAB$R_RFA_FIELDS	16
                           00000010  0000       	RAB$R_RFA_FIELDS=16
                                     0000       	
                                     0000       $EQU	RAB$L_RFA0	16
                           00000010  0000       	RAB$L_RFA0=16
                                     0000       	
                                     0000       $EQU	RAB$W_RFA4	20
                           00000014  0000       	RAB$W_RFA4=20
                                     0000       	
                                     0000       $EQU	RAB$L_CTX	24
                           00000018  0000       	RAB$L_CTX=24
                                     0000       	
                                     0000       $EQU	RAB$B_RAC	30
                           0000001E  0000       	RAB$B_RAC=30
                                     0000       	
                                     0000       $EQU	RAB$B_TMO	31
                           0000001F  0000       	RAB$B_TMO=31
                                     0000       	
                                     0000       $EQU	RAB$W_USZ	32
                           00000020  0000       	RAB$W_USZ=32
                                     0000       	
                                     0000       $EQU	RAB$W_RSZ	34
                           00000022  0000       	RAB$W_RSZ=34
                                     0000       	
                                     0000       $EQU	RAB$L_UBF	36
                           00000024  0000       	RAB$L_UBF=36
                                     0000       	
                                     0000       $EQU	RAB$L_RBF	40
                           00000028  0000       	RAB$L_RBF=40
                                     0000       	
                                     0000       $EQU	RAB$L_RHB	44
                           0000002C  0000       	RAB$L_RHB=44
                                     0000       	
                                     0000       $EQU	RAB$R_KBF_OVERLAY	48
                           00000030  0000       	RAB$R_KBF_OVERLAY=48
                                     0000       	
                                     0000       $EQU	RAB$L_KBF	48
                           00000030  0000       	RAB$L_KBF=48
                                     0000       	
                                     0000       $EQU	RAB$L_PBF	48
                           00000030  0000       	RAB$L_PBF=48
                                     0000       	
                                     0000       $EQU	RAB$R_KSZ_OVERLAY	52
                           00000034  0000       	RAB$R_KSZ_OVERLAY=52
                                     0000       	
                                     0000       $EQU	RAB$B_KSZ	52
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  36
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000034  0000       	RAB$B_KSZ=52
                                     0000       	
                                     0000       $EQU	RAB$B_PSZ	52
                           00000034  0000       	RAB$B_PSZ=52
                                     0000       	
                                     0000       $EQU	RAB$B_KRF	53
                           00000035  0000       	RAB$B_KRF=53
                                     0000       	
                                     0000       $EQU	RAB$B_MBF	54
                           00000036  0000       	RAB$B_MBF=54
                                     0000       	
                                     0000       $EQU	RAB$B_MBC	55
                           00000037  0000       	RAB$B_MBC=55
                                     0000       	
                                     0000       $EQU	RAB$R_BKT_OVERLAY	56
                           00000038  0000       	RAB$R_BKT_OVERLAY=56
                                     0000       	
                                     0000       $EQU	RAB$L_BKT	56
                           00000038  0000       	RAB$L_BKT=56
                                     0000       	
                                     0000       $EQU	RAB$L_DCT	56
                           00000038  0000       	RAB$L_DCT=56
                                     0000       	
                                     0000       $EQU	RAB$L_FAB	60
                           0000003C  0000       	RAB$L_FAB=60
                                     0000       	
                                     0000       $EQU	RAB$L_XAB	64
                           00000040  0000       	RAB$L_XAB=64
                                     0000       	
                                     0000       	$DEFEND	RAB,,DEF
                                     0000       	.MACRO	$RABDEF A
                                     0000       	.ENDM	$RABDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                 000019F8       	.RESTORE
                                     19F8       	
                                     19F8       	
                                     19F8       $$R_TABINIT		RAB$C_BID,RAB$C_BLN
                                     19F8       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           000019F8  19F8       $$.TAB=.
                                 01  19F8       	.BYTE RAB$C_BID
                                 44  19F9       	.BYTE RAB$C_BLN
                           00001A3C  19FA       	.BLKB RAB$C_BLN-2
                           00001A3C  1A3C       $$.TABEND=.
                                     1A3C       
                                     1A3C       	$$R_VBFSET RAB,<rah>
                           00000000  1A3C       $$.TMP=0
                                     1A3C       	.IRP X,<rah>
                                     1A3C       	.IF DF RAB$V_'X
                                     1A3C       		$$.TMP=$$.TMP!<1@RAB$V_'X>
                                     1A3C       	.IFF
                                     1A3C       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1A3C       	.ENDC
                                     1A3C       	.ENDR
                                     1A3C       	.IF DF RAB$V_rah
                           00000200  1A3C       		$$.TMP=$$.TMP!<1@RAB$V_rah>
                                     1A3C       	.IFF
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  37
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1A3C       		.ERROR		; UNDEFINED BIT VALUE CODE: rah;
                                     1A3C       	.ENDC
                                     1A3C       	
                                     1A3C       	
                           000019FC  1A3C       	.=$$.TAB+RAB$L_ROP
                           00000200' 19FC       	.ADDRESS	$$.TMP
                           00001A10  1A00       	.=$$.TAB+RAB$L_CTX
                           00000000' 1A10       	.ADDRESS	0
                           00001A16  1A14       	.=$$.TAB+RAB$B_RAC
                                     1A16       	.IF DF RAB$C_SEQ
                                 00  1A16       	.BYTE	RAB$C_SEQ
                                     1A17       	.IFF
                                     1A17       	.BYTE
                                     1A17       	.ERROR				; UNDEFINED VALUE FOR FIELD: CNST;
                                     1A17       	.ENDC
                                 00  1A17       	.BYTE	0
                               00A0  1A18       	.WORD	c_max_len
                               0000  1A1A       	.WORD	0
                           000018F7' 1A1C       	.ADDRESS	v_inbuf
                           00000000' 1A20       	.ADDRESS	0
                           00000000' 1A24       	.ADDRESS	0
                           00000000' 1A28       	.ADDRESS	0
                                     1A2C       	.IF NB <>
                                     1A2C       	.=$$.TAB+RAB$L_PBF
                                     1A2C       	.ADDRESS	
                                     1A2C       	.ENDC
                                 00  1A2C       	.BYTE	0
                                     1A2D       	.IF NB <>
                                     1A2D       	.=$$.TAB+RAB$B_PSZ
                                     1A2D       	.BYTE	
                                     1A2D       	.ENDC
                                 00  1A2D       	.BYTE	0
                                 00  1A2E       	.BYTE	0
                                 00  1A2F       	.BYTE	0
                           00000000' 1A30       	.ADDRESS	0
                           000019A8' 1A34       	.ADDRESS	v_infab
                           00000000' 1A38       	.ADDRESS	0
                           00001A3C  1A3C       	.=$$.TABEND
                                     1A3C       	
                                     1A3C   420 v_fnamelen:
                                 00  1A3C   421 	.byte	0		; length of file name for { load }
                                     1A3D   422 v_fname:
                           00001ADD  1A3D   423 	.blkb	c_max_len	; buffer for fil ename for {load}
                                     1ADD   424 
                                     1ADD   425 
                                     1ADD   426 ;
                                     1ADD   427 ; rms buffers for VTIL block i/o (which is actually rms record i/o)
                                     1ADD   428 ;
                                     1ADD   429 	.align long
                                     1AE0   430 v_blkfab:
                                     1AE0   431 	$fab	dnm=<vtilblocks.dat>,-	; default input file name
                                     1AE0   432 		fac=<get,upd>,-		; block i/o operations
                                     1AE0   433 		fnm=<vtilblocks>,-	; input file name
                                     1AE0   434 		mrs=c_block_size,-	; maximum record size
                                     1AE0   435 		rfm=<fix>		; fixed length records
                                     1AE0       	$FABDEF
                                     1AE0       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  38
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1AE0       	$$R_TABINIT	FAB$C_BID, FAB$C_BLN
                                     1AE0       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           00001AE0  1AE0       $$.TAB=.
                                 03  1AE0       	.BYTE FAB$C_BID
                                 50  1AE1       	.BYTE FAB$C_BLN
                           00001B30  1AE2       	.BLKB FAB$C_BLN-2
                           00001B30  1B30       $$.TABEND=.
                                     1B30       
                                     1B30       	$$R_VBFSET	FAB,<>
                           00000000  1B30       $$.TMP=0
                                     1B30       	.IRP X,<>
                                     1B30       	.IF DF FAB$V_'X
                                     1B30       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1B30       	.IFF
                                     1B30       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B30       	.ENDC
                                     1B30       	.ENDR
                                     1B30       	
                           00001AE4  1B30       	.=$$.TAB+FAB$L_FOP
                           00000000' 1AE4       	.ADDRESS	$$.TMP
                           00001AF0  1AE8       	.=$$.TAB+FAB$L_ALQ
                           00000000' 1AF0       	.ADDRESS	0
                               0000  1AF4       	.WORD	0
                                     1AF6       	$$R_VBFSET	FAB,<get,upd>
                           00000000  1AF6       $$.TMP=0
                                     1AF6       	.IRP X,<get,upd>
                                     1AF6       	.IF DF FAB$V_'X
                                     1AF6       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AF6       	.ENDC
                                     1AF6       	.ENDR
                                     1AF6       	.IF DF FAB$V_get
                           00000002  1AF6       		$$.TMP=$$.TMP!<1@FAB$V_get>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: get;
                                     1AF6       	.ENDC
                                     1AF6       	
                                     1AF6       	.IF DF FAB$V_upd
                           0000000A  1AF6       		$$.TMP=$$.TMP!<1@FAB$V_upd>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: upd;
                                     1AF6       	.ENDC
                                     1AF6       	
                                     1AF6       	
                                 0A  1AF6       	.BYTE	$$.TMP
                                     1AF7       	$$R_VBFSET	FAB,<>
                           00000000  1AF7       $$.TMP=0
                                     1AF7       	.IRP X,<>
                                     1AF7       	.IF DF FAB$V_'X
                                     1AF7       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AF7       	.IFF
                                     1AF7       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AF7       	.ENDC
                                     1AF7       	.ENDR
                                     1AF7       	
                                 00  1AF7       	.BYTE	$$.TMP
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  39
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000000' 1AF8       	.ADDRESS	0
                                 00  1AFC       	.BYTE	0
                                     1AFD       	.IF DF FAB$C_SEQ
                                 00  1AFD       	.BYTE	FAB$C_SEQ
                                     1AFE       	.IFF
                                     1AFE       	.BYTE
                                     1AFE       	.ERROR			; UNDEFINED VALUE FOR FIELD : SEQ;
                                     1AFE       	.ENDC
                                     1AFE       	$$R_VBFSET	FAB,<>
                           00000000  1AFE       $$.TMP=0
                                     1AFE       	.IRP X,<>
                                     1AFE       	.IF DF FAB$V_'X
                                     1AFE       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AFE       	.IFF
                                     1AFE       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AFE       	.ENDC
                                     1AFE       	.ENDR
                                     1AFE       	
                                 00  1AFE       	.BYTE	$$.TMP
                                     1AFF       	.IF DF FAB$C_fix
                                 01  1AFF       	.BYTE	FAB$C_fix
                                     1B00       	.IFF
                                     1B00       	.BYTE
                                     1B00       	.ERROR			; UNDEFINED VALUE FOR FIELD : fix;
                                     1B00       	.ENDC
                                     1B00       	$$R_VBFSET	FAB,<>
                           00000000  1B00       $$.TMP=0
                                     1B00       	.IRP X,<>
                                     1B00       	.IF DF FAB$V_'X
                                     1B00       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1B00       	.IFF
                                     1B00       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B00       	.ENDC
                                     1B00       	.ENDR
                                     1B00       	
                                 00  1B00       	.BYTE	$$.TMP
                                 00  1B01       	.BYTE	0
                               0000  1B02       	.WORD
                           00000000' 1B04       	.ADDRESS	0
                           00000000' 1B08       	.ADDRESS	0
                           00000000' 1B0C       	.ADDRESS	0
                           00000000' 1B10       	.ADDRESS	0
                                 00  1B14       	.BYTE	0
                                 00  1B15       	.BYTE	0
                               0400  1B16       	.WORD	c_block_size
                           00000000' 1B18       	.ADDRESS	0
                               0000  1B1C       	.WORD	0
                                 00  1B1E       	.BYTE	0
                                 00  1B1F       	.BYTE	0
                           00001B28  1B20       	.=$$.TAB+FAB$W_GBC
                               0000  1B28       	.WORD	0
                                 00  1B2A       	.BYTE	<<0@FAB$V_LNM_MODE> + <0@FAB$V_CHAN_MODE> + -
                                     1B2B       		<0@FAB$V_FILE_MODE>>
                                     1B2B       	.IIF NE 8-8, .ERROR	; INVALID BYTE SIZE
                                     1B2B       	.IF NB <vtilblocks>
                                     1B2B       	.SAVE
                                 00000000       	.PSECT $RMSNAM
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  40
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000000  0000       	$$.TMPX=.
      73 6B 63 6F 6C 62 6C 69 74 76  0000       	.ASCII %vtilblocks%
                           0000000A  000A       	$$.TMPX1=.-$$.TMPX
                                 00001B2B       	.RESTORE
                           00001B0C  1B2B       	.=$$.TAB+FAB$L_FNA
                           00000000' 1B0C       	.ADDRESS	$$.TMPX
                           00001B14  1B10       	.=$$.TAB+FAB$B_FNS
                                 0A  1B14       	.BYTE	$$.TMPX1
                                     1B15       	.ENDC
                                     1B15       	.IF NB <vtilblocks.dat>
                                     1B15       	.SAVE
                                 0000000A       	.PSECT $RMSNAM
                           0000000A  000A       	$$.TMPX=.
64 2E 73 6B 63 6F 6C 62 6C 69 74 76  000A       	.ASCII %vtilblocks.dat%
                              74 61  0016       
                           0000000E  0018       	$$.TMPX1=.-$$.TMPX
                                 00001B15       	.RESTORE
                           00001B10  1B15       	.=$$.TAB+FAB$L_DNA
                           0000000A' 1B10       	.ADDRESS	$$.TMPX
                           00001B15  1B14       	.=$$.TAB+FAB$B_DNS
                                 0E  1B15       	.BYTE	$$.TMPX1
                                     1B16       	.ENDC
                           00001B30  1B16       	.=$$.TABEND
                                     1B30       	
                                     1B30   436 v_blkrab:
                                     1B30   437 	$rab	fab=v_blkfab,-		; pointer to fab
                                     1B30   438 		kfb=v_blkkey,-		; pointer to key
                                     1B30   439 		ksz=c_keysize,-		; size of key
                                     1B30   440 		rac=<key>,-		; random access by record number
                                     1B30   441 		ubf=v_blkbuff,-		; address of user buffer
                                     1B30   442 		usz=c_block_size	; and the record size
                                     1B30       $RABDEF
                                     1B30       	
                                     1B30       $$R_TABINIT		RAB$C_BID,RAB$C_BLN
                                     1B30       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           00001B30  1B30       $$.TAB=.
                                 01  1B30       	.BYTE RAB$C_BID
                                 44  1B31       	.BYTE RAB$C_BLN
                           00001B74  1B32       	.BLKB RAB$C_BLN-2
                           00001B74  1B74       $$.TABEND=.
                                     1B74       
                                     1B74       	$$R_VBFSET RAB,<>
                           00000000  1B74       $$.TMP=0
                                     1B74       	.IRP X,<>
                                     1B74       	.IF DF RAB$V_'X
                                     1B74       		$$.TMP=$$.TMP!<1@RAB$V_'X>
                                     1B74       	.IFF
                                     1B74       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B74       	.ENDC
                                     1B74       	.ENDR
                                     1B74       	
                           00001B34  1B74       	.=$$.TAB+RAB$L_ROP
                           00000000' 1B34       	.ADDRESS	$$.TMP
                           00001B48  1B38       	.=$$.TAB+RAB$L_CTX
                           00000000' 1B48       	.ADDRESS	0
                           00001B4E  1B4C       	.=$$.TAB+RAB$B_RAC
                                     1B4E       	.IF DF RAB$C_key
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  41
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 01  1B4E       	.BYTE	RAB$C_key
                                     1B4F       	.IFF
                                     1B4F       	.BYTE
                                     1B4F       	.ERROR				; UNDEFINED VALUE FOR FIELD: CNST;
                                     1B4F       	.ENDC
                                 00  1B4F       	.BYTE	0
                               0400  1B50       	.WORD	c_block_size
                               0000  1B52       	.WORD	0
                           00004000' 1B54       	.ADDRESS	v_blkbuff
                           00000000' 1B58       	.ADDRESS	0
                           00000000' 1B5C       	.ADDRESS	0
                           00000000' 1B60       	.ADDRESS	0
                                     1B64       	.IF NB <>
                                     1B64       	.=$$.TAB+RAB$L_PBF
                                     1B64       	.ADDRESS	
                                     1B64       	.ENDC
                                 04  1B64       	.BYTE	c_keysize
                                     1B65       	.IF NB <>
                                     1B65       	.=$$.TAB+RAB$B_PSZ
                                     1B65       	.BYTE	
                                     1B65       	.ENDC
                                 00  1B65       	.BYTE	0
                                 00  1B66       	.BYTE	0
                                 00  1B67       	.BYTE	0
                           00000000' 1B68       	.ADDRESS	0
                           00001AE0' 1B6C       	.ADDRESS	v_blkfab
                           00000000' 1B70       	.ADDRESS	0
                           00001B74  1B74       	.=$$.TABEND
                                     1B74       	
                                     1B74   443 v_blkkey:
                           00000000  1B74   444 	.long				; buffer for key (longword pos rec #)
                                     1B78   445 v_blockio:
                                 00  1B78   446 	.byte	c_false			; true when block file is open
                                     1B79   447 v_current_buff:				; Buffer # of most recently accessed
                           00000000  1B79   448 	.long	0			; block
                                     1B7D   449 
                                     1B7D   450 v_buf_inuse:
                           00001B80  1B7D   451 	.blkb	c_max_blocks		; flags for inuse and modified
                                     1B80   452 v_buf_blk_nums:
                           00001B8C  1B80   453 	.blkl	c_max_blocks		; block numbers in buffers
                                     1B8C   454 
                                     1B8C   455 ;
                                     1B8C   456 ; Moved the Block i/o buffers away from the rest of the block i/o stuff
                                     1B8C   457 ; to the end of the dictionary because that is safer.  They are away from
                                     1B8C   458 ; other variables that might get overwritten if someone tries to write
                                     1B8C   459 ; too long a string to the buffers, for instance.
                                     1B8C   460 ;
                                     1B8C   461 
                                     1B8C   462 
                                     1B8C   463 ;
                                     1B8C   464 ; variables for terminal input
                                     1B8C   465 ;
                                     1B8C   466 v_readlen:
                               0000  1B8C   467 	.word			; length of returned input
                                     1B8E   468 v_readdsc:
                               00A0  1B8E   469 	.word	c_max_len	; maximum length
                                 00' 1B90   470 	.byte	dsc$k_dtype_t	; data type text
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  42
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 00' 1B91   471 	.byte	dsc$k_class_s	; descriptor class
                                     1B92   472 v_readaddr:
                           00000000  1B92   473 	.long	0		; pointer to the input buffer
                                     1B96   474 ; v_static_dsc is the middle of a descriptor so it can be copied onto ds
                                     1B96   475 ; to make full desciptor when top fo stack is ( addr count )
                                     1B96   476 v_static_dsc:
                                 00' 1B96   477 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1B97   478 	.byte	dsc$k_class_s	; descriptor class
                                     1B98   479 v_outlen:
                               0000  1B98   480 	.word	0		; length of output
                                     1B9A   481 v_outbuf:
                           00001C3A  1B9A   482 	.blkb	c_max_len	; output bufer
                                     1C3A   483 
                                     1C3A   484 
                                     1C3A   485 ;
                                     1C3A   486 ; Variables for calling the EVE editor using its callable interface.
                                     1C3A   487 ;
                                     1C3A   488 v_tpu_com:			; buffer for constant section of command
3D 6E 6F 69 74 63 65 73 2F 75 70 74  1C3A   489 	.ascii	\tpu/section=eve$dir:eve_edt \ ; use my version of eve
5F 65 76 65 3A 72 69 64 24 65 76 65  1C46       
                        20 74 64 65  1C52       
                           0000001C  1C56   490 c_tpu_com_len = . - v_tpu_com	; length of command is a constant
                                     1C56   491 v_tpu_com2:			; buffer for user section of command
                           00001CF6  1C56   492 	.blkb	c_max_len
                                     1CF6   493 v_tpu_dsc:
                               0000  1CF6   494 	.word	0		; descriptor for command to pass to tpu$tpu
                                 00' 1CF8   495 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1CF9   496 	.byte	dsc$k_class_s	; descriptor class
                           00001C3A' 1CFA   497 	.long	 v_tpu_com	; pointer to tpu command buffer
                                     1CFE   498 ;
                                     1CFE   499 ; Buffers for $ASSIGN, $DASSIGN, and $QIO
                                     1CFE   500 ;
                                     1CFE   501 v_input_name:
6F 63 24 73 79 73 00001D06'010E0000' 1CFE   502 	.ascid	/sys$command/
                     64 6E 61 6D 6D  1D0C       
                                     1D11   503 v_input_chan:
                           00001D13  1D11   504 	.blkw	1
                                     1D13   505 ;
                                     1D13   506 ; Buffers for $GETCHN_S
                                     1D13   507 ;
                                     1D13   508 v_getchn_ret_len:		; returned length of buffer info
                           00000000  1D13   509 	.long	0
                                     1D17   510 v_getchn_in_buf:		; input buffer for getchn, tells about output
                                     1D17   511 				; buffer
                           00000008  1D17   512 	.long	8		; length of output buffer
                                     1D1B   513 v_getchn_buf_adr:
                           00001D1F' 1D1B   514 	.long	v_getchn_buf	; address of output buffer
                                     1D1F   515 v_getchn_buf:			; output buffer
                  00000000 00000000  1D1F   516 	.quad	0		; cleared to begin
                                     1D27   517 
                                     1D27   518 ;
                                     1D27   519 ; System Variables
                                     1D27   520 ;
                                     1D27   521 v_trap_depth:		; depth to unwind stack in trap handler
                           00000001  1D27   522 	.long	1	; unwind to establisher, i.e, main body, 1 deep
                                     1D2B   523 v_ctrlc_depth:		; depth to unwind stack in control/c handler
                           00000002  1D2B   524 	.long	2	; unwind to main program, 2 deep (ctrlc and a_start)
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  43
V1.01                           Data Section                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1D2F   525 v_errors:
                           00000000  1D2F   526 	.long	0	; Number of errors caught by condition handler so far
                                     1D33   527 v_returnstack:		; original return stack pointer.  Save it when we
                           00000000  1D33   528 	.long	0	; abort out of jsb's we return from the right spot
                                     1D37   529 v_context:		; points to data field of the word for the vocabulary
                           00000000  1D37   530 	.long	0	; in which words are searched for.
                                     1D3B   531 v_current:		; points to data field of the word for the vocabulary
                           00000000  1D3B   532 	.long	0	; that new words are linked into.
                                     1D3F   533 v_compiler:		; Pointer to most recent word in compiler vocabulary
                           00000000  1D3F   534 	.long	0
                                     1D43   535 v_kernel:		; Pointer to most recnet word in kernel vocabulary
                           00000000  1D43   536 	.long	0	; data field of { kernel }
                                     1D47   537 v_infile:		; Flag.	 If true, reading from an input file.
                                 00  1D47   538 	.byte	c_false	; If false, reading from terminal.  Set by { load }
                                     1D48   539 v_filelinenum:		; number of lines read from input file
                           00000000  1D48   540 	.long	0	; used in error reporting
                                     1D4C   541 v_state:		; Flag.	 True if compiletime word found
                                 00  1D4C   542 	.byte	c_false ; in compile mode (then set to false by ?execute),
                                     1D4D   543 			; otherwise false.
                                     1D4D   544 v_mode:			; Flag.	 True if in compile mode, false if execute mode.
                                 00  1D4D   545 	.byte	c_false ; true => compile word, false => execute word
                                     1D4E   546 v_radix:
                           0000000A  1D4E   547 	.long	10	; base for number conversion on input and output
                                     1D52   548 v_hld:
                           00000000  1D52   549 	.long	0	; pointer to number output conversion buffer
                                     1D56   550 
                                     1D56   551 	newpage <Kernel Built-ins>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  44
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1D56       	.sbttl	Kernel Built-ins
                                     1D56       	
                                 00000000   552 	.psect	vtilcode,exe,nowrt
                                     0000   553 ;******************************************************************************
                                     0000   554 ;
                                     0000   555 ; Kernel Built-Ins -- Original vocabulary of words.  All other vocabularies
                                     0000   556 ;	link into this one, except the compiler (compiletime word) vocabulary.
                                     0000   557 ;
                                     0000   558 ;******************************************************************************
                                     0000   559 _kernel_begin:
                                     0000   560 
                                     0000   561 
                                     0000   562 ;+++t
                                     0000   563 ;k> ! (store) -- ( n a -- ) store longword `n?' at `a'.
                                     0000   564 ;---
                                     0000   565 	header	i_store,<!>
                           FFFFFFFC' 0000       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0004       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  0004       	.nchr  nchr, ^\!\	; nchr = length( ! )
                           00000001  0004       	.if    le, nchr		; nchr <= 0
                                     0004       	   .ascic \i_store\	; no auxillary !, use principle one
                                     0004       	.if_false		; else
                              21 00' 0004       	  .ascic \!\		; use auxillary !
                                 01  0004       
                                     0006       	.endc			; end if
                                     0006       i_store:			; use ! of word as v1_kernel label
                                     0006       	
                 00 BB   04 AB   D0  0006   566 	movl	4(r11),@(r11)		; store item at what's pointed to by
                                     000B   567 					; top of stack
                       5B   08   C0  000B   568 	addl2	#8,r11			; pop arguments
                                 05  000E   569 	rsb				; end of !
                                     000F   570 
                                     000F   571 
                                     000F   572 ;+++
                                     000F   573 ;k> # -- ( n1 -- n2 ) generate next output character in number conversion.
                                     000F   574 ;	used between { <# } and { #> }.
                                     000F   575 ;---
                                     000F   576 	header	i_sharp,<#>
                           FFFFFFFC  000F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0013       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  0013       	.nchr  nchr, ^\#\	; nchr = length( # )
                           00000001  0013       	.if    le, nchr		; nchr <= 0
                                     0013       	   .ascic \i_sharp\	; no auxillary #, use principle one
                                     0013       	.if_false		; else
                              23 00' 0013       	  .ascic \#\		; use auxillary #
                                 01  0013       
                                     0015       	.endc			; end if
                                     0015       i_sharp:			; use # of word as v1_kernel label
                                     0015       	
              7B   00001D4E'EF   D0  0015   577 	movl	v_radix,-(r11)	; put radix on stack
                   000001CD'EF   16  001C   578 	jsb	i_div_mod	; get next digit
                   00000E5A'EF   16  0022   579 	jsb	tochar		; make it appropriate ascii char
                   000006AC'EF   16  0028   580 	jsb	hold		; put in output string
                                 05  002E   581 	rsb			; end of #
                                     002F   582 
                                     002F   583 
                                     002F   584 ;+++
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  45
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     002F   585 ;k> #> -- ( n1 -- a n2 ) End numeric output.  Leaves length and address of
                                     002F   586 ;	numeric text on stack for { write }.
                                     002F   587 ;---
                                     002F   588 	header	i_sharp_greater,^\#>\
                           FFFFFFFC  002F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0033       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0033       	.nchr  nchr, ^\#>\	; nchr = length( #> )
                           00000002  0033       	.if    le, nchr		; nchr <= 0
                                     0033       	   .ascic \i_sharp_greater\	; no auxillary #>, use principle one
                                     0033       	.if_false		; else
                           3E 23 00' 0033       	  .ascic \#>\		; use auxillary #>
                                 02  0033       
                                     0036       	.endc			; end if
                                     0036       i_sharp_greater:			; use #> of word as v1_kernel label
                                     0036       	
              6B   00001D52'EF   D0  0036   589 	movl	v_hld,(r11)		; drop number, put address of output
                                     003D   590 					; on stack
         50   00000109 8F   59   C1  003D   591 	addl3	r9,#c_pad_moat,r0	; get address of pad
         7B   50   00001D52'EF   C3  0045   592 	subl3	v_hld,r0,-(r11)		; put count on stack
                                     004D   593 					; count = pad - hld
                                 05  004D   594 	rsb				; end of #>
                                     004E   595 
                                     004E   596 
                                     004E   597 ;+++
                                     004E   598 ;k> #s -- ( n1 -- n2 ) Convert all all digits of n1 to output string.  Leaves 0.
                                     004E   599 ;	Used between { <# } and { #> }.
                                     004E   600 ;---
                                     004E   601 	header	i_sharp_s,<#s>
                           FFFFFFFC  004E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0052       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0052       	.nchr  nchr, ^\#s\	; nchr = length( #s )
                           00000002  0052       	.if    le, nchr		; nchr <= 0
                                     0052       	   .ascic \i_sharp_s\	; no auxillary #s, use principle one
                                     0052       	.if_false		; else
                           73 23 00' 0052       	  .ascic \#s\		; use auxillary #s
                                 02  0052       
                                     0055       	.endc			; end if
                                     0055       i_sharp_s:			; use #s of word as v1_kernel label
                                     0055       	
                         BD AF   16  0055   602 	jsb	i_sharp			; output at least one character
                            6B   D5  0058   603 	tstl	(r11)			; is top not = 0?
                            F9   12  005A   604 	bneq	i_sharp_s		; yes, do it again
                                 05  005C   605 	rsb				; no, exit
                                     005D   606 					; end of #s
                                     005D   607 
                                     005D   608 
                                     005D   609 ;+++
                                     005D   610 ;k> (# -- ( -- ) Start count of items on the stack.  Used with { #) }.
                                     005D   611 ;	Uses the loop stack!
                                     005D   612 ;---
                                     005D   613 	header	i_count_begin,<(#>
                           FFFFFFFC  005D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0061       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0061       	.nchr  nchr, ^\(#\	; nchr = length( (# )
                           00000002  0061       	.if    le, nchr		; nchr <= 0
                                     0061       	   .ascic \i_count_begin\	; no auxillary (#, use principle one
                                     0061       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  46
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           23 28 00' 0061       	  .ascic \(#\		; use auxillary (#
                                 02  0061       
                                     0064       	.endc			; end if
                                     0064       i_count_begin:			; use (# of word as v1_kernel label
                                     0064       	
                       7A   5B   D0  0064   614 	movl	r11,-(r10)		; save address of top of stack
                                 05  0067   615 	rsb				; end of (#
                                     0068   616 
                                     0068   617 
                                     0068   618 ;+++
                                     0068   619 ;k> (and) -- ( n1 n2 -- n3 ) bitwise and of n1 and n2.
                                     0068   620 ;---
                                     0068   621 	header	i_bit_and,<(and)>
                           FFFFFFFC  0068       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  006C       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  006C       	.nchr  nchr, ^\(and)\	; nchr = length( (and) )
                           00000005  006C       	.if    le, nchr		; nchr <= 0
                                     006C       	   .ascic \i_bit_and\	; no auxillary (and), use principle one
                                     006C       	.if_false		; else
                  29 64 6E 61 28 00' 006C       	  .ascic \(and)\		; use auxillary (and)
                                 05  006C       
                                     0072       	.endc			; end if
                                     0072       i_bit_and:			; use (and) of word as v1_kernel label
                                     0072       	
                       6B   6B   D2  0072   622 	mcoml	(r11),(r11)		; make ones comp because blc ones
                                     0075   623 					; comps mask
                       6B   8B   CA  0075   624 	bicl2	(r11)+,(r11)		; and it
                                 05  0078   625 	rsb				; end of (and)
                                     0079   626 
                                     0079   627 
                                     0079   628 ;+++
                                     0079   629 ;k> (not) -- ( n1 n2 -- n3 ) bitwise not of n1 and n2.
                                     0079   630 ;---
                                     0079   631 	header	i_bit_not,<(not)>
                           FFFFFFFC  0079       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  007D       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  007D       	.nchr  nchr, ^\(not)\	; nchr = length( (not) )
                           00000005  007D       	.if    le, nchr		; nchr <= 0
                                     007D       	   .ascic \i_bit_not\	; no auxillary (not), use principle one
                                     007D       	.if_false		; else
                  29 74 6F 6E 28 00' 007D       	  .ascic \(not)\		; use auxillary (not)
                                 05  007D       
                                     0083       	.endc			; end if
                                     0083       i_bit_not:			; use (not) of word as v1_kernel label
                                     0083       	
                       6B   6B   D2  0083   632 	mcoml	(r11),(r11)		; not it
                                 05  0086   633 	rsb				; end of (not)
                                     0087   634 
                                     0087   635 
                                     0087   636 ;+++
                                     0087   637 ;k> (or) -- ( n1 n2 -- n3 ) bitwise or of n1 and n2.
                                     0087   638 ;---
                                     0087   639 	header	i_bit_or,<(or)>
                           FFFFFFFC  0087       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  008B       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  008B       	.nchr  nchr, ^\(or)\	; nchr = length( (or) )
                           00000004  008B       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  47
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     008B       	   .ascic \i_bit_or\	; no auxillary (or), use principle one
                                     008B       	.if_false		; else
                     29 72 6F 28 00' 008B       	  .ascic \(or)\		; use auxillary (or)
                                 04  008B       
                                     0090       	.endc			; end if
                                     0090       i_bit_or:			; use (or) of word as v1_kernel label
                                     0090       	
                       6B   8B   C8  0090   640 	bisl2	(r11)+,(r11)		; or it
                                 05  0093   641 	rsb				; end of (or)
                                     0094   642 
                                     0094   643 
                                     0094   644 ;+++
                                     0094   645 ;k> (xor) -- ( n1 n2 -- n3) bitwise xor of n1 and n2.
                                     0094   646 ;---
                                     0094   647 	header	i_bit_xor,<(xor)>
                           FFFFFFFC  0094       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0098       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  0098       	.nchr  nchr, ^\(xor)\	; nchr = length( (xor) )
                           00000005  0098       	.if    le, nchr		; nchr <= 0
                                     0098       	   .ascic \i_bit_xor\	; no auxillary (xor), use principle one
                                     0098       	.if_false		; else
                  29 72 6F 78 28 00' 0098       	  .ascic \(xor)\		; use auxillary (xor)
                                 05  0098       
                                     009E       	.endc			; end if
                                     009E       i_bit_xor:			; use (xor) of word as v1_kernel label
                                     009E       	
                       6B   8B   CC  009E   648 	xorl2	(r11)+,(r11)		; xor it
                                 05  00A1   649 	rsb				; end of (xor)
                                     00A2   650 
                                     00A2   651 
                                     00A2   652 ;+++t
                                     00A2   653 ;k> * -- ( n1 n2 -- n3) multiply top two stack items, leave result on stack.
                                     00A2   654 ;---
                                     00A2   655 	header	i_multiply,<*>
                           FFFFFFFC  00A2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00A6       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  00A6       	.nchr  nchr, ^\*\	; nchr = length( * )
                           00000001  00A6       	.if    le, nchr		; nchr <= 0
                                     00A6       	   .ascic \i_multiply\	; no auxillary *, use principle one
                                     00A6       	.if_false		; else
                              2A 00' 00A6       	  .ascic \*\		; use auxillary *
                                 01  00A6       
                                     00A8       	.endc			; end if
                                     00A8       i_multiply:			; use * of word as v1_kernel label
                                     00A8       	
                       6B   8B   C4  00A8   656 	mull2	(r11)+,(r11)		; multiply them
                                 05  00AB   657 	rsb				; end of *
                                     00AC   658 
                                     00AC   659 
                                     00AC   660 ;+++
                                     00AC   661 ;k> #) -- ( -- n ) Return number of items on stack since last { (# }.
                                     00AC   662 ;	uses the loop stack!
                                     00AC   663 ;---
                                     00AC   664 	header	i_count_end,<#)>
                           FFFFFFFC  00AC       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00B0       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  00B0       	.nchr  nchr, ^\#)\	; nchr = length( #) )
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  48
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000002  00B0       	.if    le, nchr		; nchr <= 0
                                     00B0       	   .ascic \i_count_end\	; no auxillary #), use principle one
                                     00B0       	.if_false		; else
                           29 23 00' 00B0       	  .ascic \#)\		; use auxillary #)
                                 02  00B0       
                                     00B3       	.endc			; end if
                                     00B3       i_count_end:			; use #) of word as v1_kernel label
                                     00B3       	
                  7B   8A   5B   C3  00B3   665 	subl3	r11,(r10)+,-(r11)	; number of bytes difference in
                                     00B7   666 					; top of stack then and now.
                       6B   04   C6  00B7   667 	divl2	#4,(r11)		; divide to get number of stack
                                     00BA   668 					; items (longwords)
                                 05  00BA   669 	rsb				; end of #)
                                     00BB   670 
                                     00BB   671 
                                     00BB   672 ;+++t
                                     00BB   673 ;k> + -- ( n1 n2 -- n3 ) add the top two stack items, leave result on stack.
                                     00BB   674 ;---
                                     00BB   675 	header	i_add,<+>
                           FFFFFFFC  00BB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00BF       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  00BF       	.nchr  nchr, ^\+\	; nchr = length( + )
                           00000001  00BF       	.if    le, nchr		; nchr <= 0
                                     00BF       	   .ascic \i_add\	; no auxillary +, use principle one
                                     00BF       	.if_false		; else
                              2B 00' 00BF       	  .ascic \+\		; use auxillary +
                                 01  00BF       
                                     00C1       	.endc			; end if
                                     00C1       i_add:			; use + of word as v1_kernel label
                                     00C1       	
                       6B   8B   C0  00C1   676 	addl2	(r11)+,(r11)		; add them and leave the result on stack
                                 05  00C4   677 	rsb				; end of +
                                     00C5   678 
                                     00C5   679 
                                     00C5   680 ;+++
                                     00C5   681 ;k> +! -- ( n a -- ) Adds `n' to contents of `a'.
                                     00C5   682 ;---
                                     00C5   683 	header	i_plus_store,<+!>
                           FFFFFFFC  00C5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00C9       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  00C9       	.nchr  nchr, ^\+!\	; nchr = length( +! )
                           00000002  00C9       	.if    le, nchr		; nchr <= 0
                                     00C9       	   .ascic \i_plus_store\	; no auxillary +!, use principle one
                                     00C9       	.if_false		; else
                           21 2B 00' 00C9       	  .ascic \+!\		; use auxillary +!
                                 02  00C9       
                                     00CC       	.endc			; end if
                                     00CC       i_plus_store:			; use +! of word as v1_kernel label
                                     00CC       	
                                     00CC   684 ; Add top of stack to cents of address that is top of stack.
                 00 BB   04 AB   C0  00CC   685 	addl2	   4(r11),@(r11)	;
                       5B   08   C0  00D1   686 	addl2	   #8,r11		; pop arguments
                                 05  00D4   687 	rsb				; end of +!
                                     00D5   688 
                                     00D5   689 
                                     00D5   690 ;+++
                                     00D5   691 ;k> +rot - (n1 n2 n3 -- n3 n1 n2 ) rotate top 3 items on the stack up,
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  49
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     00D5   692 ;	bringing the second to the top.
                                     00D5   693 ;---
                                     00D5   694 	header	i_plus_rot,<+rot>
                           FFFFFFFC  00D5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00D9       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  00D9       	.nchr  nchr, ^\+rot\	; nchr = length( +rot )
                           00000004  00D9       	.if    le, nchr		; nchr <= 0
                                     00D9       	   .ascic \i_plus_rot\	; no auxillary +rot, use principle one
                                     00D9       	.if_false		; else
                     74 6F 72 2B 00' 00D9       	  .ascic \+rot\		; use auxillary +rot
                                 04  00D9       
                                     00DE       	.endc			; end if
                                     00DE       i_plus_rot:			; use +rot of word as v1_kernel label
                                     00DE       	
                       50   6B   D0  00DE   695 	movl	(r11),r0		; t1 = n3
                    6B   04 AB   D0  00E1   696 	movl	4(r11),(r11)		; n3 = n2
                 04 AB   08 AB   D0  00E5   697 	movl	8(r11),4(r11)		; n2 = n1
                    08 AB   50   D0  00EA   698 	movl	r0,8(r11)		; n1 = t1 (old n3)
                                 05  00EE   699 	rsb				; end of +rot
                                     00EF   700 
                                     00EF   701 
                                     00EF   702 ;+++
                                     00EF   703 ;k> , -- ( n -- ) Compile a longword `n' into the dictionary.
                                     00EF   704 ;---
                                     00EF   705 	header	i_comma,<,>
                           FFFFFFFC  00EF       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00F3       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  00F3       	.nchr  nchr, ^\,\	; nchr = length( , )
                           00000001  00F3       	.if    le, nchr		; nchr <= 0
                                     00F3       	   .ascic \i_comma\	; no auxillary ,, use principle one
                                     00F3       	.if_false		; else
                              2C 00' 00F3       	  .ascic \,\		; use auxillary ,
                                 01  00F3       
                                     00F5       	.endc			; end if
                                     00F5       i_comma:			; use , of word as v1_kernel label
                                     00F5       	
                       89   8B   D0  00F5   706 	movl	(r11)+,(r9)+		; store longword in dictionary
                                 05  00F8   707 	rsb				; end of ,
                                     00F9   708 
                                     00F9   709 
                                     00F9   710 ;+++t
                                     00F9   711 ;k> - -- ( n1 n2 -- n3 ) subtract the top stack item from the next stack item.
                                     00F9   712 ;---
                                     00F9   713 	header	i_subtract,<->
                           FFFFFFFC  00F9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00FD       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  00FD       	.nchr  nchr, ^\-\	; nchr = length( - )
                           00000001  00FD       	.if    le, nchr		; nchr <= 0
                                     00FD       	   .ascic \i_subtract\	; no auxillary -, use principle one
                                     00FD       	.if_false		; else
                              2D 00' 00FD       	  .ascic \-\		; use auxillary -
                                 01  00FD       
                                     00FF       	.endc			; end if
                                     00FF       i_subtract:			; use - of word as v1_kernel label
                                     00FF       	
                       6B   8B   C2  00FF   714 	subl2	(r11)+,(r11)		; subract and leave result on stack.
                                 05  0102   715 	rsb				; end of -
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  50
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0103   716 
                                     0103   717 
                                     0103   718 ;+++
                                     0103   719 ;k> -rot -- ( n1 n2 n3 -- n2 n3 n1 ) rotate top 3 items on the stack down,
                                     0103   720 ;	bringing the third to the top.
                                     0103   721 ;---
                                     0103   722 	header	i_minus_rot,<-rot>
                           FFFFFFFC  0103       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0107       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  0107       	.nchr  nchr, ^\-rot\	; nchr = length( -rot )
                           00000004  0107       	.if    le, nchr		; nchr <= 0
                                     0107       	   .ascic \i_minus_rot\	; no auxillary -rot, use principle one
                                     0107       	.if_false		; else
                     74 6F 72 2D 00' 0107       	  .ascic \-rot\		; use auxillary -rot
                                 04  0107       
                                     010C       	.endc			; end if
                                     010C       i_minus_rot:			; use -rot of word as v1_kernel label
                                     010C       	
                    50   08 AB   D0  010C   723 	movl	8(r11),r0		; t1 = n1
                 08 AB   04 AB   D0  0110   724 	movl	4(r11),8(r11)		; n1 = n2
                    04 AB   6B   D0  0115   725 	movl	(r11),4(r11)		; n2 = n3
                       6B   50   D0  0119   726 	movl	r0,(r11)		; n3 = n1
                                 05  011C   727 	rsb				; end of -rot
                                     011D   728 
                                     011D   729 
                                     011D   730 ;+++
                                     011D   731 ;k> . -- ( n -- ) output the top of the stack as a signed number and pop it.
                                     011D   732 ;---
                                     011D   733 	header	i_dot,<.>
                           FFFFFFFC  011D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0121       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  0121       	.nchr  nchr, ^\.\	; nchr = length( . )
                           00000001  0121       	.if    le, nchr		; nchr <= 0
                                     0121       	   .ascic \i_dot\	; no auxillary ., use principle one
                                     0121       	.if_false		; else
                              2E 00' 0121       	  .ascic \.\		; use auxillary .
                                 01  0121       
                                     0123       	.endc			; end if
                                     0123       i_dot:			; use . of word as v1_kernel label
                                     0123       	
                       7A   6B   D0  0123   734 	movl	(r11),-(r10)		; dup ds>ls
                   000003AE'EF   16  0126   735 	jsb	abs			; abs
                   00000239'EF   16  012C   736 	jsb	i_less_sharp		; <#
                       FF1F CF   16  0132   737 	jsb	i_sharp_s		; #s
                       7B   8A   D0  0136   738 	movl	(r10)+,-(r11)		; ls>ds
                   00000B7C'EF   16  0139   739 	jsb	sign			; sign
                       FEF3 CF   16  013F   740 	jsb	i_sharp_greater		; #>
                   00000FE9'EF   16  0143   741 	jsb	write			; output it
                       7B   20   D0  0149   742 	movl	#c_blank,-(r11)		; put space on stack
                   00000987'EF   16  014C   743 	jsb	putc			; output it
                                 05  0152   744 	rsb				; end of .
                                     0153   745 
                                     0153   746 
                                     0153   747 ;+++
                                     0153   748 ;k> .( -- ( -- ) write the text following until the next `)' to the screen.
                                     0153   749 ;	This word should only be used *OUTSIDE* a definition (i.e.,
                                     0153   750 ;	in execute mode).
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  51
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0153   751 ;---
                                     0153   752 	header	i_dot_lparen,<.(>
                           FFFFFFFC  0153       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0157       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0157       	.nchr  nchr, ^\.(\	; nchr = length( .( )
                           00000002  0157       	.if    le, nchr		; nchr <= 0
                                     0157       	   .ascic \i_dot_lparen\	; no auxillary .(, use principle one
                                     0157       	.if_false		; else
                           28 2E 00' 0157       	  .ascic \.(\		; use auxillary .(
                                 02  0157       
                                     015A       	.endc			; end if
                                     015A       i_dot_lparen:			; use .( of word as v1_kernel label
                                     015A       	
                       7B   29   D0  015A   753 	movl	#^a\)\,-(r11)		; set up for `)' delimited token.
                   00000E7B'EF   16  015D   754 	jsb	token			; get the token
                  7B   59   01   C1  0163   755 	addl3	#1,r9,-(r11)		; address of string
                       7B   69   9A  0167   756 	movzbl	(r9),-(r11)		; get count of string on stack
                   00000FE9'EF   16  016A   757 	jsb	write			; put it on the screen
                                 05  0170   758 	rsb				; end of .(
                                     0171   759 
                                     0171   760 
                                     0171   761 ;---
                                     0171   762 ;k> .sb -- ( -- ) output the stack from the bottom up without consuming it.
                                     0171   763 ;	The last item printed is the top of the stack.
                                     0171   764 ;---
                                     0171   765 	header	i_dot_sb,<.sb>
                           FFFFFFFC  0171       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0175       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  0175       	.nchr  nchr, ^\.sb\	; nchr = length( .sb )
                           00000003  0175       	.if    le, nchr		; nchr <= 0
                                     0175       	   .ascic \i_dot_sb\	; no auxillary .sb, use principle one
                                     0175       	.if_false		; else
                        62 73 2E 00' 0175       	  .ascic \.sb\		; use auxillary .sb
                                 03  0175       
                                     0179       	.endc			; end if
                                     0179       i_dot_sb:			; use .sb of word as v1_kernel label
                                     0179       	
              7A   00001000'8F   D0  0179   766 	movl	#c_ds_start,-(r10)	; save end of stack.
                                     0180   767 10$:
                       6A   5B   D1  0180   768 	cmpl	r11,(r10)		; at top of stack yet?
                            0C   18  0183   769 	bgeq	100$			; yes, leave
                       6A   04   C2  0185   770 	subl2	#4,(r10)		; move to item
                    7B   00 BA   D0  0188   771 	movl	@(r10),-(r11)		; put item on top of stack
                         94 AF   16  018C   772 	jsb	i_dot			; print it
                            EF   11  018F   773 	brb	10$			; do it again
                                     0191   774 100$:
                       5A   04   C0  0191   775 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  0194   776 	rsb				; end of .sb
                                     0195   777 
                                     0195   778 
                                     0195   779 ;+++
                                     0195   780 ;k> .st -- ( -- ) output stack from the top down without consuming it.
                                     0195   781 ;	The last item printed is the bottom of the stack.
                                     0195   782 ;---
                                     0195   783 	header	i_dot_st,<.st>
                           FFFFFFFC  0195       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0199       	v1_kernel = -4		; where to link the next word to in this v1_kernel
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  52
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000003  0199       	.nchr  nchr, ^\.st\	; nchr = length( .st )
                           00000003  0199       	.if    le, nchr		; nchr <= 0
                                     0199       	   .ascic \i_dot_st\	; no auxillary .st, use principle one
                                     0199       	.if_false		; else
                        74 73 2E 00' 0199       	  .ascic \.st\		; use auxillary .st
                                 03  0199       
                                     019D       	.endc			; end if
                                     019D       i_dot_st:			; use .st of word as v1_kernel label
                                     019D       	
                       7A   5B   D0  019D   784 	movl	r11,-(r10)		; save sp on top of loop stack
                                     01A0   785 10$:
              00001000'8F   6A   D1  01A0   786 	cmpl	(r10),#c_ds_start	; Is stack empty?
                            0D   18  01A7   787 	bgeq	20$			; yes
                    7B   00 BA   D0  01A9   788 	movl	@(r10),-(r11)		; put item on top
                       FF72 CF   16  01AD   789 	jsb	i_dot			; print it
                       6A   04   C0  01B1   790 	addl2	#4,(r10)		; move down stack
                            EA   11  01B4   791 	brb	10$			; do it again
                                     01B6   792 20$:
                       5A   04   C0  01B6   793 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  01B9   794 	rsb				; end of .st
                                     01BA   795 
                                     01BA   796 
                                     01BA   797 ;+++t
                                     01BA   798 ;k> / -- ( n1 n2 -- n3 ) divides second stack item by top stack item, leaves
                                     01BA   799 ;	result on stack.  n3 = n1 / n2.
                                     01BA   800 ;---
                                     01BA   801 	header	i_divide,</>
                           FFFFFFFC  01BA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01BE       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  01BE       	.nchr  nchr, ^\/\	; nchr = length( / )
                           00000001  01BE       	.if    le, nchr		; nchr <= 0
                                     01BE       	   .ascic \i_divide\	; no auxillary /, use principle one
                                     01BE       	.if_false		; else
                              2F 00' 01BE       	  .ascic \/\		; use auxillary /
                                 01  01BE       
                                     01C0       	.endc			; end if
                                     01C0       i_divide:			; use / of word as v1_kernel label
                                     01C0       	
                       6B   8B   C6  01C0   802 	divl2	(r11)+,(r11)
                                 05  01C3   803 	rsb				; end of /
                                     01C4   804 
                                     01C4   805 
                                     01C4   806 ;+++
                                     01C4   807 ;k> /mod -- ( n1 n2 -- n3 n4 ) divides second stack item by top stack item,
                                     01C4   808 ;	leaves ( quotient remainder ) on the stack.  n3 = n1 / n2, n4 = n1 - (n3 * n2).
                                     01C4   809 ;---
                                     01C4   810 	header	i_div_mod,</mod>
                           FFFFFFFC  01C4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01C8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  01C8       	.nchr  nchr, ^\/mod\	; nchr = length( /mod )
                           00000004  01C8       	.if    le, nchr		; nchr <= 0
                                     01C8       	   .ascic \i_div_mod\	; no auxillary /mod, use principle one
                                     01C8       	.if_false		; else
                     64 6F 6D 2F 00' 01C8       	  .ascic \/mod\		; use auxillary /mod
                                 04  01C8       
                                     01CD       	.endc			; end if
                                     01CD       i_div_mod:			; use /mod of word as v1_kernel label
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  53
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     01CD       	
               50   04 AB   6B   C7  01CD   811 	divl3	(r11),4(r11),r0		; r0 = n1 / n2 = n3
                  51   8B   50   C5  01D2   812 	mull3	r0,(r11)+,r1		; tmp = n2 * n3
                  51   8B   51   C3  01D6   813 	subl3	r1,(r11)+,r1		; r1 = n1 - (n2 * n3) = n4
                       7B   50   D0  01DA   814 	movl	r0,-(r11)		; push n3, quotient
                       7B   51   D0  01DD   815 	movl	r1,-(r11)		; push n4, remainder
                                 05  01E0   816 	rsb				; end of /mod
                                     01E1   817 
                                     01E1   818 
                                     01E1   819 ;+++
                                     01E1   820 ;k> 1+ -- ( n -- n+1 ) Add one to the top of the stack.
                                     01E1   821 ;---
                                     01E1   822 	header	i_one_plus,<1+>
                           FFFFFFFC  01E1       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01E5       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  01E5       	.nchr  nchr, ^\1+\	; nchr = length( 1+ )
                           00000002  01E5       	.if    le, nchr		; nchr <= 0
                                     01E5       	   .ascic \i_one_plus\	; no auxillary 1+, use principle one
                                     01E5       	.if_false		; else
                           2B 31 00' 01E5       	  .ascic \1+\		; use auxillary 1+
                                 02  01E5       
                                     01E8       	.endc			; end if
                                     01E8       i_one_plus:			; use 1+ of word as v1_kernel label
                                     01E8       	
                            6B   D6  01E8   823 	incl	(r11)			; dd one to the top of the stack.
                                 05  01EA   824 	rsb				; end of 1+
                                     01EB   825 
                                     01EB   826 
                                     01EB   827 ;+++
                                     01EB   828 ;k> 1- -- ( n -- n-1 ) Subtract one from the top of the stack.
                                     01EB   829 ;---
                                     01EB   830 	header	i_one_minus,<1->
                           FFFFFFFC  01EB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01EF       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  01EF       	.nchr  nchr, ^\1-\	; nchr = length( 1- )
                           00000002  01EF       	.if    le, nchr		; nchr <= 0
                                     01EF       	   .ascic \i_one_minus\	; no auxillary 1-, use principle one
                                     01EF       	.if_false		; else
                           2D 31 00' 01EF       	  .ascic \1-\		; use auxillary 1-
                                 02  01EF       
                                     01F2       	.endc			; end if
                                     01F2       i_one_minus:			; use 1- of word as v1_kernel label
                                     01F2       	
                            6B   D7  01F2   831 	decl	(r11)			; subtract one from top of stack
                                 05  01F4   832 	rsb				; end of 1-
                                     01F5   833 
                                     01F5   834 
                                     01F5   835 ;+++
                                     01F5   836 ;k> : -- ( -- ) (colon) defining word that starts a word definition.
                                     01F5   837 ;	sets { mode } to true
                                     01F5   838 ;	Note that { : } is a compiling word an so is in compiler vocab.
                                     01F5   839 ;---
                                     01F5   840 	header	i_colon,<:>
                           FFFFFFFC  01F5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01F9       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  01F9       	.nchr  nchr, ^\:\	; nchr = length( : )
                           00000001  01F9       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  54
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     01F9       	   .ascic \i_colon\	; no auxillary :, use principle one
                                     01F9       	.if_false		; else
                              3A 00' 01F9       	  .ascic \:\		; use auxillary :
                                 01  01F9       
                                     01FB       	.endc			; end if
                                     01FB       i_colon:			; use : of word as v1_kernel label
                                     01FB       	
     00001D37'EF   00001D3B'EF   D0  01FB   841 	movl	v_current,v_context	; search same vocab we are defining into
                   000003DB'EF   16  0206   842 	jsb	create			; create header for new word
                                     020C   843 ;??? Should I now set the high bit in the length byte (To prevent word from
                                     020C   844 ; being found during its own definition)?
                   00000B93'EF   16  020C   845 	jsb	smudge			; set smudge bit so word isn't found
           00001D4D'EF   FF 8F   90  0212   846 	movb	#c_true,v_mode		; set compiler v_mode
                                 05  021A   847 	rsb				; end of :
                                     021B   848 
                                     021B   849 
                                     021B   850 ;+++t
                                     021B   851 ;k> < -- ( n1 n2 -- f ) true if n1 < n2, false otherwise.
                                     021B   852 ;---
                                     021B   853 	header	i_less,^\<\
                           FFFFFFFC  021B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  021F       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  021F       	.nchr  nchr, ^\<\	; nchr = length( < )
                           00000001  021F       	.if    le, nchr		; nchr <= 0
                                     021F       	   .ascic \i_less\	; no auxillary <, use principle one
                                     021F       	.if_false		; else
                              3C 00' 021F       	  .ascic \<\		; use auxillary <
                                 01  021F       
                                     0221       	.endc			; end if
                                     0221       i_less:			; use < of word as v1_kernel label
                                     0221       	
                       8B   8B   D1  0221   854 	cmpl	(r11)+,(r11)+		; reverse order, so n2 > n1
                            04   14  0224   855 	bgtr	10$			; yes
                       7B   00   D0  0226   856 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0229   857 	rsb				; return
                                     022A   858 10$:
              7B   FFFFFFFF 8F   D0  022A   859 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0231   860 	rsb				; end of <
                                     0232   861 
                                     0232   862 
                                     0232   863 ;+++
                                     0232   864 ;k> <# -- ( -- ) start numeric output conversion.
                                     0232   865 ;---
                                     0232   866 	header	i_less_sharp,^\<#\
                           FFFFFFFC  0232       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0236       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0236       	.nchr  nchr, ^\<#\	; nchr = length( <# )
                           00000002  0236       	.if    le, nchr		; nchr <= 0
                                     0236       	   .ascic \i_less_sharp\	; no auxillary <#, use principle one
                                     0236       	.if_false		; else
                           23 3C 00' 0236       	  .ascic \<#\		; use auxillary <#
                                 02  0236       
                                     0239       	.endc			; end if
                                     0239       i_less_sharp:			; use <# of word as v1_kernel label
                                     0239       	
00001D52'EF   00000109'EF   59   C1  0239   867 	addl3	r9,c_pad_moat,v_hld	; pad hld !
                                 05  0245   868 	rsb				; end of <#
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  55
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0246   869 
                                     0246   870 
                                     0246   871 ;+++t
                                     0246   872 ;k> <= -- ( n1 n2 -- f ) true if n1 <= n2, false otherwise.
                                     0246   873 ;---
                                     0246   874 	header	i_less_equal,^\<=\
                           FFFFFFFC  0246       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  024A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  024A       	.nchr  nchr, ^\<=\	; nchr = length( <= )
                           00000002  024A       	.if    le, nchr		; nchr <= 0
                                     024A       	   .ascic \i_less_equal\	; no auxillary <=, use principle one
                                     024A       	.if_false		; else
                           3D 3C 00' 024A       	  .ascic \<=\		; use auxillary <=
                                 02  024A       
                                     024D       	.endc			; end if
                                     024D       i_less_equal:			; use <= of word as v1_kernel label
                                     024D       	
                       8B   8B   D1  024D   875 	cmpl	(r11)+,(r11)+		; reverse order, so n2 >= n1
                            04   18  0250   876 	bgeq	10$			; yes
                       7B   00   D0  0252   877 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0255   878 	rsb				; return
                                     0256   879 10$:
              7B   FFFFFFFF 8F   D0  0256   880 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  025D   881 	rsb				; end of <
                                     025E   882 
                                     025E   883 
                                     025E   884 ;+++t
                                     025E   885 ;k> = -- ( n1 n2 -- f ) true if n1 = n2, false otherwise
                                     025E   886 ;---
                                     025E   887 	header	i_equal,<=>
                           FFFFFFFC  025E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0262       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  0262       	.nchr  nchr, ^\=\	; nchr = length( = )
                           00000001  0262       	.if    le, nchr		; nchr <= 0
                                     0262       	   .ascic \i_equal\	; no auxillary =, use principle one
                                     0262       	.if_false		; else
                              3D 00' 0262       	  .ascic \=\		; use auxillary =
                                 01  0262       
                                     0264       	.endc			; end if
                                     0264       i_equal:			; use = of word as v1_kernel label
                                     0264       	
                       8B   8B   D1  0264   888 	cmpl	(r11)+,(r11)+		; n2 = n1?
                            04   13  0267   889 	beql	10$			; yes
                       7B   00   D0  0269   890 	movl	#c_false,-(r11)		; no, leave with false
                                 05  026C   891 	rsb				; return
                                     026D   892 10$:
              7B   FFFFFFFF 8F   D0  026D   893 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0274   894 	rsb				; end of =
                                     0275   895 
                                     0275   896 
                                     0275   897 ;+++
                                     0275   898 ;K> =text -- ( a1 a2 n -- f ) compare strings of length `n' at `a1' and `a2',
                                     0275   899 ;	return true if they are equal, false otherwise.
                                     0275   900 ;---
                                     0275   901 	header	i_equal_text,<=text>
                           FFFFFFFC  0275       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0279       	v1_kernel = -4		; where to link the next word to in this v1_kernel
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  56
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000005  0279       	.nchr  nchr, ^\=text\	; nchr = length( =text )
                           00000005  0279       	.if    le, nchr		; nchr <= 0
                                     0279       	   .ascic \i_equal_text\	; no auxillary =text, use principle one
                                     0279       	.if_false		; else
                  74 78 65 74 3D 00' 0279       	  .ascic \=text\		; use auxillary =text
                                 05  0279       
                                     027F       	.endc			; end if
                                     027F       i_equal_text:			; use =text of word as v1_kernel label
                                     027F       	
            08 BB   04 BB   6B   29  027F   902 	cmpc3	(r11),@4(r11),@8(r11)	; Are they equal>
                            0B   12  0285   903 	bneq	10$			; no
                       5B   0C   C0  0287   904 	addl2	#12,r11			; pop arguments
              7B   FFFFFFFF 8F   D0  028A   905 	movl	#c_true,-(r11)		; yes, leave true
                                 05  0291   906 	rsb				; return
                                     0292   907 10$:
                       5B   0C   C0  0292   908 	addl2	#12,r11			; pop arguments
                       7B   00   D0  0295   909 	movl	#c_false,-(r11)		; no, they aren't equal, leave false.
                                 05  0298   910 	rsb				; end of =text
                                     0299   911 
                                     0299   912 
                                     0299   913 ;+++t
                                     0299   914 ;k> > -- ( n1 n2 -- f ) true if n1 > n2, false otherwise.
                                     0299   915 ;---
                                     0299   916 	header	i_greter,^\>\
                           FFFFFFFC  0299       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  029D       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  029D       	.nchr  nchr, ^\>\	; nchr = length( > )
                           00000001  029D       	.if    le, nchr		; nchr <= 0
                                     029D       	   .ascic \i_greter\	; no auxillary >, use principle one
                                     029D       	.if_false		; else
                              3E 00' 029D       	  .ascic \>\		; use auxillary >
                                 01  029D       
                                     029F       	.endc			; end if
                                     029F       i_greter:			; use > of word as v1_kernel label
                                     029F       	
                       8B   8B   D1  029F   917 	cmpl	(r11)+,(r11)+		; reverse order, so n2 < n1
                            04   19  02A2   918 	blss	10$			; yes
                       7B   00   D0  02A4   919 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02A7   920 	rsb				; return
                                     02A8   921 10$:
                       7B   00   D0  02A8   922 	movl	#c_false,-(r11)		; yes, leave with false
                                 05  02AB   923 	rsb				; end of >
                                     02AC   924 
                                     02AC   925 
                                     02AC   926 ;+++t
                                     02AC   927 ;k> >= -- ( n1 n2 -- f ) true if n1 >= n2; false otherwise.
                                     02AC   928 ;---
                                     02AC   929 	header	i_greater_equal,^\>=\
                           FFFFFFFC  02AC       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02B0       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  02B0       	.nchr  nchr, ^\>=\	; nchr = length( >= )
                           00000002  02B0       	.if    le, nchr		; nchr <= 0
                                     02B0       	   .ascic \i_greater_equal\	; no auxillary >=, use principle one
                                     02B0       	.if_false		; else
                           3D 3E 00' 02B0       	  .ascic \>=\		; use auxillary >=
                                 02  02B0       
                                     02B3       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  57
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     02B3       i_greater_equal:			; use >= of word as v1_kernel label
                                     02B3       	
                       8B   8B   D1  02B3   930 	cmpl	(r11)+,(r11)+		; reverse order, so n2 <= n1
                            04   15  02B6   931 	bleq	10$			; yes
                       7B   00   D0  02B8   932 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02BB   933 	rsb				; return
                                     02BC   934 10$:
              7B   FFFFFFFF 8F   D0  02BC   935 	movl	#c_true,-(r11)		; yes, leave with false
                                 05  02C3   936 	rsb				; end of >=
                                     02C4   937 
                                     02C4   938 
                                     02C4   939 ;+++
                                     02C4   940 ;k> ? -- ( a -- ) Output contents of `a' as a long in current radix.
                                     02C4   941 ;---
                                     02C4   942 ; Remark on the internal name of this word: { header q_,<?> } is aesthetically
                                     02C4   943 ; displeasing, so make it i_question by analogoy with i_dot for { . }.
                                     02C4   944 	header	i_question,<?>
                           FFFFFFFC  02C4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02C8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  02C8       	.nchr  nchr, ^\?\	; nchr = length( ? )
                           00000001  02C8       	.if    le, nchr		; nchr <= 0
                                     02C8       	   .ascic \i_question\	; no auxillary ?, use principle one
                                     02C8       	.if_false		; else
                              3F 00' 02C8       	  .ascic \?\		; use auxillary ?
                                 01  02C8       
                                     02CA       	.endc			; end if
                                     02CA       i_question:			; use ? of word as v1_kernel label
                                     02CA       	
                    6B   00 BB   D0  02CA   945 	movl	@(r11),(r11)		; get contents of `a'.
                       FE51 CF   16  02CE   946 	jsb	i_dot			; print contents
                                 05  02D2   947 	rsb				; end of ?
                                     02D3   948 
                                     02D3   949 
                                     02D3   950 ;+++
                                     02D3   951 ;k> ?cr -- ( -- ) start a new line unless already at beginning of line.
                                     02D3   952 ;---
                                     02D3   953 	header	q_cr,<?cr>
                           FFFFFFFC  02D3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02D7       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  02D7       	.nchr  nchr, ^\?cr\	; nchr = length( ?cr )
                           00000003  02D7       	.if    le, nchr		; nchr <= 0
                                     02D7       	   .ascic \q_cr\	; no auxillary ?cr, use principle one
                                     02D7       	.if_false		; else
                        72 63 3F 00' 02D7       	  .ascic \?cr\		; use auxillary ?cr
                                 03  02D7       
                                     02DB       	.endc			; end if
                                     02DB       q_cr:			; use ?cr of word as v1_kernel label
                                     02DB       	
                   00001B98'EF   B5  02DB   954 	tstw	v_outlen		; At beginning of line?
                            06   13  02E1   955 	beql	10$			; yes, exit
                   000003A7'EF   16  02E3   956 	jsb	cr			; no, start new line
                                     02E9   957 10$:
                                 05  02E9   958 	rsb				; end of ?cr
                                     02EA   959 
                                     02EA   960 
                                     02EA   961 ;+++
                                     02EA   962 ;k> ?dup -- ( f -- f ? f ) Duplicate top of stack only if it is true (non-zero).
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  58
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     02EA   963 ;	Used so don't always have to drop 0 in else.
                                     02EA   964 ;---
                                     02EA   965 	header	q_dup,<?dup>
                           FFFFFFFC  02EA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02EE       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  02EE       	.nchr  nchr, ^\?dup\	; nchr = length( ?dup )
                           00000004  02EE       	.if    le, nchr		; nchr <= 0
                                     02EE       	   .ascic \q_dup\	; no auxillary ?dup, use principle one
                                     02EE       	.if_false		; else
                     70 75 64 3F 00' 02EE       	  .ascic \?dup\		; use auxillary ?dup
                                 04  02EE       
                                     02F3       	.endc			; end if
                                     02F3       q_dup:			; use ?dup of word as v1_kernel label
                                     02F3       	
                            6B   D5  02F3   966 	tstl	(r11)			; is it zero?
                            03   13  02F5   967 	beql	10$			; yes, don't duplicate it.
                       7B   6B   D0  02F7   968 	movl	(r11),-(r11)		; no, duplicate it.
                                     02FA   969 10$:
                                 05  02FA   970 	rsb				; end of ?dup
                                     02FB   971 
                                     02FB   972 
                                     02FB   973 ;+++
                                     02FB   974 ;k> ?n-cr -- ( n -- ) starts new line on terminal if < n chars left on line.
                                     02FB   975 ;---
                                     02FB   976 	header	q_n_cr,<?n-cr>
                           FFFFFFFC  02FB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02FF       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  02FF       	.nchr  nchr, ^\?n-cr\	; nchr = length( ?n-cr )
                           00000005  02FF       	.if    le, nchr		; nchr <= 0
                                     02FF       	   .ascic \q_n_cr\	; no auxillary ?n-cr, use principle one
                                     02FF       	.if_false		; else
                  72 63 2D 6E 3F 00' 02FF       	  .ascic \?n-cr\		; use auxillary ?n-cr
                                 05  02FF       
                                     0305       	.endc			; end if
                                     0305       q_n_cr:			; use ?n-cr of word as v1_kernel label
                                     0305       	
              50   00001B98'EF   3C  0305   977 	movzwl	v_outlen,r0		; get current length of line.
         50   00000050 8F   50   C3  030C   978 	subl3	r0,#c_screen_len,r0	; get current length of line
                       50   8B   D1  0314   979 	cmpl	(r11)+,r0		; enough characers left?
                            06   19  0317   980 	blss	10$			; yes, go to return
                                     0319   981 ; no, not enough characters left on line.
                   000003A7'EF   16  0319   982 	jsb	cr			; start a new line
                                     031F   983 10$:
                                 05  031F   984 	rsb				; end of ?n-cr
                                     0320   985 
                                     0320   986 
                                     0320   987 ;+++t
                                     0320   988 ;k> ?number -- ( -- n ? f ) Convert token at eodp to a number, and if compiling
                                     0320   989 ;	enclose it as a literal in the current word.  If executing, push on
                                     0320   990 ;	the  stack.  If not a number, leave false on stack.  If a number leave
                                     0320   991 ;	a true on stack.
                                     0320   992 ;---
                                     0320   993 	header	q_number,<?number>
                           FFFFFFFC  0320       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0324       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000007  0324       	.nchr  nchr, ^\?number\	; nchr = length( ?number )
                           00000007  0324       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  59
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0324       	   .ascic \q_number\	; no auxillary ?number, use principle one
                                     0324       	.if_false		; else
            72 65 62 6D 75 6E 3F 00' 0324       	  .ascic \?number\		; use auxillary ?number
                                 07  0324       
                                     032C       	.endc			; end if
                                     032C       q_number:			; use ?number of word as v1_kernel label
                                     032C       	
                   000008B9'EF   16  032C   994 	jsb	number			; try to make it a number
                            6B   D5  0332   995 	tstl	(r11)			; is it a number?
                            18   13  0334   996 	beql	10$			; no, exit leaving false on the stack
                       5B   04   C0  0336   997 	addl2	#4,r11			; yes.	pop flag
                   00001D4D'EF   95  0339   998 	tstb	v_mode			; are we compiling?
                            06   13  033F   999 	beql	20$			; no, leaving it on stack
                   0000133C'EF   16  0341  1000 	jsb	literal			; yes, include in dictionary as
                                     0347  1001 					; a literal
                                     0347  1002 20$:
              7B   FFFFFFFF 8F   D0  0347  1003 	movl	#c_true,-(r11)		; leave with true on stack
                                     034E  1004 10$:
                                 05  034E  1005 	rsb				; end of ?number
                                     034F  1006 
                                     034F  1007 
                                     034F  1008 ;+++t
                                     034F  1009 ;k> ?search -- ( -- a ? f )  search context vocabulary for most recent token,
                                     034F  1010 ;	return false if not found, or ( addr true ) if found.  If compiling,
                                     034F  1011 ;	search compiler vocab if not found in context and set { state }
                                     034F  1012 ;	true.  Compare byte-counted string at eodp to find.
                                     034F  1013 ;---
                                     034F  1014 	header	q_search,<?search>
                           FFFFFFFC  034F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0353       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000007  0353       	.nchr  nchr, ^\?search\	; nchr = length( ?search )
                           00000007  0353       	.if    le, nchr		; nchr <= 0
                                     0353       	   .ascic \q_search\	; no auxillary ?search, use principle one
                                     0353       	.if_false		; else
            68 63 72 61 65 73 3F 00' 0353       	  .ascic \?search\		; use auxillary ?search
                                 07  0353       
                                     035B       	.endc			; end if
                                     035B       q_search:			; use ?search of word as v1_kernel label
                                     035B       	
                                     035B  1015 ;??? this next perhaps should have been
                                     035B  1016 ;	movl	@v_context,(r11)
                                     035B  1017 ;	tstb	v_mode
                                     035B  1018 ;	beql	5$
                                     035B  1019 ;	movl	@(r11),(r11)
                                     035B  1020 ;5$:
                                     035B  1021 ; which would (during compilation of new words)
                                     035B  1022 ; start the search at the word before the one currently being compiled;
                                     035B  1023 ; this would allow use of older definition of word `x' in new definition
                                     035B  1024 ; of word `x'.	However, as it stands it allows easy recursion.
                                     035B  1025 ;??? changed to eliminate recusion by default, as that is probably more
                                     035B  1026 ; useful, since RECURSE is a simple way to get recusion.
                                     035B  1027 ;??? The problem with this is that if you switch ocabularies while defining
                                     035B  1028 ; a word, the new vocab (which you want to search from the first) also is
                                     035B  1029 ; searched from the second word.  Perhaps I should set the smudge bit (gasp!
                                     035B  1030 ; Horrors!).
                                     035B  1031 ; get pointer to pointer to start of vocab
              7B   00001D37'FF   D0  035B  1032 	movl @v_context,-(r11)		; get address of current word
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  60
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0362  1033 ;??? took out to test smudge bit
                                     0362  1034 ;	tstb  v_mode			; Are we compiling?
                                     0362  1035 ;	beql  5$			; no, go on.
                                     0362  1036 ; yes, so skip address of word we are defining, so we can use
                                     0362  1037 ; previous definitions of this word.
                                     0362  1038 ;	movl	@(r11),(r11)		; get address of previous word
                                     0362  1039 5$:
                   00000B1F'EF   16  0362  1040 	jsb	search			; search it
                            6B   D5  0368  1041 	tstl	(r11)			; Was it found?
                            21   12  036A  1042 	bneq	10$			; yes, exit with ( addr true ) on dstack
                   00001D4D'EF   95  036C  1043 	tstb	v_mode			; no. Are we compiling?
                            19   13  0372  1044 	beql	10$			; no, exit leaving false on dstack
              6B   00001D3F'EF   D0  0374  1045 	movl	v_compiler,(r11)	; yes, get adddress of compiler vocab
                   00000B1F'EF   16  037B  1046 	jsb	search			; search it
                            6B   D5  0381  1047 	tstl	(r11)			; Was it found?
                            08   13  0383  1048 	beql	10$			; no, exit with false on dstack
           00001D4C'EF   FF 8F   90  0385  1049 	movb	#c_true,v_state		; yes, set v_state flag
                                     038D  1050 					; exit with ( addr true ) on dstack
                                     038D  1051 10$:
                                 05  038D  1052 	rsb				; end of ?search
                                     038E  1053 ;??? Should the compiler vocabulary be searched *before* the context vocabulary
                                     038E  1054 ; when we are compiling?  This would allow defining new versions in compiler
                                     038E  1055 ; of words in context that would be more efficient during compilation (or
                                     038E  1056 ; have a different effect, or allow immediate and noimmediate words that
                                     038E  1057 ; should do the same thing, like { % }).
                                     038E  1058 
                                     038E  1059 
                                     038E  1060 
                                     038E  1061 ;+++t
                                     038E  1062 ;k> @ -- (fetch) ( a -- l ) Fetches contents of longword at `a'.
                                     038E  1063 ;---
                                     038E  1064 	header	i_fetch,<@>
                           FFFFFFFC  038E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0392       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  0392       	.nchr  nchr, ^\@\	; nchr = length( @ )
                           00000001  0392       	.if    le, nchr		; nchr <= 0
                                     0392       	   .ascic \i_fetch\	; no auxillary @, use principle one
                                     0392       	.if_false		; else
                              40 00' 0392       	  .ascic \@\		; use auxillary @
                                 01  0392       
                                     0394       	.endc			; end if
                                     0394       i_fetch:			; use @ of word as v1_kernel label
                                     0394       	
                    6B   00 BB   D0  0394  1065 	movl	@(r11),(r11)		; get contents of address at top-of-ds
                                 05  0398  1066 	rsb				; end of @
                                     0399  1067 
                                     0399  1068 
                                     0399  1069 ;+++
                                     0399  1070 ;k> abort -- ( -- ) clear data stack and restart VTIL.
                                     0399  1071 ;---
                                     0399  1072 	header	abort
                           FFFFFFFC  0399       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  039D       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  039D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  039D       	.if    le, nchr		; nchr <= 0
                  74 72 6F 62 61 00' 039D       	   .ascic \abort\	; no auxillary , use principle one
                                 05  039D       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  61
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     03A3       	.if_false		; else
                                     03A3       	  .ascic \\		; use auxillary 
                                     03A3       	.endc			; end if
                                     03A3       abort:			; use  of word as v1_kernel label
                                     03A3       	
                          123E   31  03A3  1073 	brw	r_warm_start		; end of abort
                                     03A6  1074 
                                     03A6  1075 
                                     03A6  1076 ;+++
                                     03A6  1077 ;k> abs -- ( n1 -- n2 ) Takes the absolute value of top of stack.
                                     03A6  1078 ;---
                                     03A6  1079 	header	abs
                           FFFFFFFC  03A6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  03AA       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  03AA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03AA       	.if    le, nchr		; nchr <= 0
                        73 62 61 00' 03AA       	   .ascic \abs\	; no auxillary , use principle one
                                 03  03AA       
                                     03AE       	.if_false		; else
                                     03AE       	  .ascic \\		; use auxillary 
                                     03AE       	.endc			; end if
                                     03AE       abs:			; use  of word as v1_kernel label
                                     03AE       	
                            6B   D5  03AE  1080 	tstl	(r11)			; is top of stack < 0?
                            03   18  03B0  1081 	bgeq	10$			; no, go on
                       6B   6B   CE  03B2  1082 	mnegl	(r11),(r11)		; yes, negate it
                                     03B5  1083 10$:
                                 05  03B5  1084 	rsb				; end of abs
                                     03B6  1085 
                                     03B6  1086 
                                     03B6  1087 ;+++t
                                     03B6  1088 ;k> ac: -- ( b -- ) assembler constant (makes opcode & operand defintions)
                                     03B6  1089 ;	ac creates a word that compiles the byte on the top of the stack at
                                     03B6  1090 ;	definition into the dictionary.
                                     03B6  1091 ;---
                                     03B6  1092 	header	i_ac_colon,<ac:>
                           FFFFFFFC  03B6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  03BA       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  03BA       	.nchr  nchr, ^\ac:\	; nchr = length( ac: )
                           00000003  03BA       	.if    le, nchr		; nchr <= 0
                                     03BA       	   .ascic \i_ac_colon\	; no auxillary ac:, use principle one
                                     03BA       	.if_false		; else
                        3A 63 61 00' 03BA       	  .ascic \ac:\		; use auxillary ac:
                                 03  03BA       
                                     03BE       	.endc			; end if
                                     03BE       i_ac_colon:			; use ac: of word as v1_kernel label
                                     03BE       	
                   000003DB'EF   16  03BE  1093 	jsb	create			; enclose name in dictionary
                    89   90 8F   90  03C4  1094 	movb	#op_movb,(r9)+		; `movb'
                    89   AF 8F   90  03C8  1095 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  03CC  1096 	movb	#2,(r9)+		; (pc+2)
                    89   89 8F   90  03CF  1097 	movb	#adm_ainc_r9,(r9)+	; (r9)+
                       89   05   90  03D3  1098 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  03D6  1099 	movb	(r11),(r9)+		; enclose byte value in dictionary
                       5B   04   C0  03D9  1100 	addl	#4,r11			; pop argument
                                     03DC  1101 ; Make it an compiletime word so it will compile the machine language into the
                                     03DC  1102 ; dictionary when defining a new word and will not be found otherwise.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  62
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                   0000035A'EF   16  03DC  1103 	jsb	compiletime
                                 05  03E2  1104 	rsb				; end of ac:
                                     03E3  1105 
                                     03E3  1106 
                                     03E3  1107 ;+++t
                                     03E3  1108 ;k> and -- ( f1 f2 -- f ) logical and f1 and f2
                                     03E3  1109 ;---
                                     03E3  1110 	header	and
                           FFFFFFFC  03E3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  03E7       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  03E7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03E7       	.if    le, nchr		; nchr <= 0
                        64 6E 61 00' 03E7       	   .ascic \and\	; no auxillary , use principle one
                                 03  03E7       
                                     03EB       	.if_false		; else
                                     03EB       	  .ascic \\		; use auxillary 
                                     03EB       	.endc			; end if
                                     03EB       and:			; use  of word as v1_kernel label
                                     03EB       	
                            8B   D5  03EB  1111 	tstl	(r11)+			; is first false?
                            0C   13  03ED  1112 	beql	10$			; yes
                            8B   D5  03EF  1113 	tstl	(r11)+			; no, is second false?
                            0B   13  03F1  1114 	beql	20$			; yes
              7B   FFFFFFFF 8F   D0  03F3  1115 	movl	#c_true,-(r11)		; no, both true, leave with true
                                 05  03FA  1116 	rsb				; return
                                     03FB  1117 10$:
                       6B   04   C0  03FB  1118 	addl2	#4,(r11)		; pop second item off, don't need
                                     03FE  1119 					; to check
                                     03FE  1120 20$:
                       7B   00   D0  03FE  1121 	movl	#c_false,-(r11)		; leave with false
                                 05  0401  1122 	rsb				; end of and
                                     0402  1123 
                                     0402  1124 
                                     0402  1125 ;+++
                                     0402  1126 ;k> array -- ( n -- ) create word that pushes addres of `n' bytes
                                     0402  1127 ;	which are saved in the dictionary.
                                     0402  1128 ;---
                                     0402  1129 	header	array
                           FFFFFFFC  0402       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0406       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0406       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0406       	.if    le, nchr		; nchr <= 0
                  79 61 72 72 61 00' 0406       	   .ascic \array\	; no auxillary , use principle one
                                 05  0406       
                                     040C       	.if_false		; else
                                     040C       	  .ascic \\		; use auxillary 
                                     040C       	.endc			; end if
                                     040C       array:			; use  of word as v1_kernel label
                                     040C       	
                   000003DB'EF   16  040C  1130 	jsb	create			; enclose next token in dictinary
                    89   9E 8F   90  0412  1131 	movb	#op_movab,(r9)+		; `moval'
                    89   AF 8F   90  0416  1132 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  041A  1133 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  041D  1134 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0421  1135 	movb	#op_rsb,(r9)+		; `rsb'
                       59   8B   C0  0424  1136 	addl2	(r11)+,r9		; save `n' bytes in dictionary
                                 05  0427  1137 	rsb				; end of array
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  63
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0428  1138 
                                     0428  1139 
                                     0428  1140 ;+++
                                     0428  1141 ;k> ascii -- ( -- n ) put ascii value of first character of next token on stack.
                                     0428  1142 ;	Note that this cannot be used in colon definitions!  (See { [ascii] }.)
                                     0428  1143 ;---
                                     0428  1144 	header	ascii
                           FFFFFFFC  0428       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  042C       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  042C       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  042C       	.if    le, nchr		; nchr <= 0
                  69 69 63 73 61 00' 042C       	   .ascic \ascii\	; no auxillary , use principle one
                                 05  042C       
                                     0432       	.if_false		; else
                                     0432       	  .ascic \\		; use auxillary 
                                     0432       	.endc			; end if
                                     0432       ascii:			; use  of word as v1_kernel label
                                     0432       	
                       7B   20   D0  0432  1145 	movl	#c_blank,-(r11)		; set up for blank separated token
                   00000E7B'EF   16  0435  1146 	jsb	token			; get it
                    7B   01 A9   9A  043B  1147 	movzbl	1(r9),-(r11)		; put ascii value of token on stack
                                 05  043F  1148 	rsb				; end of ascii
                                     0440  1149 
                                     0440  1150 
                                     0440  1151 ;+++
                                     0440  1152 ;k> b! -- ( b a -- ) store 8 bits of `b' at address `a'.
                                     0440  1153 ;---
                                     0440  1154 	header	i_b_store,<b!>
                           FFFFFFFC  0440       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0444       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0444       	.nchr  nchr, ^\b!\	; nchr = length( b! )
                           00000002  0444       	.if    le, nchr		; nchr <= 0
                                     0444       	   .ascic \i_b_store\	; no auxillary b!, use principle one
                                     0444       	.if_false		; else
                           21 62 00' 0444       	  .ascic \b!\		; use auxillary b!
                                 02  0444       
                                     0447       	.endc			; end if
                                     0447       i_b_store:			; use b! of word as v1_kernel label
                                     0447       	
                 00 BB   04 AB   90  0447  1155 	movb	4(r11),@(r11)		; store byte at what's pointed to by
                                     044C  1156 					; top of stack
                       5B   08   C0  044C  1157 	addl2	#8,r11			; pop arguments
                                 05  044F  1158 	rsb				; end of b!
                                     0450  1159 
                                     0450  1160 
                                     0450  1161 ;+++
                                     0450  1162 ;k> b, -- ( b -- ) store low byte of top stack entry into dictionary.
                                     0450  1163 ;---
                                     0450  1164 	header	i_b_comma,<b,>
                           FFFFFFFC  0450       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0454       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0454       	.nchr  nchr, ^\b,\	; nchr = length( b, )
                           00000002  0454       	.if    le, nchr		; nchr <= 0
                                     0454       	   .ascic \i_b_comma\	; no auxillary b,, use principle one
                                     0454       	.if_false		; else
                           2C 62 00' 0454       	  .ascic \b,\		; use auxillary b,
                                 02  0454       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  64
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0457       	.endc			; end if
                                     0457       i_b_comma:			; use b, of word as v1_kernel label
                                     0457       	
                       89   6B   90  0457  1165 	movb	(r11),(r9)+		; store in dictinary
                       5B   04   C0  045A  1166 	addl2	#4,r11			; pop argument
                                 05  045D  1167 	rsb				; end of b,
                                     045E  1168 
                                     045E  1169 
                                     045E  1170 ;+++
                                     045E  1171 ;k> b@ -- ( a -- b ) Fetch byte from address `a'.
                                     045E  1172 ;---
                                     045E  1173 	header	i_b_fetch,<b@>.
                           0000045E' 045E       	.long	.		; back link to the previous word in this .
                           FFFFFFFC  0462       	. = -4		; where to link the next word to in this .
                           00000002  FFFC       	.nchr  nchr, ^\b@\	; nchr = length( b@ )
                           00000002  FFFC       	.if    le, nchr		; nchr <= 0
                                     FFFC       	   .ascic \i_b_fetch\	; no auxillary b@, use principle one
                                     FFFC       	.if_false		; else
                           40 62 00' FFFC       	  .ascic \b@\		; use auxillary b@
                                 02  FFFC       
                                     FFFF       	.endc			; end if
                                     FFFF       i_b_fetch:			; use b@ of word as . label
                                     FFFF       	
                    6B   00 BB   9A  FFFF  1174 	movzbl	@(r11),(r11)
                                 05  0003  1175 	rsb				; end of b@
                                     0004  1176 
                                     0004  1177 
                                     0004  1178 ;+++
                                     0004  1179 ;k> bcount -- ( a -- a n ) Given the address of a byte-counted
                                     0004  1180 ;	string, leave address of first character in string and the
                                     0004  1181 ;	count of the string on the stack.
                                     0004  1182 ;---
                                     0004  1183 	header	bcount
                           FFFFFFFC  0004       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0008       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0008       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0008       	.if    le, nchr		; nchr <= 0
               74 6E 75 6F 63 62 00' 0008       	   .ascic \bcount\	; no auxillary , use principle one
                                 06  0008       
                                     000F       	.if_false		; else
                                     000F       	  .ascic \\		; use auxillary 
                                     000F       	.endc			; end if
                                     000F       bcount:			; use  of word as v1_kernel label
                                     000F       	
                    50   00 BB   9A  000F  1184 	movzbl	@(r11),r0		; get length of string
                            6B   D6  0013  1185 	incl	(r11)			; move over byte-count
                       7B   50   D0  0015  1186 	movl	r0,-(r11)		; put count on stack
                                 05  0018  1187 	rsb				; end of bcount
                                     0019  1188 
                                     0019  1189 
                                     0019  1190 ;+++
                                     0019  1191 ;k> binary -- ( -- ) Set the base to binary
                                     0019  1192 ;---
                                     0019  1193 	header	binary
                           FFFFFFFC  0019       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  001D       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  001D       	.nchr  nchr, ^\\	; nchr = length(  )
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  65
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000000  001D       	.if    le, nchr		; nchr <= 0
               79 72 61 6E 69 62 00' 001D       	   .ascic \binary\	; no auxillary , use principle one
                                 06  001D       
                                     0024       	.if_false		; else
                                     0024       	  .ascic \\		; use auxillary 
                                     0024       	.endc			; end if
                                     0024       binary:			; use  of word as v1_kernel label
                                     0024       	
              00001D4E'EF   02   D0  0024  1194 	movl	#2,v_radix		; switch to base 2
                                 05  002B  1195 	rsb				; end of binary
                                     002C  1196 
                                     002C  1197 
                                     002C  1198 ;+++
                                     002C  1199 ;k> (bl) -- ( -- c ) Pushes ascii value of a blank on the stack.
                                     002C  1200 ;---
                                     002C  1201 	header	i_bl,<(bl)>
                           FFFFFFFC  002C       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0030       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  0030       	.nchr  nchr, ^\(bl)\	; nchr = length( (bl) )
                           00000004  0030       	.if    le, nchr		; nchr <= 0
                                     0030       	   .ascic \i_bl\	; no auxillary (bl), use principle one
                                     0030       	.if_false		; else
                     29 6C 62 28 00' 0030       	  .ascic \(bl)\		; use auxillary (bl)
                                 04  0030       
                                     0035       	.endc			; end if
                                     0035       i_bl:			; use (bl) of word as v1_kernel label
                                     0035       	
                       7B   20   D0  0035  1202 	movl	#c_blank,-(r11)		; put on stack
                                 05  0038  1203 	rsb				; end of (bl)
                                     0039  1204 
                                     0039  1205 
                                     0039  1206 ;+++
                                     0039  1207 ;k> blank --- ( a w -- ) fill `w' bytes from `a' with blanks.
                                     0039  1208 ;---
                                     0039  1209 	header	blank
                           FFFFFFFC  0039       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  003D       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  003D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  003D       	.if    le, nchr		; nchr <= 0
                  6B 6E 61 6C 62 00' 003D       	   .ascic \blank\	; no auxillary , use principle one
                                 05  003D       
                                     0043       	.if_false		; else
                                     0043       	  .ascic \\		; use auxillary 
                                     0043       	.endc			; end if
                                     0043       blank:			; use  of word as v1_kernel label
                                     0043       	
                       69   00   2C  0043  1210 	movc5	#0,(r9),-		; srclen,src  use (r9) to be safe
                            20       0046  1211 		#c_blank,-		; fill with blanks
                    04 BB   6B       0047  1212 		(r11),@4(r11)		; destlen, dest
                       5B   08   C0  004A  1213 	addl2	#8,r11			; pop arguments
                                 05  004D  1214 	rsb				; end of blank
                                     004E  1215 
                                     004E  1216 
                                     004E  1217 ;+++
                                     004E  1218 ;k> block -- ( l -- a ) Get block `l' into buffer at address `a'.
                                     004E  1219 ;---
                                     004E  1220 	header	block
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  66
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           FFFFFFFC  004E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0052       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0052       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0052       	.if    le, nchr		; nchr <= 0
                  6B 63 6F 6C 62 00' 0052       	   .ascic \block\	; no auxillary , use principle one
                                 05  0052       
                                     0058       	.if_false		; else
                                     0058       	  .ascic \\		; use auxillary 
                                     0058       	.endc			; end if
                                     0058       block:			; use  of word as v1_kernel label
                                     0058       	
                                     0058  1221 ; Is the block already in memory?
                            50   D4  0058  1222 	clrl   r0			; start with buffer 0
                                     005A  1223 10$:
                            6B   D1  005A  1224 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       005C  1225 		v_buf_blk_nums[r0]	;   block we are looking for?
                            4E   13  0062  1226 	beql	100$			; yes, go on
                    F2 50   03   F2  0064  1227 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     0068  1228 ;
                                     0068  1229 ; not in memory, so we have to get it in
                                     0068  1230 ;
                                     0068  1231 ; Are there any unused buffers?
                            50   D4  0068  1232 	clrl	r0			; start with buffer 0
                                     006A  1233 20$:
                 00001B7D'EF40   95  006A  1234 	tstb	v_buf_inuse[r0]		; is it in use?
                            25   13  0071  1235 	beql	90$			; no, read block into it
                    F3 50   03   F2  0073  1236 	aoblss	#c_max_blocks,r0,20$	; move to next buffer, if any
                                     0077  1237 ; Are there any unmodified buffers?
                            50   D4  0077  1238 	clrl	r0
                                     0079  1239 30$:
                            02   91  0079  1240 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       007B  1241 		v_buf_inuse[r0]		;   been modified?
                            15   12  0081  1242 	bneq	90$			; no, read block into it
                    F2 50   03   F2  0083  1243 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     0087  1244 ; all buffers are modified, so we must write out out and use it.
                            50   D4  0087  1245 	clrl	r0			; for now, always use the zero'th one
                       7A   50   D0  0089  1246 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  008C  1247 	movl	r0,-(r11)		; set up for buffer-write
                   00000292'EF   16  008F  1248 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0095  1249 	movl	(r10)+,r0		; get the buffer number back
                                     0098  1250 ; read block into buffer
                                     0098  1251 90$:
                            6B   D0  0098  1252 	movl	(r11),-			; Save the new block number in
                 FFFFE480'EF40       009A  1253 		-v_buf_blk_nums[r0]	;   buffer
                            01   90  00A0  1254 	movb	#c_inuse,-		; flag that buffer is in use
                 00001B7D'EF40       00A2  1255 		v_buf_inuse[r0]
                       6B   50   D0  00A8  1256 	movl	r0,(r11)		; set up for buffer-read
                   00000256'EF   16  00AB  1257 	jsb	i_buffer_read		; read block into buffer
                                 05  00B1  1258 	rsb				; return
                                     00B2  1259 ;
                                     00B2  1260 ; block already in memory
                                     00B2  1261 ;
                                     00B2  1262 100$:
                                     00B2  1263 ; Comes here if block already in memory, with buffers in r0, block# on stack
         6B   00000400 8F   50   C5  00B2  1264 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  00BA  1265 	addl2	#v_blkbuff,(r11)	; calcualte addressof `r0'th buffer
              00001B79'EF   50   D0  00C1  1266 	movl	r0,v_current_buff	; mark this as most current block
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  67
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 05  00C8  1267 	rsb				; end of block
                                     00C9  1268 
                                     00C9  1269 
                                     00C9  1270 
                                     00C9  1271 ;+++
                                     00C9  1272 ;k> block-close -- ( -- ) Close the block file
                                     00C9  1273 ;---
                                     00C9  1274 	header	i_block_close,<block-close>
                           FFFFFFFC  00C9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  00CD       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000B  00CD       	.nchr  nchr, ^\block-close\	; nchr = length( block-close )
                           0000000B  00CD       	.if    le, nchr		; nchr <= 0
                                     00CD       	   .ascic \i_block_close\	; no auxillary block-close, use principle one
                                     00CD       	.if_false		; else
65 73 6F 6C 63 2D 6B 63 6F 6C 62 00' 00CD       	  .ascic \block-close\		; use auxillary block-close
                                 0B  00CD       
                                     00D9       	.endc			; end if
                                     00D9       i_block_close:			; use block-close of word as v1_kernel label
                                     00D9       	
                   00001B78'EF   95  00D9  1275 	tstb	v_blockio		; is the block file open?
                            1A   13  00DF  1276 	beql	100$			; no, return
                                     00E1  1277 	$close	fab=v_blkfab		; Yes, close block file
                                     00E1       		$RMSCALL	CLOSE,v_blkfab,,
                                     00E1       	.GLOBL	SYS$CLOSE
                                     00E1       	.IF	B <v_blkfab>
                                     00E1       	CALLG	(AP),G^SYS$CLOSE
                                     00E1       	$$.TMP=0
                                     00E1       	.IF	NB <>
                                     00E1       	$$.TMP=1
                                     00E1       	.ENDC
                                     00E1       	.IF	NB <>
                                     00E1       	$$.TMP=1
                                     00E1       	.ENDC
                                     00E1       	.IF	NE $$.TMP
                                     00E1       	.ERROR				; v_blkfab= parameter missing;
                                     00E1       	.ENDC
                                     00E1       	.ENDC
                                     00E1       	.IF	NB <v_blkfab>
                           00000001  00E1       	$$.TMP1=1
                                     00E1       	.IF	NB <>
                                     00E1       	PUSHAL	
                                     00E1       	$$.TMP1=3
                                     00E1       	.ENDC
                                     00E1       	.IF	NB <>
                                     00E1       	PUSHAL	
                                     00E1       	.IF	EQ <$$.TMP1-1>
                                     00E1       	$$.TMP1=2
                                     00E1       	.ENDC
                                     00E1       	.IFF
                           FFFFFFFE  00E1       	.IF	EQ <$$.TMP1-3>
                                     00E1       	PUSHL	#0
                                     00E1       	.ENDC
                                     00E1       	.ENDC
                           000000CF  00E1       	.NTYPE	$$.TMP2,v_blkfab
                           00000070  00E1       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     00E1       	PUSHL	v_blkfab
                                     00E1       	.IFF
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  68
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           000000B0  00E1       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     00E1       	PUSHL	v_blkfab
                                     00E1       	.IFF
                   00001AE0'EF   DF  00E1       	PUSHAL	v_blkfab
                                     00E7       	.ENDC
                                     00E7       	.ENDC
              00000000'GF   01   FB  00E7       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     00EE       	.ENDC
                                     00EE       	
                                     00EE       	
                         03 50   E8  00EE  1278 	blbs	r0,10$			; go on if no error
                          1676   31  00F1  1279 	brw	_error_exit		; exit with error message
                                     00F4  1280 10$:
              00001B78'EF   00   90  00F4  1281 	movb	#c_false,v_blockio	; we're not using block file
                                     00FB  1282 100$:
                                 05  00FB  1283 	rsb				; end of block-close
                                     00FC  1284 
                                     00FC  1285 
                                     00FC  1286 ;+++
                                     00FC  1287 ;k> blocok-open -- ( -- ) Open the block file.
                                     00FC  1288 ;---
                                     00FC  1289 	header	i_block_open,<block-open>
                           FFFFFFFC  00FC       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0100       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000A  0100       	.nchr  nchr, ^\block-open\	; nchr = length( block-open )
                           0000000A  0100       	.if    le, nchr		; nchr <= 0
                                     0100       	   .ascic \i_block_open\	; no auxillary block-open, use principle one
                                     0100       	.if_false		; else
   6E 65 70 6F 2D 6B 63 6F 6C 62 00' 0100       	  .ascic \block-open\		; use auxillary block-open
                                 0A  0100       
                                     010B       	.endc			; end if
                                     010B       i_block_open:			; use block-open of word as v1_kernel label
                                     010B       	
                   00001B78'EF   95  010B  1290 	tstb	v_blockio		; Is block file open?
                            2E   12  0111  1291 	bneq	100$			; Yes, don't open again
                                     0113  1292 ; no, open it
                                     0113  1293 	$open	fab=v_blkfab		; open block file
                                     0113       		$RMSCALL	OPEN,v_blkfab,,
                                     0113       	.GLOBL	SYS$OPEN
                                     0113       	.IF	B <v_blkfab>
                                     0113       	CALLG	(AP),G^SYS$OPEN
                                     0113       	$$.TMP=0
                                     0113       	.IF	NB <>
                                     0113       	$$.TMP=1
                                     0113       	.ENDC
                                     0113       	.IF	NB <>
                                     0113       	$$.TMP=1
                                     0113       	.ENDC
                                     0113       	.IF	NE $$.TMP
                                     0113       	.ERROR				; v_blkfab= parameter missing;
                                     0113       	.ENDC
                                     0113       	.ENDC
                                     0113       	.IF	NB <v_blkfab>
                           00000001  0113       	$$.TMP1=1
                                     0113       	.IF	NB <>
                                     0113       	PUSHAL	
                                     0113       	$$.TMP1=3
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  69
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0113       	.ENDC
                                     0113       	.IF	NB <>
                                     0113       	PUSHAL	
                                     0113       	.IF	EQ <$$.TMP1-1>
                                     0113       	$$.TMP1=2
                                     0113       	.ENDC
                                     0113       	.IFF
                           FFFFFFFE  0113       	.IF	EQ <$$.TMP1-3>
                                     0113       	PUSHL	#0
                                     0113       	.ENDC
                                     0113       	.ENDC
                           000000CF  0113       	.NTYPE	$$.TMP2,v_blkfab
                           00000070  0113       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0113       	PUSHL	v_blkfab
                                     0113       	.IFF
                           000000B0  0113       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0113       	PUSHL	v_blkfab
                                     0113       	.IFF
                   00001AE0'EF   DF  0113       	PUSHAL	v_blkfab
                                     0119       	.ENDC
                                     0119       	.ENDC
              00000000'GF   01   FB  0119       	CALLS	#$$.TMP1,G^SYS$OPEN
                                     0120       	.ENDC
                                     0120       	
                                     0120       	
                         03 50   E8  0120  1294 	blbs	r0,10$			; no error, go on
                          1644   31  0123  1295 	brw	_error_exit		; quit on error
                                     0126  1296 10$:
                                     0126  1297 	$connect rab=v_blkrab		; connect to block file
                                     0126       		$RMSCALL	CONNECT,v_blkrab,,
                                     0126       	.GLOBL	SYS$CONNECT
                                     0126       	.IF	B <v_blkrab>
                                     0126       	CALLG	(AP),G^SYS$CONNECT
                                     0126       	$$.TMP=0
                                     0126       	.IF	NB <>
                                     0126       	$$.TMP=1
                                     0126       	.ENDC
                                     0126       	.IF	NB <>
                                     0126       	$$.TMP=1
                                     0126       	.ENDC
                                     0126       	.IF	NE $$.TMP
                                     0126       	.ERROR				; v_blkrab= parameter missing;
                                     0126       	.ENDC
                                     0126       	.ENDC
                                     0126       	.IF	NB <v_blkrab>
                           00000001  0126       	$$.TMP1=1
                                     0126       	.IF	NB <>
                                     0126       	PUSHAL	
                                     0126       	$$.TMP1=3
                                     0126       	.ENDC
                                     0126       	.IF	NB <>
                                     0126       	PUSHAL	
                                     0126       	.IF	EQ <$$.TMP1-1>
                                     0126       	$$.TMP1=2
                                     0126       	.ENDC
                                     0126       	.IFF
                           FFFFFFFE  0126       	.IF	EQ <$$.TMP1-3>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  70
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0126       	PUSHL	#0
                                     0126       	.ENDC
                                     0126       	.ENDC
                           000000CF  0126       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  0126       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0126       	PUSHL	v_blkrab
                                     0126       	.IFF
                           000000B0  0126       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0126       	PUSHL	v_blkrab
                                     0126       	.IFF
                   00001B30'EF   DF  0126       	PUSHAL	v_blkrab
                                     012C       	.ENDC
                                     012C       	.ENDC
              00000000'GF   01   FB  012C       	CALLS	#$$.TMP1,G^SYS$CONNECT
                                     0133       	.ENDC
                                     0133       	
                                     0133       	
                         03 50   E8  0133  1298 	blbs	 r0,20$			; no error, go on
                          1631   31  0136  1299 	brw	 _error_exit		; quit on error
                                     0139  1300 20$:
           00001B78'EF   FF 8F   90  0139  1301 	movb	#c_true,v_blockio	; yes, we are using the block file
                                     0141  1302 100$:
                                 05  0141  1303 	rsb				; end of block-open
                                     0142  1304 
                                     0142  1305 
                                     0142  1306 ;+++
                                     0142  1307 ;k> block-read -- ( l a -- ) Read block `l' from buffer at address `a'.
                                     0142  1308 ;---
                                     0142  1309 	header	i_block_read,<block-read>
                           FFFFFFFC  0142       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0146       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000A  0146       	.nchr  nchr, ^\block-read\	; nchr = length( block-read )
                           0000000A  0146       	.if    le, nchr		; nchr <= 0
                                     0146       	   .ascic \i_block_read\	; no auxillary block-read, use principle one
                                     0146       	.if_false		; else
   64 61 65 72 2D 6B 63 6F 6C 62 00' 0146       	  .ascic \block-read\		; use auxillary block-read
                                 0A  0146       
                                     0151       	.endc			; end if
                                     0151       i_block_read:			; use block-read of word as v1_kernel label
                                     0151       	
                            8B   D0  0151  1310 	movl	(r11)+,-		; get address of buffer
                   00001B54'EF       0153  1311 		v_blkrab+rab$l_ubf	;   into  rab
                            8B   D0  0158  1312 	movl	(r11)+,-		; get VTIL block (rms record) number
                   00001B74'EF       015A  1313 		v_blkkey		;   into rab's key
                                     015F  1314 	$get	rab=v_blkrab		; read the block
                                     015F       		$RMSCALL	GET,v_blkrab,,
                                     015F       	.GLOBL	SYS$GET
                                     015F       	.IF	B <v_blkrab>
                                     015F       	CALLG	(AP),G^SYS$GET
                                     015F       	$$.TMP=0
                                     015F       	.IF	NB <>
                                     015F       	$$.TMP=1
                                     015F       	.ENDC
                                     015F       	.IF	NB <>
                                     015F       	$$.TMP=1
                                     015F       	.ENDC
                                     015F       	.IF	NE $$.TMP
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  71
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     015F       	.ERROR				; v_blkrab= parameter missing;
                                     015F       	.ENDC
                                     015F       	.ENDC
                                     015F       	.IF	NB <v_blkrab>
                           00000001  015F       	$$.TMP1=1
                                     015F       	.IF	NB <>
                                     015F       	PUSHAL	
                                     015F       	$$.TMP1=3
                                     015F       	.ENDC
                                     015F       	.IF	NB <>
                                     015F       	PUSHAL	
                                     015F       	.IF	EQ <$$.TMP1-1>
                                     015F       	$$.TMP1=2
                                     015F       	.ENDC
                                     015F       	.IFF
                           FFFFFFFE  015F       	.IF	EQ <$$.TMP1-3>
                                     015F       	PUSHL	#0
                                     015F       	.ENDC
                                     015F       	.ENDC
                           000000CF  015F       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  015F       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     015F       	PUSHL	v_blkrab
                                     015F       	.IFF
                           000000B0  015F       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     015F       	PUSHL	v_blkrab
                                     015F       	.IFF
                   00001B30'EF   DF  015F       	PUSHAL	v_blkrab
                                     0165       	.ENDC
                                     0165       	.ENDC
              00000000'GF   01   FB  0165       	CALLS	#$$.TMP1,G^SYS$GET
                                     016C       	.ENDC
                                     016C       	
                                     016C       	
                         03 50   E8  016C  1315 	blbs	r0,100$			; no errors, go on
                          15F8   31  016F  1316 	brw	_error_exit		; exit and signal error
                                     0172  1317 100$:
                                 05  0172  1318 	rsb				; end of block-read
                                     0173  1319 
                                     0173  1320 
                                     0173  1321 ;+++
                                     0173  1322 ;k> block-write -- ( l a -- ) Write block `l' from buffer at address `a'.
                                     0173  1323 ;---
                                     0173  1324 	header	i_block_write,<block-write>
                           FFFFFFFC  0173       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0177       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000B  0177       	.nchr  nchr, ^\block-write\	; nchr = length( block-write )
                           0000000B  0177       	.if    le, nchr		; nchr <= 0
                                     0177       	   .ascic \i_block_write\	; no auxillary block-write, use principle one
                                     0177       	.if_false		; else
65 74 69 72 77 2D 6B 63 6F 6C 62 00' 0177       	  .ascic \block-write\		; use auxillary block-write
                                 0B  0177       
                                     0183       	.endc			; end if
                                     0183       i_block_write:			; use block-write of word as v1_kernel label
                                     0183       	
                            8B   D0  0183  1325 	movl	(r11)+,-		; get buffer address
                   00001B58'EF       0185  1326 		v_blkrab+rab$l_rbf	;   into rab
                            8B   D0  018A  1327 	movl	(r11)+,-		; get VTIL block (rms record) number
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  72
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                   00001B74'EF       018C  1328 		v_blkkey		;   into key buffer
                       0400 8F   B0  0191  1329 	movw	#c_block_size,-		; get proper VTIL block (rms record)
                   00001B52'EF       0195  1330 		v_blkrab+rab$w_rsz	;   size into fab
                                     019A  1331 	$find	rab=v_blkrab		; find the correct block
                                     019A       		$RMSCALL	FIND,v_blkrab,,
                                     019A       	.GLOBL	SYS$FIND
                                     019A       	.IF	B <v_blkrab>
                                     019A       	CALLG	(AP),G^SYS$FIND
                                     019A       	$$.TMP=0
                                     019A       	.IF	NB <>
                                     019A       	$$.TMP=1
                                     019A       	.ENDC
                                     019A       	.IF	NB <>
                                     019A       	$$.TMP=1
                                     019A       	.ENDC
                                     019A       	.IF	NE $$.TMP
                                     019A       	.ERROR				; v_blkrab= parameter missing;
                                     019A       	.ENDC
                                     019A       	.ENDC
                                     019A       	.IF	NB <v_blkrab>
                           00000001  019A       	$$.TMP1=1
                                     019A       	.IF	NB <>
                                     019A       	PUSHAL	
                                     019A       	$$.TMP1=3
                                     019A       	.ENDC
                                     019A       	.IF	NB <>
                                     019A       	PUSHAL	
                                     019A       	.IF	EQ <$$.TMP1-1>
                                     019A       	$$.TMP1=2
                                     019A       	.ENDC
                                     019A       	.IFF
                           FFFFFFFE  019A       	.IF	EQ <$$.TMP1-3>
                                     019A       	PUSHL	#0
                                     019A       	.ENDC
                                     019A       	.ENDC
                           000000CF  019A       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  019A       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     019A       	PUSHL	v_blkrab
                                     019A       	.IFF
                           000000B0  019A       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     019A       	PUSHL	v_blkrab
                                     019A       	.IFF
                   00001B30'EF   DF  019A       	PUSHAL	v_blkrab
                                     01A0       	.ENDC
                                     01A0       	.ENDC
              00000000'GF   01   FB  01A0       	CALLS	#$$.TMP1,G^SYS$FIND
                                     01A7       	.ENDC
                                     01A7       	
                                     01A7       	
                                     01A7  1332 	$update	rab=v_blkrab		; write the block
                                     01A7       		$RMSCALL	UPDATE,v_blkrab,,
                                     01A7       	.GLOBL	SYS$UPDATE
                                     01A7       	.IF	B <v_blkrab>
                                     01A7       	CALLG	(AP),G^SYS$UPDATE
                                     01A7       	$$.TMP=0
                                     01A7       	.IF	NB <>
                                     01A7       	$$.TMP=1
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  73
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     01A7       	.ENDC
                                     01A7       	.IF	NB <>
                                     01A7       	$$.TMP=1
                                     01A7       	.ENDC
                                     01A7       	.IF	NE $$.TMP
                                     01A7       	.ERROR				; v_blkrab= parameter missing;
                                     01A7       	.ENDC
                                     01A7       	.ENDC
                                     01A7       	.IF	NB <v_blkrab>
                           00000001  01A7       	$$.TMP1=1
                                     01A7       	.IF	NB <>
                                     01A7       	PUSHAL	
                                     01A7       	$$.TMP1=3
                                     01A7       	.ENDC
                                     01A7       	.IF	NB <>
                                     01A7       	PUSHAL	
                                     01A7       	.IF	EQ <$$.TMP1-1>
                                     01A7       	$$.TMP1=2
                                     01A7       	.ENDC
                                     01A7       	.IFF
                           FFFFFFFE  01A7       	.IF	EQ <$$.TMP1-3>
                                     01A7       	PUSHL	#0
                                     01A7       	.ENDC
                                     01A7       	.ENDC
                           000000CF  01A7       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  01A7       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     01A7       	PUSHL	v_blkrab
                                     01A7       	.IFF
                           000000B0  01A7       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     01A7       	PUSHL	v_blkrab
                                     01A7       	.IFF
                   00001B30'EF   DF  01A7       	PUSHAL	v_blkrab
                                     01AD       	.ENDC
                                     01AD       	.ENDC
              00000000'GF   01   FB  01AD       	CALLS	#$$.TMP1,G^SYS$UPDATE
                                     01B4       	.ENDC
                                     01B4       	
                                     01B4       	
                         03 50   E8  01B4  1333 	blbs	r0,100$			; no errors, go on
                          15B0   31  01B7  1334 	brw	_error_exit		; exit and signal error
                                     01BA  1335 100$:
                                 05  01BA  1336 	rsb				; end of block-write
                                     01BB  1337 
                                     01BB  1338 
                                     01BB  1339 ;+++
                                     01BB  1340 ;k> break -- ( -- ) Breakpoint!	 For use in debugging kernel and compiler.
                                     01BB  1341 ;	This word should only be executed when running in the VAX/VMS Debugger.
                                     01BB  1342 ;---
                                     01BB  1343 	header	break
                           FFFFFFFC  01BB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01BF       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  01BF       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  01BF       	.if    le, nchr		; nchr <= 0
                  6B 61 65 72 62 00' 01BF       	   .ascic \break\	; no auxillary , use principle one
                                 05  01BF       
                                     01C5       	.if_false		; else
                                     01C5       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  74
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     01C5       	.endc			; end if
                                     01C5       break:			; use  of word as v1_kernel label
                                     01C5       	
                                 03  01C5  1344 	bpt				; breakpoint
                                 05  01C6  1345 	rsb				; end of break
                                     01C7  1346 
                                     01C7  1347 
                                     01C7  1348 ;+++
                                     01C7  1349 ;k> bs@ -- ( a -- l ) Fetch byte at `a' and sign extend it to longword on stack.
                                     01C7  1350 ;---
                                     01C7  1351 	header	i_bs_fetch,<bs@>
                           FFFFFFFC  01C7       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01CB       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  01CB       	.nchr  nchr, ^\bs@\	; nchr = length( bs@ )
                           00000003  01CB       	.if    le, nchr		; nchr <= 0
                                     01CB       	   .ascic \i_bs_fetch\	; no auxillary bs@, use principle one
                                     01CB       	.if_false		; else
                        40 73 62 00' 01CB       	  .ascic \bs@\		; use auxillary bs@
                                 03  01CB       
                                     01CF       	.endc			; end if
                                     01CF       i_bs_fetch:			; use bs@ of word as v1_kernel label
                                     01CF       	
                    6B   00 BB   98  01CF  1352 	cvtbl	@(r11),(r11)		; sign extend it
                                 05  01D3  1353 	rsb				; end of bs@
                                     01D4  1354 
                                     01D4  1355 
                                     01D4  1356 ;+++
                                     01D4  1357 ;k> buffer -- ( l -- a ) Get buffer at `a' that will be written to block `l'.
                                     01D4  1358 ;---
                                     01D4  1359 	header	buffer
                           FFFFFFFC  01D4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  01D8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  01D8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  01D8       	.if    le, nchr		; nchr <= 0
               72 65 66 66 75 62 00' 01D8       	   .ascic \buffer\	; no auxillary , use principle one
                                 06  01D8       
                                     01DF       	.if_false		; else
                                     01DF       	  .ascic \\		; use auxillary 
                                     01DF       	.endc			; end if
                                     01DF       buffer:			; use  of word as v1_kernel label
                                     01DF       	
                                     01DF  1360 ; Is the block already in memory?
                            50   D4  01DF  1361 	clrl   r0			; start with buffer 0
                                     01E1  1362 10$:
                            6B   D1  01E1  1363 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       01E3  1364 		v_buf_blk_nums[r0]	;   block we are looking for?
                            44   13  01E9  1365 	beql	100$			; yes, go on
                    F2 50   03   F2  01EB  1366 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     01EF  1367 ;
                                     01EF  1368 ; not in memory, so we have to get it in
                                     01EF  1369 ;
                                     01EF  1370 ; Are there unused buffers?
                            50   D4  01EF  1371 	clrl	r0			; start with buffer 0
                                     01F1  1372 20$:
                 00001B7D'EF40   95  01F1  1373 	tstb	v_buf_inuse[r0]		; Is it in use?
                            25   13  01F8  1374 	beql	90$			; no, read block into it
                    F3 50   03   F2  01FA  1375 	aoblss	#c_max_blocks,r0,20$	; move to the next buffer, if any
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  75
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     01FE  1376 ; Are there any unmodified buffers?
                            50   D4  01FE  1377 	clrl	r0
                                     0200  1378 30$:
                            02   91  0200  1379 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       0202  1380 		v_buf_inuse[r0]		;   been modified?
                            15   12  0208  1381 	bneq	90$			; no, read block into it
                    F2 50   03   F2  020A  1382 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     020E  1383 ; all buffers are modified, so we must write one out and use it.
                            50   D4  020E  1384 	clrl	r0			; for now, always use zero'th one
                       7A   50   D0  0210  1385 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  0213  1386 	movl	r0,-(r11)		; set up for buffer-write
                   00000292'EF   16  0216  1387 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  021C  1388 	movl	(r10)+,r0		; get the buffer number back
                                     021F  1389 ;
                                     021F  1390 ; come here with bloc## on stack and buffer# in r0.
                                     021F  1391 ;
                                     021F  1392 90$:
                                     021F  1393 ; save block info
                            6B   D0  021F  1394 	movl	(r11),-			; Save the new block number in
                 00001B80'EF40       0221  1395 		v_buf_blk_nums[r0]	;   buffer
                            01   90  0227  1396 	movb	#c_inuse,-		; Flag that buffer is in use
                 00001B7D'EF40       0229  1397 		v_buf_inuse[r0]
                                     022F  1398 
                                     022F  1399 100$:
                                     022F  1400 ; leave address of buffer on stack
         6B   00000400 8F   50   C5  022F  1401 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  0237  1402 	addl2	#v_blkbuff,(r11)	; calculate address of `r0'th buffer
              00001B79'EF   50   D0  023E  1403 	movl	r0,v_current_buff	; mark this as most current block
                                 05  0245  1404 	rsb				; end of buffer
                                     0246  1405 
                                     0246  1406 
                                     0246  1407 ;+++
                                     0246  1408 ;k> buffer-read -- ( n -- a ) read into a block into buffer `n'.  The block
                                     0246  1409 ;	number is already in the buffer.  Leave `a', the address of the
                                     0246  1410 ;	block buffer.  This word assumes that buffer is correctly set up
                                     0246  1411 ;	(block number, etc).
                                     0246  1412 ;---
                                     0246  1413 	header	i_buffer_read,<buffer-read>
                           FFFFFFFC  0246       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  024A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000B  024A       	.nchr  nchr, ^\buffer-read\	; nchr = length( buffer-read )
                           0000000B  024A       	.if    le, nchr		; nchr <= 0
                                     024A       	   .ascic \i_buffer_read\	; no auxillary buffer-read, use principle one
                                     024A       	.if_false		; else
64 61 65 72 2D 72 65 66 66 75 62 00' 024A       	  .ascic \buffer-read\		; use auxillary buffer-read
                                 0B  024A       
                                     0256       	.endc			; end if
                                     0256       i_buffer_read:			; use buffer-read of word as v1_kernel label
                                     0256       	
                       50   8B   D0  0256  1414 	movl	(r11)+,r0		; get buffer number
              00001B79'EF   50   D0  0259  1415 	movl	r0,v_current_buff	; save buffer number as most current
         51   00000400 8F   50   C5  0260  1416 	mull3	r0,#c_block_size,r1	; offset to `r0'th buffer
         7B   00004000'8F   51   C1  0268  1417 	addl3	r1,#v_blkbuff,-(r11)	; put address of buffer on stack
                                     0270  1418 					; this is left after exit
            7B   00001B80'EF40   D0  0270  1419 	movl	v_buf_blk_nums[r0],-	; number of block
                                     0278  1420 		-(r11)			;   to read
                    7B   04 AB   D0  0278  1421 	movl	4(r11),-(r11)		; get another copy of the buffer address
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  76
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       FED1 CF   16  027C  1422 	jsb	i_block_read		; read the block
                                 05  0280  1423 	rsb				; end of buffer-read
                                     0281  1424 
                                     0281  1425 
                                     0281  1426 ;+++
                                     0281  1427 ;k> buffer-write -- ( n -- ) write block in buffer number n to file.
                                     0281  1428 ;	Note that the block number is in the buffer already.
                                     0281  1429 ;---
                                     0281  1430 	header	i_buffer_write,<buffer-write>
                           FFFFFFFC  0281       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0285       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000C  0285       	.nchr  nchr, ^\buffer-write\	; nchr = length( buffer-write )
                           0000000C  0285       	.if    le, nchr		; nchr <= 0
                                     0285       	   .ascic \i_buffer_write\	; no auxillary buffer-write, use principle one
                                     0285       	.if_false		; else
74 69 72 77 2D 72 65 66 66 75 62 00' 0285       	  .ascic \buffer-write\		; use auxillary buffer-write
                                 65  0291       
                                 0C  0285       
                                     0292       	.endc			; end if
                                     0292       i_buffer_write:			; use buffer-write of word as v1_kernel label
                                     0292       	
                       50   8B   D0  0292  1431 	movl	(r11)+,r0		; get buffer number
            7B   00001B80'EF40   D0  0295  1432 	movl	v_buf_blk_nums[r0],-	; number of block
                                     029D  1433 		-(r11)			;   to write
         51   00000400 8F   50   C5  029D  1434 	mull3	r0,#c_block_size,r1	; offset into the buffer buffer
         7B   00004000'8F   51   C1  02A5  1435 	addl3	r1,#v_blkbuff,-(r11)	; address of buffer to write
                                     02AD  1436 					; this is left after exit
                       FED2 CF   16  02AD  1437 	jsb	i_block_write		; write the block
                                 05  02B1  1438 	rsb				; end of buffer-write
                                     02B2  1439 
                                     02B2  1440 
                                     02B2  1441 ;+++
                                     02B2  1442 ;k> byte -- ( n -- ) Creates word that pushes address of byte on stack.
                                     02B2  1443 ;---
                                     02B2  1444 	header	byte,<byte>
                           FFFFFFFC  02B2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02B6       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  02B6       	.nchr  nchr, ^\byte\	; nchr = length( byte )
                           00000004  02B6       	.if    le, nchr		; nchr <= 0
                                     02B6       	   .ascic \byte\	; no auxillary byte, use principle one
                                     02B6       	.if_false		; else
                     65 74 79 62 00' 02B6       	  .ascic \byte\		; use auxillary byte
                                 04  02B6       
                                     02BB       	.endc			; end if
                                     02BB       byte:			; use byte of word as v1_kernel label
                                     02BB       	
                   000003DB'EF   16  02BB  1445 	jsb	create			; enclose next token in dictionary
                    89   9E 8F   90  02C1  1446 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  02C5  1447 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  02C9  1448 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  02CC  1449 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  02D0  1450 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  02D3  1451 	movb	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  02D6  1452 	addl2	#4,r11			; pop argument
                                 05  02D9  1453 	rsb				; end of byte
                                     02DA  1454 
                                     02DA  1455 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  77
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     02DA  1456 ;+++t
                                     02DA  1457 ;k> cfa -- ( a -- a ) given addrss of header of word, return the address of
                                     02DA  1458 ;	the code for that word (i.e., the Code Field Address).
                                     02DA  1459 ;---
                                     02DA  1460 ;??? the smudge bit makes this one a little harder.
                                     02DA  1461 	header	cfa
                           FFFFFFFC  02DA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02DE       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  02DE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  02DE       	.if    le, nchr		; nchr <= 0
                        61 66 63 00' 02DE       	   .ascic \cfa\	; no auxillary , use principle one
                                 03  02DE       
                                     02E2       	.if_false		; else
                                     02E2       	  .ascic \\		; use auxillary 
                                     02E2       	.endc			; end if
                                     02E2       cfa:			; use  of word as v1_kernel label
                                     02E2       	
                       6B   04   C0  02E2  1462 	addl2	#4,(r11)		; skip over link field
                    50   00 BB   9A  02E5  1463 	movzbl	@(r11),r0		; get unsigned byte-count of name
                    50   80 8F   8A  02E9  1464 	bicb2	#^b10000000,r0		; clear smudge bit of count
                            6B   D6  02ED  1465 	incl	(r11)			; skip over count byte
                       6B   50   C0  02EF  1466 	addl2	r0,(r11)		; skip over name field
                                 05  02F2  1467 	rsb				; end of cfa
                                     02F3  1468 
                                     02F3  1469 
                                     02F3  1470 ;+++
                                     02F3  1471 ;k> clist -- ( -- ) list compiler vocabulary.
                                     02F3  1472 ;---
                                     02F3  1473 	header	clist
                           FFFFFFFC  02F3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  02F7       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  02F7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  02F7       	.if    le, nchr		; nchr <= 0
                  74 73 69 6C 63 00' 02F7       	   .ascic \clist\	; no auxillary , use principle one
                                 05  02F7       
                                     02FD       	.if_false		; else
                                     02FD       	  .ascic \\		; use auxillary 
                                     02FD       	.endc			; end if
                                     02FD       clist:			; use  of word as v1_kernel label
                                     02FD       	
              7B   00001D3F'EF   D0  02FD  1474 	movl	v_compiler,-(r11)	; get address of most recent word
                                     0304  1475 					;   in compiler vocabulary
                                     0304  1476 10$:
                            6B   D5  0304  1477 	tstl	(r11)			; nil pointer?
                            23   13  0306  1478 	beql	100$			; yes, exit loop
                  7B   04   6B   C1  0308  1479 	addl3	(r11),#4,-(r11)		; get address of name field
                       FCFF CF   16  030C  1480 	jsb	bcount			; set up for write
                       7B   6B   D0  0310  1481 	movl	(r11),-(r11)		; set up for ?cr
                         EF AF   16  0313  1482 	jsb	q_n_cr			; start new line if word is too long
                   00000FE9'EF   16  0316  1483 	jsb	write			; tell user
                       71   20   D0  031C  1484 	movl	#c_blank,-(r1)		; blank to separate words
                   00000987'EF   16  031F  1485 	jsb	putc			; output it
                    6B   00 BB   D0  0325  1486 	movl	@(r11),(r11)		; get previous word's lfa
                            D9   11  0329  1487 	brb	10$			; try it again
                                     032B  1488 100$:
                       5B   04   C0  032B  1489 	addl2	#4,r11			; pop pointer off stack
                                 05  032E  1490 	rsb				; end of clist
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  78
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     032F  1491 
                                     032F  1492 
                                     032F  1493 ;+++t
                                     032F  1494 ;k> compile-jsb ( a -- ) compile a jump to subroutine to location `a'.
                                     032F  1495 ;---
                                     032F  1496 ;??? At the moment this uses absolute mode.  Should it use displacment
                                     032F  1497 ; off a register so that it can be ?relocatable (like stoic)?  Or should it
                                     032F  1498 ; use a brw (which I'm not sure would work in { defer< ... >defer }.
                                     032F  1499 	header	   i_compile_jsb,<compile-jsb>
                           FFFFFFFC  032F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0333       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000B  0333       	.nchr  nchr, ^\compile-jsb\	; nchr = length( compile-jsb )
                           0000000B  0333       	.if    le, nchr		; nchr <= 0
                                     0333       	   .ascic \i_compile_jsb\	; no auxillary compile-jsb, use principle one
                                     0333       	.if_false		; else
62 73 6A 2D 65 6C 69 70 6D 6F 63 00' 0333       	  .ascic \compile-jsb\		; use auxillary compile-jsb
                                 0B  0333       
                                     033F       	.endc			; end if
                                     033F       i_compile_jsb:			; use compile-jsb of word as v1_kernel label
                                     033F       	
                       89   16   90  033F  1500 	movb	   #op_jsb,(r9)+	; `jsb'
                    69   9F 8F   90  0342  1501 	movb	   #adm_absolute,(r9)	; absolute mode
                       89   8B   D0  0346  1502 	movl	   (r11)+,(r9)+		; save place to jump to in dictionary
                                 05  0349  1503 	rsb				; end of compile-jsb
                                     034A  1504 
                                     034A  1505 
                                     034A  1506 ;+++
                                     034A  1507 ;k> compiletime -- ( -- ) move word defined to the compiler vocabulary.
                                     034A  1508 ;	This word unlinks the last word in the current vocabulary and
                                     034A  1509 ;	links it to the compiler vocabulary.  Compiiler words are *never*
                                     034A  1510 ;	executed during execute mode.
                                     034A  1511 ;---
                                     034A  1512 	header	compiletime
                           FFFFFFFC  034A       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  034E       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  034E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  034E       	.if    le, nchr		; nchr <= 0
65 6D 69 74 65 6C 69 70 6D 6F 63 00' 034E       	   .ascic \compiletime\	; no auxillary , use principle one
                                 0B  034E       
                                     035A       	.if_false		; else
                                     035A       	  .ascic \\		; use auxillary 
                                     035A       	.endc			; end if
                                     035A       compiletime:			; use  of word as v1_kernel label
                                     035A       	
              50   00001D3B'FF   D0  035A  1513 	movl	@v_current,r0		; save pointer to word we a unlinking
              00001D3B'FF   60   D0  0361  1514 	movl	(r0),@v_current		; make current previous word in vocab
              60   00001D3F'EF   D0  0368  1515 	movl	v_compiler,(r0)		; link word to prev in compiler vocab
              00001D3F'EF   50   D0  036F  1516 	movl	r0,v_compiler		; make v_compiler point to new word
                                 05  0376  1517 	rsb				; end of compiletime
                                     0377  1518 ;??? Should I also have immediate words, that execute in *both* compile
                                     0377  1519 ; mode and execute mode?  This would require some sort of attribute flag,
                                     0377  1520 ; which would have to be checked during compilation.  It would allow
                                     0377  1521 ; considerably more flexibility (remember how % started out a word and ended
                                     0377  1522 ; up part of _interpreter because it was either compiletime or runtime?).
                                     0377  1523 ;??? Much beter idea.  Have a compile buffer like STOIC and have only
                                     0377  1524 ; compiletime and runtime words, both of which are in the same vocabulary.
                                     0377  1525 ; If not inside a { : ... ; }, do a jsb at the end of the line? if in colon
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  79
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0377  1526 ; definition, copy it to the dictionary and update dictionary links.
                                     0377  1527 ; Have to think about this.
                                     0377  1528 
                                     0377  1529 
                                     0377  1530 ;+++
                                     0377  1531 ;k> context -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     0377  1532 ;	vocabulary in which we currently search for words (the `context').
                                     0377  1533 ;---
                                     0377  1534 	header	context
                           FFFFFFFC  0377       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  037B       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  037B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  037B       	.if    le, nchr		; nchr <= 0
            74 78 65 74 6E 6F 63 00' 037B       	   .ascic \context\	; no auxillary , use principle one
                                 07  037B       
                                     0383       	.if_false		; else
                                     0383       	  .ascic \\		; use auxillary 
                                     0383       	.endc			; end if
                                     0383       context:			; use  of word as v1_kernel label
                                     0383       	
              7B   00001D37'EF   DE  0383  1535 	moval	v_context,-(r11)	; move address of pointer to vocab
                                     038A  1536 					; that is searched when defining
                                     038A  1537 					; to stack
                                 05  038A  1538 	rsb				; end of context
                                     038B  1539 
                                     038B  1540 
                                     038B  1541 ;+++
                                     038B  1542 ;k> count -- ( a1 -- a2 n ) Given word-counted string at `a' returns
                                     038B  1543 ;	address of characters in string and string's length on top of stack.
                                     038B  1544 ;---
                                     038B  1545 	header	count
                           FFFFFFFC  038B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  038F       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  038F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  038F       	.if    le, nchr		; nchr <= 0
                  74 6E 75 6F 63 00' 038F       	   .ascic \count\	; no auxillary , use principle one
                                 05  038F       
                                     0395       	.if_false		; else
                                     0395       	  .ascic \\		; use auxillary 
                                     0395       	.endc			; end if
                                     0395       count:			; use  of word as v1_kernel label
                                     0395       	
                    50   00 BB   3C  0395  1546 	movzwl	@(r11),r0		; get length of string
                       6B   02   C0  0399  1547 	addl2	#2,(r11)		; move pointer to first character
                       7B   50   D0  039C  1548 	movl	r0,-(r11)		; put count on top of stack
                                 05  039F  1549 	rsb				; end of count
                                     03A0  1550 
                                     03A0  1551 
                                     03A0  1552 ;+++
                                     03A0  1553 ;k> cr -- ( -- )  Start new output line (C_arriage R_eturn).
                                     03A0  1554 ;---
                                     03A0  1555 	header	cr
                           FFFFFFFC  03A0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  03A4       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  03A4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03A4       	.if    le, nchr		; nchr <= 0
                           72 63 00' 03A4       	   .ascic \cr\	; no auxillary , use principle one
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  80
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 02  03A4       
                                     03A7       	.if_false		; else
                                     03A7       	  .ascic \\		; use auxillary 
                                     03A7       	.endc			; end if
                                     03A7       cr:			; use  of word as v1_kernel label
                                     03A7       	
              7B   00001B9A'EF   9E  03A7  1556 	movab	v_outbuf,-(r11)		; move address of output buffer on stack
              7B   00001B9A'EF   3C  03AE  1557 	movzwl	v_outbuf,-(r11)		; put count on stack
           02 AB   00001B96'EF   B0  03B5  1558 	movw	v_static_dsc,2(r11)	; put middle of descriptor on ~~~ Is this correct?
                            5B   DD  03BD  1559 	pushl	r11			; push address of output descriptor
              00000000'GF   01   FB  03BF  1560 	calls	#1,g^lib$put_output	; output it
                       5B   08   C0  03C6  1561 	addl2	#8,r11			; pop descriptor off stack
                   00001B98'EF   B4  03C9  1562 	clrw	v_outlen		; clear output length
                                 05  03CF  1563 	rsb				; end of cr
                                     03D0  1564 
                                     03D0  1565 
                                     03D0  1566 ;+++t
                                     03D0  1567 ;k> create -- ( -- ) Enclose next token in input stream in the dictionary,
                                     03D0  1568 ;	truncating it if it is too long.
                                     03D0  1569 ;---
                                     03D0  1570 	header	create
                           FFFFFFFC  03D0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  03D4       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  03D4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03D4       	.if    le, nchr		; nchr <= 0
               65 74 61 65 72 63 00' 03D4       	   .ascic \create\	; no auxillary , use principle one
                                 06  03D4       
                                     03DB       	.if_false		; else
                                     03DB       	  .ascic \\		; use auxillary 
                                     03DB       	.endc			; end if
                                     03DB       create:			; use  of word as v1_kernel label
                                     03DB       	
              69   00001D3B'FF   D0  03DB  1571 	movl	@v_current,(r9)		; make link field
              00001D3B'FF   59   D0  03E2  1572 	movl	r9,@v_current		; make vocab point to here, newest word
                       59   04   C0  03E9  1573 	addl2	#4,r9			; move eodp over link field
                       7B   20   D0  03EC  1574 	movl	#c_blank,-(r11)		; set up to get blank separated token
                   00000E7B'EF   16  03EF  1575 	jsb	token			; get token
              69   00000050 8F   D1  03F5  1576 	cmpl	#c_max_name_len,(r9)	; is the name over the maximum length?
                            46   12  03FC  1577 	bneq	10$			; no, go on
              7B   000018D8'EF   9E  03FE  1578 	movab	v_nametoolong,-(r11)	; address of error message on stack
                       FC06 CF   16  0405  1579 	jsb	bcount			; get ( addr count )
                   00000FE9'EF   16  0409  1580 	jsb	write			; write out message
                  7B   59   01   C1  040F  1581 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9E  0413  1582 	movab	(r9),-(r11)		; count of name
                   00000FE9'EF   16  0416  1583 	jsb	write			; write out untruncated name
                         88 AF   16  041C  1584 	jsb	cr			; start new line
              69   00000050 8F   D0  041F  1585 	movl	#c_max_name_len,(r9)	; truncate name
              7B   000018E8'EF   9E  0426  1586 	movab	v_nametrunc,-(r11)	; get address of stack
                       FBDE CF   16  042D  1587 	jsb	bcount			; get ( addr count )
                   00000FE9'EF   16  0431  1588 	jsb	write			; write out message
                  7B   59   01   C1  0437  1589 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9A  043B  1590 	movzbl	(r9),-(r11)		; count of name
                   00000FE9'EF   16  043E  1591 	jsb	write			; write out truncated name
                                     0444  1592 10$:
                       50   89   9A  0444  1593 	movzbl	(r9)+,r0		; get byte length and move over it
                       59   50   C0  0447  1594 	addl2	r0,r9			; move over string
                       69   05   90  044A  1595 	movb	#op_rsb,(r9)		; stick a `rsb' in just in case
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  81
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 05  044D  1596 	rsb				; end of create
                                     044E  1597 
                                     044E  1598 
                                     044E  1599 ;+++
                                     044E  1600 ;k> current -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     044E  1601 ;	vocabulary we link new words into.
                                     044E  1602 ;---
                                     044E  1603 	header	current
                           FFFFFFFC  044E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0452       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0452       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0452       	.if    le, nchr		; nchr <= 0
            74 6E 65 72 72 75 63 00' 0452       	   .ascic \current\	; no auxillary , use principle one
                                 07  0452       
                                     045A       	.if_false		; else
                                     045A       	  .ascic \\		; use auxillary 
                                     045A       	.endc			; end if
                                     045A       current:			; use  of word as v1_kernel label
                                     045A       	
              7B   00001D3B'EF   DE  045A  1604 	moval	v_current,-(r11)	; move address (of pointer to vocab
                                     0461  1605 					; that new words are linked to when
                                     0461  1606 					; defining) to stack
                                 05  0461  1607 	rsb				; end of current
                                     0462  1608 
                                     0462  1609 
                                     0462  1610 ;+++
                                     0462  1611 ;k> decimal -- ( -- ) Set base to decimal.
                                     0462  1612 ;---
                                     0462  1613 	header	decimal
                           FFFFFFFC  0462       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0466       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0466       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0466       	.if    le, nchr		; nchr <= 0
            6C 61 6D 69 63 65 64 00' 0466       	   .ascic \decimal\	; no auxillary , use principle one
                                 07  0466       
                                     046E       	.if_false		; else
                                     046E       	  .ascic \\		; use auxillary 
                                     046E       	.endc			; end if
                                     046E       decimal:			; use  of word as v1_kernel label
                                     046E       	
              00001D4E'EF   0A   D0  046E  1614 	movl	#10,v_radix		; switch to base 10
                                 05  0475  1615 	rsb				; end of decimal
                                     0476  1616 
                                     0476  1617 
                                     0476  1618 ;+++
                                     0476  1619 ;k> definitions -- ( -- )  Sets curren to context. { <name> definitions }
                                     0476  1620 ;	makes all new words link into vocabulary { <name> }
                                     0476  1621 ;	(i.e., new operators will be linked dictionary currently being searched).
                                     0476  1622 ;---
                                     0476  1623 	header	definitions
                           FFFFFFFC  0476       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  047A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  047A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  047A       	.if    le, nchr		; nchr <= 0
73 6E 6F 69 74 69 6E 69 66 65 64 00' 047A       	   .ascic \definitions\	; no auxillary , use principle one
                                 0B  047A       
                                     0486       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  82
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0486       	  .ascic \\		; use auxillary 
                                     0486       	.endc			; end if
                                     0486       definitions:			; use  of word as v1_kernel label
                                     0486       	
     00001D3B'EF   00001D37'EF   D0  0486  1624 	movl	v_context, v_current
                                 05  0491  1625 	rsb				; end of definitions
                                     0492  1626 
                                     0492  1627 
                                     0492  1628 ;+++
                                     0492  1629 ;k> drop -- ( n -- ) Drop the top stack item.
                                     0492  1630 ;---
                                     0492  1631 	header	drop
                           FFFFFFFC  0492       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0496       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0496       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0496       	.if    le, nchr		; nchr <= 0
                     70 6F 72 64 00' 0496       	   .ascic \drop\	; no auxillary , use principle one
                                 04  0496       
                                     049B       	.if_false		; else
                                     049B       	  .ascic \\		; use auxillary 
                                     049B       	.endc			; end if
                                     049B       drop:			; use  of word as v1_kernel label
                                     049B       	
                       5B   04   C0  049B  1632 	addl2	#4,r11			; pop argument, dropping top item
                                 05  049E  1633 	rsb				; end of drop
                                     049F  1634 
                                     049F  1635 
                                     049F  1636 ;+++
                                     049F  1637 ;k> ds>ls -- ( n -- ) move `n' to loop stack.
                                     049F  1638 ;---
                                     049F  1639 	header	i_ds_to_ls,^/ds>ls/
                           FFFFFFFC  049F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  04A3       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  04A3       	.nchr  nchr, ^\ds>ls\	; nchr = length( ds>ls )
                           00000005  04A3       	.if    le, nchr		; nchr <= 0
                                     04A3       	   .ascic \i_ds_to_ls\	; no auxillary ds>ls, use principle one
                                     04A3       	.if_false		; else
                  73 6C 3E 73 64 00' 04A3       	  .ascic \ds>ls\		; use auxillary ds>ls
                                 05  04A3       
                                     04A9       	.endc			; end if
                                     04A9       i_ds_to_ls:			; use ds>ls of word as v1_kernel label
                                     04A9       	
                       7A   8B   D0  04A9  1640 	movl	(r11)+,-(r10)		; pop from dstack, move to lstack.
                                 05  04AC  1641 	rsb				; end of ds>ls
                                     04AD  1642 
                                     04AD  1643 
                                     04AD  1644 ;+++
                                     04AD  1645 ;k> dup -- ( n -- n n ) Duplicated the top stack entry.
                                     04AD  1646 ;---
                                     04AD  1647 	header	dup
                           FFFFFFFC  04AD       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  04B1       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  04B1       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  04B1       	.if    le, nchr		; nchr <= 0
                        70 75 64 00' 04B1       	   .ascic \dup\	; no auxillary , use principle one
                                 03  04B1       
                                     04B5       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  83
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     04B5       	  .ascic \\		; use auxillary 
                                     04B5       	.endc			; end if
                                     04B5       dup:			; use  of word as v1_kernel label
                                     04B5       	
                       7B   6B   D0  04B5  1648 	movl	(r11),-(r11)
                                 05  04B8  1649 	rsb				; end of dup
                                     04B9  1650 
                                     04B9  1651 
                                     04B9  1652 ;+++
                                     04B9  1653 ;k> empty-buffers -- ( -- ) Mark all buffers unmodified without writing.
                                     04B9  1654 ;---
                                     04B9  1655 	header	i_empty_buffers,<empty-buffers>
                           FFFFFFFC  04B9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  04BD       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000D  04BD       	.nchr  nchr, ^\empty-buffers\	; nchr = length( empty-buffers )
                           0000000D  04BD       	.if    le, nchr		; nchr <= 0
                                     04BD       	   .ascic \i_empty_buffers\	; no auxillary empty-buffers, use principle one
                                     04BD       	.if_false		; else
65 66 66 75 62 2D 79 74 70 6D 65 00' 04BD       	  .ascic \empty-buffers\		; use auxillary empty-buffers
                              73 72  04C9       
                                 0D  04BD       
                                     04CB       	.endc			; end if
                                     04CB       i_empty_buffers:			; use empty-buffers of word as v1_kernel label
                                     04CB       	
                            50   D4  04CB  1656 	clrl	r0			; buffer number
                                     04CD  1657 10$:
                            00   90  04CD  1658 	movb	#c_false,-		; mark with c_false to show
                 00001B7D'EF40       04CF  1659 		v_buf_inuse[r0]		;   emptied, not in use
                            00   D0  04D5  1660 	movl	#c_false,-		; mark with c_false to show
                 00001B80'EF40       04D7  1661 		v_buf_blk_nums[r0]	;  holds no block number
                            02   F1  04DD  1662 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFEA 50   01       04DF  1663 		#1,r0,10$		; move to next buffer number, if any
                                 05  04E3  1664 	rsb				; end of empty buffers
                                     04E4  1665 
                                     04E4  1666 
                                     04E4  1667 ;
                                     04E4  1668 ;??? Note: the `eodp' words are supplied so that the user can work with the
                                     04E4  1669 ;	dictionary without having to know if eodp is a register or a variable.
                                     04E4  1670 ;
                                     04E4  1671 
                                     04E4  1672 
                                     04E4  1673 ;+++
                                     04E4  1674 ;k> eodp -- ( -- a ) Return address of next free byte in dictionary.
                                     04E4  1675 ;	Means "end of dictinary pointer".
                                     04E4  1676 ;---
                                     04E4  1677 	header	eodp
                           FFFFFFFC  04E4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  04E8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  04E8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  04E8       	.if    le, nchr		; nchr <= 0
                     70 64 6F 65 00' 04E8       	   .ascic \eodp\	; no auxillary , use principle one
                                 04  04E8       
                                     04ED       	.if_false		; else
                                     04ED       	  .ascic \\		; use auxillary 
                                     04ED       	.endc			; end if
                                     04ED       eodp:			; use  of word as v1_kernel label
                                     04ED       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  84
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       7B   59   D0  04ED  1678 	movl	r9,-(r11)		; get
                                 05  04F0  1679 	rsb				; end of eodp
                                     04F1  1680 
                                     04F1  1681 
                                     04F1  1682 ;+++
                                     04F1  1683 ;k> eodp! -- ( a -- ) Make `a' new value of end of dictionary  pointer.
                                     04F1  1684 ;---
                                     04F1  1685 	header	i_eod_store,<eodp!>
                           FFFFFFFC  04F1       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  04F5       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  04F5       	.nchr  nchr, ^\eodp!\	; nchr = length( eodp! )
                           00000005  04F5       	.if    le, nchr		; nchr <= 0
                                     04F5       	   .ascic \i_eod_store\	; no auxillary eodp!, use principle one
                                     04F5       	.if_false		; else
                  21 70 64 6F 65 00' 04F5       	  .ascic \eodp!\		; use auxillary eodp!
                                 05  04F5       
                                     04FB       	.endc			; end if
                                     04FB       i_eod_store:			; use eodp! of word as v1_kernel label
                                     04FB       	
                       59   8B   D0  04FB  1686 	movl	(r11)+,r9		; make eodp = top of stack
                                 05  04FE  1687 	rsb				; end of edop!
                                     04FF  1688 
                                     04FF  1689 
                                     04FF  1690 ;+++
                                     04FF  1691 ;k> eodp+! -- ( n -- ) Add `n' to end of dictionary pointer.
                                     04FF  1692 ;---
                                     04FF  1693 	header	i_eodp_plus_store,<eodp+!>
                           FFFFFFFC  04FF       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0503       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000006  0503       	.nchr  nchr, ^\eodp+!\	; nchr = length( eodp+! )
                           00000006  0503       	.if    le, nchr		; nchr <= 0
                                     0503       	   .ascic \i_eodp_plus_store\	; no auxillary eodp+!, use principle one
                                     0503       	.if_false		; else
               21 2B 70 64 6F 65 00' 0503       	  .ascic \eodp+!\		; use auxillary eodp+!
                                 06  0503       
                                     050A       	.endc			; end if
                                     050A       i_eodp_plus_store:			; use eodp+! of word as v1_kernel label
                                     050A       	
                       59   8B   C0  050A  1694 	addl2	(r11)+,r9		; add top of stack to eodp
                                 05  050D  1695 	rsb				; end of eodp+!
                                     050E  1696 
                                     050E  1697 
                                     050E  1698 ;+++
                                     050E  1699 ;k> eve -- call up eve editor.	Format: { eve filename }.
                                     050E  1700 ;---
                                     050E  1701 	header	eve
                           FFFFFFFC  050E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0512       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0512       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0512       	.if    le, nchr		; nchr <= 0
                        65 76 65 00' 0512       	   .ascic \eve\	; no auxillary , use principle one
                                 03  0512       
                                     0516       	.if_false		; else
                                     0516       	  .ascic \\		; use auxillary 
                                     0516       	.endc			; end if
                                     0516       eve:			; use  of word as v1_kernel label
                                     0516       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  85
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       7B   20   D0  0516  1702 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   00000E7B'EF   16  0519  1703 	jsb	token			; get the token
                       56   69   9A  051F  1704 	movzbl	(r9),r6			; save length
                  57   59   01   C1  0522  1705 	addl3	#1,r9,r7		; start of string
         00001C56'EF   67   56   28  0526  1706 	movc3	r6,(r7),v_tpu_com2	; move string into buffer
         00001CF6'EF   56   1C   A1  052E  1707 	addw3	#c_tpu_com_len,r6,-	; put length in descriptor
                                     0536  1708 		v_tpu_dsc
                   00001CF6'EF   7F  0536  1709 	pushaq	v_tpu_dsc		; push address of command
              00000000'GF   01   FB  053C  1710 	calls	#1,g^tpu$tpu		; call tpu
                         01 50   E9  0543  1711 	blbc	r0,10$			; ?error
                                 05  0546  1712 	rsb				; no, exit
                                     0547  1713 10$:					; yes, signal and patch
                            50   DD  0547  1714 	pushl	r0			; set up for signal
              00000000'GF   01   FB  0549  1715 	calls	#1,g^lib$signal		; signal it
                          1091   31  0550  1716 	brw	r_warm_start		; patch VTIL to run
                                     0553  1717 					; end of eve
                                     0553  1718 
                                     0553  1719 
                                     0553  1720 ;+++
                                     0553  1721 ;k> exit -- ( -- ) Exit VTIL.  Never returns.
                                     0553  1722 ;---
                                     0553  1723 	header	i_exit,<exit>
                           FFFFFFFC  0553       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0557       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  0557       	.nchr  nchr, ^\exit\	; nchr = length( exit )
                           00000004  0557       	.if    le, nchr		; nchr <= 0
                                     0557       	   .ascic \i_exit\	; no auxillary exit, use principle one
                                     0557       	.if_false		; else
                     74 69 78 65 00' 0557       	  .ascic \exit\		; use auxillary exit
                                 04  0557       
                                     055C       	.endc			; end if
                                     055C       i_exit:			; use exit of word as v1_kernel label
                                     055C       	
                          123E   31  055C  1724 	brw	_exit			; exit silently
                                     055F  1725 
                                     055F  1726 
                                     055F  1727 ;+++
                                     055F  1728 ;k> fill -- ( a w c -- l ) Fill `w' bytes from `a' with character `c'.
                                     055F  1729 ;---
                                     055F  1730 	header	fill
                           FFFFFFFC  055F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0563       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0563       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0563       	.if    le, nchr		; nchr <= 0
                     6C 6C 69 66 00' 0563       	   .ascic \fill\	; no auxillary , use principle one
                                 04  0563       
                                     0568       	.if_false		; else
                                     0568       	  .ascic \\		; use auxillary 
                                     0568       	.endc			; end if
                                     0568       fill:			; use  of word as v1_kernel label
                                     0568       	
                       69   00   2C  0568  1731 	movc5	#0,(r9),-		; srclen,src (use eodp just to be safe)
                            6B       056B  1732 		(r11),-			; fill character
                 08 BB   04 AB       056C  1733 		4(r11),@8(r11)		; destlen, dest
                       5B   0C   C0  0570  1734 	addl2	#12,r11			; pop arguments
                                 05  0573  1735 	rsb				; end of fill
                                     0574  1736 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  86
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0574  1737 
                                     0574  1738 ;+++
                                     0574  1739 ;k> flush-buffers -- ( -- ) wite all modified buffers and mark them unmodified.
                                     0574  1740 ;---
                                     0574  1741 	header	i_flush_buffers,<flush-buffers>
                           FFFFFFFC  0574       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0578       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000D  0578       	.nchr  nchr, ^\flush-buffers\	; nchr = length( flush-buffers )
                           0000000D  0578       	.if    le, nchr		; nchr <= 0
                                     0578       	   .ascic \i_flush_buffers\	; no auxillary flush-buffers, use principle one
                                     0578       	.if_false		; else
65 66 66 75 62 2D 68 73 75 6C 66 00' 0578       	  .ascic \flush-buffers\		; use auxillary flush-buffers
                              73 72  0584       
                                 0D  0578       
                                     0586       	.endc			; end if
                                     0586       i_flush_buffers:			; use flush-buffers of word as v1_kernel label
                                     0586       	
                            50   D4  0586  1742 	clrl	r0			; bufffer number
                                     0588  1743 10$:
                            02   91  0588  1744 	cmpb	#c_modified,-		; Has the buffer
                 00001B7D'EF40       058A  1745 		v_buf_inuse[r0]		;   been modified?
                            15   12  0590  1746 	bneq	20$			; no, skip it
                       7A   50   D0  0592  1747 	movl	r0,-(r10)		; save the buffer name
                       7B   50   D0  0595  1748 	movl	r0,-(r11)		; set up for buffer-write
                       FCF6 CF   16  0598  1749 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  059C  1750 	movl	(r10)+,r0		; get the buffer number back
                            00   90  059F  1751 	movb	#c_false,-		; mark the buffer as
                 00001B7D'EF40       05A1  1752 		v_buf_inuse[r0]		;   flushed, not in use
                                     05A7  1753 20$:
                            02   F1  05A7  1754 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFDB 50   01       05A9  1755 		#1,r0,10$		; move to next buffer number, if any
                                 05  05AD  1756 	rsb				; end of flush-buffers
                                     05AE  1757 
                                     05AE  1758 
                                     05AE  1759 ;+++
                                     05AE  1760 ;k> forget -- ( -- ) reset content vocab back to word before word forgotten.
                                     05AE  1761 ;	Note that while this makes the forgotten word and any words
                                     05AE  1762 ;	defined after it unavailale, it does not reclaim an space,
                                     05AE  1763 ;	since the other vocabularies can be threaded through in the
                                     05AE  1764 ;	dictionary between words of this vocabulary.
                                     05AE  1765 ;---
                                     05AE  1766 ;??? Should I make { forget } = { forget/erase }?  Why did I make both
                                     05AE  1767 ; in the first place?
                                     05AE  1768 	header	forget
                           FFFFFFFC  05AE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  05B2       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  05B2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  05B2       	.if    le, nchr		; nchr <= 0
               74 65 67 72 6F 66 00' 05B2       	   .ascic \forget\	; no auxillary , use principle one
                                 06  05B2       
                                     05B9       	.if_false		; else
                                     05B9       	  .ascic \\		; use auxillary 
                                     05B9       	.endc			; end if
                                     05B9       forget:			; use  of word as v1_kernel label
                                     05B9       	
                       7B   20   D0  05B9  1769 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   00000E7B'EF   16  05BC  1770 	jsb	token			; get token
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  87
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

              7B   00001D37'FF   D0  05C2  1771 	movl	@v_context,-(r11)	; start search at context
                   00000B1F'EF   16  05C9  1772 	jsb	search			; search it
                            8B   D5  05CF  1773 	tstl	(r11)+			; Was it found?
                            0C   13  05D1  1774 	beql	100$			; No, tell user
                                     05D3  1775 ; make vocab point to word before the forgotten one.
           00001D37'FF   00 BB   D0  05D3  1776 	movl	@(r11),@v_context	;
                       5B   04   C0  05DB  1777 	addl2	#4,r11			; pop address of found word
                                 05  05DE  1778 	rsb				; exit
                                     05DF  1779 100$:
              7B   000018C7'EF   9E  05DF  1780 	movab	v_wordnotfound,-(r11)	; put address of error message on stack
                       FA25 CF   16  05E6  1781 	jsb	bcount			; get address of text and length
                   00000FE9'EF   16  05EA  1782 	jsb	write			; write error message
                       7B   59   D0  05F0  1783 	movl	r9,-(r11)		; address of token not found in search
                       FA18 CF   16  05F3  1784 	jsb	bcount			; get address of text and length
                   00000FE9'EF   16  05F7  1785 	jsb	write			; write the name of the word
                          0FE4   31  05FD  1786 	brw	r_warm_start		; end of forget
                                     0600  1787 
                                     0600  1788 
                                     0600  1789 ;+++
                                     0600  1790 ;k> forget/erase -- ( -- ) rset context vocab to word before word forgotten
                                     0600  1791 ;	and move the dictinary back to header address of word forgotten.
                                     0600  1792 ;	In other words, dictinary is truncated BEFORE the word forgotten. ~~~Add warning
                                     0600  1793 ;---
                                     0600  1794 	header	i_forget_erase,<forget/erase>
                           FFFFFFFC  0600       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0604       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000C  0604       	.nchr  nchr, ^\forget/erase\	; nchr = length( forget/erase )
                           0000000C  0604       	.if    le, nchr		; nchr <= 0
                                     0604       	   .ascic \i_forget_erase\	; no auxillary forget/erase, use principle one
                                     0604       	.if_false		; else
73 61 72 65 2F 74 65 67 72 6F 66 00' 0604       	  .ascic \forget/erase\		; use auxillary forget/erase
                                 65  0610       
                                 0C  0604       
                                     0611       	.endc			; end if
                                     0611       i_forget_erase:			; use forget/erase of word as v1_kernel label
                                     0611       	
                       7B   20   D0  0611  1795 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   00000E7B'EF   16  0614  1796 	jsb	token			; get token
              7B   00001D37'FF   D0  061A  1797 	movl	@v_context,-(r11)	; start search at contxt
                   00000B1F'EF   16  0621  1798 	jsb	search			; search it
                            8B   D5  0627  1799 	tstl	(r11)+			; Was it found?
                            0F   13  0629  1800 	beql	100$			; No, tell user
                                     062B  1801 ; make vocab point to word before the forgotten one.
           00001D37'FF   00 BB   D0  062B  1802 	movl	@(r11),@v_context
                       59   6B   D0  0633  1803 	movl	(r11),r9		; truncate dictionary
                       6B   04   C0  0636  1804 	addl2	#4,(r11)		; pop address of found word
                                 05  0639  1805 	rsb				; return
                                     063A  1806 100$:
              7B   000018C7'EF   9E  063A  1807 	movab	v_wordnotfound,-(r11)	;
                       F9CA CF   16  0641  1808 	jsb	bcount			; get address of text and length
                   00000FE9'EF   16  0645  1809 	jsb	write			; write error message
                       7B   59   D0  064B  1810 	movl	r9,-(r11)		; address of token not found in search
                       F9BD CF   16  064E  1811 	jsb	bcount			; get addres of text and length
                   00000FE9'EF   16  0652  1812 	jsb	write			; write the name of the word ~~ not found
                          0F89   31  0658  1813 	brw	r_warm_start		; end of forget/erase
                                     065B  1814 
                                     065B  1815 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  88
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     065B  1816 ;+++
                                     065B  1817 ;k> freemem -- ( -- l ) print amount of memory left in dictionary
                                     065B  1818 ;--- ~~~ does it really leave a longword on the stack?
                                     065B  1819 	header	freemem
                           FFFFFFFC  065B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  065F       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  065F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  065F       	.if    le, nchr		; nchr <= 0
            6D 65 6D 65 65 72 66 00' 065F       	   .ascic \freemem\	; no auxillary , use principle one
                                 07  065F       
                                     0667       	.if_false		; else
                                     0667       	  .ascic \\		; use auxillary 
                                     0667       	.endc			; end if
                                     0667       freemem:			; use  of word as v1_kernel label
                                     0667       	
         7B   00004000'8F   59   C3  0667  1820 	subl3	r9,#c_dict_end,-(r11)	; put free space on stack
                       FAB0 CF   16  066F  1821 	jsb	i_dot			; print it
                                 05  0673  1822 	rsb				; end of freemem
                                     0674  1823 
                                     0674  1824 
                                     0674  1825 ;+++
                                     0674  1826 ;k> halt -- ( l -- ) halt VTIL, use `l' as returned value.  Never returns. ~~~ Change "returned value" to "exit status?
                                     0674  1827 ;---
                                     0674  1828 	header	i_halt,<halt>
                           FFFFFFFC  0674       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0678       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  0678       	.nchr  nchr, ^\halt\	; nchr = length( halt )
                           00000004  0678       	.if    le, nchr		; nchr <= 0
                                     0678       	   .ascic \i_halt\	; no auxillary halt, use principle one
                                     0678       	.if_false		; else
                     74 6C 61 68 00' 0678       	  .ascic \halt\		; use auxillary halt
                                 04  0678       
                                     067D       	.endc			; end if
                                     067D       i_halt:			; use halt of word as v1_kernel label
                                     067D       	
                       50   8B   D0  067D  1829 	movl	(r11)+,r0		; put error number in right place
                          10E7   31  0680  1830 	brw	_error_exit		; go to error exit routine
                                     0683  1831 					; end of halt
                                     0683  1832 
                                     0683  1833 
                                     0683  1834 ;+++
                                     0683  1835 ;k> hex -- ( -- ) Set the base to hexidecimal.
                                     0683  1836 ;---
                                     0683  1837 	header	hex
                           FFFFFFFC  0683       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0687       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0687       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0687       	.if    le, nchr		; nchr <= 0
                        78 65 68 00' 0687       	   .ascic \hex\	; no auxillary , use principle one
                                 03  0687       
                                     068B       	.if_false		; else
                                     068B       	  .ascic \\		; use auxillary 
                                     068B       	.endc			; end if
                                     068B       hex:			; use  of word as v1_kernel label
                                     068B       	
              00001D4E'EF   10   D0  068B  1838 	movl	#16,v_radix		; switch to base 16 (hexadecimal)
                                 05  0692  1839 	rsb				; end of hex
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  89
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0693  1840 
                                     0693  1841 
                                     0693  1842 ;+++
                                     0693  1843 ;k> hld -- ( -- a ) Variable hld, return address of hld.
                                     0693  1844 ;---
                                     0693  1845 	header	hld
                           FFFFFFFC  0693       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0697       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0697       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0697       	.if    le, nchr		; nchr <= 0
                        64 6C 68 00' 0697       	   .ascic \hld\	; no auxillary , use principle one
                                 03  0697       
                                     069B       	.if_false		; else
                                     069B       	  .ascic \\		; use auxillary 
                                     069B       	.endc			; end if
                                     069B       hld:			; use  of word as v1_kernel label
                                     069B       	
              7B   00001D52'EF   DE  069B  1846 	moval	v_hld,-(r11)		; leave address on stack
                                 05  06A2  1847 	rsb				; end of hld
                                     06A3  1848 
                                     06A3  1849 
                                     06A3  1850 ;+++
                                     06A3  1851 ;k> hold -- ( -- ) Insert `c' in current numeric output string.
                                     06A3  1852 ;---
                                     06A3  1853 	header	hold
                           FFFFFFFC  06A3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  06A7       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  06A7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  06A7       	.if    le, nchr		; nchr <= 0
                     64 6C 6F 68 00' 06A7       	   .ascic \hold\	; no auxillary , use principle one
                                 04  06A7       
                                     06AC       	.if_false		; else
                                     06AC       	  .ascic \\		; use auxillary 
                                     06AC       	.endc			; end if
                                     06AC       hold:			; use  of word as v1_kernel label
                                     06AC       	
                   00001D52'EF   D7  06AC  1854 	decl	v_hld			; move pointer down one char
              00001D52'FF   6B   90  06B2  1855 	movb	(r11),@v_hld		; fill new char w/top of stack
                       5B   04   C0  06B9  1856 	addl2	#4,r11			; pop char off stack
                                 05  06BC  1857 	rsb				; end of hold
                                     06BD  1858 
                                     06BD  1859 
                                     06BD  1860 ;+++
                                     06BD  1861 ;k> i> -- ( -- ) Copy the top of the loop stack to the data stack.
                                     06BD  1862 ;	This word is used inside of { do ... loop }'s to get the index
                                     06BD  1863 ;	of the innermost loop onto the top of the stack.
                                     06BD  1864 ;---
                                     06BD  1865 	header	i_i_to,^\i>\
                           FFFFFFFC  06BD       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  06C1       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  06C1       	.nchr  nchr, ^\i>\	; nchr = length( i> )
                           00000002  06C1       	.if    le, nchr		; nchr <= 0
                                     06C1       	   .ascic \i_i_to\	; no auxillary i>, use principle one
                                     06C1       	.if_false		; else
                           3E 69 00' 06C1       	  .ascic \i>\		; use auxillary i>
                                 02  06C1       
                                     06C4       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  90
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     06C4       i_i_to:			; use i> of word as v1_kernel label
                                     06C4       	
                       7B   6A   D0  06C4  1866 	movl	(r10),-(r11)		; copy w/o consuming ~~~ from loop stack.
                                 05  06C7  1867 	rsb				; end of i>
                                     06C8  1868 
                                     06C8  1869 
                                     06C8  1870 ;+++
                                     06C8  1871 ;k> kernel -- ( -- ) Set context to kernel vocabulary.
                                     06C8  1872 ;---
                                     06C8  1873 	header	kernel
                           FFFFFFFC  06C8       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  06CC       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  06CC       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  06CC       	.if    le, nchr		; nchr <= 0
               6C 65 6E 72 65 6B 00' 06CC       	   .ascic \kernel\	; no auxillary , use principle one
                                 06  06CC       
                                     06D3       	.if_false		; else
                                     06D3       	  .ascic \\		; use auxillary 
                                     06D3       	.endc			; end if
                                     06D3       kernel:			; use  of word as v1_kernel label
                                     06D3       	
     00001D37'EF   00001D43'EF   DE  06D3  1874 	moval	v_kernel,v_context
                                 05  06DE  1875 	rsb				; end of kernel
                                     06DF  1876 
                                     06DF  1877 
                                     06DF  1878 ;+++
                                     06DF  1879 ;k> leave -- ( -- ) Leave a { do } loop at end of this iteration.
                                     06DF  1880 ;---
                                     06DF  1881 	header	leave
                           FFFFFFFC  06DF       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  06E3       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  06E3       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  06E3       	.if    le, nchr		; nchr <= 0
                  65 76 61 65 6C 00' 06E3       	   .ascic \leave\	; no auxillary , use principle one
                                 05  06E3       
                                     06E9       	.if_false		; else
                                     06E9       	  .ascic \\		; use auxillary 
                                     06E9       	.endc			; end if
                                     06E9       leave:			; use  of word as v1_kernel label
                                     06E9       	
                    04 AA   6A   D0  06E9  1882 	movl	(r10),4(r10)		; make limit = index so loop will exit
                                 05  06ED  1883 	rsb				; end of leave
                                     06EE  1884 
                                     06EE  1885 
                                     06EE  1886 ;+++
                                     06EE  1887 ;k> load -- ( -- ) Take input from file instead of the terminal.
                                     06EE  1888 ;	Format: { load filename }
                                     06EE  1889 ;---
                                     06EE  1890 	header	load
                           FFFFFFFC  06EE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  06F2       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  06F2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  06F2       	.if    le, nchr		; nchr <= 0
                     64 61 6F 6C 00' 06F2       	   .ascic \load\	; no auxillary , use principle one
                                 04  06F2       
                                     06F7       	.if_false		; else
                                     06F7       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  91
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     06F7       	.endc			; end if
                                     06F7       load:			; use  of word as v1_kernel label
                                     06F7       	
                       7B   20   D0  06F7  1891 	movl	#c_blank,-(r11)		; set up for blank terminated file name
                   00000E7B'EF   16  06FA  1892 	jsb	token			; get v_fname
                       56   69   9A  0700  1893 	movzbl	(r9),r6			; get count of v_fname
      00001A3D'EF   01 A9   56   28  0703  1894 	movc3	r6,1(r9),v_fname	; move to name buffer
              00001A3C'EF   56   90  070C  1895 	movb	r6,v_fnamelen		; save length
                   00001A3D'EF   DE  0713  1896 	moval	v_fname,-
                   000019D4'EF       0719  1897 		v_infab+fab$l_fna	; tell it where filespec is
                   00001A3C'EF   90  071E  1898 	movb	v_fnamelen,-
                   000019DC'EF       0724  1899 		v_infab+fab$b_fns	; tell it what size filespec is
                                     0729  1900 	$open	fab=v_infab		; open input file
                                     0729       		$RMSCALL	OPEN,v_infab,,
                                     0729       	.GLOBL	SYS$OPEN
                                     0729       	.IF	B <v_infab>
                                     0729       	CALLG	(AP),G^SYS$OPEN
                                     0729       	$$.TMP=0
                                     0729       	.IF	NB <>
                                     0729       	$$.TMP=1
                                     0729       	.ENDC
                                     0729       	.IF	NB <>
                                     0729       	$$.TMP=1
                                     0729       	.ENDC
                                     0729       	.IF	NE $$.TMP
                                     0729       	.ERROR				; v_infab= parameter missing;
                                     0729       	.ENDC
                                     0729       	.ENDC
                                     0729       	.IF	NB <v_infab>
                           00000001  0729       	$$.TMP1=1
                                     0729       	.IF	NB <>
                                     0729       	PUSHAL	
                                     0729       	$$.TMP1=3
                                     0729       	.ENDC
                                     0729       	.IF	NB <>
                                     0729       	PUSHAL	
                                     0729       	.IF	EQ <$$.TMP1-1>
                                     0729       	$$.TMP1=2
                                     0729       	.ENDC
                                     0729       	.IFF
                           FFFFFFFE  0729       	.IF	EQ <$$.TMP1-3>
                                     0729       	PUSHL	#0
                                     0729       	.ENDC
                                     0729       	.ENDC
                           000000CF  0729       	.NTYPE	$$.TMP2,v_infab
                           00000070  0729       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0729       	PUSHL	v_infab
                                     0729       	.IFF
                           000000B0  0729       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0729       	PUSHL	v_infab
                                     0729       	.IFF
                   000019A8'EF   DF  0729       	PUSHAL	v_infab
                                     072F       	.ENDC
                                     072F       	.ENDC
              00000000'GF   01   FB  072F       	CALLS	#$$.TMP1,G^SYS$OPEN
                                     0736       	.ENDC
                                     0736       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  92
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0736       	
                         12 50   E9  0736  1901 	blbc	r0,10$			; Quit on error
                                     0739  1902 	$connect rab=v_inrab		; connect to input
                                     0739       		$RMSCALL	CONNECT,v_inrab,,
                                     0739       	.GLOBL	SYS$CONNECT
                                     0739       	.IF	B <v_inrab>
                                     0739       	CALLG	(AP),G^SYS$CONNECT
                                     0739       	$$.TMP=0
                                     0739       	.IF	NB <>
                                     0739       	$$.TMP=1
                                     0739       	.ENDC
                                     0739       	.IF	NB <>
                                     0739       	$$.TMP=1
                                     0739       	.ENDC
                                     0739       	.IF	NE $$.TMP
                                     0739       	.ERROR				; v_inrab= parameter missing;
                                     0739       	.ENDC
                                     0739       	.ENDC
                                     0739       	.IF	NB <v_inrab>
                           00000001  0739       	$$.TMP1=1
                                     0739       	.IF	NB <>
                                     0739       	PUSHAL	
                                     0739       	$$.TMP1=3
                                     0739       	.ENDC
                                     0739       	.IF	NB <>
                                     0739       	PUSHAL	
                                     0739       	.IF	EQ <$$.TMP1-1>
                                     0739       	$$.TMP1=2
                                     0739       	.ENDC
                                     0739       	.IFF
                           FFFFFFFE  0739       	.IF	EQ <$$.TMP1-3>
                                     0739       	PUSHL	#0
                                     0739       	.ENDC
                                     0739       	.ENDC
                           000000CF  0739       	.NTYPE	$$.TMP2,v_inrab
                           00000070  0739       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0739       	PUSHL	v_inrab
                                     0739       	.IFF
                           000000B0  0739       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0739       	PUSHL	v_inrab
                                     0739       	.IFF
                   000019F8'EF   DF  0739       	PUSHAL	v_inrab
                                     073F       	.ENDC
                                     073F       	.ENDC
              00000000'GF   01   FB  073F       	CALLS	#$$.TMP1,G^SYS$CONNECT
                                     0746       	.ENDC
                                     0746       	
                                     0746       	
                         23 50   E9  0746  1903 	blbc	r0,20$			; Quit on error
                            2B   11  0749  1904 	brb	40$			; branch to read loop
                                     074B  1905 10$:
              00000000'8F   50   D1  074B  1906 	cmpl	r0,#rms$_fnf		; is it file not found?
                            0E   12  0752  1907 	bneq	15$			; no
                   0000189A'EF   7F  0754  1908 	pushaq	v_filenotfound		;
              00000000'GF   01   FB  075A  1909 	calls	#1,g^lib$put_output	; Tell user file not found
                                 05  0761  1910 	rsb				; return
                                     0762  1911 15$:
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  93
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

              56   000019A8'EF   DE  0762  1912 	moval	v_infab,r6		; error: keep fab address
                          1008   31  0769  1913 	brw	_f_err			; signal file error
                                     076C  1914 20$:
              56   000019F8'EF   DE  076C  1915 	moval	v_inrab,r6		; keep rab address
                          100D   31  0773  1916 	brw	_r_err			; signal record error
                                     0776  1917 40$:
           00001D47'EF   FF 8F   90  0776  1918 	movb	#c_true,v_infile	; set input from file flag
              00001D48'EF   00   D0  077E  1919 	movl	#0,v_filelinenum	; reinitialize number of lines read
                                 05  0785  1920 	rsb				; end of load
                                     0786  1921 
                                     0786  1922 
                                     0786  1923 ;+++t
                                     0786  1924 ;k> long -- ( n -- ) Create a word that pushed address of longword on stack,
                                     0786  1925 ;	save space in dictionary, and initialize to `n'.
                                     0786  1926 ;---
                                     0786  1927 	header	i_long,<long>
                           FFFFFFFC  0786       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  078A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000004  078A       	.nchr  nchr, ^\long\	; nchr = length( long )
                           00000004  078A       	.if    le, nchr		; nchr <= 0
                                     078A       	   .ascic \i_long\	; no auxillary long, use principle one
                                     078A       	.if_false		; else
                     67 6E 6F 6C 00' 078A       	  .ascic \long\		; use auxillary long
                                 04  078A       
                                     078F       	.endc			; end if
                                     078F       i_long:			; use long of word as v1_kernel label
                                     078F       	
                       FC48 CF   16  078F  1928 	jsb	create			; enclose next token in dictionary
                    89   DE 8F   90  0793  1929 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  0797  1930 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  079B  1931 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  079E  1932 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  07A2  1933 	movb	#op_rsb,(r9)+		; `rsb'
                       89   8B   D0  07A5  1934 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                                 05  07A8  1935 	rsb				; end of long
                                     07A9  1936 
                                     07A9  1937 
                                     07A9  1938 ;+++t
                                     07A9  1939 ;k> longconst -- ( n -- ) Create a word that pushed a `n' to the stack.
                                     07A9  1940 ;---
                                     07A9  1941 	header	longconst
                           FFFFFFFC  07A9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  07AD       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  07AD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07AD       	.if    le, nchr		; nchr <= 0
      74 73 6E 6F 63 67 6E 6F 6C 00' 07AD       	   .ascic \longconst\	; no auxillary , use principle one
                                 09  07AD       
                                     07B7       	.if_false		; else
                                     07B7       	  .ascic \\		; use auxillary 
                                     07B7       	.endc			; end if
                                     07B7       longconst:			; use  of word as v1_kernel label
                                     07B7       	
                       FC20 CF   16  07B7  1942 	jsb	create			; enclose next token in dictionary
                   0000133C'EF   16  07BB  1943 	jsb	literal			; enclose code in dictionary
                       89   05   90  07C1  1944 	movb	#op_rsb,(r9)+		; stick `rsb' into dictionary to
                                     07C4  1945 					;   end constant word
                                 05  07C4  1946 	rsb				; end of longconst
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  94
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     07C5  1947 
                                     07C5  1948 
                                     07C5  1949 ;+++
                                     07C5  1950 ;k> ls>ds -- ( -- n ) Remove `n' from loop stack.
                                     07C5  1951 ;---
                                     07C5  1952 	header	i_ls_to_ds,^/ls>ds/
                           FFFFFFFC  07C5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  07C9       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  07C9       	.nchr  nchr, ^\ls>ds\	; nchr = length( ls>ds )
                           00000005  07C9       	.if    le, nchr		; nchr <= 0
                                     07C9       	   .ascic \i_ls_to_ds\	; no auxillary ls>ds, use principle one
                                     07C9       	.if_false		; else
                  73 64 3E 73 6C 00' 07C9       	  .ascic \ls>ds\		; use auxillary ls>ds
                                 05  07C9       
                                     07CF       	.endc			; end if
                                     07CF       i_ls_to_ds:			; use ls>ds of word as v1_kernel label
                                     07CF       	
                       7B   8A   D0  07CF  1953 	movl	(r10)+,-(r11)		; pop from loop stack, move to dstack
                                 05  07D2  1954 	rsb				; end of ls>ds
                                     07D3  1955 
                                     07D3  1956 
                                     07D3  1957 ;+++
                                     07D3  1958 ;k> match -- ( a1 n1 a2 n2 -- a3 ? f ) Search for string of length `n2' at
                                     07D3  1959 ;	`a2' in string of length `n' at `a'.
                                     07D3  1960 ;---
                                     07D3  1961 	header	i_match,<match>
                           FFFFFFFC  07D3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  07D7       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  07D7       	.nchr  nchr, ^\match\	; nchr = length( match )
                           00000005  07D7       	.if    le, nchr		; nchr <= 0
                                     07D7       	   .ascic \i_match\	; no auxillary match, use principle one
                                     07D7       	.if_false		; else
                  68 63 74 61 6D 00' 07D7       	  .ascic \match\		; use auxillary match
                                 05  07D7       
                                     07DD       	.endc			; end if
                                     07DD       i_match:			; use match of word as v1_kernel label
                                     07DD       	
                    04 BB   6B   39  07DD  1962 	matchc	(r11),@4(r11),-		; object string (one we're looking for)
                 0C BB   08 AB       07E1  1963 		8(r11),@12(r11)		; source string (one we're looking in)
                            12   12  07E5  1964 	bneq	100$			; no match found
                                     07E7  1965 ; match found, calcualte its address.  matchc leaves in r3 the address of the
                                     07E7  1966 ; byte after last byte matched in the source string, so address of matched
                                     07E7  1967 ; string is r3 - objectlen.
                  50   53   61   C3  07E7  1968 	subl3  (r1),r3,r0		; calculate address of matched string
                       5B   10   C0  07EB  1969 	addl2  #16,r11			; pop arguments
                       7B   50   D0  07EE  1970 	movl   r0,-(r11)		; put address of matched string on stack
              7B   FFFFFFFF 8F   D0  07F1  1971 	movl   #c_true,-(r11)		; leave true on top of stack
                                 05  07F8  1972 	rsb				; return
                                     07F9  1973 100$:
                                     07F9  1974 ; no match found
                       5B   10   C0  07F9  1975 	addl2	#16,r11			; pop arguments
                       7B   00   D0  07FC  1976 	movl	#c_false,-(r11)		; leave a false ~~~ on top of stack
                                 05  07FF  1977 	rsb				; end of match
                                     0800  1978 
                                     0800  1979 
                                     0800  1980 ;+++
                                     0800  1981 ;k> max -- ( n1 n2 -- n2 ) Leave larger of n1 and n2 on stack.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  95
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0800  1982 ;---
                                     0800  1983 	header	max
                           FFFFFFFC  0800       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0804       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0804       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0804       	.if    le, nchr		; nchr <= 0
                        78 61 6D 00' 0804       	   .ascic \max\	; no auxillary , use principle one
                                 03  0804       
                                     0808       	.if_false		; else
                                     0808       	  .ascic \\		; use auxillary 
                                     0808       	.endc			; end if
                                     0808       max:			; use  of word as v1_kernel label
                                     0808       	
                    04 AB   6B   D1  0808  1984 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   15  080C  1985 	bleq	10$			; Top less than under item?
                                     080E  1986 ; no, top greater
                    04 AB   6B   D0  080E  1987 	movl	(r11),4(r11)		; move greater down stack
                                     0812  1988 10$:
                       5B   04   C0  0812  1989 	addl2	#4,r11			; pop first argument, since
                                     0815  1990 					;   great is in second item now
                                 05  0815  1991 	rsb				; end of max
                                     0816  1992 
                                     0816  1993 
                                     0816  1994 ;+++
                                     0816  1995 ;k> message -- ( a -- ) writes word-counted string at `a' to terminal.
                                     0816  1996 ;---
                                     0816  1997 	header	message
                           FFFFFFFC  0816       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  081A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  081A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  081A       	.if    le, nchr		; nchr <= 0
            65 67 61 73 73 65 6D 00' 081A       	   .ascic \message\	; no auxillary , use principle one
                                 07  081A       
                                     0822       	.if_false		; else
                                     0822       	  .ascic \\		; use auxillary 
                                     0822       	.endc			; end if
                                     0822       message:			; use  of word as v1_kernel label
                                     0822       	
                       FB6F CF   16  0822  1998 	jsb	count			; set up for write
                   00000FE9'EF   16  0826  1999 	jsb	write			; write it out
                                 05  082C  2000 	rsb				; end of message
                                     082D  2001 
                                     082D  2002 
                                     082D  2003 ;+++
                                     082D  2004 ;k> min -- ( n1 n2 -- n2 ) Leaves small or n1 and n2 on stack.
                                     082D  2005 ;---
                                     082D  2006 	header	min
                           FFFFFFFC  082D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0831       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0831       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0831       	.if    le, nchr		; nchr <= 0
                        6E 69 6D 00' 0831       	   .ascic \min\	; no auxillary , use principle one
                                 03  0831       
                                     0835       	.if_false		; else
                                     0835       	  .ascic \\		; use auxillary 
                                     0835       	.endc			; end if
                                     0835       min:			; use  of word as v1_kernel label
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  96
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0835       	
                    04 AB   6B   D1  0835  2007 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   18  0839  2008 	bgeq	10$			; Top is greater than under item
                    04 AB   6B   D0  083B  2009 	movl	(r11),4(r11)		;
                                     083F  2010 10$:
                       5B   04   C0  083F  2011 	addl2	#4,r11			; pop top stack item since lesser is
                                     0842  2012 					;   in second line.
                                 05  0842  2013 	rsb				; end of min
                                     0843  2014 
                                     0843  2015 
                                     0843  2016 ;+++
                                     0843  2017 ;k> mod -- ( n1 n2 -- n3 ) Leave remainder of n1 / n2 on stack.
                                     0843  2018 ;---
                                     0843  2019 	header	mod
                           FFFFFFFC  0843       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0847       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0847       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0847       	.if    le, nchr		; nchr <= 0
                        64 6F 6D 00' 0847       	   .ascic \mod\	; no auxillary , use principle one
                                 03  0847       
                                     084B       	.if_false		; else
                                     084B       	  .ascic \\		; use auxillary 
                                     084B       	.endc			; end if
                                     084B       mod:			; use  of word as v1_kernel label
                                     084B       	
               50   04 AB   6B   C7  084B  2020 	divl3	(r11),4(r11),r0		; r0 = n1 / n2
                  51   8B   50   C5  0850  2021 	mull3	r0,(r11)+,r1		; temp = n2 * n3
                       6B   51   C2  0854  2022 	subl2	r1,(r11)		; n3 = n1 - quotient
                                 05  0857  2023 	rsb				; end of mod
                                     0858  2024 
                                     0858  2025 
                                     0858  2026 ;+++
                                     0858  2027 ;k> move -- ( a1 a2 w -- ) Copies `w' bytes from `a1' to `a2'.
                                     0858  2028 ;---
                                     0858  2029 	header	move
                           FFFFFFFC  0858       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  085C       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  085C       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  085C       	.if    le, nchr		; nchr <= 0
                     65 76 6F 6D 00' 085C       	   .ascic \move\	; no auxillary , use principle one
                                 04  085C       
                                     0861       	.if_false		; else
                                     0861       	  .ascic \\		; use auxillary 
                                     0861       	.endc			; end if
                                     0861       move:			; use  of word as v1_kernel label
                                     0861       	
            04 BB   08 BB   6B   28  0861  2030 	movc3	(r11),@8(r11),@4(r11)	;
                       5B   0C   C0  0867  2031 	addl2	#12,r11			; pop arguments
                                 05  086A  2032 	rsb				; end of move
                                     086B  2033 
                                     086B  2034 
                                     086B  2035 ;+++
                                     086B  2036 ;k> move&fill -- ( a1 w1 a2 w2 c -- ) copies bytes from `a1' to `a2'.
                                     086B  2037 ;	If `w2' > `wl', fill with c.  If `w2' < `w1', truncate.
                                     086B  2038 ;---
                                     086B  2039 	header	i_move_fill,<move&fill>
                           FFFFFFFC  086B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  97
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           FFFFFFFC  086F       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000009  086F       	.nchr  nchr, ^\move&fill\	; nchr = length( move&fill )
                           00000009  086F       	.if    le, nchr		; nchr <= 0
                                     086F       	   .ascic \i_move_fill\	; no auxillary move&fill, use principle one
                                     086F       	.if_false		; else
      6C 6C 69 66 26 65 76 6F 6D 00' 086F       	  .ascic \move&fill\		; use auxillary move&fill
                                 09  086F       
                                     0879       	.endc			; end if
                                     0879       i_move_fill:			; use move&fill of word as v1_kernel label
                                     0879       	
                 10 BB   0C AB   2C  0879  2040 	movc5	12(r11),@16(r11),-	; sourcelen, source
                            6B       087E  2041 		(r11),-			; fill character
                 08 BB   04 AB       087F  2042 		4(r11),@8(r11)		; destlen, destination
                       5B   14   C0  0883  2043 	addl2	#20,r11			; pop arguments
                                 05  0886  2044 	rsb				; end of move/fill
                                     0887  2045 
                                     0887  2046 
                                     0887  2047 ;+++
                                     0887  2048 ;k> negate -- ( n -- -n )  Leave two's complement of top stack item on stack.
                                     0887  2049 ;---
                                     0887  2050 	header	negage
                           FFFFFFFC  0887       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  088B       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  088B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  088B       	.if    le, nchr		; nchr <= 0
               65 67 61 67 65 6E 00' 088B       	   .ascic \negage\	; no auxillary , use principle one
                                 06  088B       
                                     0892       	.if_false		; else
                                     0892       	  .ascic \\		; use auxillary 
                                     0892       	.endc			; end if
                                     0892       negage:			; use  of word as v1_kernel label
                                     0892       	
                       6B   6B   CE  0892  2051 	mnegl	(r11),(r11)		; negate it
                                 05  0895  2052 	rsb				; end of negate
                                     0896  2053 
                                     0896  2054 
                                     0896  2055 ;+++
                                     0896  2056 ;k> not -- ( f1 -- f2 ) Logical not of top  of stack; not f1.
                                     0896  2057 ;---
                                     0896  2058 	header	not
                           FFFFFFFC  0896       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  089A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  089A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  089A       	.if    le, nchr		; nchr <= 0
                        74 6F 6E 00' 089A       	   .ascic \not\	; no auxillary , use principle one
                                 03  089A       
                                     089E       	.if_false		; else
                                     089E       	  .ascic \\		; use auxillary 
                                     089E       	.endc			; end if
                                     089E       not:			; use  of word as v1_kernel label
                                     089E       	
                            8B   D5  089E  2059 	tstl	(r11)+			; Is it false?
                            04   13  08A0  2060 	beql	10$			; yes
                       7B   00   D0  08A2  2061 	movl	#c_false,-(r11)		; no, leave with false on stack
                                 05  08A5  2062 	rsb				; return
                                     08A6  2063 10$:
              7B   FFFFFFFF 8F   D0  08A6  2064 	movl	#c_true,-(r11)		; it is false, leave with true on stack
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  98
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 05  08AD  2065 	rsb				; end of not
                                     08AE  2066 
                                     08AE  2067 
                                     08AE  2068 ;+++t
                                     08AE  2069 ;k> number -- ( -- n ? f ) Try to turn token at eodp into a number.  If
                                     08AE  2070 ;	it is a number, leave ( number true ) on stack.  If it is not a number
                                     08AE  2071 ;	leave ( false ) on stack.
                                     08AE  2072 ;---
                                     08AE  2073 	header	number
                           FFFFFFFC  08AE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  08B2       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  08B2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08B2       	.if    le, nchr		; nchr <= 0
               72 65 62 6D 75 6E 00' 08B2       	   .ascic \number\	; no auxillary , use principle one
                                 06  08B2       
                                     08B9       	.if_false		; else
                                     08B9       	  .ascic \\		; use auxillary 
                                     08B9       	.endc			; end if
                                     08B9       number:			; use  of word as v1_kernel label
                                     08B9       	
                            50   D4  08B9  2074 	clrl	r0			; clear result
                            51   D4  08BB  2075 	clrl	r1			; clear sign
                       56   59   D0  08BD  2076 	movl	r9, r6			; get pointer to token
                       57   86   9A  08C0  2077 	movzbl	(r6)+,r7		; get byte count
                       66   2D   91  08C3  2078 	cmpb	#^a/-/,(r6)		; does it have a leading minus sign?
                            07   12  08C6  2079 	bneq	_number_top		; no, go on
                       51   01   D0  08C8  2080 	movl	#1,r1			; yes, set flag
                            56   D6  08CB  2081 	incl	r6			; advance over sign
                            57   D7  08CD  2082 	decl	r7			; length = length - 1
                                     08CF  2083 _number_top:
                       52   66   9A  08CF  2084 	movzbl	(r6),r2			; get byte
                       52   30   C2  08D2  2085 	subl2	#^x30,r2			; check in range 0...9
                            52   D5  08D5  2086 	tstl	r2			; Is it negative?
                            52   19  08D7  2087 	blss	_invalid_number		; yes, leave with false
                       09   52   D1  08D9  2088 	cmpl	r2,#9			; r2 <= 9
                            20   15  08DC  2089 	bleq	_check_base		; yes, continue
                       11   52   D1  08DE  2090 	cmpl	r2,#^x11		; Is it A or greater?
                            48   19  08E1  2091 	blss	_invalid_number		; no, leave with false
                       2A   52   D1  08E3  2092 	cmpl	r2,#^x2a		; is it Z or less
                            05   14  08E6  2093 	bgtr	_check_lowercase	; no, go check if lower case
                       52   07   C2  08E8  2094 	subl2	#7,r2			; convert to ^xA...^xZ
                            11   11  08EB  2095 	brb	_check_base		; now check if it is valid in current
                                     08ED  2096 					; base
                                     08ED  2097 _check_lowercase:
                       31   52   D1  08ED  2098 	cmpl	r2,#^x31		; Is it a or greater?
                            39   19  08F0  2099 	blss	_invalid_number		; no, leave with false
              0000004A 8F   52   D1  08F2  2100 	cmpl	r2,#^x4a		; Is it z or less?
                            30   14  08F9  2101 	bgtr	_invalid_number		; no, leave with false.
                       52   27   C2  08FB  2102 	subl2	#^x27,r2		; convert to ^xA...^xZ
                                     08FE  2103 _check_base:
              00001D4E'EF   52   D1  08FE  2104 	cmpl	r2,v_radix		; is it in set 0... base-1?
                            24   18  0905  2105 	bgeq	_invalid_number		; no, leave w/false
              50   00001D4E'EF   C4  0907  2106 	mull2	v_radix,r0		; result = result * base
                       50   52   C0  090E  2107 	addl2	r2,r0			; result = result + num
                            57   D7  0911  2108 	decl	r7			; count = count - 1
                            56   D6  0913  2109 	incl	r6			; move to next byte in number
                            57   D5  0915  2110 	tstl	r7			; count = 0?
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page  99
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                            B6   14  0917  2111 	bgtr	_number_top		; no, do it again
                            51   D5  0919  2112 	tstl	r1			; negative?
                            03   14  091B  2113 	bgtr	20$			; no
                       50   50   CE  091D  2114 	mnegl	r0,r0			; yes, negate it.
                                     0920  2115 20$:
                       7B   50   D0  0920  2116 	movl	r0,-(r11)		; put result on stack
              7B   FFFFFFFF 8F   D0  0923  2117 	movl	#c_true,-(r11)		; put true on stack
                                 05  092A  2118 	rsb				; exit with ( number true ) on dstack
                                     092B  2119 _invalid_number:
                       7B   00   D0  092B  2120 	movl	#c_false,-(r11)		; exit with ( false ) on dstack
                                 05  092E  2121 	rsb				; end of number
                                     092F  2122 
                                     092F  2123 
                                     092F  2124 ;+++
                                     092F  2125 ;,> octal -- ( -- ) Set the base to octal.
                                     092F  2126 ;---
                                     092F  2127 	header	octal
                           FFFFFFFC  092F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0933       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0933       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0933       	.if    le, nchr		; nchr <= 0
                  6C 61 74 63 6F 00' 0933       	   .ascic \octal\	; no auxillary , use principle one
                                 05  0933       
                                     0939       	.if_false		; else
                                     0939       	  .ascic \\		; use auxillary 
                                     0939       	.endc			; end if
                                     0939       octal:			; use  of word as v1_kernel label
                                     0939       	
              00001D4E'EF   08   D0  0939  2128 	movl	#8,v_radix		; Switch to base 8
                                 05  0940  2129 	rsb				; end of octal
                                     0941  2130 
                                     0941  2131 
                                     0941  2132 ;+++t
                                     0941  2133 ;k> or -- ( f1 f2 -- f ) Logical or, f1 or f2.
                                     0941  2134 ;---
                                     0941  2135 	header	or
                           FFFFFFFC  0941       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0945       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0945       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0945       	.if    le, nchr		; nchr <= 0
                           72 6F 00' 0945       	   .ascic \or\	; no auxillary , use principle one
                                 02  0945       
                                     0948       	.if_false		; else
                                     0948       	  .ascic \\		; use auxillary 
                                     0948       	.endc			; end if
                                     0948       or:			; use  of word as v1_kernel label
                                     0948       	
                            8B   D5  0948  2136 	tstl	(r11)+			; is first true?
                            08   12  094A  2137 	bneq	10$			; Yes
                            8B   D5  094C  2138 	tstl	(r11)+			; Is seconed true?
                            07   12  094E  2139 	bneq	20$			; Yes
                       7B   00   D0  0950  2140 	movl	#c_false,-(r11)		; Both false, leave with false on stack
                                 05  0953  2141 	rsb				; return
                                     0954  2142 10$:
                       5B   04   C0  0954  2143 	addl2	#4,r11			; pop second item off, don't need
                                     0957  2144 					;   to check
                                     0957  2145 20$:
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 100
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

              7B   FFFFFFFF 8F   D0  0957  2146 	movl	#c_true,-(r11)		; Yes, one or both true.  Leave with
                                     095E  2147 					;   true on stack.
                                 05  095E  2148 	rsb				; end of or
                                     095F  2149 
                                     095F  2150 
                                     095F  2151 ;+++
                                     095F  2152 ;k> over -- ( n1 n2 -- n1 n2 n1 ) Leave a copy of the second item on the stack.
                                     095F  2153 ;+++
                                     095F  2154 	header	over			; push copy of n1 on top of stack
                           FFFFFFFC  095F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0963       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0963       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0963       	.if    le, nchr		; nchr <= 0
                     72 65 76 6F 00' 0963       	   .ascic \over\	; no auxillary , use principle one
                                 04  0963       
                                     0968       	.if_false		; else
                                     0968       	  .ascic \\		; use auxillary 
                                     0968       	.endc			; end if
                                     0968       over:			; use  of word as v1_kernel label
                                     0968       	
                    7B   04 AB   D0  0968  2155 	movl	4(r11),-(r11)
                                 05  096C  2156 	rsb				; end of over
                                     096D  2157 
                                     096D  2158 
                                     096D  2159 ;+++
                                     096D  2160 ;k> pad -- ( -- a ) Leave address of (edop + c_pad_moat) on stack.
                                     096D  2161 ;	This is a good area to use for temporary storage of such things
                                     096D  2162 ;	as strings.
                                     096D  2163 ;---
                                     096D  2164 	header	pad
                           FFFFFFFC  096D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0971       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0971       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0971       	.if    le, nchr		; nchr <= 0
                        64 61 70 00' 0971       	   .ascic \pad\	; no auxillary , use principle one
                                 03  0971       
                                     0975       	.if_false		; else
                                     0975       	  .ascic \\		; use auxillary 
                                     0975       	.endc			; end if
                                     0975       pad:			; use  of word as v1_kernel label
                                     0975       	
         7B   00000109 8F   59   C1  0975  2165 	addl3	r9,#c_pad_moat,-(r11)	;
                                 05  097D  2166 	rsb				; end of pad
                                     097E  2167 
                                     097E  2168 
                                     097E  2169 ;+++
                                     097E  2170 ;k> putc -- ( c -- ) Output character `c'.
                                     097E  2171 ;---
                                     097E  2172 	header	putc
                           FFFFFFFC  097E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0982       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0982       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0982       	.if    le, nchr		; nchr <= 0
                     63 74 75 70 00' 0982       	   .ascic \putc\	; no auxillary , use principle one
                                 04  0982       
                                     0987       	.if_false		; else
                                     0987       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 101
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0987       	.endc			; end if
                                     0987       putc:			; use  of word as v1_kernel label
                                     0987       	
         00A0 8F   00001B98'EF   B1  0987  2173 	cmpw	v_outlen,#c_max_len	; is output buffer full?
                            04   19  0990  2174 	blss	10$			; no, go on
                       FA11 CF   16  0992  2175 	jsb	cr			; yes output it
                                     0996  2176 10$:
              50   00001B9A'EF   9E  0996  2177 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  099D  2178 	movzwl	v_outlen,r1		; index into buffer
                       50   51   C0  09A4  2179 	addl2	r1,r0			; pointer to next available char
                       60   6B   90  09A7  2180 	movb	(r11),(r0)		; move char into buffer
                       5B   04   C0  09AA  2181 	addl2	#4,r11			; pop char off stack
                   00001B98'EF   B6  09AD  2182 	incw	v_outlen		; increment index (or length)
                                 05  09B3  2183 	rsb				; end of putc
                                     09B4  2184 
                                     09B4  2185 
                                     09B4  2186 ;+++
                                     09B4  2187 ;k> radix ( -- a ) leave address of system radix longword on stack.
                                     09B4  2188 ;---
                                     09B4  2189 	header	radix
                           FFFFFFFC  09B4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  09B8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  09B8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  09B8       	.if    le, nchr		; nchr <= 0
                  78 69 64 61 72 00' 09B8       	   .ascic \radix\	; no auxillary , use principle one
                                 05  09B8       
                                     09BE       	.if_false		; else
                                     09BE       	  .ascic \\		; use auxillary 
                                     09BE       	.endc			; end if
                                     09BE       radix:			; use  of word as v1_kernel label
                                     09BE       	
              7B   00001D4E'EF   DE  09BE  2190 	moval	v_radix,-(r11)		; leave address on dstack
                                 05  09C5  2191 	rsb				; end of radix
                                     09C6  2192 
                                     09C6  2193 
                                     09C6  2194 ;+++
                                     09C6  2195 ;k> read ( a -- ) return a byte-counted string from terminal at `a'
                                     09C6  2196 ;---
                                     09C6  2197 	header	read
                           FFFFFFFC  09C6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  09CA       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  09CA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  09CA       	.if    le, nchr		; nchr <= 0
                     64 61 65 72 00' 09CA       	   .ascic \read\	; no auxillary , use principle one
                                 04  09CA       
                                     09CF       	.if_false		; else
                                     09CF       	  .ascic \\		; use auxillary 
                                     09CF       	.endc			; end if
                                     09CF       read:			; use  of word as v1_kernel label
                                     09CF       	
              00001B92'EF   6B   D0  09CF  2198 	movl	(r11),v_readaddr	; v_readaddr = address to write to
                   00001B92'EF   D6  09D6  2199 	incl	v_readaddr		; allow for byte count before string
                   00001B8C'EF   3F  09DC  2200 	pushaw	v_readlen		; where to put returned length
                                     09E2  2201 ; Is there any outstanding output?
                   00001B98'EF   B5  09E2  2202 	tstw   v_outlen			;
                            04   12  09E8  2203 	bneq   10$			; yes~~~, branch to output prompt
                            00   DD  09EA  2204 	pushl  #0			; omit prompt since no output
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 102
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                            1B   11  09EC  2205 	brb    20$			; skip over prompting
                                     09EE  2206 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  09EE  2207 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  09F5  2208 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  09FC  2209 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                            5B   DD  0A04  2210 	pushl	r11			; put address of descriptor on rstack
                       5B   08   C0  0A06  2211 	addl2	#8,r11			; move stack ptr back over descriptor
                                     0A09  2212 20$:
                   00001B8E'EF   7F  0A09  2213 	pushaq	v_readdsc		; push address of descriptor
              00000000'GF   03   FB  0A0F  2214 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0A16  2215 	isstrerr
              50   00000000'8F   D1  0A16       	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                            06   13  0A1D       	beql	30000$		; yes, ignore and go on
                         03 50   E8  0A1F       	blbs	r0,30000$		; no error, go on
                          0D45   31  0A22       	brw	_error_exit		; error, branch to error handler
                                     0A25       30000$:
                                     0A25       	
                                     0A25  2216 30$:
                   00001B98'EF   B4  0A25  2217 	clrw	v_outlen		; clean output length, since any
                                     0A2B  2218 					;   outstanding was just output
           00 BB   00001B8C'EF   33  0A2B  2219 	cvtwb	v_readlen,@(r11)	; save byte-count at address on stack
                       5B   04   C0  0A33  2220 	addl2	#4,r11			; pop address off stack
                                 05  0A36  2221 	rsb				; end of read
                                     0A37  2222 
                                     0A37  2223 
                                     0A37  2224 ;+++t
                                     0A37  2225 ;k> readstr ( a n -- ) Read line from terminal into word-counted string.
                                     0A37  2226 ;	`a' is address of word-counted string.
                                     0A37  2227 ;	'n' is maximum length.
                                     0A37  2228 ;---
                                     0A37  2229 	header	readstr
                           FFFFFFFC  0A37       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0A3B       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0A3B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0A3B       	.if    le, nchr		; nchr <= 0
            72 74 73 64 61 65 72 00' 0A3B       	   .ascic \readstr\	; no auxillary , use principle one
                                 07  0A3B       
                                     0A43       	.if_false		; else
                                     0A43       	  .ascic \\		; use auxillary 
                                     0A43       	.endc			; end if
                                     0A43       readstr:			; use  of word as v1_kernel label
                                     0A43       	
                         04 AB   DD  0A43  2230 	pushl	4(r11)			; where to put returned length
                    04 AB   02   C0  0A46  2231 	addl2	#2,4(r11)		; move pointer over length word
           02 AB   00001B96'EF   B0  0A4A  2232 	movw	v_static_dsc,2(r11)	; move middle of descriptor on dstack
                   00001B98'EF   B5  0A52  2233 	tstw	v_outlen		; Is there any outstanding output?
                            04   12  0A58  2234 	bneq	10$			; yes
                            00   DD  0A5A  2235 	pushl	#0			; omit prompt since no output
                            21   11  0A5C  2236 	brb	20$			; skip over prompting
                                     0A5E  2237 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0A5E  2238 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0A65  2239 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0A6C  2240 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                   00001B98'EF   B4  0A74  2241 	clrw	v_outlen		; clear output length, since any
                                     0A7A  2242 					;   outstanding will be saved.
                            5B   DD  0A7A  2243 	pushl	r11			; put addrss of descriptor on rstack
                       5B   08   C0  0A7C  2244 	addl2	#8,r11			; move stack ptr back over descriptor
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 103
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0A7F  2245 20$:
                            5B   DD  0A7F  2246 	pushl	r11			; push address of descriptor
              00000000'GF   03   FB  0A81  2247 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0A88  2248 	isstrerr
              50   00000000'8F   D1  0A88       	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                            06   13  0A8F       	beql	30001$		; yes, ignore and go on
                         03 50   E8  0A91       	blbs	r0,30001$		; no error, go on
                          0CD3   31  0A94       	brw	_error_exit		; error, branch to error handler
                                     0A97       30001$:
                                     0A97       	
                       5B   08   C0  0A97  2249 	addl2	#8,r11			; pop arguments
                                 05  0A9A  2250 	rsb				; end of readstr
                                     0A9B  2251 
                                     0A9B  2252 
                                     0A9B  2253 ;+++
                                     0A9B  2254 ;k> restart -- ( -- ) Restart VTIL, patching it to run again.
                                     0A9B  2255 ;	Used in cases of error.  Never RETURNs.
                                     0A9B  2256 ;---
                                     0A9B  2257 	header	restart
                           FFFFFFFC  0A9B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0A9F       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0A9F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0A9F       	.if    le, nchr		; nchr <= 0
            74 72 61 74 73 65 72 00' 0A9F       	   .ascic \restart\	; no auxillary , use principle one
                                 07  0A9F       
                                     0AA7       	.if_false		; else
                                     0AA7       	  .ascic \\		; use auxillary 
                                     0AA7       	.endc			; end if
                                     0AA7       restart:			; use  of word as v1_kernel label
                                     0AA7       	
                          0B3A   31  0AA7  2258 	brw	r_warm_start		; patch it
                                     0AAA  2259 					; end of restart
                                     0AAA  2260 
                                     0AAA  2261 
                                     0AAA  2262 ;+++
                                     0AAA  2263 ;k> s! -- ( n a -- ) Store a short integer (first 16 bits of `n' at `a'.~~~ `n' should be a `s'.
                                     0AAA  2264 ;---
                                     0AAA  2265 	header	i_word_store,<s!>
                           FFFFFFFC  0AAA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0AAE       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0AAE       	.nchr  nchr, ^\s!\	; nchr = length( s! )
                           00000002  0AAE       	.if    le, nchr		; nchr <= 0
                                     0AAE       	   .ascic \i_word_store\	; no auxillary s!, use principle one
                                     0AAE       	.if_false		; else
                           21 73 00' 0AAE       	  .ascic \s!\		; use auxillary s!
                                 02  0AAE       
                                     0AB1       	.endc			; end if
                                     0AB1       i_word_store:			; use s! of word as v1_kernel label
                                     0AB1       	
                 00 BB   04 AB   B0  0AB1  2266 	movw	4(r11),@(r11)		; store the first 16 bits
                       5B   08   C0  0AB6  2267 	addl2	#8,r11			; pop arguments
                                 05  0AB9  2268 	rsb				; end of s!
                                     0ABA  2269 
                                     0ABA  2270 
                                     0ABA  2271 ;+++
                                     0ABA  2272 ;k> s, -- ( s -- ) Store low word of `s' in dictinary.
                                     0ABA  2273 ;---
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 104
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0ABA  2274 	header	i_w_comma,<s,>
                           FFFFFFFC  0ABA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0ABE       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0ABE       	.nchr  nchr, ^\s,\	; nchr = length( s, )
                           00000002  0ABE       	.if    le, nchr		; nchr <= 0
                                     0ABE       	   .ascic \i_w_comma\	; no auxillary s,, use principle one
                                     0ABE       	.if_false		; else
                           2C 73 00' 0ABE       	  .ascic \s,\		; use auxillary s,
                                 02  0ABE       
                                     0AC1       	.endc			; end if
                                     0AC1       i_w_comma:			; use s, of word as v1_kernel label
                                     0AC1       	
                       89   6B   B0  0AC1  2275 	movw	(r11),(r9)+		; store short in dictinary
                       5B   08   C0  0AC4  2276 	addl2	#8,r11			; pop arguments
                                 05  0AC7  2277 	rsb				; end of s,
                                     0AC8  2278 
                                     0AC8  2279 
                                     0AC8  2280 ;+++
                                     0AC8  2281 ;k> s@ -- ( a -- n ) Fetch 16 bits from `a' and zero-extend to longword.
                                     0AC8  2282 ;---
                                     0AC8  2283 	header	i_word_fetch,<s@>
                           FFFFFFFC  0AC8       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0ACC       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000002  0ACC       	.nchr  nchr, ^\s@\	; nchr = length( s@ )
                           00000002  0ACC       	.if    le, nchr		; nchr <= 0
                                     0ACC       	   .ascic \i_word_fetch\	; no auxillary s@, use principle one
                                     0ACC       	.if_false		; else
                           40 73 00' 0ACC       	  .ascic \s@\		; use auxillary s@
                                 02  0ACC       
                                     0ACF       	.endc			; end if
                                     0ACF       i_word_fetch:			; use s@ of word as v1_kernel label
                                     0ACF       	
                    6B   00 BB   3C  0ACF  2284 	movzwl	@(r11),(r11)		; get contents
                                 05  0AD3  2285 	rsb				; end of s@
                                     0AD4  2286 
                                     0AD4  2287 
                                     0AD4  2288 ;+++
                                     0AD4  2289 ;k> ss@ -- ( a -- n ) Fetch short at `a' and sign extend it to longword.
                                     0AD4  2290 ;---
                                     0AD4  2291 	header	i_ws_fetch,<ss@>
                           FFFFFFFC  0AD4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0AD8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  0AD8       	.nchr  nchr, ^\ss@\	; nchr = length( ss@ )
                           00000003  0AD8       	.if    le, nchr		; nchr <= 0
                                     0AD8       	   .ascic \i_ws_fetch\	; no auxillary ss@, use principle one
                                     0AD8       	.if_false		; else
                        40 73 73 00' 0AD8       	  .ascic \ss@\		; use auxillary ss@
                                 03  0AD8       
                                     0ADC       	.endc			; end if
                                     0ADC       i_ws_fetch:			; use ss@ of word as v1_kernel label
                                     0ADC       	
                    6B   00 BB   32  0ADC  2292 	cvtwl	@(r11),(r11)		; get contents, sign extend it
                                 05  0AE0  2293 	rsb				; end of ss@
                                     0AE1  2294 
                                     0AE1  2295 
                                     0AE1  2296 ;+++
                                     0AE1  2297 ;k> save-buffers -- ( -- ) Write all modified buffers and mark them unmodified.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 105
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0AE1  2298 ;---
                                     0AE1  2299 	header	i_save_buffers,<save-buffers>
                           FFFFFFFC  0AE1       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0AE5       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           0000000C  0AE5       	.nchr  nchr, ^\save-buffers\	; nchr = length( save-buffers )
                           0000000C  0AE5       	.if    le, nchr		; nchr <= 0
                                     0AE5       	   .ascic \i_save_buffers\	; no auxillary save-buffers, use principle one
                                     0AE5       	.if_false		; else
72 65 66 66 75 62 2D 65 76 61 73 00' 0AE5       	  .ascic \save-buffers\		; use auxillary save-buffers
                                 73  0AF1       
                                 0C  0AE5       
                                     0AF2       	.endc			; end if
                                     0AF2       i_save_buffers:			; use save-buffers of word as v1_kernel label
                                     0AF2       	
                            50   D4  0AF2  2300 	clrl	r0			; buffer number
                                     0AF4  2301 10$:
                            02   91  0AF4  2302 	cmpb	#c_modified,-		; Has the buffer
                       1B7D'C0       0AF6  2303 		v_buf_inuse(r0)		;   been modified? ~~~ Why not [r0]?
                            12   12  0AF9  2304 	bneq	20$			; no, skip it
                       7A   50   D0  0AFB  2305 	movl	r0,-(r10)		; save the buffer number
                       7B   50   D0  0AFE  2306 	movl	r0,-(r11)		; set up for buffer-write
                       F78D CF   16  0B01  2307 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0B05  2308 	movl	(r10)+,r0		; get the buffer number back
                            01   90  0B08  2309 	movb	#c_inuse,-		; mark the buffer as
                       1B7D'C0       0B0A  2310 		v_buf_inuse(r0)		;   in use, but not modified.
                                     0B0D  2311 20$:
                            02   F1  0B0D  2312 	acbl	#c_max_blocks-1,-	; buffer # is in [0 .. c_max_blocks-1]
                  FFE1 50   01       0B0F  2313 		#1,r0,10$		; move to next buffer number, if any
                                 05  0B13  2314 	rsb				; end of save-buffers
                                     0B14  2315 
                                     0B14  2316 
                                     0B14  2317 ;+++t
                                     0B14  2318 ;k> search -- ( a1 -- a2 ? f )  Search vocabulary at `a1' for a match with
                                     0B14  2319 ;	byte-counted string at eodp.  Return  ( false ) if not found, or
                                     0B14  2320 ;	( addr true ) if found.
                                     0B14  2321 ;---
                                     0B14  2322 	header	search
                           FFFFFFFC  0B14       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0B18       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0B18       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B18       	.if    le, nchr		; nchr <= 0
               68 63 72 61 65 73 00' 0B18       	   .ascic \search\	; no auxillary , use principle one
                                 06  0B18       
                                     0B1F       	.if_false		; else
                                     0B1F       	  .ascic \\		; use auxillary 
                                     0B1F       	.endc			; end if
                                     0B1F       search:			; use  of word as v1_kernel label
                                     0B1F       	
                            6B   D5  0B1F  2323 	tstl	(r11)			; Is it nil pointer on top of stack?
                            29   13  0B21  2324 	beql	10$			; yes, stop search, leave false on stack
                  56   6B   04   C1  0B23  2325 	addl3	#4,(r11),r6		; r6 = Address of byte-count
                       69   66   91  0B27  2326 	cmpb	(r6),(r9)		; no, ?equal length
                            1A   12  0B2A  2327 	bneq	20$			; no
                       56   69   99  0B2C  2328 	cvtbw	(r9),r6			; yes, get string length
                  57   6B   05   C1  0B2F  2329 	addl3	#5,(r11),r7		; get address of word name
                  58   59   01   C1  0B33  2330 	addl3	#1,r9,r8		; get address of token
                  68   67   56   29  0B37  2331 	cmpc3	r6,(r7),(r8)		; compare strings
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 106
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                            09   12  0B3B  2332 	bneq	20$			; strings don't match
                                     0B3D  2333 ; string match
              7B   FFFFFFFF 8F   D0  0B3D  2334 	movl	#c_true,-(r11)		; move true to top of stack
                            06   11  0B44  2335 	brb	10$			; exit leaving ( addr true ) on dstack.
                                     0B46  2336 20$:
                    6B   00 BB   D0  0B46  2337 	movl	@(r11),(r11)		; get address of next word
                            D3   11  0B4A  2338 	brb	search			; try it again
                                     0B4C  2339 10$:
                                 05  0B4C  2340 	rsb				; end of search
                                     0B4D  2341 
                                     0B4D  2342 
                                     0B4D  2343 ;+++
                                     0B4D  2344 ;k> short -- ( n -- ) Create a word that pushed the address of two bytes
                                     0B4D  2345 ;	(a VAX memory `word') on the stack, reserves space in the dictionary
                                     0B4D  2346 ;	for those two bytes, and initializes it to the value of `n'.
                                     0B4D  2347 ;---
                                     0B4D  2348 	header	i_short,<short>
                           FFFFFFFC  0B4D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0B51       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000005  0B51       	.nchr  nchr, ^\short\	; nchr = length( short )
                           00000005  0B51       	.if    le, nchr		; nchr <= 0
                                     0B51       	   .ascic \i_short\	; no auxillary short, use principle one
                                     0B51       	.if_false		; else
                  74 72 6F 68 73 00' 0B51       	  .ascic \short\		; use auxillary short
                                 05  0B51       
                                     0B57       	.endc			; end if
                                     0B57       i_short:			; use short of word as v1_kernel label
                                     0B57       	
                       F880 CF   16  0B57  2349 	jsb	create			; enclose next token in dictionary
                       89   3E   90  0B5B  2350 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  0B5E  2351 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0B62  2352 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0B65  2353 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0B69  2354 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  0B6C  2355 	movw	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  0B6F  2356 	addl2	#4,r11			; pop aruments
                                 05  0B72  2357 	rsb				; end of short
                                     0B73  2358 
                                     0B73  2359 
                                     0B73  2360 ;+++
                                     0B73  2361 ;k> sign -- ( n -- ) Output minus in pictured numeric if top of stack is < 0.
                                     0B73  2362 ;---
                                     0B73  2363 	header	sign
                           FFFFFFFC  0B73       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0B77       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0B77       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B77       	.if    le, nchr		; nchr <= 0
                     6E 67 69 73 00' 0B77       	   .ascic \sign\	; no auxillary , use principle one
                                 04  0B77       
                                     0B7C       	.if_false		; else
                                     0B7C       	  .ascic \\		; use auxillary 
                                     0B7C       	.endc			; end if
                                     0B7C       sign:			; use  of word as v1_kernel label
                                     0B7C       	
                            8B   D5  0B7C  2364 	tstl	(r11)+			; tos < 0?
                            07   18  0B7E  2365 	bgeq	10$			; no, exit
                       7B   2D   D0  0B80  2366 	movl	#^a\-\,-(r11)		; put ascii for minus sign on stack
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 107
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       FB25 CF   16  0B83  2367 	jsb	hold			; put it in output string
                                     0B87  2368 10$:
                                 05  0B87  2369 	rsb				; end of sign
                                     0B88  2370 
                                     0B88  2371 
                                     0B88  2372 ;+++
                                     0B88  2373 ;k> smudge -- ( -- ) Sets the smudge (high) bit in the length byte as the word
                                     0B88  2374 ;	that is currently being defined won't be found in itself.
                                     0B88  2375 ;---
                                     0B88  2376 	header	smudge
                           FFFFFFFC  0B88       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0B8C       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0B8C       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B8C       	.if    le, nchr		; nchr <= 0
               65 67 64 75 6D 73 00' 0B8C       	   .ascic \smudge\	; no auxillary , use principle one
                                 06  0B8C       
                                     0B93       	.if_false		; else
                                     0B93       	  .ascic \\		; use auxillary 
                                     0B93       	.endc			; end if
                                     0B93       smudge:			; use  of word as v1_kernel label
                                     0B93       	
              50   00001D3B'FF   D0  0B93  2377 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  0B9A  2378 	addl2	#4,r0			; move over link field
                    60   40 8F   88  0B9D  2379 	bisb2	#^b1000000,(r0)		; set smudge bit
                                 05  0BA1  2380 	rsb				; end of smudge
                                     0BA2  2381 
                                     0BA2  2382 
                                     0BA2  2383 ;+++
                                     0BA2  2384 ;k> sp@ -- ( -- l ) Returns the address of the top fo the data stack before
                                     0BA2  2385 ;	{ sp@ } is executed.
                                     0BA2  2386 ;---
                                     0BA2  2387 	header	i_sp_fetch,<sp@>
                           FFFFFFFC  0BA2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0BA6       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  0BA6       	.nchr  nchr, ^\sp@\	; nchr = length( sp@ )
                           00000003  0BA6       	.if    le, nchr		; nchr <= 0
                                     0BA6       	   .ascic \i_sp_fetch\	; no auxillary sp@, use principle one
                                     0BA6       	.if_false		; else
                        40 70 73 00' 0BA6       	  .ascic \sp@\		; use auxillary sp@
                                 03  0BA6       
                                     0BAA       	.endc			; end if
                                     0BAA       i_sp_fetch:			; use sp@ of word as v1_kernel label
                                     0BAA       	
                       7B   5B   D0  0BAA  2388 	movl	r11,-(r11)		; put address of top of stack on stack
                                 05  0BAD  2389 	rsb				; end of sp@
                                     0BAE  2390 
                                     0BAE  2391 
                                     0BAE  2392 ;+++
                                     0BAE  2393 ;k> sp0 -- ( -- l ) Returns the address of the bottom of the data stack.
                                     0BAE  2394 ;	Note that the stack grows downward, so this is actually the
                                     0BAE  2395 ;	top in memory of the data-stack structure's space.
                                     0BAE  2396 ;___
                                     0BAE  2397 	header	i_sp_0,<sp0>
                           FFFFFFFC  0BAE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0BB2       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000003  0BB2       	.nchr  nchr, ^\sp0\	; nchr = length( sp0 )
                           00000003  0BB2       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 108
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0BB2       	   .ascic \i_sp_0\	; no auxillary sp0, use principle one
                                     0BB2       	.if_false		; else
                        30 70 73 00' 0BB2       	  .ascic \sp0\		; use auxillary sp0
                                 03  0BB2       
                                     0BB6       	.endc			; end if
                                     0BB6       i_sp_0:			; use sp0 of word as v1_kernel label
                                     0BB6       	
              7B   00001000'EF   DE  0BB6  2398 	moval	c_ds_start,-(r11)	; put address on stack
                                 05  0BBD  2399 	rsb				; end of sp0
                                     0BBE  2400 
                                     0BBE  2401 
                                     0BBE  2402 ;+++
                                     0BBE  2403 ;k> space -- ( -- ) Output a space to terminal.
                                     0BBE  2404 ;---
                                     0BBE  2405 	header	space
                           FFFFFFFC  0BBE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0BC2       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0BC2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0BC2       	.if    le, nchr		; nchr <= 0
                  65 63 61 70 73 00' 0BC2       	   .ascic \space\	; no auxillary , use principle one
                                 05  0BC2       
                                     0BC8       	.if_false		; else
                                     0BC8       	  .ascic \\		; use auxillary 
                                     0BC8       	.endc			; end if
                                     0BC8       space:			; use  of word as v1_kernel label
                                     0BC8       	
         00A0 8F   00001B98'EF   B1  0BC8  2406 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            04   19  0BD1  2407 	blss	10$			; no, go on
                       F7D0 CF   16  0BD3  2408 	jsb	cr			; yes, output it
                                     0BD7  2409 10$:
              50   00001B9A'EF   9E  0BD7  2410 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  0BDE  2411 	movzwl	v_outlen,r1		; index into buffer
              00000028'EF   51   C0  0BE5  2412 	addl2	r1,40			; pointer to next available buffer
                       60   20   90  0BEC  2413 	movb	#c_blank,(r0)		; move char into buffer
                   00001B98'EF   B6  0BEF  2414 	incw	v_outlen		; increment index (or length)
                                 05  0BF5  2415 	rsb				; end of space
                                     0BF6  2416 
                                     0BF6  2417 
                                     0BF6  2418 ;+++
                                     0BF6  2419 ;,> spaces -- ( n -- ) Output `n' spaces to terminal
                                     0BF6  2420 ;---
                                     0BF6  2421 	header	spaces
                           FFFFFFFC  0BF6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0BFA       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0BFA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0BFA       	.if    le, nchr		; nchr <= 0
               73 65 63 61 70 73 00' 0BFA       	   .ascic \spaces\	; no auxillary , use principle one
                                 06  0BFA       
                                     0C01       	.if_false		; else
                                     0C01       	  .ascic \\		; use auxillary 
                                     0C01       	.endc			; end if
                                     0C01       spaces:			; use  of word as v1_kernel label
                                     0C01       	
                            6B   D5  0C01  2422 	tstl	(r11)			; Is it less than or equal to zero?
                            0E   15  0C03  2423 	bleq	100$			; yes, exit
                       7B   01   D0  0C05  2424 	movl	#1,-(r11)		; no, save space on stack for index
                                     0C08  2425 10$:
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 109
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                         BD AF   16  0C08  2426 	jsb	space			; output one space
                 F8 6B   04 AB   F2  0C0B  2427 	aoblss	4(r11),(r11),10$	; (r11) += 1, repeat if (r11) < 4(r11)
                       5B   04   C0  0C10  2428 	addl2	#4,r11			; pop index
                                     0C13  2429 100$:
                       5B   04   C0  0C13  2430 	addl2	#4,r11			; pop argument
                                 05  0C16  2431 	rsb				; end of spaces
                                     0C17  2432 
                                     0C17  2433 
                                     0C17  2434 ;+++t
                                     0C17  2435 ;k> sread ( -- ) Read a line from terminal or file into input stream,
                                     0C17  2436 ;	depending on value of { infile }.  if { infile } is true, read
                                     0C17  2437 ;	from file; otherwise, read from terminal.
                                     0C17  2438 ;---
                                     0C17  2439 	header	sread
                           FFFFFFFC  0C17       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0C1B       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0C1B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C1B       	.if    le, nchr		; nchr <= 0
                  64 61 65 72 73 00' 0C1B       	   .ascic \sread\	; no auxillary , use principle one
                                 05  0C1B       
                                     0C21       	.if_false		; else
                                     0C21       	  .ascic \\		; use auxillary 
                                     0C21       	.endc			; end if
                                     0C21       sread:			; use  of word as v1_kernel label
                                     0C21       	
                   00001B98'EF   B5  0C21  2440 	tstw	v_outlen		; Is there any outstanding output?
                            04   13  0C27  2441 	beql	5$			; no
                       F77A CF   16  0C29  2442 	jsb	cr			; yes, output it
                                     0C2D  2443 5$:
     0000199B'EF   000018F7'EF   DE  0C2D  2444 	moval	v_inbuf,v_inptr		; start at beginning of line
                   00001D47'EF   95  0C38  2445 	tstb	v_infile		; getting input from file?
                            37   12  0C3E  2446 	bneq	10$			; yes, go do it
                                     0C40  2447 ; no, get from terminal
                   00001999'EF   3F  0C40  2448 	pushaw	v_inlen			; save returned length
                   0000182A'EF   7F  0C46  2449 	pushaq	v_vtilprompt		; use vtil prompt
                   0000199F'EF   7F  0C4C  2450 	pushaq	v_in_dsc		; address of input descriptor
              00000000'GF   03   FB  0C52  2451 	calls	#3,g^lib$get_input	; get a line from terminal
                         0F 50   E8  0C59  2452 	blbs	r0,8$			; no error, go on
              50   00000000'8F   D1  0C5C  2453 	cmpl	#rms$_eof,r0		; Is it eof from terminal?
                            03   12  0C63  2454 	bneq	7$			; no, go die messily
                          0B35   31  0C65  2455 	brw	_exit			; yes, exit silently
                                     0C68  2456 7$:
                          0AFF   31  0C68  2457 	brw	_error_exit		; die messily
                                     0C6B  2458 8$:
     00001997'EF   00001999'EF   B0  0C6B  2459 	movw	v_inlen,v_org_inlen	; save original length
                                 05  0C76  2460 	rsb				; success read from terminal, return
                                     0C77  2461 10$:
                                     0C77  2462 	$get	rab=v_inrab		; get a record
                                     0C77       		$RMSCALL	GET,v_inrab,,
                                     0C77       	.GLOBL	SYS$GET
                                     0C77       	.IF	B <v_inrab>
                                     0C77       	CALLG	(AP),G^SYS$GET
                                     0C77       	$$.TMP=0
                                     0C77       	.IF	NB <>
                                     0C77       	$$.TMP=1
                                     0C77       	.ENDC
                                     0C77       	.IF	NB <>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 110
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0C77       	$$.TMP=1
                                     0C77       	.ENDC
                                     0C77       	.IF	NE $$.TMP
                                     0C77       	.ERROR				; v_inrab= parameter missing;
                                     0C77       	.ENDC
                                     0C77       	.ENDC
                                     0C77       	.IF	NB <v_inrab>
                           00000001  0C77       	$$.TMP1=1
                                     0C77       	.IF	NB <>
                                     0C77       	PUSHAL	
                                     0C77       	$$.TMP1=3
                                     0C77       	.ENDC
                                     0C77       	.IF	NB <>
                                     0C77       	PUSHAL	
                                     0C77       	.IF	EQ <$$.TMP1-1>
                                     0C77       	$$.TMP1=2
                                     0C77       	.ENDC
                                     0C77       	.IFF
                           FFFFFFFE  0C77       	.IF	EQ <$$.TMP1-3>
                                     0C77       	PUSHL	#0
                                     0C77       	.ENDC
                                     0C77       	.ENDC
                           000000CF  0C77       	.NTYPE	$$.TMP2,v_inrab
                           00000070  0C77       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0C77       	PUSHL	v_inrab
                                     0C77       	.IFF
                           000000B0  0C77       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0C77       	PUSHL	v_inrab
                                     0C77       	.IFF
                   000019F8'EF   DF  0C77       	PUSHAL	v_inrab
                                     0C7D       	.ENDC
                                     0C7D       	.ENDC
              00000000'GF   01   FB  0C7D       	CALLS	#$$.TMP1,G^SYS$GET
                                     0C84       	.ENDC
                                     0C84       	
                                     0C84       	
                         13 50   E8  0C84  2463 	blbs	r0,20$			; write the record
              00000000'8F   50   D1  0C87  2464 	cmpl	r0,#rms$_eof		; was error end-of-file
                            27   13  0C8E  2465 	beql	30$			; successful completion
                                     0C90  2466 ; error otherwize
              56   000019F8'EF   DE  0C90  2467 	moval	v_inrab,r6		; keep rab address
                          0AE9   31  0C97  2468 	brw	_r_err			; signal record error
                                     0C9A  2469 20$:
                   00001A1A'EF   B0  0C9A  2470 	movw	v_inrab+rab$w_rsz,-	; input rab set record size
                   00001999'EF       0CA0  2471 		v_inlen
                   00001A1A'EF   B0  0CA5  2472 	movw	v_inrab+rab$w_rsz,-
                   00001997'EF       0CAB  2473 		v_org_inlen
                   00001D48'EF   D6  0CB0  2474 	incl	v_filelinenum		; increment line number in file
                                 05  0CB6  2475 	rsb				; success read from file, return
                                     0CB7  2476 30$:
                                     0CB7  2477 	$close	fab=v_infab		; close input
                                     0CB7       		$RMSCALL	CLOSE,v_infab,,
                                     0CB7       	.GLOBL	SYS$CLOSE
                                     0CB7       	.IF	B <v_infab>
                                     0CB7       	CALLG	(AP),G^SYS$CLOSE
                                     0CB7       	$$.TMP=0
                                     0CB7       	.IF	NB <>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 111
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0CB7       	$$.TMP=1
                                     0CB7       	.ENDC
                                     0CB7       	.IF	NB <>
                                     0CB7       	$$.TMP=1
                                     0CB7       	.ENDC
                                     0CB7       	.IF	NE $$.TMP
                                     0CB7       	.ERROR				; v_infab= parameter missing;
                                     0CB7       	.ENDC
                                     0CB7       	.ENDC
                                     0CB7       	.IF	NB <v_infab>
                           00000001  0CB7       	$$.TMP1=1
                                     0CB7       	.IF	NB <>
                                     0CB7       	PUSHAL	
                                     0CB7       	$$.TMP1=3
                                     0CB7       	.ENDC
                                     0CB7       	.IF	NB <>
                                     0CB7       	PUSHAL	
                                     0CB7       	.IF	EQ <$$.TMP1-1>
                                     0CB7       	$$.TMP1=2
                                     0CB7       	.ENDC
                                     0CB7       	.IFF
                           FFFFFFFE  0CB7       	.IF	EQ <$$.TMP1-3>
                                     0CB7       	PUSHL	#0
                                     0CB7       	.ENDC
                                     0CB7       	.ENDC
                           000000CF  0CB7       	.NTYPE	$$.TMP2,v_infab
                           00000070  0CB7       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0CB7       	PUSHL	v_infab
                                     0CB7       	.IFF
                           000000B0  0CB7       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0CB7       	PUSHL	v_infab
                                     0CB7       	.IFF
                   000019A8'EF   DF  0CB7       	PUSHAL	v_infab
                                     0CBD       	.ENDC
                                     0CBD       	.ENDC
              00000000'GF   01   FB  0CBD       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     0CC4       	.ENDC
                                     0CC4       	
                                     0CC4       	
              00001D47'EF   00   90  0CC4  2478 	movb	#c_false,v_infile	; set v_infile flag false
              00001D48'EF   00   D0  0CCB  2479 	movl	#0,v_filelinenum	; zero file line as well
                                 05  0CD2  2480 	rsb				; end of sread
                                     0CD3  2481 
                                     0CD3  2482 
                                     0CD3  2483 ;+++
                                     0CD3  2484 ;k> strcat -- ( a1 a2 -- ) Catenate string at `a`' to string at `a2'.
                                     0CD3  2485 ;	Works only with strings defined by { string } or { string" }
                                     0CD3  2486 ;	since it uses maxlen of string at `a2'.
                                     0CD3  2487 ;---
                                     0CD3  2488 	header	strcat
                           FFFFFFFC  0CD3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0CD7       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0CD7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CD7       	.if    le, nchr		; nchr <= 0
               74 61 63 72 74 73 00' 0CD7       	   .ascic \strcat\	; no auxillary , use principle one
                                 06  0CD7       
                                     0CDE       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 112
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0CDE       	  .ascic \\		; use auxillary 
                                     0CDE       	.endc			; end if
                                     0CDE       strcat:			; use  of word as v1_kernel label
                                     0CDE       	
                    50   04 BB   3C  0CDE  2489 	movzwl	@4(r11),r0		; length of src
                    57   00 BB   3C  0CE2  2490 	movzwl	@(r11),r7		; length of dest
               53   04 AB   02   C1  0CE6  2491 	addl3	#2,4(r11),r3		; address of src characters
                       52   6B   D0  0CEB  2492 	movl	(r11),r2		; address of dest
                  54   52   02   C3  0CEE  2493 	subl3	#2,r2,r4		; address of maxlen of dest
                  52   52   02   C1  0CF2  2494 	addl3	#2,r2,r2		; address of dest char
                       55   64   3C  0CF6  2495 	movzwl	(r4),r5			; maxlen of dest
                  56   55   57   C3  0CF9  2496 	subl3	r7,r5,r6		; space available in dest
                       50   56   D1  0CFD  2497 	cmpl	r6,r0			; less space available than to copy
                            03   15  0D00  2498 	bleq	10$			; yes, use space available in dest as len
                       56   50   D0  0D02  2499 	movl	r0,r6			; no, move all characters in src
                                     0D05  2500 10$:
                       52   57   C0  0D05  2501 	addl2	r7,r2			; start at end of dest chars
                  62   63   56   28  0D08  2502 	movc3	r6,(r3),(r2)		; copy the string
                    00 BB   56   A0  0D0C  2503 	addw2	r6,@(r11)		; store the new length
                       5B   08   C0  0D10  2504 	addl2	#8,r11			; pop arguments
                                 05  0D13  2505 	rsb				; end of strcat
                                     0D14  2506 
                                     0D14  2507 
                                     0D14  2508 ;+++
                                     0D14  2509 ;k> strcmp -- ( a1 a2 -- n ) Compare word-counted strings.
                                     0D14  2510 ;	Return 0 if string at `a`' = string at `a2'.
                                     0D14  2511 ;	Return >0 if string at `a`' > string at `a2'.
                                     0D14  2512 ;	Return <0 if string at `a1' < string at `a2'.
                                     0D14  2513 ;---
                                     0D14  2514 	header	strcmp
                           FFFFFFFC  0D14       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0D18       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0D18       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D18       	.if    le, nchr		; nchr <= 0
               70 6D 63 72 74 73 00' 0D18       	   .ascic \strcmp\	; no auxillary , use principle one
                                 06  0D18       
                                     0D1F       	.if_false		; else
                                     0D1F       	  .ascic \\		; use auxillary 
                                     0D1F       	.endc			; end if
                                     0D1F       strcmp:			; use  of word as v1_kernel label
                                     0D1F       	
                    50   04 BB   3C  0D1F  2515 	movzwl	@4(r11),r0		; length of str1
               51   04 AB   02   C1  0D23  2516 	addl3	#2,4(r11),r1		; address of chars in str1
                    52   00 BB   3C  0D28  2517 	movzwl	@(r11),r2		; length of str2
                  53   6B   02   C1  0D2C  2518 	addl3	#2,(r11),r3		; address of chars in str2
                       5B   08   C0  0D30  2519 	addl2	#8,r11			; pop top two stack items
        63   52   00   61   50   2D  0D33  2520 	cmpc5	r0,(r1),#0,r2,(r3)	; compare chars with 0 fill
                            0A   13  0D39  2521 	beql	10$			; str1 = str2
                            0C   14  0D3B  2522 	bgtr	20$			; str1 > str2
              7B   FFFFFFFF 8F   D0  0D3D  2523 	movl	#-1,-(r11)		; str1 < str2
                                 05  0D44  2524 	rsb				; exit
                                     0D45  2525 10$:
                       7B   00   D0  0D45  2526 	movl	#0,-(r11)		; str1 = str2
                                 05  0D48  2527 	rsb				; exit
                                     0D49  2528 20$:
                       7B   01   D0  0D49  2529 	movl	#1,-(r11)		; str1 > str2
                                 05  0D4C  2530 	rsb				; end of strcmp
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 113
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0D4D  2531 
                                     0D4D  2532 
                                     0D4D  2533 ;+++
                                     0D4D  2534 ;k> strcpy -- ( a1 a2 -- ) copy word counted string at `a1' to w-string at `a2'.
                                     0D4D  2535 ;	Both must be word-counted, and string at `a2' must have maxlen 2bytes
                                     0D4D  2536 ;	(i.e., defined by { string } or { string" }).
                                     0D4D  2537 ;---
                                     0D4D  2538 	header	strcpy
                           FFFFFFFC  0D4D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0D51       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0D51       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D51       	.if    le, nchr		; nchr <= 0
               79 70 63 72 74 73 00' 0D51       	   .ascic \strcpy\	; no auxillary , use principle one
                                 06  0D51       
                                     0D58       	.if_false		; else
                                     0D58       	  .ascic \\		; use auxillary 
                                     0D58       	.endc			; end if
                                     0D58       strcpy:			; use  of word as v1_kernel label
                                     0D58       	
                       50   6B   D0  0D58  2539 	movl	(r11),r0		; get address of destination
                    51   04 AB   D0  0D5B  2540 	movl	4(r11),r1		; get address of source
                       56   61   3C  0D5F  2541 	movzwl	(r1),r6			; length of source
                  52   50   02   C3  0D62  2542 	subl3	#2,r0,r2		; address of destination max len
                       52   62   3C  0D66  2543 	movzwl	(r2),r2			; dest max len
                       56   52   D1  0D69  2544 	cmpl	r2,r6			; max len < source len?
                            03   18  0D6C  2545 	bgeq	10$			; no
                       56   52   D0  0D6E  2546 	movl	r2,r6			; yes, use max len for src len
                                     0D71  2547 10$:
            02 A0   02 AB   56   28  0D71  2548 	movc3	r6,2(r11),2(r0)		; move the strings
                    00 BB   56   B0  0D77  2549 	movw	r6,@(r11)		; save the new length of dest
                       5B   08   C0  0D7B  2550 	addl2	#8,r11			; pop arguments
                                 05  0D7E  2551 	rsb				; end of strcpy
                                     0D7F  2552 
                                     0D7F  2553 
                                     0D7F  2554 ;+++
                                     0D7F  2555 ;k> string -- ( n -- ) Create a string variable with maximum length of `n'.
                                     0D7F  2556 ;	The first 2 bytes of the string contains its length.
                                     0D7F  2557 ;	The 2 bytes previous to the string contains its maximum length.
                                     0D7F  2558 ;---
                                     0D7F  2559 	header	string,<string>
                           FFFFFFFC  0D7F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0D83       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000006  0D83       	.nchr  nchr, ^\string\	; nchr = length( string )
                           00000006  0D83       	.if    le, nchr		; nchr <= 0
                                     0D83       	   .ascic \string\	; no auxillary string, use principle one
                                     0D83       	.if_false		; else
               67 6E 69 72 74 73 00' 0D83       	  .ascic \string\		; use auxillary string
                                 06  0D83       
                                     0D8A       	.endc			; end if
                                     0D8A       string:			; use string of word as v1_kernel label
                                     0D8A       	
                       F64D CF   16  0D8A  2560 	jsb	create			; make the header
                       89   3E   90  0D8E  2561 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  0D91  2562 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  0D95  2563 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  0D98  2564 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0D9C  2565 	movb	#op_rsb,(r9)+		; rsb
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 114
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       89   6B   B0  0D9F  2566 	movw	(r11),(r9)+		; maximum length
                       89   00   B0  0DA2  2567 	movw	#0,(r9)+		; make high byte of current count
                       59   8B   C0  0DA5  2568 	addl2	(r11)+,r9		; save space for characters
                                 05  0DA8  2569 	rsb				; end of string
                                     0DA9  2570 
                                     0DA9  2571 
                                     0DA9  2572 ;+++
                                     0DA9  2573 ;k> string" -- ( n -- ) Create a string variable with maximum length of `n',
                                     0DA9  2574 ;	and initialize with string from input stream up until next `"'.
                                     0DA9  2575 ;	The first 2 bytes of the string contain its length.
                                     0DA9  2576 ;	The 2 bytes previous to the string contains its maximum length.
                                     0DA9  2577 ;---
                                     0DA9  2578 	header	i_string_quote,<string">
                           FFFFFFFC  0DA9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0DAD       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000007  0DAD       	.nchr  nchr, ^\string"\	; nchr = length( string" )
                           00000007  0DAD       	.if    le, nchr		; nchr <= 0
                                     0DAD       	   .ascic \i_string_quote\	; no auxillary string", use principle one
                                     0DAD       	.if_false		; else
            22 67 6E 69 72 74 73 00' 0DAD       	  .ascic \string"\		; use auxillary string"
                                 07  0DAD       
                                     0DB5       	.endc			; end if
                                     0DB5       i_string_quote:			; use string" of word as v1_kernel label
                                     0DB5       	
                       F622 CF   16  0DB5  2579 	jsb	create			; make the header
                       89   3E   90  0DB9  2580 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  0DBC  2581 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  0DC0  2582 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  0DC3  2583 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0DC7  2584 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  0DCA  2585 	movw	(r11),(r9)+		; maximum length
                       7A   59   D0  0DCD  2586 	movl	r9,-(r10)		; save address of current length on lstack
                       89   00   90  0DD0  2587 	movb	#0,(r9)+		; make high byte of current count
                                     0DD3  2588 					;   zero since token returns a b-counted
                                     0DD3  2589 					;   string
                       7B   22   D0  0DD3  2590 	movl	#^a\"\,-(r11)		; set up for quote terminated token
                   00000E7B'EF   16  0DD6  2591 	jsb	token			; get the token
                       50   89   9A  0DDC  2592 	movzbl	(r9)+,r0		; get count and move over to first char
                       50   6B   B1  0DDF  2593 	cmpw	(r11),r0		; is max length < token length
                            03   18  0DE2  2594 	bgeq	10$			; no
                       50   6B   D0  0DE4  2595 	movl	(r11),r0		; yes, only allow maxlen chars from
                                     0DE7  2596 					;   token
                                     0DE7  2597 10$:
                    00 BA   50   B0  0DE7  2598 	movw	r0,@(r10)		; save current length
                       5A   04   C0  0DEB  2599 	addl2	#4,r10			; pop temp storage from loop stack.
                       59   8B   C0  0DEE  2600 	addl2	(r11)+,r9		; save space for characters
                                 05  0DF1  2601 	rsb				; end of string"
                                     0DF2  2602 
                                     0DF2  2603 
                                     0DF2  2604 ;+++
                                     0DF2  2605 ;k> strmax -- ( -- ) Return maximum length of string at `a'.
                                     0DF2  2606 ;---
                                     0DF2  2607 	header	strmax
                           FFFFFFFC  0DF2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0DF6       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0DF6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DF6       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 115
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

               78 61 6D 72 74 73 00' 0DF6       	   .ascic \strmax\	; no auxillary , use principle one
                                 06  0DF6       
                                     0DFD       	.if_false		; else
                                     0DFD       	  .ascic \\		; use auxillary 
                                     0DFD       	.endc			; end if
                                     0DFD       strmax:			; use  of word as v1_kernel label
                                     0DFD       	
                       6B   02   C2  0DFD  2608 	subl2	#2,(r11)		; get address of max len
                    6B   00 BB   3C  0E00  2609 	movzwl	@(r11),(r11)		; get maximum length
                                 05  0E04  2610 	rsb				; end of strmax
                                     0E05  2611 
                                     0E05  2612 
                                     0E05  2613 ;+++
                                     0E05  2614 ;k> strpos -- ( a1 n1 a2 n2 -- a3 n3 ? f ) Find pos and len of substring in str.
                                     0E05  2615 ;	Searches string whose text is at `a2' and length is `n2' for substring
                                     0E05  2616 ;	whose text is at `a`' and whose length is `n1'.  Returns true on top of
                                     0E05  2617 ;	stack if found and under that { a3 n3 }, address and length of located
                                     0E05  2618 ;	substring.  Otherwise returns false.
                                     0E05  2619 ;---
                                     0E05  2620 	header	strpos
                           FFFFFFFC  0E05       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0E09       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0E09       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E09       	.if    le, nchr		; nchr <= 0
               73 6F 70 72 74 73 00' 0E09       	   .ascic \strpos\	; no auxillary , use principle one
                                 06  0E09       
                                     0E10       	.if_false		; else
                                     0E10       	  .ascic \\		; use auxillary 
                                     0E10       	.endc			; end if
                                     0E10       strpos:			; use  of word as v1_kernel label
                                     0E10       	
                         08 AB   39  0E10  2621 	matchc	8(r11),-		; length of object string (to find)
                         0C BB       0E13  2622 		@12(r11),-		; address of object string
                            6B       0E15  2623 		(r11),-			; length of source string (to search in)
                         04 BB       0E16  2624 		@4(r11)			; address of source string
                            19   12  0E18  2625 	bneq	10$			; match not found
                    50   08 AB   D0  0E1A  2626 	movl	8(r11),r0		; save length of object string
                  51   53   50   C3  0E1E  2627 	subl3	r0,r3,r1		; calculate start addr of found string
                       5B   10   C0  0E22  2628 	addl2	#16,r11			; pop arguments
                       7B   51   D0  0E25  2629 	movl	r1,-(r11)		; put address of found string on stack
                       7B   50   D0  0E28  2630 	movl	r0,-(r11)		; put length of found string on stack
              7B   FFFFFFFF 8F   D0  0E2B  2631 	movl	#c_true,-(r11)		; put true on stack
                                 05  0E32  2632 	rsb				; rturn
                                     0E33  2633 10$:
                       5B   10   C0  0E33  2634 	addl2	#16,r11			; pop arguments
                       7B   00   D0  0E36  2635 	movl	#c_false,-(r11)
                                 05  0E39  2636 	rsb				; end of strpos
                                     0E3A  2637 
                                     0E3A  2638 
                                     0E3A  2639 ;+++
                                     0E3A  2640 ;k> swap -- ( n1 n2 -- n2 n1 ) exchange the top two items on the stack.
                                     0E3A  2641 ;---
                                     0E3A  2642 	header	swap
                           FFFFFFFC  0E3A       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0E3E       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0E3E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E3E       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 116
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                     70 61 77 73 00' 0E3E       	   .ascic \swap\	; no auxillary , use principle one
                                 04  0E3E       
                                     0E43       	.if_false		; else
                                     0E43       	  .ascic \\		; use auxillary 
                                     0E43       	.endc			; end if
                                     0E43       swap:			; use  of word as v1_kernel label
                                     0E43       	
                       50   6B   D0  0E43  2643 	movl	(r11),r0		; temp = n2
                    6B   04 AB   D0  0E46  2644 	movl	4(r11),(r11)		; n2 = n1
                    04 AB   50   D0  0E4A  2645 	movl	r0,4(r11)		; n1 = saved n2
                                 05  0E4E  2646 	rsb				; end of swap
                                     0E4F  2647 
                                     0E4F  2648 
                                     0E4F  2649 ;+++
                                     0E4F  2650 ;k> tochar -- convert top fo stack from 0..9, A..Z to '0'..'9','A'..'Z'
                                     0E4F  2651 ;	( n -- c ) where n is a number and c is a char.
                                     0E4F  2652 ;	If not in rnage leave alow.
                                     0E4F  2653 ;---
                                     0E4F  2654 	header	tochar
                           FFFFFFFC  0E4F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0E53       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0E53       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E53       	.if    le, nchr		; nchr <= 0
               72 61 68 63 6F 74 00' 0E53       	   .ascic \tochar\	; no auxillary , use principle one
                                 06  0E53       
                                     0E5A       	.if_false		; else
                                     0E5A       	  .ascic \\		; use auxillary 
                                     0E5A       	.endc			; end if
                                     0E5A       tochar:			; use  of word as v1_kernel label
                                     0E5A       	
                                     0E5A  2655 ; with 10 numbers and 26 letters, largest base is 36.
                                     0E5A  2656 ; didgits go from 0 to 35.
                            6B   D5  0E5A  2657 	tstl	(r11)			; n < 0?
                            12   19  0E5C  2658 	blss	100$			; yes, exit
                       23   6B   D1  0E5E  2659 	cmpl	(r11),#35		; n > 35
                            0D   14  0E61  2660 	bgtr	100$			; yes, exit
                       09   6B   D1  0E63  2661 	cmpl	(r11),#9		; n > 9 (not a `number') ~~~base 10 digit
                            05   14  0E66  2662 	bgtr	10$			; yes, make it 'A' .. 'Z'
                       6B   30   C0  0E68  2663 	addl2	#48,(r11)		; no, make it a '1' .. '9'
                            03   11  0E6B  2664 	brb	100$			; exit
                                     0E6D  2665 10$:
                       6B   37   C0  0E6D  2666 	addl2	#55,(r11)		; make it 'A' .. 'Z'
                                     0E70  2667 100$:
                                 05  0E70  2668 	rsb				; end of tochar.
                                     0E71  2669 
                                     0E71  2670 
                                     0E71  2671 ;+++t
                                     0E71  2672 ;k> token -- ( c -- ) Get next token from input stream and put it in dictionary.
                                     0E71  2673 ;	Note that this dos NOT increment the dictionary pointer!
                                     0E71  2674 ;---
                                     0E71  2675 	header	token
                           FFFFFFFC  0E71       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0E75       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0E75       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E75       	.if    le, nchr		; nchr <= 0
                  6E 65 6B 6F 74 00' 0E75       	   .ascic \token\	; no auxillary , use principle one
                                 05  0E75       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 117
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0E7B       	.if_false		; else
                                     0E7B       	  .ascic \\		; use auxillary 
                                     0E7B       	.endc			; end if
                                     0E7B       token:			; use  of word as v1_kernel label
                                     0E7B       	
                       6B   20   91  0E7B  2676 	cmpb	#c_blank,(r11)		; ?c = ' '~~~, an ascii blank
                            22   12  0E7E  2677 	bneq	_gettoken		; if anything but space, don't skip
                                     0E80  2678 _skipwhitespace:
0000199B'FF   00001999'EF   6B   3B  0E80  2679 	skpc	(r11),v_inlen,@v_inptr	; skip whitespace
                            06   12  0E8C  2680 	bneq	_startfound		; if something other than whitespace
                                     0E8E  2681 					; found
                       FD8F CF   16  0E8E  2682 	jsb     sread                   ; get a new line, only whitespace found
                            EC   11  0E92  2683 	brb	_skipwhitespace		; do it over
                                     0E94  2684 _startfound:
              0000199B'EF   51   D0  0E94  2685 	movl	r1,v_inptr		; where non-whitespcae found
              00001999'EF   50   B0  0E9B  2686 	movw	r0,v_inlen		; bytes remaining in string
                                     0EA2  2687 _gettoken:
                            56   D4  0EA2  2688 	clrl	r6
                            57   D4  0EA4  2689 	clrl	r7
0000199B'FF   00001999'EF   6B   3A  0EA6  2690 	locc	(r11),v_inlen,@v_inptr	; locate character
         56   00001999'EF   50   A3  0EB2  2691 	subw3	r0,v_inlen,r6		; (v_inlen = r0) = number of chars
                                     0EBA  2692 					;   to copy
              00001999'EF   50   B0  0EBA  2693 	movw    r0,v_inlen              ; these are only bytes left (including one
                                     0EC1  2694 					; located~~~close paren?
                       57   51   D0  0EC1  2695 	movl	r1,r7			; save address of found char
                       69   56   33  0EC4  2696 	cvtwb	r6,(r9)			; store byte length
                  58   59   01   C1  0EC7  2697 	addl3	#1,r9,r8		; where to put in dictinary
         68   0000199B'FF   56   28  0ECB  2698 	movc3	r6,@v_inptr,(r8)	; move string to dictinary
              0000199B'EF   57   D0  0ED3  2699 	movl	r7,v_inptr		; v_inptr points into string
                   00001999'EF   B5  0EDA  2700 	tstw	v_inlen			; Are any more char?  (including
                                     0EE0  2701 					;   located one)
                            0E   13  0EE0  2702 	beql	10$			; no, exit
              00001999'EF   01   A2  0EE2  2703 	subw2	#1,v_inlen		; yes, move over terminator
                                     0EE9  2704 					;   (located char)
              0000199B'EF   01   C0  0EE9  2705 	addl2	#1,v_inptr
                                     0EF0  2706 10$:
                       5B   04   C0  0EF0  2707 	addl2	#4,r11			; pop terminator off stack
                                 05  0EF3  2708 	rsb				; end of token
                                     0EF4  2709 
                                     0EF4  2710 
                                     0EF4  2711 ;+++t
                                     0EF4  2712 ;k> unlink -- ( -- ) Unlink the most current word from the current vocab.  Used
                                     0EF4  2713 ;	when a definition is aborted by an unknown token.
                                     0EF4  2714 ;---
                                     0EF4  2715 	header	unlink
                           FFFFFFFC  0EF4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0EF8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0EF8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0EF8       	.if    le, nchr		; nchr <= 0
               6B 6E 69 6C 6E 75 00' 0EF8       	   .ascic \unlink\	; no auxillary , use principle one
                                 06  0EF8       
                                     0EFF       	.if_false		; else
                                     0EFF       	  .ascic \\		; use auxillary 
                                     0EFF       	.endc			; end if
                                     0EFF       unlink:			; use  of word as v1_kernel label
                                     0EFF       	
              58   00001D3B'FF   D0  0EFF  2716 	movl	@v_current,r8		; reclaim directory space
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 118
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

              00001D3B'FF   69   D0  0F06  2717 	movl	(r9),@v_current		; get pointer to last word in current
                                     0F0D  2718 					; vocab from link field of word
                                     0F0D  2719 					; we just deleted
                                 05  0F0D  2720 	rsb				; end of unlink
                                     0F0E  2721 
                                     0F0E  2722 
                                     0F0E  2723 ;+++
                                     0F0E  2724 ;k> unsmudge -- clear the smudge (high) bit in the word being defined, so
                                     0F0E  2725 ;	that it can be found again.
                                     0F0E  2726 ;---
                                     0F0E  2727 	header	unsmudge
                           FFFFFFFC  0F0E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0F12       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0F12       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F12       	.if    le, nchr		; nchr <= 0
         65 67 64 75 6D 73 6E 75 00' 0F12       	   .ascic \unsmudge\	; no auxillary , use principle one
                                 08  0F12       
                                     0F1B       	.if_false		; else
                                     0F1B       	  .ascic \\		; use auxillary 
                                     0F1B       	.endc			; end if
                                     0F1B       unsmudge:			; use  of word as v1_kernel label
                                     0F1B       	
              50   00001D3B'FF   D0  0F1B  2728 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  0F22  2729 	addl2	#4,r0			; move over link field
                    60   80 8F   8A  0F25  2730 	bicb2	#^b10000000,(r0)	; clear smudge bit
                                 05  0F29  2731 	rsb				; end of unsmudge
                                     0F2A  2732 
                                     0F2A  2733 
                                     0F2A  2734 ;+++
                                     0F2A  2735 ;k> update -- ( -- ) Mark the most recent block as updated.
                                     0F2A  2736 ;---
                                     0F2A  2737 	header	update
                           FFFFFFFC  0F2A       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0F2E       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0F2E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F2E       	.if    le, nchr		; nchr <= 0
               65 74 61 64 70 75 00' 0F2E       	   .ascic \update\	; no auxillary , use principle one
                                 06  0F2E       
                                     0F35       	.if_false		; else
                                     0F35       	  .ascic \\		; use auxillary 
                                     0F35       	.endc			; end if
                                     0F35       update:			; use  of word as v1_kernel label
                                     0F35       	
              50   00001B79'EF   D0  0F35  2738 	movl	v_current_buff,r0	; get buffer number of current block
                            02   90  0F3C  2739 	movb	#c_modified,-		;
                       1B7D'C0       0F3E  2740 		v_buf_inuse(r0)		; mark buffer as updated
                                 05  0F41  2741 	rsb				; end of update
                                     0F42  2742 
                                     0F42  2743 
                                     0F42  2744 ;+++
                                     0F42  2745 ;k> variable -- ( -- ) Create a word that pushed its PFA on the stack.
                                     0F42  2746 ;	Doesn't reserve any space.  Use for making initialized arrays.
                                     0F42  2747 ;	PF = parameter field address = address of data following end
                                     0F42  2748 ;	of code body of work.
                                     0F42  2749 ;---
                                     0F42  2750 ;??? This concept is fuzzy.  Work on it.
                                     0F42  2751 	header	  variable
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 119
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           FFFFFFFC  0F42       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0F46       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0F46       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F46       	.if    le, nchr		; nchr <= 0
         65 6C 62 61 69 72 61 76 00' 0F46       	   .ascic \variable\	; no auxillary , use principle one
                                 08  0F46       
                                     0F4F       	.if_false		; else
                                     0F4F       	  .ascic \\		; use auxillary 
                                     0F4F       	.endc			; end if
                                     0F4F       variable:			; use  of word as v1_kernel label
                                     0F4F       	
                       F488 CF   16  0F4F  2752 	jsb	  create		; enclose next token in dictionary
                    89   90 8F   90  0F53  2753 	movb	  #op_movb,(r9)+	; `movb'
                    89   AF 8F   90  0F57  2754 	movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  0F5B  2755 	movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  0F5E  2756 	movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0F62  2757 	movb	  #op_rsb,(r9)+		; `rsb'
                                 05  0F65  2758 	rsb				; end of variable
                                     0F66  2759 
                                     0F66  2760 
                                     0F66  2761 ;+++
                                     0F66  2762 ;k> vlist -- ( -- ) List context vocabulary
                                     0F66  2763 ;---
                                     0F66  2764 	header	vlist
                           FFFFFFFC  0F66       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0F6A       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0F6A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F6A       	.if    le, nchr		; nchr <= 0
                  74 73 69 6C 76 00' 0F6A       	   .ascic \vlist\	; no auxillary , use principle one
                                 05  0F6A       
                                     0F70       	.if_false		; else
                                     0F70       	  .ascic \\		; use auxillary 
                                     0F70       	.endc			; end if
                                     0F70       vlist:			; use  of word as v1_kernel label
                                     0F70       	
              50   00001D37'FF   D0  0F70  2765 	movl	@v_context,r0		; get address of context vocabulary
                       7B   50   D0  0F77  2766 	movl	r0,-(r11)		; get address of most recent word
                                     0F7A  2767 10$:
                            6B   D5  0F7A  2768 	tstl	(r11)			; nil pointer?
                            22   13  0F7C  2769 	beql	100$			; yes, exit
                  7B   04   6B   C1  0F7E  2770 	addl3	(r11),#4,-(r11)		; get address of name field
                       F089 CF   16  0F82  2771 	jsb	bcount			; set up for write
                       7B   6B   D0  0F86  2772 	movl	(r11),-(r11)		; set up for ?cr
                       F378 CF   16  0F89  2773 	jsb	q_n_cr			; start new line if word too long
                   00000FE9'EF   16  0F8D  2774 	jsb	write			; tell user
                       7B   20   D0  0F93  2775 	movl	#c_blank,-(r11)		; blank to separate words
                       F9ED CF   16  0F96  2776 	jsb	putc			; output it
                    6B   00 BB   D0  0F9A  2777 	movl	@(r11),(r11)		; get previous word's LFA
                            DA   11  0F9E  2778 	brb	10$			; try it again
                                     0FA0  2779 100$:
                       5A   04   C0  0FA0  2780 	addl2	#4,r10			; pop pointer off stack
                                 05  0FA3  2781 	rsb				; end of vlist
                                     0FA4  2782 
                                     0FA4  2783 
                                     0FA4  2784 ;+++
                                     0FA4  2785 ;k> vocabulary -- ( -- ) Defining word.  Creates a new vocabulary. When the word
                                     0FA4  2786 ;	defined by this is executed, context is set to the new vocabulary.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 120
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     0FA4  2787 ;---
                                     0FA4  2788 	header	vocabulary
                           FFFFFFFC  0FA4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0FA8       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0FA8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0FA8       	.if    le, nchr		; nchr <= 0
   79 72 61 6C 75 62 61 63 6F 76 00' 0FA8       	   .ascic \vocabulary\	; no auxillary , use principle one
                                 0A  0FA8       
                                     0FB3       	.if_false		; else
                                     0FB3       	  .ascic \\		; use auxillary 
                                     0FB3       	.endc			; end if
                                     0FB3       vocabulary:			; use  of word as v1_kernel label
                                     0FB3       	
              7A   00001D37'FF   D0  0FB3  2789 	movl	@v_context,-(r10)	; save LFA of word to link to
                       F41D CF   16  0FBA  2790 	jsb	create			;   make header for new vocab~~~ word
                    89   DE 8F   90  0FBE  2791 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  0FC2  2792 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   06   90  0FC6  2793 	movb	#6,(r9)+		; (pc+2) ~~~ isn't this (pc+6)?
              89   0000009F'EF   90  0FC9  2794 	movb	adm_absolute,(r9)+	; absolute mode (address in next lword)
              89   00001D37'EF   DE  0FD0  2795 	moval	v_context,(r9)+		; context
                    89   05 8F   9E  0FD7  2796 	movab	#op_rsb,(r9)+		; rsb
                       89   8A   D0  0FDB  2797 	movl	(r10)+,(r9)+		; initialize link
                                 05  0FDE  2798 	rsb				; end of vocabulary
                                     0FDF  2799 
                                     0FDF  2800 
                                     0FDF  2801 ;+++t
                                     0FDF  2802 ;k> write -- ( a w -- ) Write string of length `w' at address `a' out to  terminal.
                                     0FDF  2803 ;---
                                     0FDF  2804 	header	write
                           FFFFFFFC  0FDF       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  0FE3       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  0FE3       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0FE3       	.if    le, nchr		; nchr <= 0
                  65 74 69 72 77 00' 0FE3       	   .ascic \write\	; no auxillary , use principle one
                                 05  0FE3       
                                     0FE9       	.if_false		; else
                                     0FE9       	  .ascic \\		; use auxillary 
                                     0FE9       	.endc			; end if
                                     0FE9       write:			; use  of word as v1_kernel label
                                     0FE9       	
         00A0 8F   00001B98'EF   B1  0FE9  2805 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            28   19  0FF2  2806 	blss	10$			; no, go get some
                                     0FF4  2807 ; yes, output it
              7B   00001B9A'EF   DE  0FF4  2808 	moval	v_outbuf,-(r11)		; put address on stack
              7B   00001B98'EF   3C  0FFB  2809 	movzwl	v_outlen,-(r11)		; put length on stack
           02 AB   00001B96'EF   B0  1002  2810 	movw	v_static_dsc,2(r11)	; put rest of descriptor in
                            5B   DD  100A  2811 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  100C  2812 	calls	#1,g^lib$put_output	; output it
                       5B   08   C0  1013  2813 	addl2	#8,r11			; pop top two entries (descriptor)
                   00001B98'EF   B4  1016  2814 	clrw	v_outlen		; nothing left in buffer
                                     101C  2815 10$:
              56   00001B98'EF   3C  101C  2816 	movzwl	v_outlen,r6		; get length
         57   000000A0 8F   56   C3  1023  2817 	subl3	r6,#c_max_len,r7	; space available in output buffer
              50   00001B9A'EF   9E  102B  2818 	movab	v_outbuf,r0		; pointer into buffer
                       50   56   C0  1032  2819 	addl2	r6,r0			; next available byte
                       57   6B   D1  1035  2820 	cmpl	(r11),r7		; chars to output <= available
                            10   14  1038  2821 	bgtr	20$			; no, do a part
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 121
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

               60   04 BB   6B   28  103A  2822 	movc3	(r11),@4(r11),(r0)	; move the string into the output buffer
              00001B98'EF   6B   A0  103F  2823 	addw2	(r11),v_outlen		; save the new # of chars in buffer
                       5B   08   C0  1046  2824 	addl2	#8,r11			; pop top two entries off stack
                                 05  1049  2825 	rsb				; return
                                     104A  2826 20$:					; more chars to output than buffer space
               60   04 BB   57   28  104A  2827 	movc3	r7,@4(r11),(r0)		; move some into buffer
                       6B   57   C2  104F  2828 	subl2	r7,(r11)		; new length to output
                    04 AB   57   C0  1052  2829 	addl2	r7,4(r11)		; new place to start in chars to output
              00001B98'EF   57   A0  1056  2830 	addw2	r7,v_outlen		; new # of chars in buffer
              7B   00001B9A'EF   9E  105D  2831 	movab	v_outbuf,-(r11)		; address of buffer on stack
              7B   00001B98'EF   9A  1064  2832 	movzbl	v_outlen,-(r11)		; count on stack
           02 AB   00001B96'EF   B0  106B  2833 	movw	v_static_dsc,2(r11)	; put middle of descriptor in
                            5B   DD  1073  2834 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  1075  2835 	calls	#1,g^lib$put_output	; display it
                   00001B98'EF   B4  107C  2836 	clrw	v_outlen		; nothing in buffer now
                       5B   08   C0  1082  2837 	addl2	#8,r11			; pop descriptor off stack
                            6B   D5  1085  2838 	tstl	(r11)			; Are there any remaining characters?
                            93   14  1087  2839 	bgtr	10$			; yes, try it again
                       5B   08   C0  1089  2840 	addl2	#8,r11			; pop arguments
                                 05  108C  2841 	rsb				; end of write
                                     108D  2842 
                                     108D  2843 
                                     108D  2844 ;+++
                                     108D  2845 ;k> xor -- ( f1 f2 -- f ) logical xor; f1 xor f2.
                                     108D  2846 ;---
                                     108D  2847 	header	xor
                           FFFFFFFC  108D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  1091       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000000  1091       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1091       	.if    le, nchr		; nchr <= 0
                        72 6F 78 00' 1091       	   .ascic \xor\	; no auxillary , use principle one
                                 03  1091       
                                     1095       	.if_false		; else
                                     1095       	  .ascic \\		; use auxillary 
                                     1095       	.endc			; end if
                                     1095       xor:			; use  of word as v1_kernel label
                                     1095       	
                            8B   D5  1095  2848 	tstl	(r11)+			; is the first one false?
                            06   13  1097  2849 	beql	10$			; yes
                            8B   D5  1099  2850 	tstl	(r11)+			; no, is the second one false?
                            0A   13  109B  2851 	beql	30$			; yes, leave with true
                            04   11  109D  2852 	brb	20$			; no leave with false
                                     109F  2853 10$:					; first one false
                            8B   D5  109F  2854 	tstl	(r11)+			; Is the second one true?
                            04   12  10A1  2855 	bneq	30$			; yes, leave with true
                                     10A3  2856 20$:					; leave with false
                       7B   00   D0  10A3  2857 	movl	#c_false,-(r11)		; leave with false
                                 05  10A6  2858 	rsb				; return
                                     10A7  2859 30$:
              7B   FFFFFFFF 8F   D0  10A7  2860 	movl	#c_true,-(r11)		; leave with true
                                 05  10AE  2861 	rsb				; end of xor
                                     10AF  2862 
                                     10AF  2863 
                                     10AF  2864 ;+++
                                     10AF  2865 ;k> ] -- ( -- ) enter compile mode.  Used with { [ } in definitions.
                                     10AF  2866 ;---
                                     10AF  2867 	header i_right_back,<]>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 122
V1.01                           Kernel Built-ins                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           FFFFFFFC  10AF       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           FFFFFFFC  10B3       	v1_kernel = -4		; where to link the next word to in this v1_kernel
                           00000001  10B3       	.nchr  nchr, ^\]\	; nchr = length( ] )
                           00000001  10B3       	.if    le, nchr		; nchr <= 0
                                     10B3       	   .ascic \i_right_back\	; no auxillary ], use principle one
                                     10B3       	.if_false		; else
                              5D 00' 10B3       	  .ascic \]\		; use auxillary ]
                                 01  10B3       
                                     10B5       	.endc			; end if
                                     10B5       i_right_back:			; use ] of word as v1_kernel label
                                     10B5       	
           00001D4D'EF   FF 8F   90  10B5  2868 	movb   #c_true,v_mode		; enter compile mode
                                 05  10BD  2869 	rsb				; end of l
                                     10BE  2870 
                                     10BE  2871 
                                     10BE  2872 _kernel_end:
                                     10BE  2873 	newpage <cCompiler Built-ins>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 123
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     10BE       	.sbttl	cCompiler Built-ins
                                     10BE       	
                                     10BE  2874 ;*******************************************************************************
                                     10BE  2875 ;
                                     10BE  2876 ; Compiler Built-ins -- a new word is unlinked from the current vocabulary
                                     10BE  2877 ;	and linked into the compilier vocabulary by the word { compiletime }.
                                     10BE  2878 ;	Computer (or compiletime} words are only search for during the
                                     10BE  2879 ;	definition of new words, which prevents them from mucking about with
                                     10BE  2880 ;	the stacks and the dictionary when we are interpreting the user's
                                     10BE  2881 ;	commands.
                                     10BE  2882 ;
                                     10BE  2883 ;*******************************************************************************
                                     10BE  2884 compiler_begin:
                                     10BE  2885 
                                     10BE  2886 
                                     10BE  2887 ;+++
                                     10BE  2888 ;c> (variable) - ( -- ) compiles the code body of a word that pushes the
                                     10BE  2889 ;	address of its parameter field on the stack.  Must be the last word
                                     10BE  2890 ;	in the word...
                                     10BE  2891 ;---
                                     10BE  2892 ;??? This concept is fuzzy.  Work on it.
                                     10BE  2893      header	  i_variable,<(variable)>,vl_compiler
                           00000000  10BE       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  10C2       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           0000000A  10C2       	.nchr  nchr, ^\(variable)\	; nchr = length( (variable) )
                           0000000A  10C2       	.if    le, nchr		; nchr <= 0
                                     10C2       	   .ascic \i_variable\	; no auxillary (variable), use principle one
                                     10C2       	.if_false		; else
   29 65 6C 62 61 69 72 61 76 28 00' 10C2       	  .ascic \(variable)\		; use auxillary (variable)
                                 0A  10C2       
                                     10CD       	.endc			; end if
                                     10CD       i_variable:			; use (variable) of word as vl_compiler label
                                     10CD       	
                    89   9E 8F   90  10CD  2894      movb	  #op_movab,(r9)+	; `movab'
                    89   AF 8F   90  10D1  2895      movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  10D5  2896      movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  10D8  2897      movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  10DC  2898      movb	  #op_rsb,(r9)+		; `rsb'
                                 05  10DF  2899      rsb				; end of (variable)
                                     10E0  2900 
                                     10E0  2901 
                                     10E0  2902 ;+++
                                     10E0  2903 ;c> +loop -- ( n -- ) where n is an increment.  Edns { do .. +loop }.  Adds top
                                     10E0  2904 ;	of stack to loop index and branches to { do } if ((index > 0) and
                                     10E0  2905 ;	(index < limit)), or if ((index < 0) and (index > limit)).~~~ WTF: and should be or???
                                     10E0  2906 ;	In other words, { +loop } with a positive argument is like Pascal's
                                     10E0  2907 ;	{ for index := start to finish do ... } and with a negative argument
                                     10E0  2908 ;	it is like { for index := start downto finish do }.
                                     10E0  2909 ;---
                                     10E0  2910 	header	i_plus_loop,<+loop>,vl_compiler
                           FFFFFFFC  10E0       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  10E4       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000005  10E4       	.nchr  nchr, ^\+loop\	; nchr = length( +loop )
                           00000005  10E4       	.if    le, nchr		; nchr <= 0
                                     10E4       	   .ascic \i_plus_loop\	; no auxillary +loop, use principle one
                                     10E4       	.if_false		; else
                  70 6F 6F 6C 2B 00' 10E4       	  .ascic \+loop\		; use auxillary +loop
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 124
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 05  10E4       
                                     10EA       	.endc			; end if
                                     10EA       i_plus_loop:			; use +loop of word as vl_compiler label
                                     10EA       	
                    89   F1 8F   90  10EA  2911 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  10EE  2912 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  10F2  2913 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8B 8F   90  10F5  2914 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   6A 8F   90  10F9  2915 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  10FD  2916 	movl	r9,r0			; save address of branch word
                       89   00   B0  1100  2917 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  1103  2918 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  1107  2919 	movw	r1,(r0)			; save displacement
                  89   00C0 8F   B0  110A  2920 	movw	#op_addl2,(r9)+		; `addl2'	pop index&limit from ls
                       89   08   90  110F  2921 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  1112  2922 	movb	#adm_r10,(r9)+		; r10
                                 05  1116  2923 	rsb				; end of +loop
                                     1117  2924 
                                     1117  2925 
                                     1117  2926 ;+++
                                     1117  2927 ;c> ." -- ( -- ) compile text until netx `"' into dictinary to be printed when
                                     1117  2928 ;	the current word is executed.
                                     1117  2929 ;---
                                     1117  2930 	header	i_dot_quote,<.">,vl_compiler
                           FFFFFFFC  1117       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  111B       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000002  111B       	.nchr  nchr, ^\."\	; nchr = length( ." )
                           00000002  111B       	.if    le, nchr		; nchr <= 0
                                     111B       	   .ascic \i_dot_quote\	; no auxillary .", use principle one
                                     111B       	.if_false		; else
                           22 2E 00' 111B       	  .ascic \."\		; use auxillary ."
                                 02  111B       
                                     111E       	.endc			; end if
                                     111E       i_dot_quote:			; use ." of word as vl_compiler label
                                     111E       	
                    89   9E 8F   90  111E  2931 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  1122  2932 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   05   90  1126  2933 	movb	#5,(r9)+		; (pc+5)	skip length byte too
                    89   7B 8F   90  1129  2934 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   31   90  112D  2935 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1130  2936 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  1133  2937 	movw	#0,(r9)+		; save space for displacement
                       7B   22   D0  1136  2938 	movl	#^a\"\,-(r11)		; set up for `"' delimited tokens
                       FD3E CF   16  1139  2939 	jsb	token			; get token
                       50   69   9A  113D  2940 	movzbl	(r9),r0			; get length of token
                  51   50   01   C1  1140  2941 	addl3	#1,r0,r1		; calc displacement (count length too)
                    00 B1   51   B0  1144  2942 	movw	r1,@(r1)		; fill in displacement
                       5A   04   C0  1148  2943 	addl2	#4,r10			; pop item off loop stack
                       59   51   C0  114B  2944 	addl2	r1,r9			; save string in dictionary
                    89   D0 8F   90  114E  2945 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  1152  2946 	movb	#adm_immediate,(r9)+	; immeidate mode
                       89   50   D0  1156  2947 	movl	r0,(r9)+		; length of string
                    89   7B 8F   90  1159  2948 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                     115D  2949 ; we now have ( address count ) on stack (when new word executed)
                       89   16   90  115D  2950 	movb	#op_jsb,(r9)+		; `jsb'
                    89   9F 8F   90  1160  2951 	movb	#adm_absolute,(r9)+	; absolute mode
                  89   FE81 CF   DE  1164  2952 	moval	write,(r9)+		; address of subroutine to jsb to
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 125
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 05  1169  2953 	rsb				; end of ."
                                     116A  2954 
                                     116A  2955 
                                     116A  2956 ;+++
                                     116A  2957 ;c> ; (semicolon) -- ( -- ) Terminate a definition started by { : }.
                                     116A  2958 ;	Sets { mode } to false and adds an rsb to the definition.
                                     116A  2959 ;---
                                     116A  2960 	header	i_semicolon,<;>,vl_compiler
                           FFFFFFFC  116A       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  116E       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000001  116E       	.nchr  nchr, ^\;\	; nchr = length( ; )
                           00000001  116E       	.if    le, nchr		; nchr <= 0
                                     116E       	   .ascic \i_semicolon\	; no auxillary ;, use principle one
                                     116E       	.if_false		; else
                              3B 00' 116E       	  .ascic \;\		; use auxillary ;
                                 01  116E       
                                     1170       	.endc			; end if
                                     1170       i_semicolon:			; use ; of word as vl_compiler label
                                     1170       	
                       89   05   90  1170  2961 	movb	#op_rsb,(r9)+		; put an rsb in to end word
              00001D4D'EF   00   90  1173  2962 	movb	#c_false,v_mode		; switch off compiler v_mode
                                     117A  2963 ;??? might need to unset high bit in count of name (smudge) bit
                       FD9D CF   16  117A  2964 	jsb	unsmudge      	     	; clear smudge bit so word is found
                                 05  117E  2965 	rsb				; end of ;
                                     117F  2966 
                                     117F  2967 
                                     117F  2968 ;+++
                                     117F  2969 ;c> >defer -- ( -- ) ends a section of code that is to copied to the
                                     117F  2970 ;	dictionary whenever this word is executed (i.e., { >defer } ends code
                                     117F  2971 ;	to be executed by all words defined by the word we are now compiling).
                                     117F  2972 ;	{ >defer } is used to define words that define words.
                                     117F  2973 ;---
                                     117F  2974 ;???  This concept is fuzzy.  Work on it.  May be fuzzy, but it works...
                                     117F  2975 	header	   i_defer_end,^\>defer\,vl_compiler
                           FFFFFFFC  117F       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1183       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000006  1183       	.nchr  nchr, ^\>defer\	; nchr = length( >defer )
                           00000006  1183       	.if    le, nchr		; nchr <= 0
                                     1183       	   .ascic \i_defer_end\	; no auxillary >defer, use principle one
                                     1183       	.if_false		; else
               72 65 66 65 64 3E 00' 1183       	  .ascic \>defer\		; use auxillary >defer
                                 06  1183       
                                     118A       	.endc			; end if
                                     118A       i_defer_end:			; use >defer of word as vl_compiler label
                                     118A       	
                  50   59   8A   C3  118A  2976 	subl3	   (r10)+,r9,r0		; calculate length and displacement
                       9A   50   B0  118E  2977 	movw	   r0,@(r10)+		; store displacement
                       9A   50   B0  1191  2978 	movw	   r0,@(r10)+		; store length
                                     1194  2979 ; make new word advance dictionary pointer over just added code
                    89   C0 8F   90  1194  2980 	movb	#op_addl2,(r9)+		; `addl2'
                    89   8F 8F   90  1198  2981 	movb	#adm_immediate,(r9)+	; i^#
                       80   50   D0  119C  2982 	movl	r0,(r0)+		; amount to advance
                    89   59 8F   90  119F  2983 	movb	#adm_r9,(r9)+		; r9
                                 05  11A3  2984 	rsb				; end of >defer
                                     11A4  2985 
                                     11A4  2986 
                                     11A4  2987 ;+++
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 126
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     11A4  2988 ;c> again -- ( -- ) Terminate a { repeat ... if ... again } loop.  { agin }
                                     11A4  2989 ;	unconditionally branches back to the { repeat }.
                                     11A4  2990 ;---
                                     11A4  2991 	header	again,,vl_compiler
                           FFFFFFFC  11A4       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  11A8       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  11A8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  11A8       	.if    le, nchr		; nchr <= 0
                  6E 69 61 67 61 00' 11A8       	   .ascic \again\	; no auxillary , use principle one
                                 05  11A8       
                                     11AE       	.if_false		; else
                                     11AE       	  .ascic \\		; use auxillary 
                                     11AE       	.endc			; end if
                                     11AE       again:			; use  of word as vl_compiler label
                                     11AE       	
                                     11AE  2992 ; save values for calculating displacement in if.
                       50   8A   D0  11AE  2993 	movl  (r10)+,r0			; save address to displace from if
                       51   8A   D0  11B1  2994 	movl  (r10)+,r1			; save address for displacement
                                     11B4  2995 ; construct negative branch from { again } to { repeat }
                       89   31   90  11B4  2996 	movb	#op_brw,(r9)+		; `brw'
                       52   59   D0  11B7  2997 	movl	r9,r2			; save address for negative displacement
                       89   00   B0  11BA  2998 	movw	#0,(r9)+		; save space for displacement
                  53   8A   59   C3  11BD  2999 	subl3	r9,(r10)+,r3		; calculate negative displacment
                       62   53   B0  11C1  3000 	movw	r3,(r2)			; save negative displacement
                                     11C4  3001 ; construct forward branch from { if } to after { again }
                  54   59   50   C3  11C4  3002 	subl3	r0,r9,r4		; calculate { if }'s displacment
                       61   54   B0  11C8  3003 	movw	r4,(r1)			; save displacement
                                 05  11CB  3004 	rsb				; end of again
                                     11CC  3005 
                                     11CC  3006 
                                     11CC  3007 ;+++
                                     11CC  3008 ;c> b^ -- ( -- ) Convert next token to number and enclose low byte in dictionary.~~~ byte immediate???
                                     11CC  3009 ;---
                                     11CC  3010 	header	i_b_up,<b^>,vl_compiler
                           FFFFFFFC  11CC       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  11D0       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000002  11D0       	.nchr  nchr, ^\b^\	; nchr = length( b^ )
                           00000002  11D0       	.if    le, nchr		; nchr <= 0
                                     11D0       	   .ascic \i_b_up\	; no auxillary b^, use principle one
                                     11D0       	.if_false		; else
                           5E 62 00' 11D0       	  .ascic \b^\		; use auxillary b^
                                 02  11D0       
                                     11D3       	.endc			; end if
                                     11D3       i_b_up:			; use b^ of word as vl_compiler label
                                     11D3       	
                       7B   20   D0  11D3  3011 	movl	#c_blank,-(r11)		; set up for blank delimeted token
                       FCA1 CF   16  11D6  3012 	jsb	token			; get it
                       F6DB CF   16  11DA  3013 	jsb	number			; try to make it a number
                            8B   D5  11DE  3014 	tstl	(r11)+			; is it a number?
                            01   12  11E0  3015 	bneq	10$			; yes
                                 05  11E2  3016 	rsb				; no, for now just exit~~~??? FIXME!
                                     11E3  3017 10$:
                       89   6B   90  11E3  3018 	movb	(r11),(r9)+		; save byte in dictionary
                       5B   04   C0  11E6  3019 	addl2	#4,r11			; pop value from dstack
                                 05  11E9  3020 	rsb				; end of b^
                                     11EA  3021 
                                     11EA  3022 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 127
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     11EA  3023 ;+++
                                     11EA  3024 ;c> defer< -- ( -- ) start a section of code that is to be copied to dictionary
                                     11EA  3025 ;	whenever this word is executed (i.e., { defer< } starts code to be
                                     11EA  3026 ;	executed by all words defined by the word we are now compiling).
                                     11EA  3027 ;	Used in defining words that are to define words.
                                     11EA  3028 ;---
                                     11EA  3029 ;??? This concept is fuzzy.  Work on it.
                                     11EA  3030 	header	i_defer_begin,^\defer<\,vl_compiler
                           FFFFFFFC  11EA       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  11EE       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000006  11EE       	.nchr  nchr, ^\defer<\	; nchr = length( defer< )
                           00000006  11EE       	.if    le, nchr		; nchr <= 0
                                     11EE       	   .ascic \i_defer_begin\	; no auxillary defer<, use principle one
                                     11EE       	.if_false		; else
               3C 72 65 66 65 64 00' 11EE       	  .ascic \defer<\		; use auxillary defer<
                                 06  11EE       
                                     11F5       	.endc			; end if
                                     11F5       i_defer_begin:			; use defer< of word as vl_compiler label
                                     11F5       	
                       89   28   90  11F5  3031 	movb	#op_movc3,(r9)+		; `movc3'
                    89   8F 8F   90  11F8  3032 	movb	#adm_immediate,(r9)+	; I^x immediate mode
                       7A   59   D0  11FC  3033 	movl	r9,-(r10)		; save address to put length in on
                                     11FF  3034 					;   the loop stack
                       89   00   B0  11FF  3035 	movw	#0,(r9)+		; save space for length
                    89   AF 8F   90  1202  3036 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  1206  3037 	movb	#4,(r9)+		; (pc+4)
                    89   69 8F   90  1209  3038 	movb	#adm_def_r9,(r9)+	; (r9)
                       89   31   90  120D  3039 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1210  3040 	movl	r9,-(r10)		; save address to put branch
                                     1213  3041 					;   displacement at on loop stack
                       89   00   B0  1213  3042 	movw	#0,(r9)+		; save space for the displacement
              7A   00000031'EF   D0  1216  3043 	movl	49,-(r10)		; save address of data start on loop
                                     121D  3044 					;   stack to calculate data length
                                 05  121D  3045 	rsb				; end of defer<
                                     121E  3046 
                                     121E  3047 
                                     121E  3048 ;+++
                                     121E  3049 ;c> do -- ( n1 n2 -- ) Program control structure; starts { do ... +loop },
                                     121E  3050 ;	{ do ... downloop }, and { do ... loop }.  Note that all do
                                     121E  3051 ;	loops execute at least once.  `n1' is the limit and `n2' is the
                                     121E  3052 ;	number to start the index at.
                                     121E  3053 ;---
                                     121E  3054 	header	i_do,<do>,vl_compiler	; VAX/VMS debug thinks do is a command
                           FFFFFFFC  121E       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1222       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000002  1222       	.nchr  nchr, ^\do\	; nchr = length( do )
                           00000002  1222       	.if    le, nchr		; nchr <= 0
                                     1222       	   .ascic \i_do\	; no auxillary do, use principle one
                                     1222       	.if_false		; else
                           6F 64 00' 1222       	  .ascic \do\		; use auxillary do
                                 02  1222       
                                     1225       	.endc			; end if
                                     1225       i_do:			; use do of word as vl_compiler label
                                     1225       	
                    89   D0 8F   90  1225  3055 	movb	#op_movl,(r9)+		; `movl'	save index
                    89   8B 8F   90  1229  3056 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   50 8F   90  122D  3057 	movb	#adm_r0,(r9)+		; r0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 128
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                    89   D0 8F   90  1231  3058 	movb	#op_movl,(r9)+		; `movl'	put limit on lstack
                    89   8B 8F   90  1235  3059 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   7A 8F   90  1239  3060 	movb	#adm_adec_r10,(r9)+	; -(r10)
                    89   D0 8F   90  123D  3061 	movb	#op_movl,(r9)+		; `movl'	put index on lstack
                    89   50 8F   90  1241  3062 	movb	#adm_r0,(r9)+		; r0
                    89   7A 8F   90  1245  3063 	movb	#adm_adec_r10,(r9)+	; -(r10)
                       7A   59   D0  1249  3064 	movl	r9,-(r10)		; save address to branch to
                                 05  124C  3065 	rsb				; end of do
                                     124D  3066 
                                     124D  3067 
                                     124D  3068 ;+++
                                     124D  3069 ;c> downloop -- ( -- ) Ends a { do ... downloop }.  Adds -1 to the loop index
                                     124D  3070 ;	and branches to { do } if ((index < 0) and (index > limit)).~~~ inverted?
                                     124D  3071 ;	In other words, { downloop } is like Pascal's
                                     124D  3072 ;	{ for index := start downto finish do }.
                                     124D  3073 ;---
                                     124D  3074 	header	downloop,,vl_compiler
                           FFFFFFFC  124D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1251       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  1251       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1251       	.if    le, nchr		; nchr <= 0
         70 6F 6F 6C 6E 77 6F 64 00' 1251       	   .ascic \downloop\	; no auxillary , use principle one
                                 08  1251       
                                     125A       	.if_false		; else
                                     125A       	  .ascic \\		; use auxillary 
                                     125A       	.endc			; end if
                                     125A       downloop:			; use  of word as vl_compiler label
                                     125A       	
                    89   F1 8F   90  125A  3075 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  125E  3076 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  1262  3077 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8F 8F   90  1265  3078 	movb	#adm_immediate,(r9)+	; immediate mode
              89   FFFFFFFF 8F   D0  1269  3079 	movl	#-1,(r9)+		; -1 is addend
                    89   6A 8F   90  1270  3080 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  1274  3081 	movl	r9,r0			; save address of branch word
                       89   00   B0  1277  3082 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  127A  3083 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  127E  3084 	movw	r1,(r0)			; save displacement
                    89   C0 8F   90  1281  3085 	movb	#op_addl2,(r9)+		; `addl2'	pop index&limit from lstack
                       89   08   90  1285  3086 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  1288  3087 	movb	#adm_r10,(r9)+		; r10
                                 05  128C  3088 	rsb				; end of downloop
                                     128D  3089 
                                     128D  3090 
                                     128D  3091 ;+++
                                     128D  3092 ;c> else -- ( -- ) In control structure { if ... else ... endif } { else }
                                     128D  3093 ;	else ends the true branch and starts the false branch.
                                     128D  3094 ;---
                                     128D  3095 	header	else,,vl_compiler
                           FFFFFFFC  128D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1291       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  1291       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1291       	.if    le, nchr		; nchr <= 0
                     65 73 6C 65 00' 1291       	   .ascic \else\	; no auxillary , use principle one
                                 04  1291       
                                     1296       	.if_false		; else
                                     1296       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 129
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1296       	.endc			; end if
                                     1296       else:			; use  of word as vl_compiler label
                                     1296       	
                       89   31   90  1296  3096 	movb	#op_brw,(r9)+		; branch over false part
                       50   59   D0  1299  3097 	movl	r9,r0			; save address of displacement
                       89   00   B0  129C  3098 	movw	#0,(r9)+		; save space for displacement
                       51   59   D0  129F  3099 	movl	r9,r1			; save address to calculate
                                     12A2  3100 					;   displacement from
                                     12A2  3101 ; make branch to false part (fill in displacement in if)
                  52   59   8A   C3  12A2  3102 	subl3	(r10)+,r9,r2		; calculate displacement
                    00 BA   52   B0  12A6  3103 	movw	r2,@(r10)		; save displacment
                       5A   04   C0  12AA  3104 	addl2	#4,r10			; pop address of displacement off lstack
                       7A   50   D0  12AD  3105 	movl	r0,-(r10)		; save address of displacement
                       7A   51   D0  12B0  3106 	movl	r1,-(r10)		; save address to displace from
                                 05  12B3  3107 	rsb				; end of else
                                     12B4  3108 
                                     12B4  3109 
                                     12B4  3110 ;+++
                                     12B4  3111 ;c> endif -- ( -- ) { endif } ends either of { if } or { else } branches.
                                     12B4  3112 ;	{ if ... else ... endif } and { if ... endif } are both legal.
                                     12B4  3113 ;---
                                     12B4  3114 	header	endif,,vl_compiler
                           FFFFFFFC  12B4       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  12B8       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  12B8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12B8       	.if    le, nchr		; nchr <= 0
                  66 69 64 6E 65 00' 12B8       	   .ascic \endif\	; no auxillary , use principle one
                                 05  12B8       
                                     12BE       	.if_false		; else
                                     12BE       	  .ascic \\		; use auxillary 
                                     12BE       	.endc			; end if
                                     12BE       endif:			; use  of word as vl_compiler label
                                     12BE       	
                  50   59   8A   C3  12BE  3115 	subl3	(r10)+,r9,r0		; calculate displacement
                    00 BA   50   B0  12C2  3116 	movw	r0,@(r10)		; save displacement
                       5A   04   C0  12C6  3117 	addl2	#4,r10			; pop address of displacement off lstack
                                 05  12C9  3118 	rsb				; end of endif
                                     12CA  3119 
                                     12CA  3120 
                                     12CA  3121 ;+++
                                     12CA  3122 ;c> endwhile -- ( -- ) ends a { while ... endwhile }.  Unconditionally branches
                                     12CA  3123 ;	back to { while }.
                                     12CA  3124 ;---
                                     12CA  3125 	header	endwhile,,vl_compiler
                           FFFFFFFC  12CA       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  12CE       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  12CE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12CE       	.if    le, nchr		; nchr <= 0
         65 6C 69 68 77 64 6E 65 00' 12CE       	   .ascic \endwhile\	; no auxillary , use principle one
                                 08  12CE       
                                     12D7       	.if_false		; else
                                     12D7       	  .ascic \\		; use auxillary 
                                     12D7       	.endc			; end if
                                     12D7       endwhile:			; use  of word as vl_compiler label
                                     12D7       	
                       89   31   90  12D7  3126 	movb	#op_brw,(r9)+		; brw back to test
                       50   59   D0  12DA  3127 	movl	r9,r0			; address to put displacement in
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 130
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       89   00   B0  12DD  3128 	movw	#0,(r9)+		; save space for displacement
                  51   59   8A   C3  12E0  3129 	subl3	(r10)+,r9,r1		; displacement to after loop
                    00 BA   51   B0  12E4  3130 	movw	r1,@(r10)		; fill in displacement to after loop
                       5A   04   C0  12E8  3131 	addl2	#4,r10			; pop off address of displacement
                  51   8A   59   C3  12EB  3132 	subl3	r9,(r10)+,r1		; displacement back to beginning
                       60   51   B0  12EF  3133 	movw	r1,(r0)			; save displacement
                                 05  12F2  3134 	rsb				; end of endwhile
                                     12F3  3135 
                                     12F3  3136 
                                     12F3  3137 ;+++
                                     12F3  3138 ;c> if -- ( n -- ) In { if ... else ... endif } or { if ... endif },
                                     12F3  3139 ;	if the top of the stack is true, execute the code following
                                     12F3  3140 ;	the { if } until an { endif } or an { else }.  At an { else } skip to
                                     12F3  3141 ;	the code after the { endif }.  If the top of the stack
                                     12F3  3142 ;	is false, skip to the { endif } or { else }.
                                     12F3  3143 ;	In the { repeat ... if ... again } if the top fo the stack is true the
                                     12F3  3144 ;	code up to the { again } is executed and then a branch back to
                                     12F3  3145 ;	{ repeat } is done.  If the top of the stack is false, execution jumps
                                     12F3  3146 ;	to the code after the { again }.
                                     12F3  3147 ;---
                                     12F3  3148 	header	if,,vl_compiler
                           FFFFFFFC  12F3       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  12F7       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  12F7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12F7       	.if    le, nchr		; nchr <= 0
                           66 69 00' 12F7       	   .ascic \if\	; no auxillary , use principle one
                                 02  12F7       
                                     12FA       	.if_false		; else
                                     12FA       	  .ascic \\		; use auxillary 
                                     12FA       	.endc			; end if
                                     12FA       if:			; use  of word as vl_compiler label
                                     12FA       	
                    89   D5 8F   90  12FA  3149 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  12FE  3150 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  1302  3151 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  1305  3152 	movb	#^x03,(r9)+		; to (pc+3)
                       89   31   90  1308  3153 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  130B  3154 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  130E  3155 	movw	#0,(r9)+		; save space for displacmnent
                       7A   59   D0  1311  3156 	movl	r9,-(r10)		; save address to calculate
                                     1314  3157 					;   displacement from
                                 05  1314  3158 	rsb				; end of if
                                     1315  3159 
                                     1315  3160 
                                     1315  3161 ;+++
                                     1315  3162 ;c> l^ -- ( -- ) Convert next token to number and enclose in dictionary.
                                     1315  3163 ;---
                                     1315  3164 	header	i_l_up,<l^>,vl_compiler
                           FFFFFFFC  1315       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1319       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000002  1319       	.nchr  nchr, ^\l^\	; nchr = length( l^ )
                           00000002  1319       	.if    le, nchr		; nchr <= 0
                                     1319       	   .ascic \i_l_up\	; no auxillary l^, use principle one
                                     1319       	.if_false		; else
                           5E 6C 00' 1319       	  .ascic \l^\		; use auxillary l^
                                 02  1319       
                                     131C       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 131
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     131C       i_l_up:			; use l^ of word as vl_compiler label
                                     131C       	
                       7B   20   D0  131C  3165 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FB58 CF   16  131F  3166 	jsb	token			; get it
                       F592 CF   16  1323  3167 	jsb	number			; try to make it a number
                            8B   D5  1327  3168 	tstl	(r11)+			; Is it a number>
                            01   12  1329  3169 	bneq	10$			; yes
                                 05  132B  3170 	rsb				; no, for now just exit~~~ WTF, no error?
                                     132C  3171 10$:
                       89   8B   D0  132C  3172 	movl	(r11)+,(r9)+		; save long in dictionary
                                 05  132F  3173 	rsb				; end of l^
                                     1330  3174 
                                     1330  3175 
                                     1330  3176 ;+++
                                     1330  3177 ;c> literal -- ( n -- ) convert top of stack to a literal in current word.
                                     1330  3178 ;---
                                     1330  3179 	header	literal,,vl_compiler
                           FFFFFFFC  1330       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1334       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  1334       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1334       	.if    le, nchr		; nchr <= 0
            6C 61 72 65 74 69 6C 00' 1334       	   .ascic \literal\	; no auxillary , use principle one
                                 07  1334       
                                     133C       	.if_false		; else
                                     133C       	  .ascic \\		; use auxillary 
                                     133C       	.endc			; end if
                                     133C       literal:			; use  of word as vl_compiler label
                                     133C       	
                    89   D0 8F   90  133C  3180 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  1340  3181 	movb	#adm_immediate,(r9)+	; immediate mode
                       89   8B   D0  1344  3182 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                    89   7B 8F   90  1347  3183 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                 05  134B  3184 	rsb				; end of literal
                                     134C  3185 
                                     134C  3186 
                                     134C  3187 ;+++
                                     134C  3188 ;c> loop -- ( -- ) Ends a { do ... loop }.  Adds 1 to loop index and branches
                                     134C  3189 ;	to { do } if ((index >= 0) and (index < limit)).  In other words,
                                     134C  3190 ;	{ loop } is like Pascal's { for index := start to finish do ... }.
                                     134C  3191 ;---
                                     134C  3192 	header	i_loop,<loop>,vl_compiler ; VAX/VMS debuffer thinks loop is a a command
                           FFFFFFFC  134C       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1350       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000004  1350       	.nchr  nchr, ^\loop\	; nchr = length( loop )
                           00000004  1350       	.if    le, nchr		; nchr <= 0
                                     1350       	   .ascic \i_loop\	; no auxillary loop, use principle one
                                     1350       	.if_false		; else
                     70 6F 6F 6C 00' 1350       	  .ascic \loop\		; use auxillary loop
                                 04  1350       
                                     1355       	.endc			; end if
                                     1355       i_loop:			; use loop of word as vl_compiler label
                                     1355       	
                    89   F1 8F   90  1355  3193 	movb	#op_acbl,(r9)+		  ; `acbl'
                    89   AA 8F   90  1359  3194 	movb	#adm_b_dis_r10,(r9)+	  ; b^(r10)
                       89   04   90  135D  3195 	movb	#4,(r9)+		  ; 4 byte displacement for previous adm
                       89   01   90  1360  3196 	movb	#^x01,(r9)+		  ; s^#1
                    89   6A 8F   90  1363  3197 	movb	#adm_def_r10,(r9)+	  ; (r10)
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 132
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                       50   59   D0  1367  3198 	movl	r9,r0			  ; save address of branch word
                       89   00   B0  136A  3199 	movw	#0,(r9)+		  ; save space for branch displacement
                  51   8A   59   C3  136D  3200 	subl3	r9,(r10)+,r1		  ; calculate displacement
                       60   51   B0  1371  3201 	movw	r1,(r0)			  ; save displacement
                    89   C0 8F   90  1374  3202 	movb	#op_addl2,(r9)+		  ; `addl2'	pop index&limit from lstack
                       89   08   90  1378  3203 	movb	#^x08,(r9)+		  ; s^#8
                    89   5A 8F   90  137B  3204 	movb	#adm_r10,(r9)+		  ; r10
                                 05  137F  3205 	rsb				  ; end of loop
                                     1380  3206 
                                     1380  3207 
                                     1380  3208 ;+++
                                     1380  3209 ;c> recurse -- ( -- ) Compile a jsb to the word that is currently being defined,
                                     1380  3210 ;	allowing recursion.
                                     1380  3211 ;---
                                     1380  3212 	header	recurse,,vl_compiler
                           FFFFFFFC  1380       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  1384       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  1384       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1384       	.if    le, nchr		; nchr <= 0
            65 73 72 75 63 65 72 00' 1384       	   .ascic \recurse\	; no auxillary , use principle one
                                 07  1384       
                                     138C       	.if_false		; else
                                     138C       	  .ascic \\		; use auxillary 
                                     138C       	.endc			; end if
                                     138C       recurse:			; use  of word as vl_compiler label
                                     138C       	
              7B   00001D37'FF   D0  138C  3213 	movl	@v_context,-(r11)	; get address of current word
                       EF4B CF   16  1393  3214 	jsb	cfa			; get the code field address
                       EFA4 CF   16  1397  3215 	jsb	i_compile_jsb		; compile it into current word
                                 05  139B  3216 	rsb				; end of recurse
                                     139C  3217 
                                     139C  3218 
                                     139C  3219 ;+++
                                     139C  3220 ;c> repeat -- ( -- ) Start { repeat ... until } and { repeat ... if ... again }
                                     139C  3221 ;	loops.
                                     139C  3222 ;---
                                     139C  3223 	header	repeat,,vl_compiler
                           FFFFFFFC  139C       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  13A0       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  13A0       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13A0       	.if    le, nchr		; nchr <= 0
               74 61 65 70 65 72 00' 13A0       	   .ascic \repeat\	; no auxillary , use principle one
                                 06  13A0       
                                     13A7       	.if_false		; else
                                     13A7       	  .ascic \\		; use auxillary 
                                     13A7       	.endc			; end if
                                     13A7       repeat:			; use  of word as vl_compiler label
                                     13A7       	
                       7A   59   D0  13A7  3224 	movl	r9,-(r10)		; save address to branch to
                                 05  13AA  3225 	rsb				; end of repeat
                                     13AB  3226 
                                     13AB  3227 
                                     13AB  3228 ;+++
                                     13AB  3229 ;c> w^ -- ( -- ) Convert next token to number, enclose low 16 bits in dictionary.
                                     13AB  3230 ;	This is used with the assembler, mainly, which is why it is w^ instead
                                     13AB  3231 ;	of  s^.
                                     13AB  3232 ;---
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 133
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     13AB  3233 	header	i_s_up,<w^>,vl_compiler
                           FFFFFFFC  13AB       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  13AF       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000002  13AF       	.nchr  nchr, ^\w^\	; nchr = length( w^ )
                           00000002  13AF       	.if    le, nchr		; nchr <= 0
                                     13AF       	   .ascic \i_s_up\	; no auxillary w^, use principle one
                                     13AF       	.if_false		; else
                           5E 77 00' 13AF       	  .ascic \w^\		; use auxillary w^
                                 02  13AF       
                                     13B2       	.endc			; end if
                                     13B2       i_s_up:			; use w^ of word as vl_compiler label
                                     13B2       	
                       7B   20   D0  13B2  3234 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FAC2 CF   16  13B5  3235 	jsb	token			; get it
                       F4FC CF   16  13B9  3236 	jsb	number			; try to make it a number
                            8B   D5  13BD  3237 	tstl	(r11)+			; Is it a number?
                            01   12  13BF  3238 	bneq	10$			; yes
                                 05  13C1  3239 	rsb				; no, for now just exit~~~ WTF, no error?
                                     13C2  3240 10$:
                       89   6B   B0  13C2  3241 	movw	(r11),(r9)+		; save word in dictionary
                       5B   04   C0  13C5  3242 	addl2	#4,r11			; pop value from dstack
                                 05  13C8  3243 	rsb				; end of w^
                                     13C9  3244 
                                     13C9  3245 
                                     13C9  3246 ;+++
                                     13C9  3247 ;c> until -- ( f -- ) End a { repeat ... until } loop.  If top of stack is
                                     13C9  3248 ;	false, branch back to the { repeat }, else fall out of loop.
                                     13C9  3249 ;---
                                     13C9  3250 	header	until,,v1_compiler
                           FFFFFFFC' 13C9       	.long	v1_compiler		; back link to the previous word in this v1_compiler
                           FFFFFFFC  13CD       	v1_compiler = -4		; where to link the next word to in this v1_compiler
                           00000000  13CD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13CD       	.if    le, nchr		; nchr <= 0
                  6C 69 74 6E 75 00' 13CD       	   .ascic \until\	; no auxillary , use principle one
                                 05  13CD       
                                     13D3       	.if_false		; else
                                     13D3       	  .ascic \\		; use auxillary 
                                     13D3       	.endc			; end if
                                     13D3       until:			; use  of word as v1_compiler label
                                     13D3       	
                    89   D5 8F   90  13D3  3251 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  13D7  3252 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  13DB  3253 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  13DE  3254 	movb	#3,(r9)+		; (pc+3)
                       89   31   90  13E1  3255 	movb	#op_brw,(r9)+		; `brw'
                       50   59   D0  13E4  3256 	movl	r9,r0			; save address of displacement
                       89   00   B0  13E7  3257 	movw	#0,(r9)+		; save space for displacement
                  51   8A   59   C3  13EA  3258 	subl3	r9,(r10)+,r1		; calcualte negative displacement
                       6A   51   B0  13EE  3259 	movw	r1,(r10)		; save negative displacement
                                 05  13F1  3260 	rsb				; end of until
                                     13F2  3261 
                                     13F2  3262 
                                     13F2  3263 ;+++
                                     13F2  3264 ;c> while -- ( f -- ) Start a { while ... endwhile } loop.  If top of stack
                                     13F2  3265 ;	is true, execute code to { endwhile }, which loops back to { while }.
                                     13F2  3266 ;	If false, skip to after the { endwhile }.
                                     13F2  3267 ;---
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 134
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     13F2  3268 	header	while,,vl_compiler
                           FFFFFFFC  13F2       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  13F6       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000000  13F6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13F6       	.if    le, nchr		; nchr <= 0
                  65 6C 69 68 77 00' 13F6       	   .ascic \while\	; no auxillary , use principle one
                                 05  13F6       
                                     13FC       	.if_false		; else
                                     13FC       	  .ascic \\		; use auxillary 
                                     13FC       	.endc			; end if
                                     13FC       while:			; use  of word as vl_compiler label
                                     13FC       	
                       7A   59   D0  13FC  3269 	movl	r9,-(r10)		; save address to branch to at endwhile
                    89   D5 8F   90  13FF  3270 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  1403  3271 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  1407  3272 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  140A  3273 	movb	#3,(r9)+		; over brw false_part
                       89   31   90  140D  3274 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1410  3275 	movl	r9,-(r10)		; save address of displacement to
                                     1413  3276 					;   statements after loop
                       89   00   B0  1413  3277 	movw	#0,(r9)+		; save space for displacement
                       7A   59   D0  1416  3278 	movl	r9,-(r10)		; address to make diplacement to
                                     1419  3279 					;   after loop from~~~ awkward phrasing
                                 05  1419  3280 	rsb				; end of while
                                     141A  3281 
                                     141A  3282 
                                     141A  3283 ;+++
                                     141A  3284 ;c> [ -- ( -- ) leave compile mode without terminating definition.
                                     141A  3285 ;	Must be followed by { ] }.
                                     141A  3286 ;---
                                     141A  3287 	header	i_left_brack,<[>,vl_compiler
                           FFFFFFFC  141A       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  141E       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000001  141E       	.nchr  nchr, ^\[\	; nchr = length( [ )
                           00000001  141E       	.if    le, nchr		; nchr <= 0
                                     141E       	   .ascic \i_left_brack\	; no auxillary [, use principle one
                                     141E       	.if_false		; else
                              5B 00' 141E       	  .ascic \[\		; use auxillary [
                                 01  141E       
                                     1420       	.endc			; end if
                                     1420       i_left_brack:			; use [ of word as vl_compiler label
                                     1420       	
              00001D4D'EF   00   90  1420  3288 	movb	#c_false,v_mode
                                 05  1427  3289 	rsb				; end of [
                                     1428  3290 
                                     1428  3291 
                                     1428  3292 ;+++
                                     1428  3293 ;c> [ascii] -- ( -- ) compile ascii value of 1st char of next token into word.
                                     1428  3294 ;---
                                     1428  3295 	header	i_compile_ascii,<[ascii]>,vl_compiler
                           FFFFFFFC  1428       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           FFFFFFFC  142C       	vl_compiler = -4		; where to link the next word to in this vl_compiler
                           00000007  142C       	.nchr  nchr, ^\[ascii]\	; nchr = length( [ascii] )
                           00000007  142C       	.if    le, nchr		; nchr <= 0
                                     142C       	   .ascic \i_compile_ascii\	; no auxillary [ascii], use principle one
                                     142C       	.if_false		; else
            5D 69 69 63 73 61 5B 00' 142C       	  .ascic \[ascii]\		; use auxillary [ascii]
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 135
V1.01                           cCompiler Built-ins                      10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                 07  142C       
                                     1434       	.endc			; end if
                                     1434       i_compile_ascii:			; use [ascii] of word as vl_compiler label
                                     1434       	
                       7B   20   D0  1434  3296 	movl	#c_blank,-(r11)		; set up for blank separated token
                       FA40 CF   16  1437  3297 	jsb	token			; get it
                    7B   01 A9   9A  143B  3298 	movzbl	1(r9),-(r11)		; put ascii value of 1st char of token on stack
                       FEF9 CF   16  143F  3299 	jsb	literal			; compile it into the dictionary
                                 05  1443  3300 	rsb				; end of ascii
                                     1444  3301 
                                     1444  3302 
                                     1444  3303 _compiler_end:
                                     1444  3304 	newpage <Enter VTIL>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 136
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1444       	.sbttl	Enter VTIL
                                     1444       	
                                     1444  3305 ;*******************************************************************************
                                     1444  3306 ;
                                     1444  3307 ; Enter VTIL -- Set up condition handler and call main program.
                                     1444  3308 ;
                                     1444  3309 ;*******************************************************************************
                                     1444  3310 
                                     1444  3311 
                                     1444  3312 ;+++
                                     1444  3313 ;s> vtil -- entry procedure of vtil
                                     1444  3314 ;---
                               0FC0  1444  3315 	.entry	vtil,^m<r6,r7,r8,r9,r10,r11>
                                     1446  3316     .if defined ca_trapping
                                     1446  3317         .print ; Trapping is enabled

              6D   0000150D'EF   DE  1446  3318 	moval	s_trap,(fp)		; set up condition handler
                                     144D  3319     .if_false
                                     144D  3320         .print ; Trapping is not enabled
                                     144D  3321     .endc
                                     144D  3322     .if defined ca_controlc
                                     144D  3323         .print ; Control/C Trapping is enabled

                                     144D  3324 ; If a terminal, set up control/c trap
                                     144D  3325 	$assign_s chan=v_input_chan,-	; connect to sys$command
                                     144D  3326 		devnam=v_input_name
                                     144D       		.GLOBL	SYS$ASSIGN
                            00   DD  144D       		PUSHL	#0
                                     144F       		$ASNPUSH 0,#0
                           00000000  144F       		$$T1 = 0
                                     144F       		.IF IDN,<0>,<0>
                                     144F       		.IF IDN,<#0>,<#0>
                           00000001  144F       		$$T1 = 1
                                     144F       		.ENDC
                                     144F       		.ENDC
                           00000001  144F       		.IF NE $$T1
                            7E   7C  144F       		CLRQ	-(SP)
                                     1451       		.IFF
                                     1451       		$PUSHADR 0,CONTEXT=Q
                                     1451       		PUSHL	#0
                                     1451       		.ENDC
                                     1451       	
                                     1451       		$PUSHADR v_input_chan,CONTEXT=W
                                     1451       		.IF	IDN,0,v_input_chan
                                     1451       		PUSHL	#0
                                     1451       		.IFF
                           00000000  1451       		.IF EQ	12-12
                           00000000  1451       		.IF NE	12-12
                                     1451       		PUSHAW	v_input_chan
                                     1451       		.MEXIT
                                     1451       		.ENDC
                                     1451       		.ENDC
                           000000CF  1451       		.NTYPE	$$$ADR, v_input_chan
                           000000C0  1451       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  1451       		.IF GT	$$$ADR - ^XFF
                                     1451       		PUSHAW	v_input_chan
                                     1451       		.MEXIT
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 137
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1451       		.ENDC
                           00000040  1451       		.IF EQ	$$$ADR - ^X80
                                     1451       		PUSHAW	v_input_chan
                                     1451       		.MEXIT
                                     1451       		.ENDC
                           00000050  1451       		.IF EQ	$$$ADR - ^X70
                                     1451       		PUSHAW	v_input_chan
                                     1451       		.MEXIT
                                     1451       		.ENDC
                   00001D11'EF   9F  1451       		PUSHAB	v_input_chan
                                     1457       		.ENDC
                                     1457       	
                                     1457       		$PUSHADR v_input_name,CONTEXT=Q
                                     1457       		.IF	IDN,0,v_input_name
                                     1457       		PUSHL	#0
                                     1457       		.IFF
                           00000000  1457       		.IF EQ	12-12
                           00000000  1457       		.IF NE	12-12
                                     1457       		PUSHAQ	v_input_name
                                     1457       		.MEXIT
                                     1457       		.ENDC
                                     1457       		.ENDC
                           000000CF  1457       		.NTYPE	$$$ADR, v_input_name
                           000000C0  1457       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  1457       		.IF GT	$$$ADR - ^XFF
                                     1457       		PUSHAQ	v_input_name
                                     1457       		.MEXIT
                                     1457       		.ENDC
                           00000040  1457       		.IF EQ	$$$ADR - ^X80
                                     1457       		PUSHAQ	v_input_name
                                     1457       		.MEXIT
                                     1457       		.ENDC
                           00000050  1457       		.IF EQ	$$$ADR - ^X70
                                     1457       		PUSHAQ	v_input_name
                                     1457       		.MEXIT
                                     1457       		.ENDC
                   00001CFE'EF   9F  1457       		PUSHAB	v_input_name
                                     145D       		.ENDC
                                     145D       	
              00000000'GF   05   FB  145D       		CALLS	#5,G^SYS$ASSIGN
                                     1464       	
                         03 50   E8  1464  3327 	blbs	r0,1$			; exit on error~~~Success, so branch over error exit
                          0065   31  1467  3328 	brw	vtil_exit		; exit vtil
                                     146A  3329 1$:
                                     146A  3330 	$getchn_s chan=v_input_chan,-	; find out if it is a terminal
                                     146A  3331 		prilen=v_getchn_ret_len,- ; where to put length
                                     146A  3332 		pribuf=v_getchn_in_buf  ; where to find input buffer
                                     146A       		.GLOBL	SYS$GETCHN
                                     146A       		$PUSHADR 0,CONTEXT=Q
                                     146A       		.IF	IDN,0,0
                            00   DD  146A       		PUSHL	#0
                                     146C       		.IFF
                                     146C       		.IF EQ	1-1
                                     146C       		.IF NE	1-1
                                     146C       		PUSHAQ	0
                                     146C       		.MEXIT
                                     146C       		.ENDC
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 138
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     146C       		.ENDC
                                     146C       		.NTYPE	$$$ADR, 0
                                     146C       $$$ADR	=	$$$ADR & ^XFFF0
                                     146C       		.IF GT	$$$ADR - ^XFF
                                     146C       		PUSHAQ	0
                                     146C       		.MEXIT
                                     146C       		.ENDC
                                     146C       		.IF EQ	$$$ADR - ^X80
                                     146C       		PUSHAQ	0
                                     146C       		.MEXIT
                                     146C       		.ENDC
                                     146C       		.IF EQ	$$$ADR - ^X70
                                     146C       		PUSHAQ	0
                                     146C       		.MEXIT
                                     146C       		.ENDC
                                     146C       		PUSHAB	0
                                     146C       		.ENDC
                                     146C       	
                                     146C       		$PUSHADR 0,CONTEXT=W
                                     146C       		.IF	IDN,0,0
                            00   DD  146C       		PUSHL	#0
                                     146E       		.IFF
                                     146E       		.IF EQ	1-1
                                     146E       		.IF NE	1-1
                                     146E       		PUSHAW	0
                                     146E       		.MEXIT
                                     146E       		.ENDC
                                     146E       		.ENDC
                                     146E       		.NTYPE	$$$ADR, 0
                                     146E       $$$ADR	=	$$$ADR & ^XFFF0
                                     146E       		.IF GT	$$$ADR - ^XFF
                                     146E       		PUSHAW	0
                                     146E       		.MEXIT
                                     146E       		.ENDC
                                     146E       		.IF EQ	$$$ADR - ^X80
                                     146E       		PUSHAW	0
                                     146E       		.MEXIT
                                     146E       		.ENDC
                                     146E       		.IF EQ	$$$ADR - ^X70
                                     146E       		PUSHAW	0
                                     146E       		.MEXIT
                                     146E       		.ENDC
                                     146E       		PUSHAB	0
                                     146E       		.ENDC
                                     146E       	
                                     146E       		$PUSHADR v_getchn_in_buf,CONTEXT=Q
                                     146E       		.IF	IDN,0,v_getchn_in_buf
                                     146E       		PUSHL	#0
                                     146E       		.IFF
                           00000000  146E       		.IF EQ	15-15
                           00000000  146E       		.IF NE	15-15
                                     146E       		PUSHAQ	v_getchn_in_buf
                                     146E       		.MEXIT
                                     146E       		.ENDC
                                     146E       		.ENDC
                           000000CF  146E       		.NTYPE	$$$ADR, v_getchn_in_buf
                           000000C0  146E       $$$ADR	=	$$$ADR & ^XFFF0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 139
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           FFFFFFC1  146E       		.IF GT	$$$ADR - ^XFF
                                     146E       		PUSHAQ	v_getchn_in_buf
                                     146E       		.MEXIT
                                     146E       		.ENDC
                           00000040  146E       		.IF EQ	$$$ADR - ^X80
                                     146E       		PUSHAQ	v_getchn_in_buf
                                     146E       		.MEXIT
                                     146E       		.ENDC
                           00000050  146E       		.IF EQ	$$$ADR - ^X70
                                     146E       		PUSHAQ	v_getchn_in_buf
                                     146E       		.MEXIT
                                     146E       		.ENDC
                   00001D17'EF   9F  146E       		PUSHAB	v_getchn_in_buf
                                     1474       		.ENDC
                                     1474       	
                                     1474       		$PUSHADR v_getchn_ret_len,CONTEXT=W
                                     1474       		.IF	IDN,0,v_getchn_ret_len
                                     1474       		PUSHL	#0
                                     1474       		.IFF
                           00000000  1474       		.IF EQ	16-16
                           00000000  1474       		.IF NE	16-16
                                     1474       		PUSHAW	v_getchn_ret_len
                                     1474       		.MEXIT
                                     1474       		.ENDC
                                     1474       		.ENDC
                           000000CF  1474       		.NTYPE	$$$ADR, v_getchn_ret_len
                           000000C0  1474       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  1474       		.IF GT	$$$ADR - ^XFF
                                     1474       		PUSHAW	v_getchn_ret_len
                                     1474       		.MEXIT
                                     1474       		.ENDC
                           00000040  1474       		.IF EQ	$$$ADR - ^X80
                                     1474       		PUSHAW	v_getchn_ret_len
                                     1474       		.MEXIT
                                     1474       		.ENDC
                           00000050  1474       		.IF EQ	$$$ADR - ^X70
                                     1474       		PUSHAW	v_getchn_ret_len
                                     1474       		.MEXIT
                                     1474       		.ENDC
                   00001D13'EF   9F  1474       		PUSHAB	v_getchn_ret_len
                                     147A       		.ENDC
                                     147A       	
              7E   00001D11'EF   3C  147A       		MOVZWL	v_input_chan,-(SP)
              00000000'GF   05   FB  1481       		CALLS	#5,G^SYS$GETCHN
                                     1488       	
                                     1488  3333 
           00001D23'EF   00'8F   91  1488  3334 	cmpb	#dc$_term,v_getchn_buf+4 ; is it a terminal?
                            2D   12  1490  3335 	bneq	5$			; not a terminal, so don't enable ctr-c
                                     1492  3336 ; enable control-c trapping
                                     1492  3337 	.show	   meb,me
                                     1492  3338 	$qio_s	chan=v_input_chan,-
                                     1492  3339 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     1492  3340 		p1=enable_ctrlc,-
                                     1492  3341 		p3=#3
                                     1492       		.GLOBL	SYS$QIO
                                     1492       		$PUSHTWO #0,#0
                           00000000  1492       		$$T1 = 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 140
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1492       		.IF	IDN,<#0>,<#0>
                                     1492       		.IF	IDN,<#0>,<#0>
                           00000001  1492       		$$T1 = 1
                                     1492       		.ENDC
                                     1492       		.ENDC
                           00000001  1492       		.IF	NE	$$T1
                            7E   7C  1492       		CLRQ	-(SP)
                                     1494       		.IFF
                                     1494       		PUSHL	#0
                                     1494       		PUSHL	#0
                                     1494       		.ENDC
                                     1494       	
                                     1494       		$PUSHTWO #0,#3
                           00000000  1494       		$$T1 = 0
                                     1494       		.IF	IDN,<#0>,<#0>
                                     1494       		.IF	IDN,<#0>,<#3>
                                     1494       		$$T1 = 1
                                     1494       		.ENDC
                                     1494       		.ENDC
                           00000000  1494       		.IF	NE	$$T1
                                     1494       		CLRQ	-(SP)
                                     1494       		.IFF
                            00   DD  1494       		PUSHL	#0
                            03   DD  1496       		PUSHL	#3
                                     1498       		.ENDC
                                     1498       	
                            00   DD  1498       		PUSHL	#0
                                     149A       		$PUSHADR enable_ctrlc
                                     149A       		.IF	IDN,0,enable_ctrlc
                                     149A       		PUSHL	#0
                                     149A       		.IFF
                           00000000  149A       		.IF EQ	12-12
                           00000000  149A       		.IF NE	12-12
                                     149A       		PUSHAL	enable_ctrlc
                                     149A       		.MEXIT
                                     149A       		.ENDC
                                     149A       		.ENDC
                           000000EF  149A       		.NTYPE	$$$ADR, enable_ctrlc
                           000000E0  149A       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFE1  149A       		.IF GT	$$$ADR - ^XFF
                                     149A       		PUSHAL	enable_ctrlc
                                     149A       		.MEXIT
                                     149A       		.ENDC
                           00000060  149A       		.IF EQ	$$$ADR - ^X80
                                     149A       		PUSHAL	enable_ctrlc
                                     149A       		.MEXIT
                                     149A       		.ENDC
                           00000070  149A       		.IF EQ	$$$ADR - ^X70
                                     149A       		PUSHAL	enable_ctrlc
                                     149A       		.MEXIT
                                     149A       		.ENDC
                   000014D9'EF   9F  149A       		PUSHAB	enable_ctrlc
                                     14A0       		.ENDC
                                     14A0       	
                                     14A0       		$QIOPUSH #0,0
                           00000000  14A0       		$$T1 = 0
                                     14A0       		.IF	IDN,<#0>,<#0>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 141
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     14A0       		.IF	IDN,<0>,<0>
                           00000001  14A0       		$$T1 = 1
                                     14A0       		.ENDC
                                     14A0       		.ENDC
                           00000001  14A0       		.IF	NE $$T1
                            7E   7C  14A0       		CLRQ	-(SP)
                                     14A2       		.IFF
                                     14A2       		PUSHL	#0
                                     14A2       		$PUSHADR 0
                                     14A2       		.ENDC
                                     14A2       	
                                     14A2       		$PUSHADR 0,CONTEXT=Q
                                     14A2       		.IF	IDN,0,0
                            00   DD  14A2       		PUSHL	#0
                                     14A4       		.IFF
                                     14A4       		.IF EQ	1-1
                                     14A4       		.IF NE	1-1
                                     14A4       		PUSHAQ	0
                                     14A4       		.MEXIT
                                     14A4       		.ENDC
                                     14A4       		.ENDC
                                     14A4       		.NTYPE	$$$ADR, 0
                                     14A4       $$$ADR	=	$$$ADR & ^XFFF0
                                     14A4       		.IF GT	$$$ADR - ^XFF
                                     14A4       		PUSHAQ	0
                                     14A4       		.MEXIT
                                     14A4       		.ENDC
                                     14A4       		.IF EQ	$$$ADR - ^X80
                                     14A4       		PUSHAQ	0
                                     14A4       		.MEXIT
                                     14A4       		.ENDC
                                     14A4       		.IF EQ	$$$ADR - ^X70
                                     14A4       		PUSHAQ	0
                                     14A4       		.MEXIT
                                     14A4       		.ENDC
                                     14A4       		PUSHAB	0
                                     14A4       		.ENDC
                                     14A4       	
                  7E   0000'8F   3C  14A4       		MOVZWL	#IO$_SETMODE!IO$M_CTRLCAST,-(SP)
              7E   00001D11'EF   3C  14A9       		MOVZWL	v_input_chan,-(SP)
                            00   DD  14B0       		PUSHL	#0
              00000000'GF   0C   FB  14B2       		CALLS	#12,G^SYS$QIO
                                     14B9       	
                         03 50   E8  14B9  3342 	blbs	r0,6$			; no error, go on, don't deassign channel
                          0010   31  14BC  3343 	brw	vtil_exit
                                     14BF  3344 5$:
                                     14BF  3345 ;	$dassign_s chan=v_input_chan    ; channel not a terminal, deassign it.
                                     14BF  3346 6$:
                                     14BF  3347     .if_false
                                     14BF  3348         print ; Control/c trapping not enabled
                                     14BF  3349     .endc
                                     14BF  3350 
              00001577'EF   00   FB  14BF  3351 	calls	#0,s_cold_start		; call subroutine to start from scratch
                                     14C6  3352 ; If we have returned from cold start there was an error caught by the
                                     14C6  3353 ; trap subroutine and we want to a warm start.
                                     14C6  3354 10$:
              000015BF'EF   00   FB  14C6  3355 	calls	#0,s_warm_start		; call subroutine to do warm start.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 142
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     14CD  3356 ; If we have returned from warm start there was an error caught by the
                                     14CD  3357 ; trap subroutine and we want to do another warm start.
                            F7   11  14CD  3358 	brb	10$
                                     14CF  3359 
                                     14CF  3360 ;+++
                                     14CF  3361 ;r> vtil_exit -- exit if errors in setting up control-c ast or traps
                                     14CF  3362 ;---
                                     14CF  3363 vtil_exit:
                            50   DD  14CF  3364 	pushl	r0
              00000000'GF   01   FB  14D1  3365 	calls	#1,g^lib$signal
                                 04  14D8  3366 	ret				; this is return from main program.
                                     14D9  3367 
                                     14D9  3368 
                                     14D9  3369 ;+++
                                     14D9  3370 ;s> enable_ctrlc -- enable controlc trapping.
                                     14D9  3371 ;---
                               0000  14D9  3372 	.entry	enable_ctrlc,^m<>
                                     14DB  3373 ; reenable ctrlc handler...
                                     14DB  3374 	$qio_s	chan=v_input_chan,-
                                     14DB  3375 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     14DB  3376 		p1=enable_ctrlc,-
                                     14DB  3377 		p3=#3
                                     14DB       		.GLOBL	SYS$QIO
                                     14DB       		$PUSHTWO #0,#0
                           00000000  14DB       		$$T1 = 0
                                     14DB       		.IF	IDN,<#0>,<#0>
                                     14DB       		.IF	IDN,<#0>,<#0>
                           00000001  14DB       		$$T1 = 1
                                     14DB       		.ENDC
                                     14DB       		.ENDC
                           00000001  14DB       		.IF	NE	$$T1
                            7E   7C  14DB       		CLRQ	-(SP)
                                     14DD       		.IFF
                                     14DD       		PUSHL	#0
                                     14DD       		PUSHL	#0
                                     14DD       		.ENDC
                                     14DD       	
                                     14DD       		$PUSHTWO #0,#3
                           00000000  14DD       		$$T1 = 0
                                     14DD       		.IF	IDN,<#0>,<#0>
                                     14DD       		.IF	IDN,<#0>,<#3>
                                     14DD       		$$T1 = 1
                                     14DD       		.ENDC
                                     14DD       		.ENDC
                           00000000  14DD       		.IF	NE	$$T1
                                     14DD       		CLRQ	-(SP)
                                     14DD       		.IFF
                            00   DD  14DD       		PUSHL	#0
                            03   DD  14DF       		PUSHL	#3
                                     14E1       		.ENDC
                                     14E1       	
                            00   DD  14E1       		PUSHL	#0
                                     14E3       		$PUSHADR enable_ctrlc
                                     14E3       		.IF	IDN,0,enable_ctrlc
                                     14E3       		PUSHL	#0
                                     14E3       		.IFF
                           00000000  14E3       		.IF EQ	12-12
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 143
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000000  14E3       		.IF NE	12-12
                                     14E3       		PUSHAL	enable_ctrlc
                                     14E3       		.MEXIT
                                     14E3       		.ENDC
                                     14E3       		.ENDC
                           000000AF  14E3       		.NTYPE	$$$ADR, enable_ctrlc
                           000000A0  14E3       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFA1  14E3       		.IF GT	$$$ADR - ^XFF
                                     14E3       		PUSHAL	enable_ctrlc
                                     14E3       		.MEXIT
                                     14E3       		.ENDC
                           00000020  14E3       		.IF EQ	$$$ADR - ^X80
                                     14E3       		PUSHAL	enable_ctrlc
                                     14E3       		.MEXIT
                                     14E3       		.ENDC
                           00000030  14E3       		.IF EQ	$$$ADR - ^X70
                                     14E3       		PUSHAL	enable_ctrlc
                                     14E3       		.MEXIT
                                     14E3       		.ENDC
                         F3 AF   9F  14E3       		PUSHAB	enable_ctrlc
                                     14E6       		.ENDC
                                     14E6       	
                                     14E6       		$QIOPUSH #0,0
                           00000000  14E6       		$$T1 = 0
                                     14E6       		.IF	IDN,<#0>,<#0>
                                     14E6       		.IF	IDN,<0>,<0>
                           00000001  14E6       		$$T1 = 1
                                     14E6       		.ENDC
                                     14E6       		.ENDC
                           00000001  14E6       		.IF	NE $$T1
                            7E   7C  14E6       		CLRQ	-(SP)
                                     14E8       		.IFF
                                     14E8       		PUSHL	#0
                                     14E8       		$PUSHADR 0
                                     14E8       		.ENDC
                                     14E8       	
                                     14E8       		$PUSHADR 0,CONTEXT=Q
                                     14E8       		.IF	IDN,0,0
                            00   DD  14E8       		PUSHL	#0
                                     14EA       		.IFF
                                     14EA       		.IF EQ	1-1
                                     14EA       		.IF NE	1-1
                                     14EA       		PUSHAQ	0
                                     14EA       		.MEXIT
                                     14EA       		.ENDC
                                     14EA       		.ENDC
                                     14EA       		.NTYPE	$$$ADR, 0
                                     14EA       $$$ADR	=	$$$ADR & ^XFFF0
                                     14EA       		.IF GT	$$$ADR - ^XFF
                                     14EA       		PUSHAQ	0
                                     14EA       		.MEXIT
                                     14EA       		.ENDC
                                     14EA       		.IF EQ	$$$ADR - ^X80
                                     14EA       		PUSHAQ	0
                                     14EA       		.MEXIT
                                     14EA       		.ENDC
                                     14EA       		.IF EQ	$$$ADR - ^X70
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 144
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     14EA       		PUSHAQ	0
                                     14EA       		.MEXIT
                                     14EA       		.ENDC
                                     14EA       		PUSHAB	0
                                     14EA       		.ENDC
                                     14EA       	
                  7E   0000'8F   3C  14EA       		MOVZWL	#IO$_SETMODE!IO$M_CTRLCAST,-(SP)
              7E   00001D11'EF   3C  14EF       		MOVZWL	v_input_chan,-(SP)
                            00   DD  14F6       		PUSHL	#0
              00000000'GF   0C   FB  14F8       		CALLS	#12,G^SYS$QIO
                                     14FF       	
                   00000000'8F   DD  14FF  3378 	pushl	#vtil_ctrlc
              00000000'GF   01   FB  1505  3379 	calls	#1,g^lib$signal		; this should NOT return!
                                 05  150C  3380 	rsb				; end of enable_ctrlc
                                     150D  3381 
                                     150D  3382 
                                     150D  3383 ;+++
                                     150D  3384 ;s> trap --  trap routine.  Don't exit VTIL unless maximum number of errors
                                     150D  3385 ;	has been exceeded.
                                     150D  3386 ;---
                               0000  150D  3387 	.entry	s_trap,^m<>
                                     150F  3388 ; output some sort of error message
                    51   04 AC   D0  150F  3389 	movl	chf$l_sigarglst(ap),r1
                            01   DD  1513  3390 	pushl	#1
                         04 A1   DD  1515  3391 	pushl	chf$l_sig_name(r1)
                                     1518  3392 	$putmsg_s msgvec=(r1)
                                     1518       		.GLOBL	SYS$PUTMSG
                            00   DD  1518       		PUSHL	#0
                                     151A       		$PUSHADR 0,CONTEXT=Q
                                     151A       		.IF	IDN,0,0
                            00   DD  151A       		PUSHL	#0
                                     151C       		.IFF
                                     151C       		.IF EQ	1-1
                                     151C       		.IF NE	1-1
                                     151C       		PUSHAQ	0
                                     151C       		.MEXIT
                                     151C       		.ENDC
                                     151C       		.ENDC
                                     151C       		.NTYPE	$$$ADR, 0
                                     151C       $$$ADR	=	$$$ADR & ^XFFF0
                                     151C       		.IF GT	$$$ADR - ^XFF
                                     151C       		PUSHAQ	0
                                     151C       		.MEXIT
                                     151C       		.ENDC
                                     151C       		.IF EQ	$$$ADR - ^X80
                                     151C       		PUSHAQ	0
                                     151C       		.MEXIT
                                     151C       		.ENDC
                                     151C       		.IF EQ	$$$ADR - ^X70
                                     151C       		PUSHAQ	0
                                     151C       		.MEXIT
                                     151C       		.ENDC
                                     151C       		PUSHAB	0
                                     151C       		.ENDC
                                     151C       	
                                     151C       		$PUSHADR 0
                                     151C       		.IF	IDN,0,0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 145
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                            00   DD  151C       		PUSHL	#0
                                     151E       		.IFF
                                     151E       		.IF EQ	1-1
                                     151E       		.IF NE	1-1
                                     151E       		PUSHAL	0
                                     151E       		.MEXIT
                                     151E       		.ENDC
                                     151E       		.ENDC
                                     151E       		.NTYPE	$$$ADR, 0
                                     151E       $$$ADR	=	$$$ADR & ^XFFF0
                                     151E       		.IF GT	$$$ADR - ^XFF
                                     151E       		PUSHAL	0
                                     151E       		.MEXIT
                                     151E       		.ENDC
                                     151E       		.IF EQ	$$$ADR - ^X80
                                     151E       		PUSHAL	0
                                     151E       		.MEXIT
                                     151E       		.ENDC
                                     151E       		.IF EQ	$$$ADR - ^X70
                                     151E       		PUSHAL	0
                                     151E       		.MEXIT
                                     151E       		.ENDC
                                     151E       		PUSHAB	0
                                     151E       		.ENDC
                                     151E       	
                                     151E       		$PUSHADR (r1)
                                     151E       		.IF	IDN,0,(r1)
                                     151E       		PUSHL	#0
                                     151E       		.IFF
                           00000000  151E       		.IF EQ	4-4
                           00000000  151E       		.IF NE	4-4
                                     151E       		PUSHAL	(r1)
                                     151E       		.MEXIT
                                     151E       		.ENDC
                                     151E       		.ENDC
                           00000061  151E       		.NTYPE	$$$ADR, (r1)
                           00000060  151E       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFF61  151E       		.IF GT	$$$ADR - ^XFF
                                     151E       		PUSHAL	(r1)
                                     151E       		.MEXIT
                                     151E       		.ENDC
                           FFFFFFE0  151E       		.IF EQ	$$$ADR - ^X80
                                     151E       		PUSHAL	(r1)
                                     151E       		.MEXIT
                                     151E       		.ENDC
                           FFFFFFF0  151E       		.IF EQ	$$$ADR - ^X70
                                     151E       		PUSHAL	(r1)
                                     151E       		.MEXIT
                                     151E       		.ENDC
                            61   9F  151E       		PUSHAB	(r1)
                                     1520       		.ENDC
                                     1520       	
              00000000'GF   04   FB  1520       		CALLS	#4,G^SYS$PUTMSG
                                     1527       	
                                     1527  3393 ; somewhere we need to figure out how to message this as well
                   00001D2F'EF   D6  1527  3394 	incl	v_errors		; increment number of errors
              14   00001D2F'EF   D1  152D  3395 	cmpl	v_errors,#c_max_errs	; the max number of errors exceeded?
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 146
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                            1C   14  1534  3396 	bgtr	10$			; yes, go exit
                    50   08 AC   D0  1536  3397 	movl	chf$l_mcharglst(ap),r0	; get address of mechanism array
                         08 A0   D0  153A  3398 	movl	chf$l_mch_depth(r0),-	; get depth, so we will unwind to
                   00001D27'EF       153D  3399 		v_trap_depth		;   the main program
                                     1542  3400 	$unwind_s depadr=v_trap_depth	; unwind stack
                                     1542       		.GLOBL	SYS$UNWIND
                                     1542       		$PUSHADR 0
                                     1542       		.IF	IDN,0,0
                            00   DD  1542       		PUSHL	#0
                                     1544       		.IFF
                                     1544       		.IF EQ	1-1
                                     1544       		.IF NE	1-1
                                     1544       		PUSHAL	0
                                     1544       		.MEXIT
                                     1544       		.ENDC
                                     1544       		.ENDC
                                     1544       		.NTYPE	$$$ADR, 0
                                     1544       $$$ADR	=	$$$ADR & ^XFFF0
                                     1544       		.IF GT	$$$ADR - ^XFF
                                     1544       		PUSHAL	0
                                     1544       		.MEXIT
                                     1544       		.ENDC
                                     1544       		.IF EQ	$$$ADR - ^X80
                                     1544       		PUSHAL	0
                                     1544       		.MEXIT
                                     1544       		.ENDC
                                     1544       		.IF EQ	$$$ADR - ^X70
                                     1544       		PUSHAL	0
                                     1544       		.MEXIT
                                     1544       		.ENDC
                                     1544       		PUSHAB	0
                                     1544       		.ENDC
                                     1544       	
                                     1544       		$PUSHADR v_trap_depth
                                     1544       		.IF	IDN,0,v_trap_depth
                                     1544       		PUSHL	#0
                                     1544       		.IFF
                           00000000  1544       		.IF EQ	12-12
                           00000000  1544       		.IF NE	12-12
                                     1544       		PUSHAL	v_trap_depth
                                     1544       		.MEXIT
                                     1544       		.ENDC
                                     1544       		.ENDC
                           000000CF  1544       		.NTYPE	$$$ADR, v_trap_depth
                           000000C0  1544       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  1544       		.IF GT	$$$ADR - ^XFF
                                     1544       		PUSHAL	v_trap_depth
                                     1544       		.MEXIT
                                     1544       		.ENDC
                           00000040  1544       		.IF EQ	$$$ADR - ^X80
                                     1544       		PUSHAL	v_trap_depth
                                     1544       		.MEXIT
                                     1544       		.ENDC
                           00000050  1544       		.IF EQ	$$$ADR - ^X70
                                     1544       		PUSHAL	v_trap_depth
                                     1544       		.MEXIT
                                     1544       		.ENDC
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 147
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                   00001D27'EF   9F  1544       		PUSHAB	v_trap_depth
                                     154A       		.ENDC
                                     154A       	
              00000000'GF   02   FB  154A       		CALLS	#2,G^SYS$UNWIND
                                     1551       	
                                 04  1551  3401 	ret				; return to main progam
                                     1552  3402 10$:
                            00   DD  1552  3403 	pushl	#0			; number of fao parameters
                   00000000'8F   DD  1554  3404 	pushl	#vtil_maxerrors		; message number
                            02   DD  155A  3405 	pushl	#2			; number of longs in message vecor,
                                     155C  3406 					; not including this one.
                       50   5E   D0  155C  3407 	movl	sp,r0			; save address of buffer
                                     155F  3408 	$putmsg_s msgvec=(r0)		; write message
                                     155F       		.GLOBL	SYS$PUTMSG
                            00   DD  155F       		PUSHL	#0
                                     1561       		$PUSHADR 0,CONTEXT=Q
                                     1561       		.IF	IDN,0,0
                            00   DD  1561       		PUSHL	#0
                                     1563       		.IFF
                                     1563       		.IF EQ	1-1
                                     1563       		.IF NE	1-1
                                     1563       		PUSHAQ	0
                                     1563       		.MEXIT
                                     1563       		.ENDC
                                     1563       		.ENDC
                                     1563       		.NTYPE	$$$ADR, 0
                                     1563       $$$ADR	=	$$$ADR & ^XFFF0
                                     1563       		.IF GT	$$$ADR - ^XFF
                                     1563       		PUSHAQ	0
                                     1563       		.MEXIT
                                     1563       		.ENDC
                                     1563       		.IF EQ	$$$ADR - ^X80
                                     1563       		PUSHAQ	0
                                     1563       		.MEXIT
                                     1563       		.ENDC
                                     1563       		.IF EQ	$$$ADR - ^X70
                                     1563       		PUSHAQ	0
                                     1563       		.MEXIT
                                     1563       		.ENDC
                                     1563       		PUSHAB	0
                                     1563       		.ENDC
                                     1563       	
                                     1563       		$PUSHADR 0
                                     1563       		.IF	IDN,0,0
                            00   DD  1563       		PUSHL	#0
                                     1565       		.IFF
                                     1565       		.IF EQ	1-1
                                     1565       		.IF NE	1-1
                                     1565       		PUSHAL	0
                                     1565       		.MEXIT
                                     1565       		.ENDC
                                     1565       		.ENDC
                                     1565       		.NTYPE	$$$ADR, 0
                                     1565       $$$ADR	=	$$$ADR & ^XFFF0
                                     1565       		.IF GT	$$$ADR - ^XFF
                                     1565       		PUSHAL	0
                                     1565       		.MEXIT
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 148
V1.01                           Enter VTIL                               10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1565       		.ENDC
                                     1565       		.IF EQ	$$$ADR - ^X80
                                     1565       		PUSHAL	0
                                     1565       		.MEXIT
                                     1565       		.ENDC
                                     1565       		.IF EQ	$$$ADR - ^X70
                                     1565       		PUSHAL	0
                                     1565       		.MEXIT
                                     1565       		.ENDC
                                     1565       		PUSHAB	0
                                     1565       		.ENDC
                                     1565       	
                                     1565       		$PUSHADR (r0)
                                     1565       		.IF	IDN,0,(r0)
                                     1565       		PUSHL	#0
                                     1565       		.IFF
                           00000000  1565       		.IF EQ	4-4
                           00000000  1565       		.IF NE	4-4
                                     1565       		PUSHAL	(r0)
                                     1565       		.MEXIT
                                     1565       		.ENDC
                                     1565       		.ENDC
                           00000060  1565       		.NTYPE	$$$ADR, (r0)
                           00000060  1565       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFF61  1565       		.IF GT	$$$ADR - ^XFF
                                     1565       		PUSHAL	(r0)
                                     1565       		.MEXIT
                                     1565       		.ENDC
                           FFFFFFE0  1565       		.IF EQ	$$$ADR - ^X80
                                     1565       		PUSHAL	(r0)
                                     1565       		.MEXIT
                                     1565       		.ENDC
                           FFFFFFF0  1565       		.IF EQ	$$$ADR - ^X70
                                     1565       		PUSHAL	(r0)
                                     1565       		.MEXIT
                                     1565       		.ENDC
                            60   9F  1565       		PUSHAB	(r0)
                                     1567       		.ENDC
                                     1567       	
              00000000'GF   04   FB  1567       		CALLS	#4,G^SYS$PUTMSG
                                     156E       	
                                     156E  3409 	$exit_s				; exit
                                     156E       		.GLOBL	SYS$EXIT
                            01   DD  156E       		PUSHL	#1
              00000000'GF   01   FB  1570       		CALLS	#1,G^SYS$EXIT
                                     1577       	
                                     1577  3410 					; end of trap
                                     1577  3411 
                                     1577  3412 	newpage <Initialization>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 149
V1.01                           Initialization                           10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1577       	.sbttl	Initialization
                                     1577       	
                                     1577  3413 ;*******************************************************************************
                                     1577  3414 ;
                                     1577  3415 ; Initialization
                                     1577  3416 ;
                                     1577  3417 ;*******************************************************************************
                                     1577  3418 
                                     1577  3419 ;+++
                                     1577  3420 ;s> cold_start -- do all initial setup
                                     1577  3421 ;+++
                               0000  1577  3422 	.entry	s_cold_start,^m<>
              00001D33'EF   5E   D0  1579  3423 	movl	sp,v_returnstack	; save original return stack pointer
              59   00000000'8F   D0  1580  3424 	movl	#c_dict_begin,r9	; initialize dictionary pointer
                                     1587  3425 ; vl_compiler and vl_kernel are symbols that contain location of last word in
                                     1587  3426 ; these vocabularies, which are built-in.
     00001D3F'EF   FFFFFFFC 8F   D0  1587  3427 	movl	#vl_compiler,v_compiler	; Initialize compiler vocabulary
              00001D43'EF   00   D0  1592  3428 	movl	#vl_kernel,v_kernel	; Initialize kernel vocabulary
                                     1599  3429 ; greet user
                   00001800'EF   7F  1599  3430 	pushaq	v_greeting
              00000000'GF   01   FB  159F  3431 	calls	#1,g^lib$put_output	; greet user
     00001D37'EF   00001D43'EF   DE  15A6  3432 	moval	v_kernel,v_context	; Initialize context
     00001D3B'EF   00001D43'EF   DE  15B1  3433 	moval	v_kernel,v_current	; Initialize current
                          009C   31  15BC  3434 	brw	_initialize		; skip patching stuff
                                     15BF  3435 
                                     15BF  3436 
                                     15BF  3437 ;+++
                                     15BF  3438 ;s> warm_start -- do a warm start.  Called from main program.  Branched to
                                     15BF  3439 ;	internally.
                                     15BF  3440 ;---
                               0000  15BF  3441 	.entry	s_warm_start,^m<>
                                     15C1  3442 ; only greet user if entered from main program.  Otherwise we are recovering
                                     15C1  3443 ; from an internal error and are only patching, not recovering from a trap.
                   00001800'EF   7F  15C1  3444 	pushaq	   v_greeting
              00000000'GF   01   FB  15C7  3445 	calls	   #1,g^lib$put_output	; greet user
     00001D37'EF   00001D43'EF   DE  15CE  3446 	moval	   v_kernel,v_context	; Initialize context
     00001D3B'EF   00001D43'EF   DE  15D9  3447 	moval	   v_kernel,v_current	; Initialize current
                                     15E4  3448 ;+++
                                     15E4  3449 ;r> warm_start -- so we can brw to it as well as call it
                                     15E4  3450 ;---
                                     15E4  3451 r_warm_start:
                                     15E4  3452 
                                     15E4  3453 ; The following patches system variables and delivers error messages to the user
                                     15E4  3454 ; about the cause of the boom.
                   00001D4D'EF   95  15E4  3455 	tstb	v_mode		        ; were we compiling before error?
                            04   13  15EA  3456 	beql	10$			; no
                       F90F CF   16  15EC  3457 	jsb	unlink			; yes, unlink unfinished word
                                     15F0  3458 10$:
              00001D4D'EF   00   90  15F0  3459 	movb	#c_false,v_mode		; put in execute mode
              00001D4C'EF   00   90  15F7  3460 	movb	#c_false,v_state	;   just in case
              00001999'EF   00   B0  15FE  3461 	movw	#0,v_inlen		; so start with new line
              00001997'EF   00   B0  1605  3462 	movw	#0,v_org_inlen		;   just in case
                   00001D47'EF   95  160C  3463 	tstb	v_infile		; Are we getting from file?
                            3C   13  1612  3464 	beql	20$			; no
                                     1614  3465 	$close	fab=v_infab		; yes, close file
                                     1614       		$RMSCALL	CLOSE,v_infab,,
                                     1614       	.GLOBL	SYS$CLOSE
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 150
V1.01                           Initialization                           10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1614       	.IF	B <v_infab>
                                     1614       	CALLG	(AP),G^SYS$CLOSE
                                     1614       	$$.TMP=0
                                     1614       	.IF	NB <>
                                     1614       	$$.TMP=1
                                     1614       	.ENDC
                                     1614       	.IF	NB <>
                                     1614       	$$.TMP=1
                                     1614       	.ENDC
                                     1614       	.IF	NE $$.TMP
                                     1614       	.ERROR				; v_infab= parameter missing;
                                     1614       	.ENDC
                                     1614       	.ENDC
                                     1614       	.IF	NB <v_infab>
                           00000001  1614       	$$.TMP1=1
                                     1614       	.IF	NB <>
                                     1614       	PUSHAL	
                                     1614       	$$.TMP1=3
                                     1614       	.ENDC
                                     1614       	.IF	NB <>
                                     1614       	PUSHAL	
                                     1614       	.IF	EQ <$$.TMP1-1>
                                     1614       	$$.TMP1=2
                                     1614       	.ENDC
                                     1614       	.IFF
                           FFFFFFFE  1614       	.IF	EQ <$$.TMP1-3>
                                     1614       	PUSHL	#0
                                     1614       	.ENDC
                                     1614       	.ENDC
                           000000CF  1614       	.NTYPE	$$.TMP2,v_infab
                           00000070  1614       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     1614       	PUSHL	v_infab
                                     1614       	.IFF
                           000000B0  1614       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     1614       	PUSHL	v_infab
                                     1614       	.IFF
                   000019A8'EF   DF  1614       	PUSHAL	v_infab
                                     161A       	.ENDC
                                     161A       	.ENDC
              00000000'GF   01   FB  161A       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     1621       	.ENDC
                                     1621       	
                                     1621       	
              00001D47'EF   00   90  1621  3466 	movb	#c_false,v_infile	; set infile flag false
              00001D48'EF   00   D0  1628  3467 	movl	#0,v_filelinenum	; zero file line as well
              7B   00001890'EF   9E  162F  3468 	movab	v_infilemess,-(r11)	; put address of 'In file:' on stack
                       E9D5 CF   16  1636  3469 	jsb 	bcount			; convert from ascic to write format ( address count )
                       F9AB CF   16  163A  3470 	jsb	write			; put in output
              7B   00001A3D'EF   DE  163E  3471 	moval	v_fname,-(r11)		; put address of filename on stack
              7B   00001A3C'EF   9A  1645  3472 	movzbl	v_fnamelen,-(r11)	; put count of filename on stack
                       F999 CF   16  164C  3473 	jsb	write			; write filename out to terminal
                                     1650  3474 20$:
                       EC87 CF   16  1650  3475 	jsb	q_cr			; finish off outstanding input, if any
              5E   00001D33'EF   D0  1654  3476 	movl	v_returnstack,sp	; restore original return stack pointer
                                     165B  3477 
                                     165B  3478 ;
                                     165B  3479 ; The following is also done during a cold start.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 151
V1.01                           Initialization                           10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     165B  3480 ;
                                     165B  3481 _initialize:
                                     165B  3482 	; Initialize stacks.
              5B   00001000'EF   DE  165B  3483 	moval	c_ds_start,r11 		; move address of data stack to ds pointer
              5A   00001800'EF   DE  1662  3484 	moval	c_ls_start,r10		; move address of loop stack to ls pointer
                                     1669  3485 
                                     1669  3486 
                                     1669  3487 	newpage <Interpreter>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 152
V1.01                           Interpreter                              10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     1669       	.sbttl	Interpreter
                                     1669       	
                                     1669  3488 ;*******************************************************************************
                                     1669  3489 ;
                                     1669  3490 ; Interpreter -- Take commands from the user (or a file) and execute them.
                                     1669  3491 ;
                                     1669  3492 ;*******************************************************************************
                                     1669  3493 _interpreter:
                       7B   20   D0  1669  3494 	movl	#c_blank,-(r11)		; set up for space delimeted token
                       F80B CF   16  166C  3495 	jsb	token			; get the next token
                                     1670  3496 ; is it a comment?
                       69   01   91  1670  3497 	cmpb	#1,(r9)			; token only one byte long?
                            0D   12  1673  3498 	bneq	10$			; no
                 01 A9   5C 8F   91  1675  3499 	cmpb	#c_com1_begin,1(r9)	; is it a \
                            1B   13  167A  3500 	beql	_strip_comment		; yes, strip comment
                    01 A9   28   91  167C  3501 	cmpb	#c_com2_begin,1(r9)	; Is it a (
                            1F   13  1680  3502 	beql	_strip_comment2		; yes, strip second type of comment
                                     1682  3503 10$:
                       ECD5 CF   16  1682  3504 	jsb	q_search		; search for the word
                            8B   D5  1686  3505 	tstl	(r11)+			; was it found?
                            02   13  1688  3506 	beql	30$			; no, go see if number
                            1F   11  168A  3507 	brb	_q_execute		; yes, go see if execute or compile
                                     168C  3508 30$:
                       EC9C CF   16  168C  3509 	jsb	q_number		; see if it is a number
                            8B   D5  1690  3510 	tstl	(r11)+			; was it valid?
                            D5   12  1692  3511 	bneq	_interpreter		; yes, leave with number on the stack
                          0079   31  1694  3512 	brw	_unknowntoken		; no, tell user bad token
                                     1697  3513 
                                     1697  3514 
                                     1697  3515 _strip_comment:
                       7B   00   D0  1697  3516 	movl	#c_com1_end,-(r11)	; end of first type of comment
                       F7DD CF   16  169A  3517 	jsb	token			; get the token
                          FFC8   31  169E  3518 	brw	_interpreter		; end of strip comment
                                     16A1  3519 
                                     16A1  3520 
                                     16A1  3521 _strip_comment2:
                       7B   29   D0  16A1  3522 	movl	#c_com2_end,-(r11)	; end of second type of comment
                       F7D3 CF   16  16A4  3523 	jsb	token			; get the token
                          FFBE   31  16A8  3524 	brw	_interpreter		; end of strip comment2
                                     16AB  3525 
                                     16AB  3526 
                                     16AB  3527 _q_execute:
                       EC33 CF   16  16AB  3528 	jsb	cfa			; get the code field address of
                                     16AF  3529 					;   the word
     00001D4C'EF   00001D4D'EF   91  16AF  3530 	cmpb	v_mode,v_state		; v_mode = v_state?~~~ what does this tell us???
                            1E   12  16BA  3531 	bneq	10$			; no, go compile it
              00001D4C'EF   00   90  16BC  3532 	movb	#c_false,v_state	; set v_state false~~~ Why???
                            9B   16  16C3  3533 	jsb	@(r11)+			; yes, execute it
              00000000'8F   5A   D1  16C5  3534 	cmpl	r10,#c_ds_end		; stack overflow?
                            2E   19  16CC  3535 	blss	_overflow		; yes, go announce it
              00001000'8F   5B   D1  16CE  3536 	cmpl	r11,#c_ds_start		; stack underflow?
                            11   14  16D5  3537 	bgtr	_underflow		; yes, go announce it
                          FF8F   31  16D7  3538 	brw	_interpreter		; everything ok, do it again
                                     16DA  3539 10$:
              00001D4C'EF   00   90  16DA  3540 	movb	#c_false,v_state	; set v_state false~~~ what does this tell us???
                       EC5A CF   16  16E1  3541 	jsb	i_compile_jsb		; compile a jump to the word whose
                                     16E5  3542 					;   cfa addressis at the top of stack
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 153
V1.01                           Interpreter                              10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                          FF81   31  16E5  3543 	brw	_interpreter		; everthing ok, do it again
                                     16E8  3544 
                                     16E8  3545 
                                     16E8  3546 _underflow:
                       ECBB CF   16  16E8  3547 	jsb	cr			; make sure everything is output
                   00001842'EF   7F  16EC  3548 	pushaq	v_undermess		; push address of underflow message
              00000000'GF   01   FB  16F2  3549 	calls	#1,g^lib$put_output	; tell user
                          FEE8   31  16F9  3550 	brw	r_warm_start			; clean up VTIL
                                     16FC  3551 
                                     16FC  3552 
                                     16FC  3553 _overflow:
                       ECA7 CF   16  16FC  3554 	jsb	cr			; make sure everything is output
                   0000185A'EF   7F  1700  3555 	pushaq	v_overmess		; make sure everything is output
              00000000'GF   01   FB  1706  3556 	calls	#1,g^lib$put_output	; tell user
                          FED4   31  170D  3557 	brw	r_warm_start			; clean up VTIL
                                     1710  3558 
                                     1710  3559 
                                     1710  3560 _unknowntoken:
              7B   00001871'EF   9E  1710  3561 	movab	v_unknown,-(r11)	; push address of unknown token message
                       E8F4 CF   16  1717  3562 	jsb	bcount			; convert it to ( address count )
                       F8CA CF   16  171B  3563 	jsb	write			; tell user
                       7B   59   D0  171F  3564 	movl	r9,-(r11)		; get address of token
                            6B   D6  1722  3565 	incl	(r11)			; move address over byte-count
                       7B   69   9A  1724  3566 	movzbl	(r9),-(r11)		; get byte count of string on stack
                       F8BE CF   16  1727  3567 	jsb	write			; show user bad token
              7B   00001883'EF   9E  172B  3568 	movab	v_unknown2,-(r11)	; Put address of 'In line:' on stack
                       E8D9 CF   16  1732  3569 	jsb	bcount			; convert it to ( address count )
                       F8AF CF   16  1736  3570 	jsb	write			; tell user
                   00001D47'EF   95  173A  3571 	tstb	v_infile		; In a file?
                            0B   13  1740  3572 	beql	10$			; no
              7B   00001D48'EF   D0  1742  3573 	movl	v_filelinenum,-(r11)	; yes, print line number
                       E9D6 CF   16  1749  3574 	jsb	i_dot			; put number in output buffer
                                     174D  3575 10$:
                       EC56 CF   16  174D  3576 	jsb	cr			; end line
              7B   000018F7'EF   DE  1751  3577 	moval	v_inbuf,-(r11)		; get address of original line
              7B   00001997'EF   32  1758  3578 	cvtwl	v_org_inlen,-(r11)	; length of original line
                       F886 CF   16  175F  3579 	jsb	write			; show user
                       EC40 CF   16  1763  3580 	jsb	cr			; end line
                          FE7A   31  1767  3581 	brw	r_warm_start		; go clean up VTIL
                                     176A  3582 
                                     176A  3583 
                                     176A  3584 	newpage <Exit Routines>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 154
V1.01                           Exit Routines                            10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     176A       	.sbttl	Exit Routines
                                     176A       	
                                     176A  3585 ;*******************************************************************************
                                     176A  3586 ;
                                     176A  3587 ; Exit Routines -- Routines to handle successful and unsuccessful  exits
                                     176A  3588 ;
                                     176A  3589 ;*******************************************************************************
                                     176A  3590 _error_exit:				; die messily
                            50   DD  176A  3591 	pushl	r0			; put error message number on stack
              00000000'GF   01   FB  176C  3592 	calls	#1,g^lib$signal		; signal error
                                 04  1773  3593 	ret				; return
                                     1774  3594 
                                     1774  3595 
                         0C A6   DD  1774  3596 _f_err:	pushl	fab$l_stv(r6)		; push stv and sts of fab
                         08 A6   DD  1777  3597 	pushl	fab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  177A  3598 	calls	#2,g^lib$signal		; signal error
                            1A   11  1781  3599 	brb	_exit
                                     1783  3600 
                                     1783  3601 
                         0C A6   DD  1783  3602 _r_err:	pushl	rab$l_stv(r6)		; push stv and sts of rab
                         08 A6   DD  1786  3603 	pushl	rab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1789  3604 	calls	#2,g^lib$signal		; signal error
                                     1790  3605 
                                     1790  3606 
                                     1790  3607 _done:	$close	fab=v_infile		; close input
                                     1790       		$RMSCALL	CLOSE,v_infile,,
                                     1790       	.GLOBL	SYS$CLOSE
                                     1790       	.IF	B <v_infile>
                                     1790       	CALLG	(AP),G^SYS$CLOSE
                                     1790       	$$.TMP=0
                                     1790       	.IF	NB <>
                                     1790       	$$.TMP=1
                                     1790       	.ENDC
                                     1790       	.IF	NB <>
                                     1790       	$$.TMP=1
                                     1790       	.ENDC
                                     1790       	.IF	NE $$.TMP
                                     1790       	.ERROR				; v_infile= parameter missing;
                                     1790       	.ENDC
                                     1790       	.ENDC
                                     1790       	.IF	NB <v_infile>
                           00000001  1790       	$$.TMP1=1
                                     1790       	.IF	NB <>
                                     1790       	PUSHAL	
                                     1790       	$$.TMP1=3
                                     1790       	.ENDC
                                     1790       	.IF	NB <>
                                     1790       	PUSHAL	
                                     1790       	.IF	EQ <$$.TMP1-1>
                                     1790       	$$.TMP1=2
                                     1790       	.ENDC
                                     1790       	.IFF
                           FFFFFFFE  1790       	.IF	EQ <$$.TMP1-3>
                                     1790       	PUSHL	#0
                                     1790       	.ENDC
                                     1790       	.ENDC
                           000000CF  1790       	.NTYPE	$$.TMP2,v_infile
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 155
V1.01                           Exit Routines                            10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                           00000070  1790       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     1790       	PUSHL	v_infile
                                     1790       	.IFF
                           000000B0  1790       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     1790       	PUSHL	v_infile
                                     1790       	.IFF
                   00001D47'EF   DF  1790       	PUSHAL	v_infile
                                     1796       	.ENDC
                                     1796       	.ENDC
              00000000'GF   01   FB  1796       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     179D       	.ENDC
                                     179D       	
                                     179D       	
                                     179D  3608 
                                     179D  3609 
                                     179D  3610 _exit:
                       50   01   D0  179D  3611 	movl	#1,r0			; successful completion
                                     17A0  3612 	$exit_s	r0			; exit with status
                                     17A0       		.GLOBL	SYS$EXIT
                            50   DD  17A0       		PUSHL	r0
              00000000'GF   01   FB  17A2       		CALLS	#1,G^SYS$EXIT
                                     17A9       	
                                     17A9  3613 
                                     17A9  3614 
                                     17A9  3615 	newpage <Dictionary Space>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 156
V1.01                           Dictionary Space                         10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                     17A9       	.sbttl	Dictionary Space
                                     17A9       	
                                     17A9  3616 ;*******************************************************************************
                                     17A9  3617 ;
                                     17A9  3618 ; Dictionary
                                     17A9  3619 ;
                                     17A9  3620 ;*******************************************************************************
                                 00000000  3621 	.psect	vtildict
                                     0000  3622 c_dict_begin:
                           00004000  0000  3623 	. = .+<16 * 1024>		; reserve space for dictinary~~~ why not a constant
                                     4000  3624 c_dict_end:
                                     4000  3625 
                                     4000  3626 
                                     4000  3627 ;
                                     4000  3628 ; Block i/o buffers -- Here because that is the safest place for them.
                                     4000  3629 ;
                                     4000  3630 v_blkbuff:
                           00004C00  4000  3631 	.blkb	c_max_blocks * c_block_size ; buffer for block i/o
                                     4C00  3632 
                                     4C00  3633 
                                     4C00  3634 ;*******************************************************************************
                                     4C00  3635 ;
                                     4C00  3636 ; End of VTIL, and transfer address
                                     4C00  3637 ;
                                     4C00  3638 ;*******************************************************************************
                                     4C00  3639 	.end	vtil
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 157
Symbol table                                                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

$$$ADR                         = 00000060                 C_COM2_END                     = 00000029                 
$$.TAB                         = 00001B30 R     02        C_DICT_BEGIN                     00000000 R     05        
$$.TABEND                      = 00001B74 R     02        C_DICT_END                       00004000 R     05        
$$.TMP                         = 00000000                 C_DS_END                         00000000 R     02        
$$.TMP1                        = 00000001                 C_DS_SIZE                      = 00001000                 
$$.TMP2                        = 000000CF                 C_DS_START                       00001000 R     02        
$$.TMPX                        = 0000000A R     03        C_D_BLKS_IN_BLK                = 00000002                 
$$.TMPX1                       = 0000000E                 C_FALSE                        = 00000000                 
$$T1                           = 00000001                 C_INUSE                        = 00000001                 
ABORT                            000003A3 R     04        C_KEYSIZE                      = 00000004                 
ABS                              000003AE R     04        C_LS_END                         00001000 R     02        
ADM_ABSOLUTE                   = 0000009F                 C_LS_SIZE                      = 00000800                 
ADM_ADEC_R10                   = 0000007A                 C_LS_START                       00001800 R     02        
ADM_ADEC_R11                   = 0000007B                 C_MAX_BLOCKS                   = 00000003                 
ADM_AINC_R10                   = 0000008A                 C_MAX_ERRS                     = 00000014                 
ADM_AINC_R11                   = 0000008B                 C_MAX_LEN                      = 000000A0                 
ADM_AINC_R9                    = 00000089                 C_MAX_NAME_LEN                 = 00000050                 
ADM_B_DIS_R10                  = 000000AA                 C_MODIFIED                     = 00000002                 
ADM_B_REL                      = 000000AF                 C_PAD_MOAT                     = 00000109                 
ADM_DEF_R10                    = 0000006A                 C_SCREEN_LEN                   = 00000050                 
ADM_DEF_R11                    = 0000006B                 C_TPU_COM_LEN                  = 0000001C                 
ADM_DEF_R9                     = 00000069                 C_TRUE                         = FFFFFFFF                 
ADM_IMMEDIATE                  = 0000008F                 DC$_TERM                         ********   X   00        
ADM_R0                         = 00000050                 DECIMAL                          0000046E R     04        
ADM_R10                        = 0000005A                 DEFINITIONS                      00000486 R     04        
ADM_R9                         = 00000059                 DOWNLOOP                         0000125A R     04        
AGAIN                            000011AE R     04        DROP                             0000049B R     04        
AND                              000003EB R     04        DSC$K_CLASS_S                    ********   X   00        
ARRAY                            0000040C R     04        DSC$K_DTYPE_T                    ********   X   00        
ASCII                            00000432 R     04        DUP                              000004B5 R     04        
BCOUNT                           0000000F R     04        ELSE                             00001296 R     04        
BINARY                           00000024 R     04        ENABLE_CTRLC                     000014D9 RG    04        
BLANK                            00000043 R     04        ENDIF                            000012BE R     04        
BLOCK                            00000058 R     04        ENDWHILE                         000012D7 R     04        
BREAK                            000001C5 R     04        EODP                             000004ED R     04        
BUFFER                           000001DF R     04        EVE                              00000516 R     04        
BYTE                             000002BB R     04        FAB$B_DNS                      = 00000035                 
CA_CONTROLC                    = 00000000                 FAB$B_FNS                      = 00000034                 
CA_TRAPPING                    = 00000000                 FAB$C_BID                      = 00000003                 
CFA                              000002E2 R     04        FAB$C_BLN                      = 00000050                 
CHF$L_MCHARGLST                = 00000008                 FAB$C_FIX                      = 00000001                 
CHF$L_MCH_DEPTH                = 00000008                 FAB$C_SEQ                      = 00000000                 
CHF$L_SIGARGLST                = 00000004                 FAB$C_VAR                      = 00000002                 
CHF$L_SIG_NAME                 = 00000004                 FAB$L_ALQ                      = 00000010                 
CLIST                            000002FD R     04        FAB$L_DNA                      = 00000030                 
COMPILER_BEGIN                   000010BE R     04        FAB$L_FNA                      = 0000002C                 
COMPILETIME                      0000035A R     04        FAB$L_FOP                      = 00000004                 
CONTEXT                          00000383 R     04        FAB$L_STS                      = 00000008                 
COUNT                            00000395 R     04        FAB$L_STV                      = 0000000C                 
CR                               000003A7 R     04        FAB$V_CHAN_MODE                = 00000002                 
CREATE                           000003DB R     04        FAB$V_FILE_MODE                = 00000004                 
CURRENT                          0000045A R     04        FAB$V_GET                      = 00000001                 
C_BLANK                        = 00000020                 FAB$V_LNM_MODE                 = 00000000                 
C_BLOCK_SIZE                   = 00000400                 FAB$V_UPD                      = 00000003                 
C_COM1_BEGIN                   = 0000005C                 FAB$W_GBC                      = 00000048                 
C_COM1_END                     = 00000000                 FILL                             00000568 R     04        
C_COM2_BEGIN                   = 00000028                 FORGET                           000005B9 R     04        
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 158
Symbol table                                                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

FREEMEM                          00000667 R     04        I_LESS_EQUAL                     0000024D R     04        
HEX                              0000068B R     04        I_LESS_SHARP                     00000239 R     04        
HLD                              0000069B R     04        I_LONG                           0000078F R     04        
HOLD                             000006AC R     04        I_LOOP                           00001355 R     04        
IF                               000012FA R     04        I_LS_TO_DS                       000007CF R     04        
IO$M_CTRLCAST                    ********   X   00        I_L_UP                           0000131C R     04        
IO$_SETMODE                      ********   X   00        I_MATCH                          000007DD R     04        
I_AC_COLON                       000003BE R     04        I_MINUS_ROT                      0000010C R     04        
I_ADD                            000000C1 R     04        I_MOVE_FILL                      00000879 R     04        
I_BIT_AND                        00000072 R     04        I_MULTIPLY                       000000A8 R     04        
I_BIT_NOT                        00000083 R     04        I_ONE_MINUS                      000001F2 R     04        
I_BIT_OR                         00000090 R     04        I_ONE_PLUS                       000001E8 R     04        
I_BIT_XOR                        0000009E R     04        I_PLUS_LOOP                      000010EA R     04        
I_BL                             00000035 R     04        I_PLUS_ROT                       000000DE R     04        
I_BLOCK_CLOSE                    000000D9 R     04        I_PLUS_STORE                     000000CC R     04        
I_BLOCK_OPEN                     0000010B R     04        I_QUESTION                       000002CA R     04        
I_BLOCK_READ                     00000151 R     04        I_RIGHT_BACK                     000010B5 R     04        
I_BLOCK_WRITE                    00000183 R     04        I_SAVE_BUFFERS                   00000AF2 R     04        
I_BS_FETCH                       000001CF R     04        I_SEMICOLON                      00001170 R     04        
I_BUFFER_READ                    00000256 R     04        I_SHARP                          00000015 R     04        
I_BUFFER_WRITE                   00000292 R     04        I_SHARP_GREATER                  00000036 R     04        
I_B_COMMA                        00000457 R     04        I_SHARP_S                        00000055 R     04        
I_B_FETCH                        FFFFFFFF R     04        I_SHORT                          00000B57 R     04        
I_B_STORE                        00000447 R     04        I_SP_0                           00000BB6 R     04        
I_B_UP                           000011D3 R     04        I_SP_FETCH                       00000BAA R     04        
I_COLON                          000001FB R     04        I_STORE                          00000006 R     04        
I_COMMA                          000000F5 R     04        I_STRING_QUOTE                   00000DB5 R     04        
I_COMPILE_ASCII                  00001434 R     04        I_SUBTRACT                       000000FF R     04        
I_COMPILE_JSB                    0000033F R     04        I_S_UP                           000013B2 R     04        
I_COUNT_BEGIN                    00000064 R     04        I_VARIABLE                       000010CD R     04        
I_COUNT_END                      000000B3 R     04        I_WORD_FETCH                     00000ACF R     04        
I_DEFER_BEGIN                    000011F5 R     04        I_WORD_STORE                     00000AB1 R     04        
I_DEFER_END                      0000118A R     04        I_WS_FETCH                       00000ADC R     04        
I_DIVIDE                         000001C0 R     04        I_W_COMMA                        00000AC1 R     04        
I_DIV_MOD                        000001CD R     04        KERNEL                           000006D3 R     04        
I_DO                             00001225 R     04        LEAVE                            000006E9 R     04        
I_DOT                            00000123 R     04        LIB$GET_INPUT                    ********   X   00        
I_DOT_LPAREN                     0000015A R     04        LIB$PUT_OUTPUT                   ********   X   00        
I_DOT_QUOTE                      0000111E R     04        LIB$SIGNAL                       ********   X   00        
I_DOT_SB                         00000179 R     04        LIB$_INPSTRTRU                   ********   X   00        
I_DOT_ST                         0000019D R     04        LITERAL                          0000133C R     04        
I_DS_TO_LS                       000004A9 R     04        LOAD                             000006F7 R     04        
I_EMPTY_BUFFERS                  000004CB R     04        LONGCONST                        000007B7 R     04        
I_EODP_PLUS_STORE                0000050A R     04        MAX                              00000808 R     04        
I_EOD_STORE                      000004FB R     04        MESSAGE                          00000822 R     04        
I_EQUAL                          00000264 R     04        MIN                              00000835 R     04        
I_EQUAL_TEXT                     0000027F R     04        MOD                              0000084B R     04        
I_EXIT                           0000055C R     04        MOVE                             00000861 R     04        
I_FETCH                          00000394 R     04        NCHR                           = 00000007                 
I_FLUSH_BUFFERS                  00000586 R     04        NEGAGE                           00000892 R     04        
I_FORGET_ERASE                   00000611 R     04        NOT                              0000089E R     04        
I_GREATER_EQUAL                  000002B3 R     04        NUMBER                           000008B9 R     04        
I_GRETER                         0000029F R     04        OCTAL                            00000939 R     04        
I_HALT                           0000067D R     04        OP_ACBL                        = 000000F1                 
I_I_TO                           000006C4 R     04        OP_ADDL2                       = 000000C0                 
I_LEFT_BRACK                     00001420 R     04        OP_BNEQ                        = 00000012                 
I_LESS                           00000221 R     04        OP_BRW                         = 00000031                 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 159
Symbol table                                                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

OP_JSB                         = 00000016                 SYS$EXIT                         ********  G    04        
OP_MOVAB                       = 0000009E                 SYS$FIND                         ********  G    04        
OP_MOVAL                       = 000000DE                 SYS$GET                          ********  G    04        
OP_MOVAW                       = 0000003E                 SYS$GETCHN                       ********  G    04        
OP_MOVB                        = 00000090                 SYS$OPEN                         ********  G    04        
OP_MOVC3                       = 00000028                 SYS$PUTMSG                       ********  G    04        
OP_MOVL                        = 000000D0                 SYS$QIO                          ********  G    04        
OP_RSB                         = 00000005                 SYS$UNWIND                       ********  G    04        
OP_TSTL                        = 000000D5                 SYS$UPDATE                       ********  G    04        
OR                               00000948 R     04        S_COLD_START                     00001577 RG    04        
OTS$CVT_L_TI                     ********   X   00        S_TRAP                           0000150D RG    04        
OVER                             00000968 R     04        S_WARM_START                     000015BF RG    04        
PAD                              00000975 R     04        TOCHAR                           00000E5A R     04        
PUTC                             00000987 R     04        TOKEN                            00000E7B R     04        
Q_CR                             000002DB R     04        TPU$TPU                          ********   X   00        
Q_DUP                            000002F3 R     04        UNLINK                           00000EFF R     04        
Q_NUMBER                         0000032C R     04        UNSMUDGE                         00000F1B R     04        
Q_N_CR                           00000305 R     04        UNTIL                            000013D3 R     04        
Q_SEARCH                         0000035B R     04        UPDATE                           00000F35 R     04        
RAB$B_RAC                      = 0000001E                 V1_COMPILER                    = FFFFFFFC                 
RAB$C_BID                      = 00000001                 V1_KERNEL                      = FFFFFFFC                 
RAB$C_BLN                      = 00000044                 VARIABLE                         00000F4F R     04        
RAB$C_KEY                      = 00000001                 VLIST                            00000F70 R     04        
RAB$C_SEQ                      = 00000000                 VL_COMPILER                    = FFFFFFFC                 
RAB$L_CTX                      = 00000018                 VL_KERNEL                      = 00000000                 
RAB$L_RBF                      = 00000028                 VOCABULARY                       00000FB3 R     04        
RAB$L_ROP                      = 00000004                 VTIL                             00001444 RG    04        
RAB$L_STS                      = 00000008                 VTIL_CTRLC                       ********   X   00        
RAB$L_STV                      = 0000000C                 VTIL_EXIT                        000014CF R     04        
RAB$L_UBF                      = 00000024                 VTIL_MAXERRORS                   ********   X   00        
RAB$V_RAH                      = 00000009                 V_BLKBUFF                        00004000 R     05        
RAB$W_RSZ                      = 00000022                 V_BLKFAB                         00001AE0 R     02        
RADIX                            000009BE R     04        V_BLKKEY                         00001B74 R     02        
READ                             000009CF R     04        V_BLKRAB                         00001B30 R     02        
READSTR                          00000A43 R     04        V_BLOCKIO                        00001B78 R     02        
RECURSE                          0000138C R     04        V_BUF_BLK_NUMS                   00001B80 R     02        
REPEAT                           000013A7 R     04        V_BUF_INUSE                      00001B7D R     02        
RESTART                          00000AA7 R     04        V_COMPILER                       00001D3F R     02        
RMS$_EOF                         ********   X   00        V_CONTEXT                        00001D37 R     02        
RMS$_FNF                         ********   X   00        V_CTRLC_DEPTH                    00001D2B R     02        
R_WARM_START                     000015E4 R     04        V_CURRENT                        00001D3B R     02        
SEARCH                           00000B1F R     04        V_CURRENT_BUFF                   00001B79 R     02        
SIGN                             00000B7C R     04        V_ERRORS                         00001D2F R     02        
SMUDGE                           00000B93 R     04        V_FILELINENUM                    00001D48 R     02        
SPACE                            00000BC8 R     04        V_FILENOTFOUND                   0000189A R     02        
SPACES                           00000C01 R     04        V_FNAME                          00001A3D R     02        
SREAD                            00000C21 R     04        V_FNAMELEN                       00001A3C R     02        
STRCAT                           00000CDE R     04        V_GETCHN_BUF                     00001D1F R     02        
STRCMP                           00000D1F R     04        V_GETCHN_BUF_ADR                 00001D1B R     02        
STRCPY                           00000D58 R     04        V_GETCHN_IN_BUF                  00001D17 R     02        
STRING                           00000D8A R     04        V_GETCHN_RET_LEN                 00001D13 R     02        
STRMAX                           00000DFD R     04        V_GREETING                       00001800 R     02        
STRPOS                           00000E10 R     04        V_HLD                            00001D52 R     02        
SWAP                             00000E43 R     04        V_INBUF                          000018F7 R     02        
SYS$ASSIGN                       ********  G    04        V_INFAB                          000019A8 R     02        
SYS$CLOSE                        ********  G    04        V_INFILE                         00001D47 R     02        
SYS$CONNECT                      ********  G    04        V_INFILEMESS                     00001890 R     02        
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 160
Symbol table                                                             10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

V_INLEN                          00001999 R     02        _UNKNOWNTOKEN                    00001710 R     04        
V_INPTR                          0000199B R     02        
V_INPUT_CHAN                     00001D11 R     02        
V_INPUT_NAME                     00001CFE R     02        
V_INRAB                          000019F8 R     02        
V_IN_DSC                         0000199F R     02        
V_KERNEL                         00001D43 R     02        
V_MODE                           00001D4D R     02        
V_NAMETOOLONG                    000018D8 R     02        
V_NAMETRUNC                      000018E8 R     02        
V_ORG_INLEN                      00001997 R     02        
V_OUTBUF                         00001B9A R     02        
V_OUTLEN                         00001B98 R     02        
V_OVERMESS                       0000185A R     02        
V_RADIX                          00001D4E R     02        
V_READADDR                       00001B92 R     02        
V_READDSC                        00001B8E R     02        
V_READLEN                        00001B8C R     02        
V_RETURNSTACK                    00001D33 R     02        
V_STATE                          00001D4C R     02        
V_STATIC_DSC                     00001B96 R     02        
V_TPU_COM                        00001C3A R     02        
V_TPU_COM2                       00001C56 R     02        
V_TPU_DSC                        00001CF6 R     02        
V_TRAP_DEPTH                     00001D27 R     02        
V_UNDERMESS                      00001842 R     02        
V_UNKNOWN                        00001871 R     02        
V_UNKNOWN2                       00001883 R     02        
V_UNKN_BLK_MESS                  000018B1 R     02        
V_USRPROMPT                      00001838 R     02        
V_VTILPROMPT                     0000182A R     02        
V_WORDNOTFOUND                   000018C7 R     02        
WHILE                            000013FC R     04        
WRITE                            00000FE9 R     04        
XOR                              00001095 R     04        
_CHECK_BASE                      000008FE R     04        
_CHECK_LOWERCASE                 000008ED R     04        
_COMPILER_END                    00001444 R     04        
_DONE                            00001790 R     04        
_ERROR_EXIT                      0000176A R     04        
_EXIT                            0000179D R     04        
_F_ERR                           00001774 R     04        
_GETTOKEN                        00000EA2 R     04        
_INITIALIZE                      0000165B R     04        
_INTERPRETER                     00001669 R     04        
_INVALID_NUMBER                  0000092B R     04        
_KERNEL_BEGIN                    00000000 R     04        
_KERNEL_END                      000010BE R     04        
_NUMBER_TOP                      000008CF R     04        
_OVERFLOW                        000016FC R     04        
_Q_EXECUTE                       000016AB R     04        
_R_ERR                           00001783 R     04        
_SKIPWHITESPACE                  00000E80 R     04        
_STARTFOUND                      00000E94 R     04        
_STRIP_COMMENT                   00001697 R     04        
_STRIP_COMMENT2                  000016A1 R     04        
_UNDERFLOW                       000016E8 R     04        
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 161
Psect synopsis                                                           10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)


                                                +----------------+
                                                ! Psect synopsis !
                                                +----------------+

PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          ---------  ----------     
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE  
$ABS$                           00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILDATA                        00001D56  ( 7510.)  02 (  2.)  NOPIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT NOVEC LONG  
$RMSNAM                         00000018  (   24.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILCODE                        FFFFFFFF  (    0.)  04 (  4.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE  
VTILDICT                        00004C00  (19456.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 162
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)


                                             +------------------------+
                                             ! Symbol Cross Reference !
                                             +------------------------+

SYMBOL                          VALUE        DEFINITION      REFERENCES... 
------                          -----        ----------      ------------- 
$$$ADR                         =00000060     3408   (1)      3326   (1)      3332   (1)      3341   (1)      3377   (1)    
                                                             3392   (1)      3400   (1)      3408   (1)    
$$.TAB                         =00001B30-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TABEND                      =00001B74-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP                         =00000000     442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP1                        =00000001     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMP2                        =000000CF     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMPX                        =0000000A-R   435    (1)      435    (1)    
$$.TMPX1                       =0000000E     435    (1)      435    (1)    
$$T1                           =00000001     3377   (1)      3326   (1)      3341   (1)      3377   (1)    
ABORT                           000003A3-R   1072   (1)    
ABS                             000003AE-R   1079   (1)      735    (1)    
ADM_ABSOLUTE                   =0000009F     268    (1)    #-1501   (1)    #-2794   (1)    #-2951   (1)    
ADM_ADEC_R10                   =0000007A     261    (1)    #-3060   (1)    #-3063   (1)    
ADM_ADEC_R11                   =0000007B     265    (1)    #-1134   (1)    #-1449   (1)    #-1932   (1)    #-2353   (1)    
                                                           #-2564   (1)    #-2583   (1)    #-2756   (1)    #-2897   (1)    
                                                           #-2934   (1)    #-2948   (1)    #-3183   (1)    
ADM_AINC_R10                   =0000008A     262    (1)    
ADM_AINC_R11                   =0000008B     266    (1)    #-2914   (1)    #-3056   (1)    #-3059   (1)    #-3150   (1)    
                                                           #-3252   (1)    #-3271   (1)    
ADM_AINC_R9                    =00000089     258    (1)    #-1097   (1)    
ADM_B_DIS_R10                  =000000AA     263    (1)    #-2912   (1)    #-3076   (1)    #-3194   (1)    
ADM_B_REL                      =000000AF     269    (1)    #-1095   (1)    #-1132   (1)    #-1447   (1)    #-1930   (1)    
                                                           #-2351   (1)    #-2562   (1)    #-2581   (1)    #-2754   (1)    
                                                           #-2792   (1)    #-2895   (1)    #-2932   (1)    #-3036   (1)    
ADM_DEF_R10                    =0000006A     260    (1)    #-2915   (1)    #-3080   (1)    #-3197   (1)    
ADM_DEF_R11                    =0000006B     264    (1)    
ADM_DEF_R9                     =00000069     257    (1)    #-3038   (1)    
ADM_IMMEDIATE                  =0000008F     267    (1)    #-2946   (1)    #-2981   (1)    #-3032   (1)    #-3078   (1)    
                                                           #-3181   (1)    
ADM_R0                         =00000050     255    (1)    #-3057   (1)    #-3062   (1)    
ADM_R10                        =0000005A     259    (1)    #-2922   (1)    #-3087   (1)    #-3204   (1)    
ADM_R9                         =00000059     256    (1)    #-2983   (1)    
AGAIN                           000011AE-R   2991   (1)    
AND                             000003EB-R   1110   (1)    
ARRAY                           0000040C-R   1129   (1)    
ASCII                           00000432-R   1144   (1)    
BCOUNT                          0000000F-R   1183   (1)      1480   (1)      1579   (1)      1587   (1)      1781   (1)    
                                                             1784   (1)      1808   (1)      1811   (1)      2771   (1)    
                                                             3469   (1)      3562   (1)      3569   (1)    
BINARY                          00000024-R   1193   (1)    
BLANK                           00000043-R   1209   (1)    
BLOCK                           00000058-R   1220   (1)    
BREAK                           000001C5-R   1343   (1)    
BUFFER                          000001DF-R   1359   (1)    
BYTE                            000002BB-R   1444   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 163
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

CA_CONTROLC                    =00000000     53     (1)    
CA_TRAPPING                    =00000000     49     (1)    
CFA                             000002E2-R   1461   (1)      3214   (1)      3528   (1)    
CHF$L_MCHARGLST                =00000008                   #-3397   (1)    
CHF$L_MCH_DEPTH                =00000008                   #-3398   (1)    
CHF$L_SIGARGLST                =00000004                   #-3389   (1)    
CHF$L_SIG_NAME                 =00000004                   #-3391   (1)    
CLIST                           000002FD-R   1473   (1)    
COMPILER_BEGIN                  000010BE-R   2884   (1)    
COMPILETIME                     0000035A-R   1512   (1)      1103   (1)    
CONTEXT                         00000383-R   1534   (1)    
COUNT                           00000395-R   1545   (1)      1998   (1)    
CR                              000003A7-R   1555   (1)      1584   (1)      2175   (1)      2408   (1)      2442   (1)    
                                                             3547   (1)      3554   (1)      3576   (1)      3580   (1)    
                                                             956    (1)      982    (1)    
CREATE                          000003DB-R   1570   (1)      1093   (1)      1130   (1)      1445   (1)      1928   (1)    
                                                             1942   (1)      2349   (1)      2560   (1)      2579   (1)    
                                                             2752   (1)      2790   (1)      842    (1)    
CURRENT                         0000045A-R   1603   (1)    
C_BLANK                        =00000020     216    (1)    #-1145   (1)    #-1202   (1)    #-1211   (1)    #-1484   (1)    
                                                           #-1574   (1)    #-1702   (1)    #-1769   (1)    #-1795   (1)    
                                                           #-1891   (1)    #-2413   (1)    #-2676   (1)    #-2775   (1)    
                                                           #-3011   (1)    #-3165   (1)    #-3234   (1)    #-3296   (1)    
                                                           #-3494   (1)    #-742    (1)    
C_BLOCK_SIZE                   =00000400     225    (1)    #-1264   (1)    #-1329   (1)    #-1401   (1)    #-1416   (1)    
                                                           #-1434   (1)      227    (1)      3631   (1)      435    (1)    
                                                             442    (1)    
C_COM1_BEGIN                   =0000005C     217    (1)    #-3499   (1)    
C_COM1_END                     =00000000     218    (1)    #-3516   (1)    
C_COM2_BEGIN                   =00000028     220    (1)    #-3501   (1)    
C_COM2_END                     =00000029     221    (1)    #-3522   (1)    
C_DICT_BEGIN                    00000000-R   3622   (1)    #-3424   (1)    
C_DICT_END                      00004000-R   3624   (1)    #-1820   (1)    
C_DS_END                        00000000-R   345    (1)    #-3534   (1)    
C_DS_SIZE                      =00001000     231    (1)      346    (1)    
C_DS_START                      00001000-R   347    (1)      2398   (1)      3483   (1)    #-3536   (1)    #-766    (1)    
                                                           #-786    (1)    
C_D_BLKS_IN_BLK                =00000002     227    (1)    
C_FALSE                        =00000000     213    (1)    #-1121   (1)    #-1281   (1)    #-1658   (1)    #-1660   (1)    
                                                           #-1751   (1)    #-1976   (1)    #-2061   (1)    #-2120   (1)    
                                                           #-2140   (1)    #-2478   (1)    #-2635   (1)    #-2857   (1)    
                                                           #-2962   (1)    #-3288   (1)    #-3459   (1)    #-3460   (1)    
                                                           #-3466   (1)    #-3532   (1)    #-3540   (1)      446    (1)    
                                                             538    (1)      542    (1)      545    (1)    #-856    (1)    
                                                           #-877    (1)    #-890    (1)    #-909    (1)    #-919    (1)    
                                                           #-922    (1)    #-932    (1)    
C_INUSE                        =00000001     222    (1)    #-1254   (1)    #-1396   (1)    #-2309   (1)    
C_KEYSIZE                      =00000004     226    (1)      442    (1)    
C_LS_END                        00001000-R   351    (1)    
C_LS_SIZE                      =00000800     233    (1)      352    (1)    
C_LS_START                      00001800-R   353    (1)      3484   (1)    
C_MAX_BLOCKS                   =00000003     224    (1)    #-1227   (1)    #-1236   (1)    #-1243   (1)    #-1366   (1)    
                                                           #-1375   (1)    #-1382   (1)    #-1662   (1)    #-1754   (1)    
                                                           #-2312   (1)      3631   (1)      451    (1)      453    (1)    
C_MAX_ERRS                     =00000014     214    (1)    #-3395   (1)    
C_MAX_LEN                      =000000A0     228    (1)    #-2173   (1)    #-2406   (1)    #-2805   (1)    #-2817   (1)    
                                                             393    (1)      401    (1)      419    (1)      423    (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 164
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                                             469    (1)      482    (1)      492    (1)    
C_MAX_NAME_LEN                 =00000050     215    (1)    #-1576   (1)    #-1585   (1)    
C_MODIFIED                     =00000002     223    (1)    #-1240   (1)    #-1379   (1)    #-1744   (1)    #-2302   (1)    
                                                           #-2739   (1)    
C_PAD_MOAT                     =00000109     230    (1)    #-2165   (1)    #-591    (1)    #-867    (1)    
C_SCREEN_LEN                   =00000050     229    (1)    #-978    (1)    
C_TPU_COM_LEN                  =0000001C     490    (1)    #-1707   (1)    
C_TRUE                         =FFFFFFFF     211    (1)    #-1003   (1)    #-1049   (1)    #-1115   (1)    #-1301   (1)    
                                                           #-1918   (1)    #-1971   (1)    #-2064   (1)    #-2117   (1)    
                                                           #-2146   (1)    #-2334   (1)    #-2631   (1)    #-2860   (1)    
                                                           #-2868   (1)    #-846    (1)    #-859    (1)    #-880    (1)    
                                                           #-893    (1)    #-905    (1)    #-935    (1)    
DC$_TERM                        00000000-XR                #-3334   (1)      65     (1)    
DECIMAL                         0000046E-R   1613   (1)    
DEFINITIONS                     00000486-R   1623   (1)    
DOWNLOOP                        0000125A-R   3074   (1)    
DROP                            0000049B-R   1631   (1)    
DSC$K_CLASS_S                   00000000-XR                  403    (1)      471    (1)      478    (1)      496    (1)    
                                                             66     (1)    
DSC$K_DTYPE_T                   00000000-XR                  402    (1)      470    (1)      477    (1)      495    (1)    
                                                             66     (1)    
DUP                             000004B5-R   1647   (1)    
ELSE                            00001296-R   3095   (1)    
ENABLE_CTRLC                    000014D9-R   3372   (1)      3341   (1)      3377   (1)    
ENDIF                           000012BE-R   3114   (1)    
ENDWHILE                        000012D7-R   3125   (1)    
EODP                            000004ED-R   1677   (1)    
EVE                             00000516-R   1701   (1)    
FAB$B_DNS                      =00000035                     435    (1)    
FAB$B_FNS                      =00000034                   #-1899   (1)      435    (1)    
FAB$C_BID                      =00000003                     412    (1)      435    (1)    
FAB$C_BLN                      =00000050                     412    (1)      435    (1)    
FAB$C_FIX                      =00000001                     435    (1)    
FAB$C_SEQ                      =00000000                     412    (1)      435    (1)    
FAB$C_VAR                      =00000002                     412    (1)    
FAB$L_ALQ                      =00000010                     412    (1)      435    (1)    
FAB$L_DNA                      =00000030                     435    (1)    
FAB$L_FNA                      =0000002C                   #-1897   (1)      435    (1)    
FAB$L_FOP                      =00000004                     412    (1)      435    (1)    
FAB$L_STS                      =00000008                   #-3597   (1)    
FAB$L_STV                      =0000000C                   #-3596   (1)    
FAB$V_CHAN_MODE                =00000002                     412    (1)      435    (1)    
FAB$V_FILE_MODE                =00000004                     412    (1)      435    (1)    
FAB$V_GET                      =00000001                     435    (1)    
FAB$V_LNM_MODE                 =00000000                     412    (1)      435    (1)    
FAB$V_UPD                      =00000003                     435    (1)    
FAB$W_GBC                      =00000048                     412    (1)      435    (1)    
FILL                            00000568-R   1730   (1)    
FORGET                          000005B9-R   1768   (1)    
FREEMEM                         00000667-R   1819   (1)    
HEX                             0000068B-R   1837   (1)    
HLD                             0000069B-R   1845   (1)    
HOLD                            000006AC-R   1853   (1)      2367   (1)      580    (1)    
IF                              000012FA-R   3148   (1)    
IO$M_CTRLCAST                   00000000-XR                #-3341   (1)    #-3377   (1)      67     (1)    
IO$_SETMODE                     00000000-XR                #-3341   (1)    #-3377   (1)      67     (1)    
I_AC_COLON                      000003BE-R   1092   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 165
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

I_ADD                           000000C1-R   675    (1)    
I_BIT_AND                       00000072-R   621    (1)    
I_BIT_NOT                       00000083-R   631    (1)    
I_BIT_OR                        00000090-R   639    (1)    
I_BIT_XOR                       0000009E-R   647    (1)    
I_BL                            00000035-R   1201   (1)    
I_BLOCK_CLOSE                   000000D9-R   1274   (1)    
I_BLOCK_OPEN                    0000010B-R   1289   (1)    
I_BLOCK_READ                    00000151-R   1309   (1)      1422   (1)    
I_BLOCK_WRITE                   00000183-R   1324   (1)      1437   (1)    
I_BS_FETCH                      000001CF-R   1351   (1)    
I_BUFFER_READ                   00000256-R   1413   (1)      1257   (1)    
I_BUFFER_WRITE                  00000292-R   1430   (1)      1248   (1)      1387   (1)      1749   (1)      2307   (1)    
I_B_COMMA                       00000457-R   1164   (1)    
I_B_FETCH                       FFFFFFFF-R   1173   (1)    
I_B_STORE                       00000447-R   1154   (1)    
I_B_UP                          000011D3-R   3010   (1)    
I_COLON                         000001FB-R   840    (1)    
I_COMMA                         000000F5-R   705    (1)    
I_COMPILE_ASCII                 00001434-R   3295   (1)    
I_COMPILE_JSB                   0000033F-R   1499   (1)      3215   (1)      3541   (1)    
I_COUNT_BEGIN                   00000064-R   613    (1)    
I_COUNT_END                     000000B3-R   664    (1)    
I_DEFER_BEGIN                   000011F5-R   3030   (1)    
I_DEFER_END                     0000118A-R   2975   (1)    
I_DIVIDE                        000001C0-R   801    (1)    
I_DIV_MOD                       000001CD-R   810    (1)      578    (1)    
I_DO                            00001225-R   3054   (1)    
I_DOT                           00000123-R   733    (1)      1821   (1)      3574   (1)      772    (1)      789    (1)    
                                                             946    (1)    
I_DOT_LPAREN                    0000015A-R   752    (1)    
I_DOT_QUOTE                     0000111E-R   2930   (1)    
I_DOT_SB                        00000179-R   765    (1)    
I_DOT_ST                        0000019D-R   783    (1)    
I_DS_TO_LS                      000004A9-R   1639   (1)    
I_EMPTY_BUFFERS                 000004CB-R   1655   (1)    
I_EODP_PLUS_STORE               0000050A-R   1693   (1)    
I_EOD_STORE                     000004FB-R   1685   (1)    
I_EQUAL                         00000264-R   887    (1)    
I_EQUAL_TEXT                    0000027F-R   901    (1)    
I_EXIT                          0000055C-R   1723   (1)    
I_FETCH                         00000394-R   1064   (1)    
I_FLUSH_BUFFERS                 00000586-R   1741   (1)    
I_FORGET_ERASE                  00000611-R   1794   (1)    
I_GREATER_EQUAL                 000002B3-R   929    (1)    
I_GRETER                        0000029F-R   916    (1)    
I_HALT                          0000067D-R   1828   (1)    
I_I_TO                          000006C4-R   1865   (1)    
I_LEFT_BRACK                    00001420-R   3287   (1)    
I_LESS                          00000221-R   853    (1)    
I_LESS_EQUAL                    0000024D-R   874    (1)    
I_LESS_SHARP                    00000239-R   866    (1)      736    (1)    
I_LONG                          0000078F-R   1927   (1)    
I_LOOP                          00001355-R   3192   (1)    
I_LS_TO_DS                      000007CF-R   1952   (1)    
I_L_UP                          0000131C-R   3164   (1)    
I_MATCH                         000007DD-R   1961   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 166
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

I_MINUS_ROT                     0000010C-R   722    (1)    
I_MOVE_FILL                     00000879-R   2039   (1)    
I_MULTIPLY                      000000A8-R   655    (1)    
I_ONE_MINUS                     000001F2-R   830    (1)    
I_ONE_PLUS                      000001E8-R   822    (1)    
I_PLUS_LOOP                     000010EA-R   2910   (1)    
I_PLUS_ROT                      000000DE-R   694    (1)    
I_PLUS_STORE                    000000CC-R   683    (1)    
I_QUESTION                      000002CA-R   944    (1)    
I_RIGHT_BACK                    000010B5-R   2867   (1)    
I_SAVE_BUFFERS                  00000AF2-R   2299   (1)    
I_SEMICOLON                     00001170-R   2960   (1)    
I_SHARP                         00000015-R   576    (1)      602    (1)    
I_SHARP_GREATER                 00000036-R   588    (1)      740    (1)    
I_SHARP_S                       00000055-R   601    (1)    #-604    (1)      737    (1)    
I_SHORT                         00000B57-R   2348   (1)    
I_SP_0                          00000BB6-R   2397   (1)    
I_SP_FETCH                      00000BAA-R   2387   (1)    
I_STORE                         00000006-R   565    (1)    
I_STRING_QUOTE                  00000DB5-R   2578   (1)    
I_SUBTRACT                      000000FF-R   713    (1)    
I_S_UP                          000013B2-R   3233   (1)    
I_VARIABLE                      000010CD-R   2893   (1)    
I_WORD_FETCH                    00000ACF-R   2283   (1)    
I_WORD_STORE                    00000AB1-R   2265   (1)    
I_WS_FETCH                      00000ADC-R   2291   (1)    
I_W_COMMA                       00000AC1-R   2274   (1)    
KERNEL                          000006D3-R   1873   (1)    
LEAVE                           000006E9-R   1881   (1)    
LIB$GET_INPUT                   00000000-XR                  2214   (1)      2247   (1)      2451   (1)      69     (1)    
LIB$PUT_OUTPUT                  00000000-XR                  1560   (1)      1909   (1)      2812   (1)      2835   (1)    
                                                             3431   (1)      3445   (1)      3549   (1)      3556   (1)    
                                                             69     (1)    
LIB$SIGNAL                      00000000-XR                  1715   (1)      3365   (1)      3379   (1)      3592   (1)    
                                                             3598   (1)      3604   (1)      69     (1)    
LIB$_INPSTRTRU                  00000000-XR                #-2215   (1)    #-2248   (1)      68     (1)    
LITERAL                         0000133C-R   3179   (1)      1000   (1)      1943   (1)      3299   (1)    
LOAD                            000006F7-R   1890   (1)    
LONGCONST                       000007B7-R   1941   (1)    
MAX                             00000808-R   1983   (1)    
MESSAGE                         00000822-R   1997   (1)    
MIN                             00000835-R   2006   (1)    
MOD                             0000084B-R   2019   (1)    
MOVE                            00000861-R   2029   (1)    
NCHR                           =00000007     3295   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1173   (1)      1183   (1)    
                                                             1193   (1)      1201   (1)      1209   (1)      1220   (1)    
                                                             1274   (1)      1289   (1)      1309   (1)      1324   (1)    
                                                             1343   (1)      1351   (1)      1359   (1)      1413   (1)    
                                                             1430   (1)      1444   (1)      1461   (1)      1473   (1)    
                                                             1499   (1)      1512   (1)      1534   (1)      1545   (1)    
                                                             1555   (1)      1570   (1)      1603   (1)      1613   (1)    
                                                             1623   (1)      1631   (1)      1639   (1)      1647   (1)    
                                                             1655   (1)      1677   (1)      1685   (1)      1693   (1)    
                                                             1701   (1)      1723   (1)      1730   (1)      1741   (1)    
                                                             1768   (1)      1794   (1)      1819   (1)      1828   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 167
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                                             1837   (1)      1845   (1)      1853   (1)      1865   (1)    
                                                             1873   (1)      1881   (1)      1890   (1)      1927   (1)    
                                                             1941   (1)      1952   (1)      1961   (1)      1983   (1)    
                                                             1997   (1)      2006   (1)      2019   (1)      2029   (1)    
                                                             2039   (1)      2050   (1)      2058   (1)      2073   (1)    
                                                             2127   (1)      2135   (1)      2154   (1)      2164   (1)    
                                                             2172   (1)      2189   (1)      2197   (1)      2229   (1)    
                                                             2257   (1)      2265   (1)      2274   (1)      2283   (1)    
                                                             2291   (1)      2299   (1)      2322   (1)      2348   (1)    
                                                             2363   (1)      2376   (1)      2387   (1)      2397   (1)    
                                                             2405   (1)      2421   (1)      2439   (1)      2488   (1)    
                                                             2514   (1)      2538   (1)      2559   (1)      2578   (1)    
                                                             2607   (1)      2620   (1)      2642   (1)      2654   (1)    
                                                             2675   (1)      2715   (1)      2727   (1)      2737   (1)    
                                                             2751   (1)      2764   (1)      2788   (1)      2804   (1)    
                                                             2847   (1)      2867   (1)      2893   (1)      2910   (1)    
                                                             2930   (1)      2960   (1)      2975   (1)      2991   (1)    
                                                             3010   (1)      3030   (1)      3054   (1)      3074   (1)    
                                                             3095   (1)      3114   (1)      3125   (1)      3148   (1)    
                                                             3164   (1)      3179   (1)      3192   (1)      3212   (1)    
                                                             3223   (1)      3233   (1)      3250   (1)      3268   (1)    
                                                             3287   (1)      3295   (1)      565    (1)      576    (1)    
                                                             588    (1)      601    (1)      613    (1)      621    (1)    
                                                             631    (1)      639    (1)      647    (1)      655    (1)    
                                                             664    (1)      675    (1)      683    (1)      694    (1)    
                                                             705    (1)      713    (1)      722    (1)      733    (1)    
                                                             752    (1)      765    (1)      783    (1)      801    (1)    
                                                             810    (1)      822    (1)      830    (1)      840    (1)    
                                                             853    (1)      866    (1)      874    (1)      887    (1)    
                                                             901    (1)      916    (1)      929    (1)      944    (1)    
                                                             953    (1)      965    (1)      976    (1)      993    (1)    
NEGAGE                          00000892-R   2050   (1)    
NOT                             0000089E-R   2058   (1)    
NUMBER                          000008B9-R   2073   (1)      3013   (1)      3167   (1)      3236   (1)      994    (1)    
OCTAL                           00000939-R   2127   (1)    
OP_ACBL                        =000000F1     238    (1)    #-2911   (1)    #-3075   (1)    #-3193   (1)    
OP_ADDL2                       =000000C0     239    (1)    #-2920   (1)    #-2980   (1)    #-3085   (1)    #-3202   (1)    
OP_BNEQ                        =00000012     240    (1)    #-3151   (1)    #-3253   (1)    #-3272   (1)    
OP_BRW                         =00000031     241    (1)    #-2935   (1)    #-2996   (1)    #-3039   (1)    #-3096   (1)    
                                                           #-3126   (1)    #-3153   (1)    #-3255   (1)    #-3274   (1)    
OP_JSB                         =00000016     242    (1)    #-1500   (1)    #-2950   (1)    
OP_MOVAB                       =0000009E     243    (1)    #-1131   (1)    #-1446   (1)    #-2894   (1)    #-2931   (1)    
OP_MOVAL                       =000000DE     244    (1)    #-1929   (1)    #-2791   (1)    
OP_MOVAW                       =0000003E     245    (1)    #-2350   (1)    #-2561   (1)    #-2580   (1)    
OP_MOVB                        =00000090     246    (1)    #-1094   (1)    #-2753   (1)    
OP_MOVC3                       =00000028     247    (1)    #-3031   (1)    
OP_MOVL                        =000000D0     248    (1)    #-2945   (1)    #-3055   (1)    #-3058   (1)    #-3061   (1)    
                                                           #-3180   (1)    
OP_RSB                         =00000005     249    (1)    #-1098   (1)    #-1135   (1)    #-1450   (1)    #-1595   (1)    
                                                           #-1933   (1)    #-1944   (1)    #-2354   (1)    #-2565   (1)    
                                                           #-2584   (1)    #-2757   (1)      2796   (1)    #-2898   (1)    
                                                           #-2961   (1)    
OP_TSTL                        =000000D5     250    (1)    #-3149   (1)    #-3251   (1)    #-3270   (1)    
OR                              00000948-R   2135   (1)    
OTS$CVT_L_TI                    00000000-XR                  70     (1)    
OVER                            00000968-R   2154   (1)    
PAD                             00000975-R   2164   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 168
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

PUTC                            00000987-R   2172   (1)      1485   (1)      2776   (1)      743    (1)    
Q_CR                            000002DB-R   953    (1)      3475   (1)    
Q_DUP                           000002F3-R   965    (1)    
Q_NUMBER                        0000032C-R   993    (1)      3509   (1)    
Q_N_CR                          00000305-R   976    (1)      1482   (1)      2773   (1)    
Q_SEARCH                        0000035B-R   1014   (1)      3504   (1)    
RAB$B_RAC                      =0000001E                     419    (1)      442    (1)    
RAB$C_BID                      =00000001                     419    (1)      442    (1)    
RAB$C_BLN                      =00000044                     419    (1)      442    (1)    
RAB$C_KEY                      =00000001                     442    (1)    
RAB$C_SEQ                      =00000000                     419    (1)    
RAB$L_CTX                      =00000018                     419    (1)      442    (1)    
RAB$L_RBF                      =00000028                   #-1326   (1)    
RAB$L_ROP                      =00000004                     419    (1)      442    (1)    
RAB$L_STS                      =00000008                   #-3603   (1)    
RAB$L_STV                      =0000000C                   #-3602   (1)    
RAB$L_UBF                      =00000024                   #-1311   (1)    
RAB$V_RAH                      =00000009                     419    (1)    
RAB$W_RSZ                      =00000022                   #-1330   (1)    #-2470   (1)    #-2472   (1)    
RADIX                           000009BE-R   2189   (1)    
READ                            000009CF-R   2197   (1)    
READSTR                         00000A43-R   2229   (1)    
RECURSE                         0000138C-R   3212   (1)    
REPEAT                          000013A7-R   3223   (1)    
RESTART                         00000AA7-R   2257   (1)    
RMS$_EOF                        00000000-XR                #-2453   (1)    #-2464   (1)      71     (1)    
RMS$_FNF                        00000000-XR                #-1906   (1)      71     (1)    
R_WARM_START                    000015E4-R   3451   (1)    #-1073   (1)    #-1716   (1)    #-1786   (1)    #-1813   (1)    
                                                           #-2258   (1)    #-3550   (1)    #-3557   (1)    #-3581   (1)    
SEARCH                          00000B1F-R   2322   (1)      1040   (1)      1046   (1)      1772   (1)      1798   (1)    
                                                           #-2338   (1)    
SIGN                            00000B7C-R   2363   (1)      739    (1)    
SMUDGE                          00000B93-R   2376   (1)      845    (1)    
SPACE                           00000BC8-R   2405   (1)      2426   (1)    
SPACES                          00000C01-R   2421   (1)    
SREAD                           00000C21-R   2439   (1)      2682   (1)    
STRCAT                          00000CDE-R   2488   (1)    
STRCMP                          00000D1F-R   2514   (1)    
STRCPY                          00000D58-R   2538   (1)    
STRING                          00000D8A-R   2559   (1)    
STRMAX                          00000DFD-R   2607   (1)    
STRPOS                          00000E10-R   2620   (1)    
SWAP                            00000E43-R   2642   (1)    
SYS$ASSIGN                      00000000-XR                  3326   (1)    
SYS$CLOSE                       00000000-XR                  1277   (1)      2477   (1)      3465   (1)      3607   (1)    
SYS$CONNECT                     00000000-XR                  1297   (1)      1902   (1)    
SYS$EXIT                        00000000-XR                  3409   (1)      3612   (1)    
SYS$FIND                        00000000-XR                  1331   (1)    
SYS$GET                         00000000-XR                  1314   (1)      2462   (1)    
SYS$GETCHN                      00000000-XR                  3332   (1)    
SYS$OPEN                        00000000-XR                  1293   (1)      1900   (1)    
SYS$PUTMSG                      00000000-XR                  3392   (1)      3408   (1)    
SYS$QIO                         00000000-XR                  3341   (1)      3377   (1)    
SYS$UNWIND                      00000000-XR                  3400   (1)    
SYS$UPDATE                      00000000-XR                  1332   (1)    
S_COLD_START                    00001577-R   3422   (1)      3351   (1)    
S_TRAP                          0000150D-R   3387   (1)      3318   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 169
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

S_WARM_START                    000015BF-R   3441   (1)      3355   (1)    
TOCHAR                          00000E5A-R   2654   (1)      579    (1)    
TOKEN                           00000E7B-R   2675   (1)      1146   (1)      1575   (1)      1703   (1)      1770   (1)    
                                                             1796   (1)      1892   (1)      2591   (1)      2939   (1)    
                                                             3012   (1)      3166   (1)      3235   (1)      3297   (1)    
                                                             3495   (1)      3517   (1)      3523   (1)      754    (1)    
TPU$TPU                         00000000-XR                  1710   (1)      72     (1)    
UNLINK                          00000EFF-R   2715   (1)      3457   (1)    
UNSMUDGE                        00000F1B-R   2727   (1)      2964   (1)    
UNTIL                           000013D3-R   3250   (1)    
UPDATE                          00000F35-R   2737   (1)    
V1_COMPILER                    =FFFFFFFC     3250   (1)      3250   (1)    
V1_KERNEL                      =FFFFFFFC     2867   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1183   (1)      1193   (1)    
                                                             1201   (1)      1209   (1)      1220   (1)      1274   (1)    
                                                             1289   (1)      1309   (1)      1324   (1)      1343   (1)    
                                                             1351   (1)      1359   (1)      1413   (1)      1430   (1)    
                                                             1444   (1)      1461   (1)      1473   (1)      1499   (1)    
                                                             1512   (1)      1534   (1)      1545   (1)      1555   (1)    
                                                             1570   (1)      1603   (1)      1613   (1)      1623   (1)    
                                                             1631   (1)      1639   (1)      1647   (1)      1655   (1)    
                                                             1677   (1)      1685   (1)      1693   (1)      1701   (1)    
                                                             1723   (1)      1730   (1)      1741   (1)      1768   (1)    
                                                             1794   (1)      1819   (1)      1828   (1)      1837   (1)    
                                                             1845   (1)      1853   (1)      1865   (1)      1873   (1)    
                                                             1881   (1)      1890   (1)      1927   (1)      1941   (1)    
                                                             1952   (1)      1961   (1)      1983   (1)      1997   (1)    
                                                             2006   (1)      2019   (1)      2029   (1)      2039   (1)    
                                                             2050   (1)      2058   (1)      2073   (1)      2127   (1)    
                                                             2135   (1)      2154   (1)      2164   (1)      2172   (1)    
                                                             2189   (1)      2197   (1)      2229   (1)      2257   (1)    
                                                             2265   (1)      2274   (1)      2283   (1)      2291   (1)    
                                                             2299   (1)      2322   (1)      2348   (1)      2363   (1)    
                                                             2376   (1)      2387   (1)      2397   (1)      2405   (1)    
                                                             2421   (1)      2439   (1)      2488   (1)      2514   (1)    
                                                             2538   (1)      2559   (1)      2578   (1)      2607   (1)    
                                                             2620   (1)      2642   (1)      2654   (1)      2675   (1)    
                                                             2715   (1)      2727   (1)      2737   (1)      2751   (1)    
                                                             2764   (1)      2788   (1)      2804   (1)      2847   (1)    
                                                             2867   (1)      565    (1)      576    (1)      588    (1)    
                                                             601    (1)      613    (1)      621    (1)      631    (1)    
                                                             639    (1)      647    (1)      655    (1)      664    (1)    
                                                             675    (1)      683    (1)      694    (1)      705    (1)    
                                                             713    (1)      722    (1)      733    (1)      752    (1)    
                                                             765    (1)      783    (1)      801    (1)      810    (1)    
                                                             822    (1)      830    (1)      840    (1)      853    (1)    
                                                             866    (1)      874    (1)      887    (1)      901    (1)    
                                                             916    (1)      929    (1)      944    (1)      953    (1)    
                                                             965    (1)      976    (1)      993    (1)    
VARIABLE                        00000F4F-R   2751   (1)    
VLIST                           00000F70-R   2764   (1)    
VL_COMPILER                    =FFFFFFFC     3295   (1)      2893   (1)      2910   (1)      2930   (1)      2960   (1)    
                                                             2975   (1)      2991   (1)      3010   (1)      3030   (1)    
                                                             3054   (1)      3074   (1)      3095   (1)      3114   (1)    
                                                             3125   (1)      3148   (1)      3164   (1)      3179   (1)    
                                                             3192   (1)      3212   (1)      3223   (1)      3233   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 170
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                                             3268   (1)      3287   (1)      3295   (1)    #-3427   (1)    
VL_KERNEL                      =00000000     282    (1)    #-3428   (1)    
VOCABULARY                      00000FB3-R   2788   (1)    
VTIL                            00001444-R   3315   (1)    
VTIL_CTRLC                      00000000-XR                #-3378   (1)      73     (1)    
VTIL_EXIT                       000014CF-R   3363   (1)    #-3328   (1)    #-3343   (1)    
VTIL_MAXERRORS                  00000000-XR                #-3404   (1)      73     (1)    
V_BLKBUFF                       00004000-R   3630   (1)    #-1265   (1)    #-1402   (1)    #-1417   (1)    #-1435   (1)    
                                                             442    (1)    
V_BLKFAB                        00001AE0-R   430    (1)      1277   (1)      1293   (1)      442    (1)    
V_BLKKEY                        00001B74-R   443    (1)    #-1313   (1)    #-1328   (1)    
V_BLKRAB                        00001B30-R   436    (1)      1297   (1)    #-1311   (1)      1314   (1)    #-1326   (1)    
                                                           #-1330   (1)      1331   (1)      1332   (1)    
V_BLOCKIO                       00001B78-R   445    (1)    #-1275   (1)    #-1281   (1)    #-1290   (1)    #-1301   (1)    
V_BUF_BLK_NUMS                  00001B80-R   452    (1)    #-1225   (1)    #-1253   (1)    #-1364   (1)    #-1395   (1)    
                                                           #-1419   (1)    #-1432   (1)    #-1661   (1)    
V_BUF_INUSE                     00001B7D-R   450    (1)    #-1234   (1)    #-1241   (1)    #-1255   (1)    #-1373   (1)    
                                                           #-1380   (1)    #-1397   (1)    #-1659   (1)    #-1745   (1)    
                                                           #-1752   (1)    #-2303   (1)    #-2310   (1)    #-2740   (1)    
V_COMPILER                      00001D3F-R   533    (1)    #-1045   (1)    #-1474   (1)    #-1515   (1)    #-1516   (1)    
                                                           #-3427   (1)    
V_CONTEXT                       00001D37-R   529    (1)    #-1032   (1)      1535   (1)    #-1624   (1)    #-1771   (1)    
                                                           #-1776   (1)    #-1797   (1)    #-1802   (1)    #-1874   (1)    
                                                           #-2765   (1)    #-2789   (1)      2795   (1)    #-3213   (1)    
                                                           #-3432   (1)    #-3446   (1)    #-841    (1)    
V_CTRLC_DEPTH                   00001D2B-R   523    (1)    
V_CURRENT                       00001D3B-R   531    (1)    #-1513   (1)    #-1514   (1)    #-1571   (1)    #-1572   (1)    
                                                             1604   (1)    #-1624   (1)    #-2377   (1)    #-2716   (1)    
                                                           #-2717   (1)    #-2728   (1)    #-3433   (1)    #-3447   (1)    
                                                           #-841    (1)    
V_CURRENT_BUFF                  00001B79-R   447    (1)    #-1266   (1)    #-1403   (1)    #-1415   (1)    #-2738   (1)    
V_ERRORS                        00001D2F-R   525    (1)    #-3394   (1)    #-3395   (1)    
V_FILELINENUM                   00001D48-R   539    (1)    #-1919   (1)    #-2474   (1)    #-2479   (1)    #-3467   (1)    
                                                           #-3573   (1)    
V_FILENOTFOUND                  0000189A-R   377    (1)      1908   (1)    
V_FNAME                         00001A3D-R   422    (1)      1894   (1)      1896   (1)      3471   (1)    
V_FNAMELEN                      00001A3C-R   420    (1)    #-1895   (1)    #-1898   (1)    #-3472   (1)    
V_GETCHN_BUF                    00001D1F-R   515    (1)    #-3334   (1)      514    (1)    
V_GETCHN_BUF_ADR                00001D1B-R   513    (1)    
V_GETCHN_IN_BUF                 00001D17-R   510    (1)      3332   (1)    
V_GETCHN_RET_LEN                00001D13-R   508    (1)      3332   (1)    
V_GREETING                      00001800-R   361    (1)      3430   (1)      3444   (1)    
V_HLD                           00001D52-R   548    (1)      1846   (1)    #-1854   (1)    #-1855   (1)    #-589    (1)    
                                                           #-592    (1)    #-867    (1)    
V_INBUF                         000018F7-R   392    (1)      2444   (1)      3577   (1)      399    (1)      404    (1)    
                                                             419    (1)    
V_INFAB                         000019A8-R   411    (1)    #-1897   (1)    #-1899   (1)      1900   (1)      1912   (1)    
                                                             2477   (1)      3465   (1)      419    (1)    
V_INFILE                        00001D47-R   537    (1)    #-1918   (1)    #-2445   (1)    #-2478   (1)    #-3463   (1)    
                                                           #-3466   (1)    #-3571   (1)      3607   (1)    
V_INFILEMESS                    00001890-R   375    (1)      3468   (1)    
V_INLEN                         00001999-R   396    (1)      2448   (1)    #-2459   (1)    #-2471   (1)    #-2679   (1)    
                                                           #-2686   (1)    #-2690   (1)    #-2691   (1)    #-2693   (1)    
                                                           #-2700   (1)    #-2703   (1)    #-3461   (1)    
V_INPTR                         0000199B-R   398    (1)    #-2444   (1)      2679   (1)    #-2685   (1)      2690   (1)    
                                                             2698   (1)    #-2699   (1)    #-2705   (1)    
V_INPUT_CHAN                    00001D11-R   503    (1)      3326   (1)    #-3332   (1)    #-3341   (1)    #-3377   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 171
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

V_INPUT_NAME                    00001CFE-R   501    (1)      3326   (1)    
V_INRAB                         000019F8-R   415    (1)      1902   (1)      1915   (1)      2462   (1)      2467   (1)    
                                                           #-2470   (1)    #-2472   (1)    
V_IN_DSC                        0000199F-R   400    (1)      2450   (1)    
V_KERNEL                        00001D43-R   535    (1)      1874   (1)    #-3428   (1)      3432   (1)      3433   (1)    
                                                             3446   (1)      3447   (1)    
V_MODE                          00001D4D-R   544    (1)    #-1043   (1)    #-2868   (1)    #-2962   (1)    #-3288   (1)    
                                                           #-3455   (1)    #-3459   (1)    #-3530   (1)    #-846    (1)    
                                                           #-998    (1)    
V_NAMETOOLONG                   000018D8-R   383    (1)      1578   (1)    
V_NAMETRUNC                     000018E8-R   385    (1)      1586   (1)    
V_ORG_INLEN                     00001997-R   394    (1)    #-2459   (1)    #-2473   (1)    #-3462   (1)    #-3578   (1)    
V_OUTBUF                        00001B9A-R   481    (1)      1556   (1)    #-1557   (1)      2177   (1)      2207   (1)    
                                                             2238   (1)      2410   (1)      2808   (1)      2818   (1)    
                                                             2831   (1)    
V_OUTLEN                        00001B98-R   479    (1)    #-1562   (1)    #-2173   (1)    #-2178   (1)    #-2182   (1)    
                                                           #-2202   (1)    #-2208   (1)    #-2217   (1)    #-2233   (1)    
                                                           #-2239   (1)    #-2241   (1)    #-2406   (1)    #-2411   (1)    
                                                           #-2414   (1)    #-2440   (1)    #-2805   (1)    #-2809   (1)    
                                                           #-2814   (1)    #-2816   (1)    #-2823   (1)    #-2830   (1)    
                                                           #-2832   (1)    #-2836   (1)    #-954    (1)    #-977    (1)    
V_OVERMESS                      0000185A-R   369    (1)      3555   (1)    
V_RADIX                         00001D4E-R   546    (1)    #-1194   (1)    #-1614   (1)    #-1838   (1)    #-2104   (1)    
                                                           #-2106   (1)    #-2128   (1)      2190   (1)    #-577    (1)    
V_READADDR                      00001B92-R   472    (1)    #-2198   (1)    #-2199   (1)    
V_READDSC                       00001B8E-R   468    (1)      2213   (1)    
V_READLEN                       00001B8C-R   466    (1)      2200   (1)    #-2219   (1)    
V_RETURNSTACK                   00001D33-R   527    (1)    #-3423   (1)    #-3476   (1)    
V_STATE                         00001D4C-R   541    (1)    #-1049   (1)    #-3460   (1)    #-3530   (1)    #-3532   (1)    
                                                           #-3540   (1)    
V_STATIC_DSC                    00001B96-R   476    (1)    #-1558   (1)    #-2209   (1)    #-2232   (1)    #-2240   (1)    
                                                           #-2810   (1)    #-2833   (1)    
V_TPU_COM                       00001C3A-R   488    (1)      490    (1)      497    (1)    
V_TPU_COM2                      00001C56-R   491    (1)      1706   (1)    
V_TPU_DSC                       00001CF6-R   493    (1)    #-1708   (1)      1709   (1)    
V_TRAP_DEPTH                    00001D27-R   521    (1)    #-3399   (1)      3400   (1)    
V_UNDERMESS                     00001842-R   367    (1)      3548   (1)    
V_UNKNOWN                       00001871-R   371    (1)      3561   (1)    
V_UNKNOWN2                      00001883-R   373    (1)      3568   (1)    
V_UNKN_BLK_MESS                 000018B1-R   379    (1)    
V_USRPROMPT                     00001838-R   365    (1)    
V_VTILPROMPT                    0000182A-R   363    (1)      2449   (1)    
V_WORDNOTFOUND                  000018C7-R   381    (1)      1780   (1)      1807   (1)    
WHILE                           000013FC-R   3268   (1)    
WRITE                           00000FE9-R   2804   (1)      1483   (1)      1580   (1)      1583   (1)      1588   (1)    
                                                             1591   (1)      1782   (1)      1785   (1)      1809   (1)    
                                                             1812   (1)      1999   (1)      2774   (1)      2952   (1)    
                                                             3470   (1)      3473   (1)      3563   (1)      3567   (1)    
                                                             3570   (1)      3579   (1)      741    (1)      757    (1)    
XOR                             00001095-R   2847   (1)    
_CHECK_BASE                     000008FE-R   2103   (1)    #-2089   (1)    #-2095   (1)    
_CHECK_LOWERCASE                000008ED-R   2097   (1)    #-2093   (1)    
_COMPILER_END                   00001444-R   3303   (1)    
_DONE                           00001790-R   3607   (1)    
_ERROR_EXIT                     0000176A-R   3590   (1)    #-1279   (1)    #-1295   (1)    #-1299   (1)    #-1316   (1)    
                                                           #-1334   (1)    #-1830   (1)    #-2215   (1)    #-2248   (1)    
                                                           #-2457   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 172
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

_EXIT                           0000179D-R   3610   (1)    #-1724   (1)    #-2455   (1)    #-3599   (1)    
_F_ERR                          00001774-R   3596   (1)    #-1913   (1)    
_GETTOKEN                       00000EA2-R   2687   (1)    #-2677   (1)    
_INITIALIZE                     0000165B-R   3481   (1)    #-3434   (1)    
_INTERPRETER                    00001669-R   3493   (1)    #-3511   (1)    #-3518   (1)    #-3524   (1)    #-3538   (1)    
                                                           #-3543   (1)    
_INVALID_NUMBER                 0000092B-R   2119   (1)    #-2087   (1)    #-2091   (1)    #-2099   (1)    #-2101   (1)    
                                                           #-2105   (1)    
_KERNEL_BEGIN                   00000000-R   559    (1)    
_KERNEL_END                     000010BE-R   2872   (1)    
_NUMBER_TOP                     000008CF-R   2083   (1)    #-2079   (1)    #-2111   (1)    
_OVERFLOW                       000016FC-R   3553   (1)    #-3535   (1)    
_Q_EXECUTE                      000016AB-R   3527   (1)    #-3507   (1)    
_R_ERR                          00001783-R   3602   (1)    #-1916   (1)    #-2468   (1)    
_SKIPWHITESPACE                 00000E80-R   2678   (1)    #-2683   (1)    
_STARTFOUND                     00000E94-R   2684   (1)    #-2680   (1)    
_STRIP_COMMENT                  00001697-R   3515   (1)    #-3500   (1)    
_STRIP_COMMENT2                 000016A1-R   3521   (1)    #-3502   (1)    
_UNDERFLOW                      000016E8-R   3546   (1)    #-3537   (1)    
_UNKNOWNTOKEN                   00001710-R   3560   (1)    #-3512   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 173
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)


                                             +------------------------+
                                             ! Macros Cross Reference !
                                             +------------------------+

MACRO             SIZE          DEFINITION       REFERENCES... 
-----             ----          ----------       ------------- 
$$R_TABINIT       1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$$R_VBFSET        1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$ASNPUSH          1             3326   (1)       3326   (1)    
$ASSIGN_S         1             3325   (1)       3325   (1)    
$CHFDEF           2             74     (1)       74     (1)    
$CLOSE            1             1277   (1)       1277   (1)       2477   (1)       3465   (1)       3607   (1)    
$CONNECT          1             1297   (1)       1297   (1)       1902   (1)    
$DEFINI           1             74     (1)       412    (1)       419    (1)       74     (1)    
$EXIT_S           1             3409   (1)       3409   (1)       3612   (1)    
$FAB              4             412    (1)       412    (1)       431    (1)    
$FABDEF           1             412    (1)       412    (1)       435    (1)    
$FIND             1             1331   (1)       1331   (1)    
$GET              1             1314   (1)       1314   (1)       2462   (1)    
$GETCHN_S         1             3330   (1)       3330   (1)    
$OPEN             1             1293   (1)       1293   (1)       1900   (1)    
$PUSHADR          1             3326   (1)       3326   (1)       3332   (1)       3341   (1)       3377   (1)       3392   (1)    
                                                 3400   (1)       3408   (1)    
$PUSHTWO          1             3341   (1)       3341   (1)       3377   (1)    
$PUTMSG_S         1             3392   (1)       3392   (1)       3408   (1)    
$QIOPUSH          1             3341   (1)       3341   (1)       3377   (1)    
$QIO_S            1             3338   (1)       3338   (1)       3374   (1)    
$RAB              2             416    (1)       416    (1)       437    (1)    
$RABDEF           1             419    (1)       419    (1)       442    (1)    
$RMSCALL          2             1277   (1)       1277   (1)       1293   (1)       1297   (1)       1314   (1)       1331   (1)    
                                                 1332   (1)       1900   (1)       1902   (1)       2462   (1)       2477   (1)    
                                                 3465   (1)       3607   (1)    
$UNWIND_S         1             3400   (1)       3400   (1)    
$UPDATE           1             1332   (1)       1332   (1)    
HEADER            1             298    (1)       1014   (1)       1064   (1)       1072   (1)       1079   (1)       1092   (1)    
                                                 1110   (1)       1129   (1)       1144   (1)       1154   (1)       1164   (1)    
                                                 1173   (1)       1183   (1)       1193   (1)       1201   (1)       1209   (1)    
                                                 1220   (1)       1274   (1)       1289   (1)       1309   (1)       1324   (1)    
                                                 1343   (1)       1351   (1)       1359   (1)       1413   (1)       1430   (1)    
                                                 1444   (1)       1461   (1)       1473   (1)       1499   (1)       1512   (1)    
                                                 1534   (1)       1545   (1)       1555   (1)       1570   (1)       1603   (1)    
                                                 1613   (1)       1623   (1)       1631   (1)       1639   (1)       1647   (1)    
                                                 1655   (1)       1677   (1)       1685   (1)       1693   (1)       1701   (1)    
                                                 1723   (1)       1730   (1)       1741   (1)       1768   (1)       1794   (1)    
                                                 1819   (1)       1828   (1)       1837   (1)       1845   (1)       1853   (1)    
                                                 1865   (1)       1873   (1)       1881   (1)       1890   (1)       1927   (1)    
                                                 1941   (1)       1952   (1)       1961   (1)       1983   (1)       1997   (1)    
                                                 2006   (1)       2019   (1)       2029   (1)       2039   (1)       2050   (1)    
                                                 2058   (1)       2073   (1)       2127   (1)       2135   (1)       2154   (1)    
                                                 2164   (1)       2172   (1)       2189   (1)       2197   (1)       2229   (1)    
                                                 2257   (1)       2265   (1)       2274   (1)       2283   (1)       2291   (1)    
                                                 2299   (1)       2322   (1)       2348   (1)       2363   (1)       2376   (1)    
                                                 2387   (1)       2397   (1)       2405   (1)       2421   (1)       2439   (1)    
                                                 2488   (1)       2514   (1)       2538   (1)       2559   (1)       2578   (1)    
                                                 2607   (1)       2620   (1)       2642   (1)       2654   (1)       2675   (1)    
                                                 2715   (1)       2727   (1)       2737   (1)       2751   (1)       2764   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 14:00:12  VAX MACRO V5.4-3            Page 174
Cross reference                                                          10-AUG-2023 17:59:31  [MPL.TKB.VTIL]VTIL.MAR;107        (1)

                                                 2788   (1)       2804   (1)       2847   (1)       2867   (1)       2893   (1)    
                                                 2910   (1)       2930   (1)       2960   (1)       2975   (1)       2991   (1)    
                                                 3010   (1)       3030   (1)       3054   (1)       3074   (1)       3095   (1)    
                                                 3114   (1)       3125   (1)       3148   (1)       3164   (1)       3179   (1)    
                                                 3192   (1)       3212   (1)       3223   (1)       3233   (1)       3250   (1)    
                                                 3268   (1)       3287   (1)       3295   (1)       565    (1)       576    (1)    
                                                 588    (1)       601    (1)       613    (1)       621    (1)       631    (1)    
                                                 639    (1)       647    (1)       655    (1)       664    (1)       675    (1)    
                                                 683    (1)       694    (1)       705    (1)       713    (1)       722    (1)    
                                                 733    (1)       752    (1)       765    (1)       783    (1)       801    (1)    
                                                 810    (1)       822    (1)       830    (1)       840    (1)       853    (1)    
                                                 866    (1)       874    (1)       887    (1)       901    (1)       916    (1)    
                                                 929    (1)       944    (1)       953    (1)       965    (1)       976    (1)    
                                                 993    (1)    
ISERROR           1             315    (1)    
ISSTRERR          1             326    (1)       2215   (1)       2248   (1)    
NEWPAGE           1             39     (1)       137    (1)       202    (1)       284    (1)       2873   (1)       3304   (1)    
                                                 334    (1)       3412   (1)       3487   (1)       3584   (1)       3615   (1)    
                                                 551    (1)       58     (1)       77     (1)    

                                             +------------------------+
                                             ! Performance indicators !
                                             +------------------------+

Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------------   
Initialization                   34     00:00:00.02    00:00:00.04
Command processing              885     00:00:00.02    00:00:00.02
Pass 1                          827     00:00:00.56    00:00:00.66
Symbol table sort                 0     00:00:00.04    00:00:00.04
Pass 2                           79     00:00:00.28    00:00:00.30
Symbol table output               0     00:00:00.00    00:00:00.00
Psect synopsis output             0     00:00:00.00    00:00:00.00
Cross-reference output           10     00:00:00.07    00:00:00.08
Assembler run totals           1839     00:00:00.99    00:00:01.14

The working set limit was 3200 pages.
232137 bytes (454 pages) of virtual memory were used to buffer the intermediate code.
There were 50 pages of symbol table space allocated to hold 720 non-local and 109 local symbols.
3639 source lines were read in Pass 1, producing 59 object records in Pass 2.
49 pages of virtual memory were used to define 34 macros.

                                            +--------------------------+
                                            ! Macro library statistics !
                                            +--------------------------+

Macro library name                           Macros defined      
------------------                           --------------      
SYS$COMMON:[SYSLIB]STARLET.MLB;2                       27        

751 GETS were required to define 27 macros.

There were no errors, warnings or information messages.

MACRO/LIST/CROSS/OBJECT=VTIL.OBJ/SHOW=EXPANSION VTIL.MAR
