VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   0
Table of contents

    (1)       58        External Symbols
    (1)       77        General Notes
    (1)      137        Implementation Notes
    (1)      202        Constants
    (1)      284        Macros
    (1)      334        Data Section
    (1)      551        Kernel Built-ins
    (1)     2873        cCompiler Built-ins
    (1)     3304        Enter VTIL
    (1)     3412        Initialization
    (1)     3487        Interpreter
    (1)     3584        Exit Routines
    (1)     3615        Dictionary Space
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   1
V1.01                                                                    12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000     1 ;
                                     0000     2 .title	VTIL VAX Threaded Interpretive Language
                                     0000     3 	.ident	/v1.01/			; version number
                                     0000     4 ;******************************************************************************
                                     0000     5 ;
                                     0000     6 ; VTIL -- VAX Threaded Interpretive Language
                                     0000     7 ;
                                     0000     8 ;	Program:	V T I L . MAR
                                     0000     9 ;	Written By:	Thomas Kurt Bond
                                     0000    10 ;	Version:	v1.01
                                     0000    11 ;	Date:		7 February 1988
                                     0000    12 ;
                                     0000    13 ; Description:
                                     0000    14 ;     This program was written for my Senior Seminar Project at West Virginia
                                     0000    15 ; Wesleyan College in the spring of 1988.
                                     0000    16 ;
                                     0000    17 ;     This program implements a Threaded Interpretive Language (TIL) in
                                     0000    18 ; VAX Macro, using subroutine threading.  Essentially, it is an interactive
                                     0000    19 ; compiler.
                                     0000    20 ;
                                     0000    21 ; History
                                     0000    22 ; Ver	  When	   Who	What
                                     0000    23 ; 1.00	  020788   tkb	Initial version.
                                     0000    24 ; 1.01	  021288   tkb	Uses a smudge bit to prevent word being defined from
                                     0000    25 ;			being found while defining it.	({ recurse } allows
                                     0000    26 ;			recursion.)  Also limits length of names to 80 characters
                                     0000    27 ;			allowing the name-length byte to have the smudge bit
                                     0000    28 ;			in it.
                                     0000    29 ;******************************************************************************
                                     0000    30 ;!> VTIL.MAR -- VAX Threaded Interpretive Langague, an interactive compiler.
                                     0000    31 
                                     0000    32 ;
                                     0000    33 ; Set up source code formatting macros.
                                     0000    34 ;
                                     0000    35 
                                     0000    36 ;+++
                                     0000    37 ;m> newpage -- change the subtitle and move to a new page.
                                     0000    38 ;---
                                     0000    39 	.macro	newpage subtitle
                                     0000    40 	.page
                                     0000    41 	.sbttl	subtitle
                                     0000    42 	.endm
                                     0000    43 
                                     0000    44 ;******************************************************************************
                                     0000    45 ;
                                     0000    46 ; Conditional Assembly Control Symbols
                                     0000    47 ;
                                     0000    48 ;******************************************************************************
                           00000000  0000    49 ca_trapping = 0		; If this is defined, code for a condition handler
                                     0000    50 			; is assembled.	 We don't always want the condition
                                     0000    51 			; handler because it also catched breakpoints in the
                                     0000    52 			; debugger.
                           00000000  0000    53 ca_controlc = 0		; If this is defined, code to trap control/c and
                                     0000    54 			; return to the VTIL interpreter is assembled.
                                     0000    55 			; Note that this uses the trapping so it is useless
                                     0000    56 			; if `ca_trapping' is not defined.
                                     0000    57 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   2
V1.01                                                                    12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000    58 	newpage <External Symbols>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   3
V1.01                           External Symbols                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.sbttl	External Symbols
                                     0000       	
                                     0000    59 ;******************************************************************************
                                     0000    60 ;
                                     0000    61 ; External Symbols
                                     0000    62 ;
                                     0000    63 ;******************************************************************************
                                     0000    64 	.dsabl	global
                                     0000    65 	.extrn	dc$_term
                                     0000    66 	.extrn	dsc$k_dtype_t, dsc$k_class_s
                                     0000    67 	.extrn	io$_setmode, io$m_ctrlcast
                                     0000    68 	.extrn	lib$_inpstrtru
                                     0000    69 	.extrn	lib$get_input, lib$put_output, lib$signal
                                     0000    70 	.extrn	ots$cvt_l_ti
                                     0000    71 	.extrn	rms$_eof, rms$_fnf
                                     0000    72 	.extrn	tpu$tpu
                                     0000    73 	.extrn	vtil_ctrlc, vtil_maxerrors
                                     0000    74 	$chfdef				; condition handling facility
                                     0000       	$DEFINI	CHF,
                                     0000       	.SAVE	LOCAL_BLOCK
                                     0000       	.NOCROSS
                                     0000       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     0000       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   4
V1.01                           External Symbols                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF	12
                           0000000C  0000       	CHF$S_CHFDEF=12
                                     0000       	
                                     0000       $EQU	CHF$L_SIGARGLST	4
                           00000004  0000       	CHF$L_SIGARGLST=4
                                     0000       	
                                     0000       $EQU	CHF$L_MCHARGLST	8
                           00000008  0000       	CHF$L_MCHARGLST=8
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF1	12
                           0000000C  0000       	CHF$S_CHFDEF1=12
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_ARGS	0
                           00000000  0000       	CHF$IS_SIG_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_ARGS	0
                           00000000  0000       	CHF$L_SIG_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_NAME	4
                           00000004  0000       	CHF$IS_SIG_NAME=4
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_NAME	4
                           00000004  0000       	CHF$L_SIG_NAME=4
                                     0000       	
                                     0000       $EQU	CHF$IS_SIG_ARG1	8
                           00000008  0000       	CHF$IS_SIG_ARG1=8
                                     0000       	
                                     0000       $EQU	CHF$L_SIG_ARG1	8
                           00000008  0000       	CHF$L_SIG_ARG1=8
                                     0000       	
                                     0000       $EQU	CHF$S_CHFDEF2	20
                           00000014  0000       	CHF$S_CHFDEF2=20
                                     0000       	
                                     0000       $EQU	CHF$IS_MCH_ARGS	0
                           00000000  0000       	CHF$IS_MCH_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_ARGS	0
                           00000000  0000       	CHF$L_MCH_ARGS=0
                                     0000       	
                                     0000       $EQU	CHF$PH_MCH_FRAME	4
                           00000004  0000       	CHF$PH_MCH_FRAME=4
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_FRAME	4
                           00000004  0000       	CHF$L_MCH_FRAME=4
                                     0000       	
                                     0000       $EQU	CHF$IS_MCH_DEPTH	8
                           00000008  0000       	CHF$IS_MCH_DEPTH=8
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_DEPTH	8
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   5
V1.01                           External Symbols                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000008  0000       	CHF$L_MCH_DEPTH=8
                                     0000       	
                                     0000       $EQU	CHF$IH_MCH_SAVR0	12
                           0000000C  0000       	CHF$IH_MCH_SAVR0=12
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_SAVR0	12
                           0000000C  0000       	CHF$L_MCH_SAVR0=12
                                     0000       	
                                     0000       $EQU	CHF$IH_MCH_SAVR1	16
                           00000010  0000       	CHF$IH_MCH_SAVR1=16
                                     0000       	
                                     0000       $EQU	CHF$L_MCH_SAVR1	16
                           00000010  0000       	CHF$L_MCH_SAVR1=16
                                     0000       	
                                     0000       	$DEFEND	CHF,,DEF
                                     0000       	.MACRO	$CHFDEF A
                                     0000       	.ENDM	$CHFDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                     0000       	.RESTORE
                                     0000       	
                                     0000       	
                                     0000    75 
                                     0000    76 
                                     0000    77 newpage <General Notes>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   6
V1.01                           General Notes                            12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.sbttl	General Notes
                                     0000       	
                                     0000    78 ;******************************************************************************
                                     0000    79 ;
                                     0000    80 ; General Notes
                                     0000    81 ;
                                     0000    82 ;******************************************************************************
                                     0000    83 ;
                                     0000    84 ; Word -- A VTIL word is the equivalent of the procedure and/or function of
                                     0000    85 ; Pascal or other langauges.  (Context will have to determine whethere we
                                     0000    86 ; are talking about VTIL words or memory 2-byte words.)	   A word finds any
                                     0000    87 ; parameters it needs on the data stack, and leaves any result on the stack
                                     0000    88 ; also.	 VTIL words (or sequences of words) will be singled out from normal text
                                     0000    89 ; by enclosing them in { } pairs, since many of them include punctuation marks
                                     0000    90 ; that might be otherwise confusing.  Also, the string `...' inside a { }
                                     0000    91 ; pair will indicate a sequence of VTIL words omitted as irrelevent to the
                                     0000    92 ; explaination.
                                     0000    93 ;
                                     0000    94 ; Stack Comments.  A stack comment shows what a word expects to find on the
                                     0000    95 ; stack and what results it leaves on the stack after execution.
                                     0000    96 ; A stack comment looks like the following: ( n1 n2 -- n1 ).  The rightmost
                                     0000    97 ; item on each side of the `--' is the top of the stack, so the items in the
                                     0000    98 ; stack comment are in the same order as they would be if you entered them from
                                     0000    99 ; the terminal.	 The `--' separates the items that word expects to find on
                                     0000   100 ; the stack from the items that it leaves on the stack.	 Ex: After you enter
                                     0000   101 ; { 1 2 3 }, 3 is on the top of the stack.  In ( n1 n2 n3 -- x1 x2 ) n3 is
                                     0000   102 ; on top of the stack before the word executes, and x2 is on top of
                                     0000   103 ; the stack after that word executes.
                                     0000   104 ;
                                     0000   105 ; Items in stack comments:
                                     0000   106 ;	?	-- `?' is not an item on the stack itself.  Instead, it
                                     0000   107 ;		   indicates that items to the left of the `?' (further
                                     0000   108 ;		   down on the stack) may or may not be present, depending
                                     0000   109 ;		   on the value of items to the right of the `?' (which
                                     0000   110 ;		   are on top of the stack).  For instance, a stack comment
                                     0000   111 ;		   of ( a -- a ? f ) indicates that the word leaves a
                                     0000   112 ;		   flag on the top of the stack, and depending on the value
                                     0000   113 ;		   of the flag will also leave an address on the stack.
                                     0000   114 ;	a	-- address
                                     0000   115 ;	b	-- unsigned byte (integer, 1 byte)
                                     0000   116 ;	c	-- unsigned characcter (1 byte)
                                     0000   117 ;	f	-- boolean flag; 0 = false, true <> 0 (usually 1)
                                     0000   118 ;	l	-- long (integer, 4 bytes)
                                     0000   119 ;	n	-- integer (usually meaning number.  A longword)
                                     0000   120 ;	s	-- short (integer, 2 bytes)
                                     0000   121 ;
                                     0000   122 ;	Note that *all* stack items are at least a longword in width.
                                     0000   123 ;	a ( b ) stack item merely says that the programmer should consider
                                     0000   124 ;	the stack as containing a value that will fit in an unsigned
                                     0000   125 ;	byte.  Words that use data types that are smaller than a longword
                                     0000   126 ;	will only use th first part of the longword in their calculations,
                                     0000   127 ;	but will still pop the whole longword containing the smaller data
                                     0000   128 ;	type from the stack, not just the smaller data type.  In other words,
                                     0000   129 ;	the stack pointer can only be manipulated in 4 byte increments or
                                     0000   130 ;	decrements.
                                     0000   131 ;
                                     0000   132 ; Starting Vocabularies -- At the moment, there are only two starting
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   7
V1.01                           General Notes                            12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000   133 ; vocabularies `compiler' and `kernel', which are independent of each other.
                                     0000   134 ; All later vocabularies should be linked into one of thse.  But See v1_*.
                                     0000   135 ;
                                     0000   136 ;******************************************************************************
                                     0000   137 	newpage <Implementation Notes>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   8
V1.01                           Implementation Notes                     12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.sbttl	Implementation Notes
                                     0000       	
                                     0000   138 ;******************************************************************************
                                     0000   139 ;
                                     0000   140 ; Implementation Notes
                                     0000   141 ;
                                     0000   142 ;******************************************************************************
                                     0000   143 ;
                                     0000   144 ; r11, ds	-- data stack pointer
                                     0000   145 ; r10, ls	-- loop stack pointer
                                     0000   146 ; r9, eodp	-- end of dictionary pointer
                                     0000   147 ; r8-r4 are used for temporary storage when using character instructions.
                                     0000   148 ;
                                     0000   149 ; header format for a word
                                     0000   150 ;	long	-- back link to next word in dictionary (hfa, lfa)
                                     0000   151 ;	byte	-- count of name byes (nfa)
                                     0000   152 ;	byte(s) -- bytes of name
                                     0000   153 ;	code	-- executable code for this word (cfa)
                                     0000   154 ;	data	-- optional data for this word (pfa)
                                     0000   155 ;
                                     0000   156 ; Names
                                     0000   157 ; Since none of the VTIL kernel and compiler words contain underscores,
                                     0000   158 ; the following conventions were followed so there would be no conflict
                                     0000   159 ; between names in the MACRO-32 source and in the VTIL.	 For instance,
                                     0000   160 ; { context } is the name of a word in the kernel that pushes the address
                                     0000   161 ; of the current vocabulary variable on the stack.  However, the definition
                                     0000   162 ; of context in the MACRO source makes `context' a label wich jsb'ing to
                                     0000   163 ; executes the word, so `context' can't be used in MACRO as a label for
                                     0000   164 ; the variable as well.
                                     0000   165 ;
                                     0000   166 ;	<name>	   -- label of start of a VTIL word called <name>
                                     0000   167 ;	_<name>	   -- internal branch points
                                     0000   168 ;	adm_<name> -- addressing mode constant value
                                     0000   169 ;	c_<name>   -- constant value
                                     0000   170 ;	ca_<name>  -- conditional assembly control symbols
                                     0000   171 ;	i_<name>   -- label of start of a VTIL word whose <name> doesn't
                                     0000   172 ;		      otherwise fit this naming convention, du to the
                                     0000   173 ;		      character limitations in VAX MACRO symbols.
                                     0000   174 ;		      For eample, i_plus = { + }, i_plus_store = { +! }
                                     0000   175 ;	op_<name>  -- opcode constant value
                                     0000   176 ;	r_<name>   -- internal routine <name> that is readed by branching and
                                     0000   177 ;		      not by jumping to subroutine.
                                     0000   178 ;	s_<name>   --  internal subroutine that is reached by a call.
                                     0000   179 ;	q_<name>   -- label of start of a VTIL word with name `?<name>'.
                                     0000   180 ;	v_<name>   -- internal variable name.
                                     0000   181 ;	vl_<name>  -- internal vocabulary link symbol used by the header macro
                                     0000   182 ;		      to link built-in vocabularies together.
                                     0000   183 ;
                                     0000   184 ;	Names of words other than looping words or branching words that should
                                     0000   185 ;	occur in pairs generally have VTIL names like { name( } and
                                     0000   186 ;	{ )name } or { name< } and { >name } and internal names like
                                     0000   187 ;	i_name_begin and i_name_end.
                                     0000   188 ;
                                     0000   189 ; To make finding words easie, all the words have a header comment
                                     0000   190 ; like this:
                                     0000   191 ;	;+++
                                     0000   192 ;	;s> name -- explanation
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page   9
V1.01                           Implementation Notes                     12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000   193 ;	;---
                                     0000   194 ; where `s' is `c' for the compiler words, `k' for the kernel words,
                                     0000   195 ; `m' for macros, `r' for routines, and `s' for subroutines.
                                     0000   196 ;
                                     0000   197 ; The string `;??? starts an internal note to the programmer.  These notes
                                     0000   198 ; generally comment about an alternate method of doing something or suggest
                                     0000   199 ; areas that should be improved.  ~~~ indicates a note made while typing this back in.
                                     0000   200 ;
                                     0000   201 ;******************************************************************************
                                     0000   202 	newpage <Constants>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  10
V1.01                           Constants                                12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.sbttl	Constants
                                     0000       	
                                     0000   203 ;******************************************************************************
                                     0000   204 ;
                                     0000   205 ; Constants -- Symbol definitions for constant values
                                     0000   206 ;
                                     0000   207 ;******************************************************************************
                                     0000   208 ;
                                     0000   209 ; General constants
                                     0000   210 ;
                           FFFFFFFF  0000   211 c_true		= -1			; true value, actually anything
                                     0000   212 					;  but 0 is true
                           00000000  0000   213 c_false		= 0			; false value
                           00000014  0000   214 c_max_errs	= 20			; Maximum number of fatal errors allowed
                           00000050  0000   215 c_max_name_len	= 80			; Maximum length of word names
                           00000020  0000   216 c_blank		= 32			; ascii blank
                           0000005C  0000   217 c_com1_begin	= ^a/\/			; start first type of comment with `\'
                           00000000  0000   218 c_com1_end	= 0			; end w/something not in a line of text
                                     0000   219 					; so it will skip the whole line
                           00000028  0000   220 c_com2_begin	= ^a/(/			; start second type of comment with `('
                           00000029  0000   221 c_com2_end	= ^a/)/			; end with `)'
                           00000001  0000   222 c_inuse		= 1			; buffer in use flag
                           00000002  0000   223 c_modified	= 2			; bufffer updated flag
                           00000003  0000   224 c_max_blocks	= 3			; number of block i/o buffers
                           00000400  0000   225 c_block_size	= 1024			; size for block i/o buffer
                           00000004  0000   226 c_keysize	= 4			; size of key (longword record number)
                           00000002  0000   227 c_d_blks_in_blk = c_block_size / 512	; number of disk blocks in VTIL block
                           000000A0  0000   228 c_max_len	= 160			; maximum length of input line
                           00000050  0000   229 c_screen_len	= 80			; screen is 80 chars wide
                           00000109  0000   230 c_pad_moat	= 265			; distance of pad from eodp
                           00001000  0000   231 c_ds_size	= 1024 * 4		; data stack size: 1024 items of
                                     0000   232 					; 4 bytes each
                           00000800  0000   233 c_ls_size	= 512 * 4		; loop stack size: 512 items of
                                     0000   234 					; 4 bytes each
                                     0000   235 ;
                                     0000   236 ; opcodes == constants for compiling opcodes into dictionary
                                     0000   237 ;
                           000000F1  0000   238 op_acbl		= ^xf1
                           000000C0  0000   239 op_addl2	= ^xc0
                           00000012  0000   240 op_bneq		= ^x12
                           00000031  0000   241 op_brw		= ^x31
                           00000016  0000   242 op_jsb		= ^x16
                           0000009E  0000   243 op_movab	= ^x9e
                           000000DE  0000   244 op_moval	= ^xde
                           0000003E  0000   245 op_movaw	= ^x3e
                           00000090  0000   246 op_movb		= ^x90
                           00000028  0000   247 op_movc3	= ^x28
                           000000D0  0000   248 op_movl		= ^xd0
                           00000005  0000   249 op_rsb		= ^x05
                           000000D5  0000   250 op_tstl		= ^xd5
                                     0000   251 ;
                                     0000   252 ; addressing modes -- constants for compiling addressing modes into dictionary.
                                     0000   253 ;	In order by register and addressing mode.
                                     0000   254 ;
                           00000050  0000   255 adm_r0		= ^x50			; r0
                           00000059  0000   256 adm_r9		= ^x59			; r9
                           00000069  0000   257 adm_def_r9	= ^x69			; (r9)
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  11
V1.01                           Constants                                12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000089  0000   258 adm_ainc_r9	= ^x89			; (r9)+
                           0000005A  0000   259 adm_r10		= ^x5a			; r10
                           0000006A  0000   260 adm_def_r10	= ^x6a			; (r10)
                           0000007A  0000   261 adm_adec_r10	= ^x7a			; -(r10)
                           0000008A  0000   262 adm_ainc_r10	= ^x8a			; (r10)+
                           000000AA  0000   263 adm_b_dis_r10	= ^xaa			; b^(r10)
                           0000006B  0000   264 adm_def_r11	= ^x6b			; (r11)
                           0000007B  0000   265 adm_adec_r11	= ^x7b			; -(r11)
                           0000008B  0000   266 adm_ainc_r11	= ^x8b			; (r11)+
                           0000008F  0000   267 adm_immediate	= ^x8f			; immediate mode
                           0000009F  0000   268 adm_absolute	= ^x9f			; absolute mode
                           000000AF  0000   269 adm_b_rel	= ^xaf			; byte relative
                                     0000   270 
                                     0000   271 ;
                                     0000   272 ; Assembly-time vocabulary links -- symbols used during assembly to link
                                     0000   273 ;	the starting vocabularies together.   These start out at 0 so that
                                     0000   274 ;	all vocabularies will end with a null pointer.	During assembly,
                                     0000   275 ;	each link holds the address of the link fields of the most recently
                                     0000   276 ;	defined.  When a word is defined with the `header' macro then
                                     0000   277 ;	link field of the new word is initialized to the valu of the
                                     0000   278 ;	link and the link is changed to the address of the link field of the
                                     0000   279 ;	new word.
                                     0000   280 ;
                           00000000  0000   281 vl_compiler = 0		   ; Links the compiler vocabulary together
                           00000000  0000   282 vl_kernel = 0		   ; Links the kernel vocabulary together
                                     0000   283 ;******************************************************************************
                                     0000   284 	newpage <Macros>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  12
V1.01                           Macros                                   12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.sbttl	Macros
                                     0000       	
                                     0000   285 ;******************************************************************************
                                     0000   286 ;
                                     0000   287 ; Macros -- Macro Definitions
                                     0000   288 ;
                                     0000   289 ;******************************************************************************
                                     0000   290 ;!+++t
                                     0000   291 ;m> header -- macro to start all words in code
                                     0000   292 ;	This macro sets up the header for the VTIL words, and inserts it
                                     0000   293 ;	into the linked vocabulary list.  Because it uses backslash delimited
                                     0000   294 ;	strings, none of the words in the starting vocabularies built in
                                     0000   295 ;	the macro source code should have backslashes in their names.
                                     0000   296 ;
                                     0000   297 ;!---
                                     0000   298 	.macro	header	macname,name=<>,branch=v1_kernel
                                     0000   299 	.long	branch		; back link to the previous word in this branch
                                     0000   300 	branch = . - 4		; where to link the next word to in this branch
                                     0000   301 	.nchr  nchr, ^\name\	; nchr = length( name )
                                     0000   302 	.if    le, nchr		; nchr <= 0
                                     0000   303 	   .ascic \macname\	; no auxillary name, use principle one
                                     0000   304 	.if_false		; else
                                     0000   305 	  .ascic \name\		; use auxillary name
                                     0000   306 	.endc			; end if
                                     0000   307 macname:			; use name of word as branch label
                                     0000   308 	.endm			; end of macro header
                                     0000   309 
                                     0000   310 
                                     0000   311 ;!+++
                                     0000   312 ;m> iserror -- simplistic error checking routine.  If error code in r0,
                                     0000   313 ;	die messily.
                                     0000   314 ;!---
                                     0000   315 	.macro	iserror badwhere=_error_exit,?goodwhere
                                     0000   316 	blbs	r0,goodwhere	; no error, go on
                                     0000   317 	brw	badwhere	; error, branch to error handler
                                     0000   318 goodwhere:
                                     0000   319 	.endm	iserror
                                     0000   320 
                                     0000   321 
                                     0000   322 ;!+++
                                     0000   323 ;m> isstrerr -- simplistic error checking routine.  If error code in r0,
                                     0000   324 ;	unless lib$_inpstrtru, die messily
                                     0000   325 ;!---
                                     0000   326 	.macro	isstrerr badwhere=_error_exit,?goodwhere
                                     0000   327 	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                                     0000   328 	beql	goodwhere		; yes, ignore and go on
                                     0000   329 	blbs	r0,goodwhere		; no error, go on
                                     0000   330 	brw	badwhere		; error, branch to error handler
                                     0000   331 goodwhere:
                                     0000   332 	.endm	isstrerr
                                     0000   333 
                                     0000   334 	newpage <Data Section>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  13
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.sbttl	Data Section
                                     0000       	
                                     0000   335 ;******************************************************************************
                                     0000   336 ;
                                     0000   337 ; Data Section -- Contains the stacks, i/o buffers, misc buffers,
                                     0000   338 ;	and the system variables.
                                     0000   339 ;
                                     0000   340 ;******************************************************************************
                                 00000000   341 	.psect	vtildata,long,noexe
                                     0000   342 ;
                                     0000   343 ; data stack allocation
                                     0000   344 ;
                                     0000   345 c_ds_end:
                           00001000  0000   346 	.blkb	c_ds_size	; reserve c_ds_size bytes for data stack
                                     1000   347 c_ds_start:
                                     1000   348 ;
                                     1000   349 ; Loop stack allocation
                                     1000   350 ;
                                     1000   351 c_ls_end:
                           00001800  1000   352 	.blkb	c_ls_size	; reserve c_ls_size bytes for loop stack
                                     1800   353 c_ls_start:
                                     1800   354 
                                     1800   355 
                                     1800   356 ;
                                     1800   357 ; message string variables
                                     1800   358 ;	.ascid strings are used by lib$get_input and lib$put_output
                                     1800   359 ;	.ascic strings are used by { write }
                                     1800   360 ;
                                     1800   361 v_greeting:
76 20 4C 49 54 56 00001808'010E0000' 1800   362 	.ascid	/VTIL v1.01 -- Welcome to TIL-land!/	; Greet the user
63 6C 65 57 20 2D 2D 20 31 30 2E 31  180E       
6C 2D 4C 49 54 20 6F 74 20 65 6D 6F  181A       
                        21 64 6E 61  1826       
                                     182A   363 v_vtilprompt:
20 3E 4C 49 54 56 00001832'010E0000' 182A   364 	.ascid	/VTIL> /	; prompt for system input
                                     1838   365 v_usrprompt:
            20 3F 00001840'010E0000' 1838   366 	.ascid	/? /		; prompt for programmer input
                                     1842   367 v_undermess:
20 6B 63 61 74 53 0000184A'010E0000' 1842   368 	.ascid	/Stack Underflow!/
      21 77 6F 6C 66 72 65 64 6E 55  1850       
                                     185A   369 v_overmess:
20 6B 63 61 74 53 00001862'010E0000' 185A   370 	.ascid	/Stack Overflow!/
         21 77 6F 6C 66 72 65 76 4F  1868       
                                     1871   371 v_unknown:
6B 6F 74 20 6E 77 6F 6E 6B 6E 55 00' 1871   372 	.ascic	/Unknown token: { /
                  20 7B 20 3A 6E 65  187D       
                                 11  1871       
                                     1883   373 v_unknown2:
3A 65 6E 69 6C 20 6E 69 20 7D 20 00' 1883   374 	.ascic	/ } in line: /
                                 20  188F       
                                 0C  1883       
                                     1890   375 v_infilemess:
      20 3A 65 6C 69 66 20 6E 49 00' 1890   376 	.ascic	/In file: /
                                 09  1890       
                                     189A   377 v_filenotfound:
6E 20 65 6C 69 46 000018A2'010E0000' 189A   378 	.ascid	/File not found!/
         21 64 6E 75 6F 66 20 74 6F  18A8       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  14
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     18B1   379 v_unkn_blk_mess:
63 6F 6C 42 20 6E 77 6F 6E 6B 55 00' 18B1   380 	.ascic	/Uknown Block Number: /
      20 3A 72 65 62 6D 75 4E 20 6B  18BD       
                                 15  18B1       
                                     18C7   381 v_wordnotfound:
6F 46 20 74 6F 4E 20 64 72 6F 57 00' 18C7   382 	.ascic	/Word Not Found: /
                     20 3A 64 6E 75  18D3       
                                 10  18C7       
                                     18D8   383 v_nametoolong:
6F 6C 20 6F 6F 74 20 65 6D 61 4E 00' 18D8   384 	.ascic	/Name too long: /
                        20 3A 67 6E  18E4       
                                 0F  18D8       
                                     18E8   385 v_nametrunc:
74 20 64 65 74 61 63 6E 75 72 54 00' 18E8   386 	.ascic	/Truncated to: /
                           20 3A 6F  18F4       
                                 0E  18E8       
                                     18F7   387 
                                     18F7   388 
                                     18F7   389 ;
                                     18F7   390 ; variables for system input
                                     18F7   391 ;
                                     18F7   392 v_inbuf:
                           00001997  18F7   393 	.blkb	c_max_len	; buffer for system input
                                     1997   394 v_org_inlen:
                               0000  1997   395 	.word	0		; original length of line
                                     1999   396 v_inlen:			; word to hold length of remaining unprocessed
                               0000  1999   397 	.word	0		; characters
                                     199B   398 v_inptr:
                           000018F7' 199B   399 	.long	v_inbuf		; pointer to current location in string
                                     199F   400 v_in_dsc:
                               00A0  199F   401 	.word	c_max_len	; maximum length for system input
                                 00' 19A1   402 	.byte	dsc$k_dtype_t	; data type text
                                 00' 19A2   403 	.byte	dsc$k_class_s	; descriptor class
                           000018F7' 19A3   404 	.long	v_inbuf		; pointer to input buffer
                                     19A7   405 
                                     19A7   406 
                                     19A7   407 ;
                                     19A7   408 ; rms buffers for loading source from a file instead of keyboard
                                     19A7   409 ;
                                     19A7   410 	.align	long			; so rms macros won't complain
                                     19A8   411 v_infab:
                                     19A8   412 	$fab
                                     19A8       	$FABDEF
                                     19A8       	$DEFINI	FAB,
                                     19A8       	.SAVE	LOCAL_BLOCK
                                     19A8       	.NOCROSS
                                     19A8       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     19A8       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  15
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	FAB$C_BID	3
                           00000003  0000       	FAB$C_BID=3
                                     0000       	
                                     0000       $EQU	FAB$M_PPF_RAT	16320
                           00003FC0  0000       	FAB$M_PPF_RAT=16320
                                     0000       	
                                     0000       $EQU	FAB$M_PPF_IND	16384
                           00004000  0000       	FAB$M_PPF_IND=16384
                                     0000       	
                                     0000       $EQU	FAB$M_PPIFI	32768
                           00008000  0000       	FAB$M_PPIFI=32768
                                     0000       	
                                     0000       $EQU	FAB$M_ASY	1
                           00000001  0000       	FAB$M_ASY=1
                                     0000       	
                                     0000       $EQU	FAB$M_MXV	2
                           00000002  0000       	FAB$M_MXV=2
                                     0000       	
                                     0000       $EQU	FAB$M_SUP	4
                           00000004  0000       	FAB$M_SUP=4
                                     0000       	
                                     0000       $EQU	FAB$M_TMP	8
                           00000008  0000       	FAB$M_TMP=8
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  16
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$M_TMD	16
                           00000010  0000       	FAB$M_TMD=16
                                     0000       	
                                     0000       $EQU	FAB$M_DFW	32
                           00000020  0000       	FAB$M_DFW=32
                                     0000       	
                                     0000       $EQU	FAB$M_SQO	64
                           00000040  0000       	FAB$M_SQO=64
                                     0000       	
                                     0000       $EQU	FAB$M_RWO	128
                           00000080  0000       	FAB$M_RWO=128
                                     0000       	
                                     0000       $EQU	FAB$M_POS	256
                           00000100  0000       	FAB$M_POS=256
                                     0000       	
                                     0000       $EQU	FAB$M_WCK	512
                           00000200  0000       	FAB$M_WCK=512
                                     0000       	
                                     0000       $EQU	FAB$M_NEF	1024
                           00000400  0000       	FAB$M_NEF=1024
                                     0000       	
                                     0000       $EQU	FAB$M_RWC	2048
                           00000800  0000       	FAB$M_RWC=2048
                                     0000       	
                                     0000       $EQU	FAB$M_DMO	4096
                           00001000  0000       	FAB$M_DMO=4096
                                     0000       	
                                     0000       $EQU	FAB$M_SPL	8192
                           00002000  0000       	FAB$M_SPL=8192
                                     0000       	
                                     0000       $EQU	FAB$M_SCF	16384
                           00004000  0000       	FAB$M_SCF=16384
                                     0000       	
                                     0000       $EQU	FAB$M_DLT	32768
                           00008000  0000       	FAB$M_DLT=32768
                                     0000       	
                                     0000       $EQU	FAB$M_NFS	65536
                           00010000  0000       	FAB$M_NFS=65536
                                     0000       	
                                     0000       $EQU	FAB$M_UFO	131072
                           00020000  0000       	FAB$M_UFO=131072
                                     0000       	
                                     0000       $EQU	FAB$M_PPF	262144
                           00040000  0000       	FAB$M_PPF=262144
                                     0000       	
                                     0000       $EQU	FAB$M_INP	524288
                           00080000  0000       	FAB$M_INP=524288
                                     0000       	
                                     0000       $EQU	FAB$M_CTG	1048576
                           00100000  0000       	FAB$M_CTG=1048576
                                     0000       	
                                     0000       $EQU	FAB$M_CBT	2097152
                           00200000  0000       	FAB$M_CBT=2097152
                                     0000       	
                                     0000       $EQU	FAB$M_SYNCSTS	4194304
                           00400000  0000       	FAB$M_SYNCSTS=4194304
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  17
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$M_RCK	8388608
                           00800000  0000       	FAB$M_RCK=8388608
                                     0000       	
                                     0000       $EQU	FAB$M_NAM	16777216
                           01000000  0000       	FAB$M_NAM=16777216
                                     0000       	
                                     0000       $EQU	FAB$M_CIF	33554432
                           02000000  0000       	FAB$M_CIF=33554432
                                     0000       	
                                     0000       $EQU	FAB$M_ESC	134217728
                           08000000  0000       	FAB$M_ESC=134217728
                                     0000       	
                                     0000       $EQU	FAB$M_TEF	268435456
                           10000000  0000       	FAB$M_TEF=268435456
                                     0000       	
                                     0000       $EQU	FAB$M_OFP	536870912
                           20000000  0000       	FAB$M_OFP=536870912
                                     0000       	
                                     0000       $EQU	FAB$M_KFO	1073741824
                           40000000  0000       	FAB$M_KFO=1073741824
                                     0000       	
                                     0000       $EQU	FAB$M_PUT	1
                           00000001  0000       	FAB$M_PUT=1
                                     0000       	
                                     0000       $EQU	FAB$M_GET	2
                           00000002  0000       	FAB$M_GET=2
                                     0000       	
                                     0000       $EQU	FAB$M_DEL	4
                           00000004  0000       	FAB$M_DEL=4
                                     0000       	
                                     0000       $EQU	FAB$M_UPD	8
                           00000008  0000       	FAB$M_UPD=8
                                     0000       	
                                     0000       $EQU	FAB$M_TRN	16
                           00000010  0000       	FAB$M_TRN=16
                                     0000       	
                                     0000       $EQU	FAB$M_BIO	32
                           00000020  0000       	FAB$M_BIO=32
                                     0000       	
                                     0000       $EQU	FAB$M_BRO	64
                           00000040  0000       	FAB$M_BRO=64
                                     0000       	
                                     0000       $EQU	FAB$M_EXE	128
                           00000080  0000       	FAB$M_EXE=128
                                     0000       	
                                     0000       $EQU	FAB$M_SHRPUT	1
                           00000001  0000       	FAB$M_SHRPUT=1
                                     0000       	
                                     0000       $EQU	FAB$M_SHRGET	2
                           00000002  0000       	FAB$M_SHRGET=2
                                     0000       	
                                     0000       $EQU	FAB$M_SHRDEL	4
                           00000004  0000       	FAB$M_SHRDEL=4
                                     0000       	
                                     0000       $EQU	FAB$M_SHRUPD	8
                           00000008  0000       	FAB$M_SHRUPD=8
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  18
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$M_MSE	16
                           00000010  0000       	FAB$M_MSE=16
                                     0000       	
                                     0000       $EQU	FAB$M_NIL	32
                           00000020  0000       	FAB$M_NIL=32
                                     0000       	
                                     0000       $EQU	FAB$M_UPI	64
                           00000040  0000       	FAB$M_UPI=64
                                     0000       	
                                     0000       $EQU	FAB$M_ORG	240
                           000000F0  0000       	FAB$M_ORG=240
                                     0000       	
                                     0000       $EQU	FAB$C_SEQ	0
                           00000000  0000       	FAB$C_SEQ=0
                                     0000       	
                                     0000       $EQU	FAB$C_REL	16
                           00000010  0000       	FAB$C_REL=16
                                     0000       	
                                     0000       $EQU	FAB$C_IDX	32
                           00000020  0000       	FAB$C_IDX=32
                                     0000       	
                                     0000       $EQU	FAB$C_HSH	48
                           00000030  0000       	FAB$C_HSH=48
                                     0000       	
                                     0000       $EQU	FAB$M_FTN	1
                           00000001  0000       	FAB$M_FTN=1
                                     0000       	
                                     0000       $EQU	FAB$M_CR	2
                           00000002  0000       	FAB$M_CR=2
                                     0000       	
                                     0000       $EQU	FAB$M_PRN	4
                           00000004  0000       	FAB$M_PRN=4
                                     0000       	
                                     0000       $EQU	FAB$M_BLK	8
                           00000008  0000       	FAB$M_BLK=8
                                     0000       	
                                     0000       $EQU	FAB$C_RFM_DFLT	2
                           00000002  0000       	FAB$C_RFM_DFLT=2
                                     0000       	
                                     0000       $EQU	FAB$C_UDF	0
                           00000000  0000       	FAB$C_UDF=0
                                     0000       	
                                     0000       $EQU	FAB$C_FIX	1
                           00000001  0000       	FAB$C_FIX=1
                                     0000       	
                                     0000       $EQU	FAB$C_VAR	2
                           00000002  0000       	FAB$C_VAR=2
                                     0000       	
                                     0000       $EQU	FAB$C_VFC	3
                           00000003  0000       	FAB$C_VFC=3
                                     0000       	
                                     0000       $EQU	FAB$C_STM	4
                           00000004  0000       	FAB$C_STM=4
                                     0000       	
                                     0000       $EQU	FAB$C_STMLF	5
                           00000005  0000       	FAB$C_STMLF=5
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  19
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$C_STMCR	6
                           00000006  0000       	FAB$C_STMCR=6
                                     0000       	
                                     0000       $EQU	FAB$C_MAXRFM	6
                           00000006  0000       	FAB$C_MAXRFM=6
                                     0000       	
                                     0000       $EQU	FAB$M_ONLY_RU	1
                           00000001  0000       	FAB$M_ONLY_RU=1
                                     0000       	
                                     0000       $EQU	FAB$M_RU	2
                           00000002  0000       	FAB$M_RU=2
                                     0000       	
                                     0000       $EQU	FAB$M_BI	4
                           00000004  0000       	FAB$M_BI=4
                                     0000       	
                                     0000       $EQU	FAB$M_AI	8
                           00000008  0000       	FAB$M_AI=8
                                     0000       	
                                     0000       $EQU	FAB$M_AT	16
                           00000010  0000       	FAB$M_AT=16
                                     0000       	
                                     0000       $EQU	FAB$M_NEVER_RU	32
                           00000020  0000       	FAB$M_NEVER_RU=32
                                     0000       	
                                     0000       $EQU	FAB$M_JOURNAL_FILE	64
                           00000040  0000       	FAB$M_JOURNAL_FILE=64
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_RU	1
                           00000001  0000       	FAB$M_RCF_RU=1
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_AI	2
                           00000002  0000       	FAB$M_RCF_AI=2
                                     0000       	
                                     0000       $EQU	FAB$M_RCF_BI	4
                           00000004  0000       	FAB$M_RCF_BI=4
                                     0000       	
                                     0000       $EQU	FAB$K_BLN	80
                           00000050  0000       	FAB$K_BLN=80
                                     0000       	
                                     0000       $EQU	FAB$C_BLN	80
                           00000050  0000       	FAB$C_BLN=80
                                     0000       	
                                     0000       $EQU	FAB$S_FABDEF	80
                           00000050  0000       	FAB$S_FABDEF=80
                                     0000       	
                                     0000       $EQU	FAB$B_BID	0
                           00000000  0000       	FAB$B_BID=0
                                     0000       	
                                     0000       $EQU	FAB$B_BLN	1
                           00000001  0000       	FAB$B_BLN=1
                                     0000       	
                                     0000       $EQU	FAB$R_IFI_OVERLAY	2
                           00000002  0000       	FAB$R_IFI_OVERLAY=2
                                     0000       	
                                     0000       $EQU	FAB$W_IFI	2
                           00000002  0000       	FAB$W_IFI=2
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  20
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$R_IFI_BITS	2
                           00000002  0000       	FAB$R_IFI_BITS=2
                                     0000       	
                                     0000       $EQU	FAB$S_PPF_RAT	8
                           00000008  0000       	FAB$S_PPF_RAT=8
                                     0000       	
                                     0000       $EQU	FAB$V_PPF_RAT	6
                           00000006  0000       	FAB$V_PPF_RAT=6
                                     0000       	
                                     0000       $EQU	FAB$V_PPF_IND	14
                           0000000E  0000       	FAB$V_PPF_IND=14
                                     0000       	
                                     0000       $EQU	FAB$V_PPIFI	15
                           0000000F  0000       	FAB$V_PPIFI=15
                                     0000       	
                                     0000       $EQU	FAB$R_FOP_OVERLAY	4
                           00000004  0000       	FAB$R_FOP_OVERLAY=4
                                     0000       	
                                     0000       $EQU	FAB$L_FOP	4
                           00000004  0000       	FAB$L_FOP=4
                                     0000       	
                                     0000       $EQU	FAB$R_FOP_BITS	4
                           00000004  0000       	FAB$R_FOP_BITS=4
                                     0000       	
                                     0000       $EQU	FAB$V_ASY	0
                           00000000  0000       	FAB$V_ASY=0
                                     0000       	
                                     0000       $EQU	FAB$V_MXV	1
                           00000001  0000       	FAB$V_MXV=1
                                     0000       	
                                     0000       $EQU	FAB$V_SUP	2
                           00000002  0000       	FAB$V_SUP=2
                                     0000       	
                                     0000       $EQU	FAB$V_TMP	3
                           00000003  0000       	FAB$V_TMP=3
                                     0000       	
                                     0000       $EQU	FAB$V_TMD	4
                           00000004  0000       	FAB$V_TMD=4
                                     0000       	
                                     0000       $EQU	FAB$V_DFW	5
                           00000005  0000       	FAB$V_DFW=5
                                     0000       	
                                     0000       $EQU	FAB$V_SQO	6
                           00000006  0000       	FAB$V_SQO=6
                                     0000       	
                                     0000       $EQU	FAB$V_RWO	7
                           00000007  0000       	FAB$V_RWO=7
                                     0000       	
                                     0000       $EQU	FAB$V_POS	8
                           00000008  0000       	FAB$V_POS=8
                                     0000       	
                                     0000       $EQU	FAB$V_WCK	9
                           00000009  0000       	FAB$V_WCK=9
                                     0000       	
                                     0000       $EQU	FAB$V_NEF	10
                           0000000A  0000       	FAB$V_NEF=10
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  21
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$V_RWC	11
                           0000000B  0000       	FAB$V_RWC=11
                                     0000       	
                                     0000       $EQU	FAB$V_DMO	12
                           0000000C  0000       	FAB$V_DMO=12
                                     0000       	
                                     0000       $EQU	FAB$V_SPL	13
                           0000000D  0000       	FAB$V_SPL=13
                                     0000       	
                                     0000       $EQU	FAB$V_SCF	14
                           0000000E  0000       	FAB$V_SCF=14
                                     0000       	
                                     0000       $EQU	FAB$V_DLT	15
                           0000000F  0000       	FAB$V_DLT=15
                                     0000       	
                                     0000       $EQU	FAB$V_NFS	16
                           00000010  0000       	FAB$V_NFS=16
                                     0000       	
                                     0000       $EQU	FAB$V_UFO	17
                           00000011  0000       	FAB$V_UFO=17
                                     0000       	
                                     0000       $EQU	FAB$V_PPF	18
                           00000012  0000       	FAB$V_PPF=18
                                     0000       	
                                     0000       $EQU	FAB$V_INP	19
                           00000013  0000       	FAB$V_INP=19
                                     0000       	
                                     0000       $EQU	FAB$V_CTG	20
                           00000014  0000       	FAB$V_CTG=20
                                     0000       	
                                     0000       $EQU	FAB$V_CBT	21
                           00000015  0000       	FAB$V_CBT=21
                                     0000       	
                                     0000       $EQU	FAB$V_SYNCSTS	22
                           00000016  0000       	FAB$V_SYNCSTS=22
                                     0000       	
                                     0000       $EQU	FAB$V_RCK	23
                           00000017  0000       	FAB$V_RCK=23
                                     0000       	
                                     0000       $EQU	FAB$V_NAM	24
                           00000018  0000       	FAB$V_NAM=24
                                     0000       	
                                     0000       $EQU	FAB$V_CIF	25
                           00000019  0000       	FAB$V_CIF=25
                                     0000       	
                                     0000       $EQU	FAB$V_ESC	27
                           0000001B  0000       	FAB$V_ESC=27
                                     0000       	
                                     0000       $EQU	FAB$V_TEF	28
                           0000001C  0000       	FAB$V_TEF=28
                                     0000       	
                                     0000       $EQU	FAB$V_OFP	29
                           0000001D  0000       	FAB$V_OFP=29
                                     0000       	
                                     0000       $EQU	FAB$V_KFO	30
                           0000001E  0000       	FAB$V_KFO=30
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  22
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$L_STS	8
                           00000008  0000       	FAB$L_STS=8
                                     0000       	
                                     0000       $EQU	FAB$L_STV	12
                           0000000C  0000       	FAB$L_STV=12
                                     0000       	
                                     0000       $EQU	FAB$L_ALQ	16
                           00000010  0000       	FAB$L_ALQ=16
                                     0000       	
                                     0000       $EQU	FAB$W_DEQ	20
                           00000014  0000       	FAB$W_DEQ=20
                                     0000       	
                                     0000       $EQU	FAB$R_FAC_OVERLAY	22
                           00000016  0000       	FAB$R_FAC_OVERLAY=22
                                     0000       	
                                     0000       $EQU	FAB$B_FAC	22
                           00000016  0000       	FAB$B_FAC=22
                                     0000       	
                                     0000       $EQU	FAB$R_FAC_BITS	22
                           00000016  0000       	FAB$R_FAC_BITS=22
                                     0000       	
                                     0000       $EQU	FAB$V_PUT	0
                           00000000  0000       	FAB$V_PUT=0
                                     0000       	
                                     0000       $EQU	FAB$V_GET	1
                           00000001  0000       	FAB$V_GET=1
                                     0000       	
                                     0000       $EQU	FAB$V_DEL	2
                           00000002  0000       	FAB$V_DEL=2
                                     0000       	
                                     0000       $EQU	FAB$V_UPD	3
                           00000003  0000       	FAB$V_UPD=3
                                     0000       	
                                     0000       $EQU	FAB$V_TRN	4
                           00000004  0000       	FAB$V_TRN=4
                                     0000       	
                                     0000       $EQU	FAB$V_BIO	5
                           00000005  0000       	FAB$V_BIO=5
                                     0000       	
                                     0000       $EQU	FAB$V_BRO	6
                           00000006  0000       	FAB$V_BRO=6
                                     0000       	
                                     0000       $EQU	FAB$V_EXE	7
                           00000007  0000       	FAB$V_EXE=7
                                     0000       	
                                     0000       $EQU	FAB$R_SHR_OVERLAY	23
                           00000017  0000       	FAB$R_SHR_OVERLAY=23
                                     0000       	
                                     0000       $EQU	FAB$B_SHR	23
                           00000017  0000       	FAB$B_SHR=23
                                     0000       	
                                     0000       $EQU	FAB$R_SHR_BITS	23
                           00000017  0000       	FAB$R_SHR_BITS=23
                                     0000       	
                                     0000       $EQU	FAB$V_SHRPUT	0
                           00000000  0000       	FAB$V_SHRPUT=0
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  23
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$V_SHRGET	1
                           00000001  0000       	FAB$V_SHRGET=1
                                     0000       	
                                     0000       $EQU	FAB$V_SHRDEL	2
                           00000002  0000       	FAB$V_SHRDEL=2
                                     0000       	
                                     0000       $EQU	FAB$V_SHRUPD	3
                           00000003  0000       	FAB$V_SHRUPD=3
                                     0000       	
                                     0000       $EQU	FAB$V_MSE	4
                           00000004  0000       	FAB$V_MSE=4
                                     0000       	
                                     0000       $EQU	FAB$V_NIL	5
                           00000005  0000       	FAB$V_NIL=5
                                     0000       	
                                     0000       $EQU	FAB$V_UPI	6
                           00000006  0000       	FAB$V_UPI=6
                                     0000       	
                                     0000       $EQU	FAB$L_CTX	24
                           00000018  0000       	FAB$L_CTX=24
                                     0000       	
                                     0000       $EQU	FAB$B_RTV	28
                           0000001C  0000       	FAB$B_RTV=28
                                     0000       	
                                     0000       $EQU	FAB$R_ORG_OVERLAY	29
                           0000001D  0000       	FAB$R_ORG_OVERLAY=29
                                     0000       	
                                     0000       $EQU	FAB$B_ORG	29
                           0000001D  0000       	FAB$B_ORG=29
                                     0000       	
                                     0000       $EQU	FAB$R_ORG_BITS	29
                           0000001D  0000       	FAB$R_ORG_BITS=29
                                     0000       	
                                     0000       $EQU	FAB$S_ORG	4
                           00000004  0000       	FAB$S_ORG=4
                                     0000       	
                                     0000       $EQU	FAB$V_ORG	4
                           00000004  0000       	FAB$V_ORG=4
                                     0000       	
                                     0000       $EQU	FAB$R_RAT_OVERLAY	30
                           0000001E  0000       	FAB$R_RAT_OVERLAY=30
                                     0000       	
                                     0000       $EQU	FAB$B_RAT	30
                           0000001E  0000       	FAB$B_RAT=30
                                     0000       	
                                     0000       $EQU	FAB$R_RAT_BITS	30
                           0000001E  0000       	FAB$R_RAT_BITS=30
                                     0000       	
                                     0000       $EQU	FAB$V_FTN	0
                           00000000  0000       	FAB$V_FTN=0
                                     0000       	
                                     0000       $EQU	FAB$V_CR	1
                           00000001  0000       	FAB$V_CR=1
                                     0000       	
                                     0000       $EQU	FAB$V_PRN	2
                           00000002  0000       	FAB$V_PRN=2
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  24
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$V_BLK	3
                           00000003  0000       	FAB$V_BLK=3
                                     0000       	
                                     0000       $EQU	FAB$B_RFM	31
                           0000001F  0000       	FAB$B_RFM=31
                                     0000       	
                                     0000       $EQU	FAB$R_JOURNAL_OVERLAY	32
                           00000020  0000       	FAB$R_JOURNAL_OVERLAY=32
                                     0000       	
                                     0000       $EQU	FAB$B_JOURNAL	32
                           00000020  0000       	FAB$B_JOURNAL=32
                                     0000       	
                                     0000       $EQU	FAB$R_JOURNAL_BITS	32
                           00000020  0000       	FAB$R_JOURNAL_BITS=32
                                     0000       	
                                     0000       $EQU	FAB$V_ONLY_RU	0
                           00000000  0000       	FAB$V_ONLY_RU=0
                                     0000       	
                                     0000       $EQU	FAB$V_RU	1
                           00000001  0000       	FAB$V_RU=1
                                     0000       	
                                     0000       $EQU	FAB$V_BI	2
                           00000002  0000       	FAB$V_BI=2
                                     0000       	
                                     0000       $EQU	FAB$V_AI	3
                           00000003  0000       	FAB$V_AI=3
                                     0000       	
                                     0000       $EQU	FAB$V_AT	4
                           00000004  0000       	FAB$V_AT=4
                                     0000       	
                                     0000       $EQU	FAB$V_NEVER_RU	5
                           00000005  0000       	FAB$V_NEVER_RU=5
                                     0000       	
                                     0000       $EQU	FAB$V_JOURNAL_FILE	6
                           00000006  0000       	FAB$V_JOURNAL_FILE=6
                                     0000       	
                                     0000       $EQU	FAB$B_RU_FACILITY	33
                           00000021  0000       	FAB$B_RU_FACILITY=33
                                     0000       	
                                     0000       $EQU	FAB$L_XAB	36
                           00000024  0000       	FAB$L_XAB=36
                                     0000       	
                                     0000       $EQU	FAB$L_NAM	40
                           00000028  0000       	FAB$L_NAM=40
                                     0000       	
                                     0000       $EQU	FAB$L_FNA	44
                           0000002C  0000       	FAB$L_FNA=44
                                     0000       	
                                     0000       $EQU	FAB$L_DNA	48
                           00000030  0000       	FAB$L_DNA=48
                                     0000       	
                                     0000       $EQU	FAB$B_FNS	52
                           00000034  0000       	FAB$B_FNS=52
                                     0000       	
                                     0000       $EQU	FAB$B_DNS	53
                           00000035  0000       	FAB$B_DNS=53
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  25
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$W_MRS	54
                           00000036  0000       	FAB$W_MRS=54
                                     0000       	
                                     0000       $EQU	FAB$L_MRN	56
                           00000038  0000       	FAB$L_MRN=56
                                     0000       	
                                     0000       $EQU	FAB$W_BLS	60
                           0000003C  0000       	FAB$W_BLS=60
                                     0000       	
                                     0000       $EQU	FAB$B_BKS	62
                           0000003E  0000       	FAB$B_BKS=62
                                     0000       	
                                     0000       $EQU	FAB$B_FSZ	63
                           0000003F  0000       	FAB$B_FSZ=63
                                     0000       	
                                     0000       $EQU	FAB$L_DEV	64
                           00000040  0000       	FAB$L_DEV=64
                                     0000       	
                                     0000       $EQU	FAB$L_SDC	68
                           00000044  0000       	FAB$L_SDC=68
                                     0000       	
                                     0000       $EQU	FAB$W_GBC	72
                           00000048  0000       	FAB$W_GBC=72
                                     0000       	
                                     0000       $EQU	FAB$R_ACMODES_OVERLAY	74
                           0000004A  0000       	FAB$R_ACMODES_OVERLAY=74
                                     0000       	
                                     0000       $EQU	FAB$B_ACMODES	74
                           0000004A  0000       	FAB$B_ACMODES=74
                                     0000       	
                                     0000       $EQU	FAB$R_ACMODES_BITS	74
                           0000004A  0000       	FAB$R_ACMODES_BITS=74
                                     0000       	
                                     0000       $EQU	FAB$S_LNM_MODE	2
                           00000002  0000       	FAB$S_LNM_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_LNM_MODE	0
                           00000000  0000       	FAB$V_LNM_MODE=0
                                     0000       	
                                     0000       $EQU	FAB$S_CHAN_MODE	2
                           00000002  0000       	FAB$S_CHAN_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_CHAN_MODE	2
                           00000002  0000       	FAB$V_CHAN_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$S_FILE_MODE	2
                           00000002  0000       	FAB$S_FILE_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_FILE_MODE	4
                           00000004  0000       	FAB$V_FILE_MODE=4
                                     0000       	
                                     0000       $EQU	FAB$S_CALLERS_MODE	2
                           00000002  0000       	FAB$S_CALLERS_MODE=2
                                     0000       	
                                     0000       $EQU	FAB$V_CALLERS_MODE	6       ;  ACMODE for user structure probing
                           00000006  0000       	FAB$V_CALLERS_MODE=6
                                     0000       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  26
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       $EQU	FAB$R_RCF_OVERLAY	75
                           0000004B  0000       	FAB$R_RCF_OVERLAY=75
                                     0000       	
                                     0000       $EQU	FAB$B_RCF	75
                           0000004B  0000       	FAB$B_RCF=75
                                     0000       	
                                     0000       $EQU	FAB$R_RCF_BITS	75
                           0000004B  0000       	FAB$R_RCF_BITS=75
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_RU	0
                           00000000  0000       	FAB$V_RCF_RU=0
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_AI	1
                           00000001  0000       	FAB$V_RCF_AI=1
                                     0000       	
                                     0000       $EQU	FAB$V_RCF_BI	2
                           00000002  0000       	FAB$V_RCF_BI=2
                                     0000       	
                                     0000       	$DEFEND	FAB,,DEF
                                     0000       	.MACRO	$FABDEF A
                                     0000       	.ENDM	$FABDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                 000019A8       	.RESTORE
                                     19A8       	
                                     19A8       	
                                     19A8       	$$R_TABINIT	FAB$C_BID, FAB$C_BLN
                                     19A8       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           000019A8  19A8       $$.TAB=.
                                 03  19A8       	.BYTE FAB$C_BID
                                 50  19A9       	.BYTE FAB$C_BLN
                           000019F8  19AA       	.BLKB FAB$C_BLN-2
                           000019F8  19F8       $$.TABEND=.
                                     19F8       
                                     19F8       	$$R_VBFSET	FAB,<>
                           00000000  19F8       $$.TMP=0
                                     19F8       	.IRP X,<>
                                     19F8       	.IF DF FAB$V_'X
                                     19F8       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19F8       	.IFF
                                     19F8       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19F8       	.ENDC
                                     19F8       	.ENDR
                                     19F8       	
                           000019AC  19F8       	.=$$.TAB+FAB$L_FOP
                           00000000' 19AC       	.ADDRESS	$$.TMP
                           000019B8  19B0       	.=$$.TAB+FAB$L_ALQ
                           00000000' 19B8       	.ADDRESS	0
                               0000  19BC       	.WORD	0
                                     19BE       	$$R_VBFSET	FAB,<>
                           00000000  19BE       $$.TMP=0
                                     19BE       	.IRP X,<>
                                     19BE       	.IF DF FAB$V_'X
                                     19BE       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19BE       	.IFF
                                     19BE       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19BE       	.ENDC
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  27
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     19BE       	.ENDR
                                     19BE       	
                                 00  19BE       	.BYTE	$$.TMP
                                     19BF       	$$R_VBFSET	FAB,<>
                           00000000  19BF       $$.TMP=0
                                     19BF       	.IRP X,<>
                                     19BF       	.IF DF FAB$V_'X
                                     19BF       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19BF       	.IFF
                                     19BF       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19BF       	.ENDC
                                     19BF       	.ENDR
                                     19BF       	
                                 00  19BF       	.BYTE	$$.TMP
                           00000000' 19C0       	.ADDRESS	0
                                 00  19C4       	.BYTE	0
                                     19C5       	.IF DF FAB$C_SEQ
                                 00  19C5       	.BYTE	FAB$C_SEQ
                                     19C6       	.IFF
                                     19C6       	.BYTE
                                     19C6       	.ERROR			; UNDEFINED VALUE FOR FIELD : SEQ;
                                     19C6       	.ENDC
                                     19C6       	$$R_VBFSET	FAB,<>
                           00000000  19C6       $$.TMP=0
                                     19C6       	.IRP X,<>
                                     19C6       	.IF DF FAB$V_'X
                                     19C6       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19C6       	.IFF
                                     19C6       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19C6       	.ENDC
                                     19C6       	.ENDR
                                     19C6       	
                                 00  19C6       	.BYTE	$$.TMP
                                     19C7       	.IF DF FAB$C_VAR
                                 02  19C7       	.BYTE	FAB$C_VAR
                                     19C8       	.IFF
                                     19C8       	.BYTE
                                     19C8       	.ERROR			; UNDEFINED VALUE FOR FIELD : VAR;
                                     19C8       	.ENDC
                                     19C8       	$$R_VBFSET	FAB,<>
                           00000000  19C8       $$.TMP=0
                                     19C8       	.IRP X,<>
                                     19C8       	.IF DF FAB$V_'X
                                     19C8       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     19C8       	.IFF
                                     19C8       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     19C8       	.ENDC
                                     19C8       	.ENDR
                                     19C8       	
                                 00  19C8       	.BYTE	$$.TMP
                                 00  19C9       	.BYTE	0
                               0000  19CA       	.WORD
                           00000000' 19CC       	.ADDRESS	0
                           00000000' 19D0       	.ADDRESS	0
                           00000000' 19D4       	.ADDRESS	0
                           00000000' 19D8       	.ADDRESS	0
                                 00  19DC       	.BYTE	0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  28
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 00  19DD       	.BYTE	0
                               0000  19DE       	.WORD	0
                           00000000' 19E0       	.ADDRESS	0
                               0000  19E4       	.WORD	0
                                 00  19E6       	.BYTE	0
                                 00  19E7       	.BYTE	0
                           000019F0  19E8       	.=$$.TAB+FAB$W_GBC
                               0000  19F0       	.WORD	0
                                 00  19F2       	.BYTE	<<0@FAB$V_LNM_MODE> + <0@FAB$V_CHAN_MODE> + -
                                     19F3       		<0@FAB$V_FILE_MODE>>
                                     19F3       	.IIF NE 8-8, .ERROR	; INVALID BYTE SIZE
                                     19F3       	.IF NB <>
                                     19F3       	.SAVE
                                     19F3       	.PSECT $RMSNAM
                                     19F3       	$$.TMPX=.
                                     19F3       	.ASCII %%
                                     19F3       	$$.TMPX1=.-$$.TMPX
                                     19F3       	.RESTORE
                                     19F3       	.=$$.TAB+FAB$L_FNA
                                     19F3       	.ADDRESS	$$.TMPX
                                     19F3       	.=$$.TAB+FAB$B_FNS
                                     19F3       	.BYTE	$$.TMPX1
                                     19F3       	.ENDC
                                     19F3       	.IF NB <>
                                     19F3       	.SAVE
                                     19F3       	.PSECT $RMSNAM
                                     19F3       	$$.TMPX=.
                                     19F3       	.ASCII %%
                                     19F3       	$$.TMPX1=.-$$.TMPX
                                     19F3       	.RESTORE
                                     19F3       	.=$$.TAB+FAB$L_DNA
                                     19F3       	.ADDRESS	$$.TMPX
                                     19F3       	.=$$.TAB+FAB$B_DNS
                                     19F3       	.BYTE	$$.TMPX1
                                     19F3       	.ENDC
                           000019F8  19F3       	.=$$.TABEND
                                     19F8       	
                                     19F8   413 ;		fnm=<infile>,-		; primary input file name
                                     19F8   414 ;		dnm=<vtil.vtil>		; default input file extension
                                     19F8   415 v_inrab:
                                     19F8   416 	$rab	fab=v_infab,-		; pointer to fab
                                     19F8   417 		rop=rah,-		; read-ahead option
                                     19F8   418 		ubf=v_inbuf,-		; record buffer
                                     19F8   419 		usz=c_max_len		; and size
                                     19F8       $RABDEF
                                     19F8       	$DEFINI	RAB,
                                     19F8       	.SAVE	LOCAL_BLOCK
                                     19F8       	.NOCROSS
                                     19F8       	.IIF	DIF <> <GLOBAL>,.ENABLE	SUPPRESSION
                                     19F8       	.PSECT	$ABS$,ABS
                                     0000       	$GBLINI	
                                     0000       	.IF	IDN <LOCAL> <GLOBAL>
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM::
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  29
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0000       	SYM==VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM==BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM==SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM==<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.IFF
                                     0000       	.IIF	DIF <LOCAL> <LOCAL>,.ERROR ;ARG MUST BE "GLOBAL","LOCAL",OR NULL
                                     0000       	.MACRO	$DEF	SYM,ALLOC,SIZ
                                     0000       	.IIF	NB,SYM,	SYM:
                                     0000       	.IIF	NB,ALLOC,	ALLOC	SIZ
                                     0000       	.ENDM	$DEF
                                     0000       	.MACRO	$EQU	SYM,VAL
                                     0000       	SYM=VAL
                                     0000       	.ENDM	$EQU
                                     0000       	.MACRO	$VIELD1	MOD,SEP,SYM,SIZ,MSK
                                     0000       	SIZ...=1
                                     0000       	.IIF	NB,SIZ,	SIZ...=SIZ
                                     0000       	.IF	NB,SYM
                                     0000       	MOD'SEP'V_'SYM=BIT...
                                     0000       	.IIF	NB,SIZ,	MOD'SEP'S_'SYM=SIZ
                                     0000       	.IIF	NB,MSK,	MOD'SEP'M_'SYM=<<<1@SIZ...>-1>@BIT...>
                                     0000       	.ENDC
                                     0000       	BIT...=BIT...+SIZ...
                                     0000       	.ENDM	$VIELD1
                                     0000       	.ENDC
                                     0000       	
                           00000000  0000       	.=0
                                     0000       	
                                     0000       $EQU	RAB$C_BID	1
                           00000001  0000       	RAB$C_BID=1
                                     0000       	
                                     0000       $EQU	RAB$M_PPF_RAT	16320
                           00003FC0  0000       	RAB$M_PPF_RAT=16320
                                     0000       	
                                     0000       $EQU	RAB$M_PPF_IND	16384
                           00004000  0000       	RAB$M_PPF_IND=16384
                                     0000       	
                                     0000       $EQU	RAB$M_PPISI	32768
                           00008000  0000       	RAB$M_PPISI=32768
                                     0000       	
                                     0000       $EQU	RAB$M_ASY	1
                           00000001  0000       	RAB$M_ASY=1
                                     0000       	
                                     0000       $EQU	RAB$M_TPT	2
                           00000002  0000       	RAB$M_TPT=2
                                     0000       	
                                     0000       $EQU	RAB$M_REA	4
                           00000004  0000       	RAB$M_REA=4
                                     0000       	
                                     0000       $EQU	RAB$M_RRL	8
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  30
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000008  0000       	RAB$M_RRL=8
                                     0000       	
                                     0000       $EQU	RAB$M_UIF	16
                           00000010  0000       	RAB$M_UIF=16
                                     0000       	
                                     0000       $EQU	RAB$M_MAS	32
                           00000020  0000       	RAB$M_MAS=32
                                     0000       	
                                     0000       $EQU	RAB$M_FDL	64
                           00000040  0000       	RAB$M_FDL=64
                                     0000       	
                                     0000       $EQU	RAB$M_HSH	128
                           00000080  0000       	RAB$M_HSH=128
                                     0000       	
                                     0000       $EQU	RAB$M_EOF	256
                           00000100  0000       	RAB$M_EOF=256
                                     0000       	
                                     0000       $EQU	RAB$M_RAH	512
                           00000200  0000       	RAB$M_RAH=512
                                     0000       	
                                     0000       $EQU	RAB$M_WBH	1024
                           00000400  0000       	RAB$M_WBH=1024
                                     0000       	
                                     0000       $EQU	RAB$M_BIO	2048
                           00000800  0000       	RAB$M_BIO=2048
                                     0000       	
                                     0000       $EQU	RAB$M_CDK	4096
                           00001000  0000       	RAB$M_CDK=4096
                                     0000       	
                                     0000       $EQU	RAB$M_LOA	8192
                           00002000  0000       	RAB$M_LOA=8192
                                     0000       	
                                     0000       $EQU	RAB$M_LIM	16384
                           00004000  0000       	RAB$M_LIM=16384
                                     0000       	
                                     0000       $EQU	RAB$M_SYNCSTS	32768
                           00008000  0000       	RAB$M_SYNCSTS=32768
                                     0000       	
                                     0000       $EQU	RAB$M_LOC	65536
                           00010000  0000       	RAB$M_LOC=65536
                                     0000       	
                                     0000       $EQU	RAB$M_WAT	131072
                           00020000  0000       	RAB$M_WAT=131072
                                     0000       	
                                     0000       $EQU	RAB$M_ULK	262144
                           00040000  0000       	RAB$M_ULK=262144
                                     0000       	
                                     0000       $EQU	RAB$M_RLK	524288
                           00080000  0000       	RAB$M_RLK=524288
                                     0000       	
                                     0000       $EQU	RAB$M_NLK	1048576
                           00100000  0000       	RAB$M_NLK=1048576
                                     0000       	
                                     0000       $EQU	RAB$M_KGE	2097152
                           00200000  0000       	RAB$M_KGE=2097152
                                     0000       	
                                     0000       $EQU	RAB$M_KGT	4194304
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  31
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00400000  0000       	RAB$M_KGT=4194304
                                     0000       	
                                     0000       $EQU	RAB$M_NXR	8388608
                           00800000  0000       	RAB$M_NXR=8388608
                                     0000       	
                                     0000       $EQU	RAB$M_RNE	16777216
                           01000000  0000       	RAB$M_RNE=16777216
                                     0000       	
                                     0000       $EQU	RAB$M_TMO	33554432
                           02000000  0000       	RAB$M_TMO=33554432
                                     0000       	
                                     0000       $EQU	RAB$M_CVT	67108864
                           04000000  0000       	RAB$M_CVT=67108864
                                     0000       	
                                     0000       $EQU	RAB$M_RNF	134217728
                           08000000  0000       	RAB$M_RNF=134217728
                                     0000       	
                                     0000       $EQU	RAB$M_ETO	268435456
                           10000000  0000       	RAB$M_ETO=268435456
                                     0000       	
                                     0000       $EQU	RAB$M_PTA	536870912
                           20000000  0000       	RAB$M_PTA=536870912
                                     0000       	
                                     0000       $EQU	RAB$M_PMT	1073741824
                           40000000  0000       	RAB$M_PMT=1073741824
                                     0000       	
                                     0000       $EQU	RAB$M_CCO	-2147483648
                           80000000  0000       	RAB$M_CCO=-2147483648
                                     0000       	
                                     0000       $EQU	RAB$M_EQNXT	2097152
                           00200000  0000       	RAB$M_EQNXT=2097152
                                     0000       	
                                     0000       $EQU	RAB$M_NXT	4194304
                           00400000  0000       	RAB$M_NXT=4194304
                                     0000       	
                                     0000       $EQU	RAB$C_SEQ	0
                           00000000  0000       	RAB$C_SEQ=0
                                     0000       	
                                     0000       $EQU	RAB$C_KEY	1
                           00000001  0000       	RAB$C_KEY=1
                                     0000       	
                                     0000       $EQU	RAB$C_RFA	2
                           00000002  0000       	RAB$C_RFA=2
                                     0000       	
                                     0000       $EQU	RAB$C_STM	3
                           00000003  0000       	RAB$C_STM=3
                                     0000       	
                                     0000       $EQU	RAB$C_MAXRAC	2
                           00000002  0000       	RAB$C_MAXRAC=2
                                     0000       	
                                     0000       $EQU	RAB$K_BLN	68
                           00000044  0000       	RAB$K_BLN=68
                                     0000       	
                                     0000       $EQU	RAB$C_BLN	68
                           00000044  0000       	RAB$C_BLN=68
                                     0000       	
                                     0000       $EQU	RAB$S_RABDEF	68
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  32
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000044  0000       	RAB$S_RABDEF=68
                                     0000       	
                                     0000       $EQU	RAB$B_BID	0
                           00000000  0000       	RAB$B_BID=0
                                     0000       	
                                     0000       $EQU	RAB$B_BLN	1
                           00000001  0000       	RAB$B_BLN=1
                                     0000       	
                                     0000       $EQU	RAB$R_ISI_OVERLAY	2
                           00000002  0000       	RAB$R_ISI_OVERLAY=2
                                     0000       	
                                     0000       $EQU	RAB$W_ISI	2
                           00000002  0000       	RAB$W_ISI=2
                                     0000       	
                                     0000       $EQU	RAB$R_ISI_BITS	2
                           00000002  0000       	RAB$R_ISI_BITS=2
                                     0000       	
                                     0000       $EQU	RAB$S_PPF_RAT	8
                           00000008  0000       	RAB$S_PPF_RAT=8
                                     0000       	
                                     0000       $EQU	RAB$V_PPF_RAT	6
                           00000006  0000       	RAB$V_PPF_RAT=6
                                     0000       	
                                     0000       $EQU	RAB$V_PPF_IND	14
                           0000000E  0000       	RAB$V_PPF_IND=14
                                     0000       	
                                     0000       $EQU	RAB$V_PPISI	15
                           0000000F  0000       	RAB$V_PPISI=15
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_OVERLAY	4
                           00000004  0000       	RAB$R_ROP_OVERLAY=4
                                     0000       	
                                     0000       $EQU	RAB$L_ROP	4
                           00000004  0000       	RAB$L_ROP=4
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_BITS0	4
                           00000004  0000       	RAB$R_ROP_BITS0=4
                                     0000       	
                                     0000       $EQU	RAB$V_ASY	0
                           00000000  0000       	RAB$V_ASY=0
                                     0000       	
                                     0000       $EQU	RAB$V_TPT	1
                           00000001  0000       	RAB$V_TPT=1
                                     0000       	
                                     0000       $EQU	RAB$V_REA	2
                           00000002  0000       	RAB$V_REA=2
                                     0000       	
                                     0000       $EQU	RAB$V_RRL	3
                           00000003  0000       	RAB$V_RRL=3
                                     0000       	
                                     0000       $EQU	RAB$V_UIF	4
                           00000004  0000       	RAB$V_UIF=4
                                     0000       	
                                     0000       $EQU	RAB$V_MAS	5
                           00000005  0000       	RAB$V_MAS=5
                                     0000       	
                                     0000       $EQU	RAB$V_FDL	6
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  33
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000006  0000       	RAB$V_FDL=6
                                     0000       	
                                     0000       $EQU	RAB$V_HSH	7
                           00000007  0000       	RAB$V_HSH=7
                                     0000       	
                                     0000       $EQU	RAB$V_EOF	8
                           00000008  0000       	RAB$V_EOF=8
                                     0000       	
                                     0000       $EQU	RAB$V_RAH	9
                           00000009  0000       	RAB$V_RAH=9
                                     0000       	
                                     0000       $EQU	RAB$V_WBH	10
                           0000000A  0000       	RAB$V_WBH=10
                                     0000       	
                                     0000       $EQU	RAB$V_BIO	11
                           0000000B  0000       	RAB$V_BIO=11
                                     0000       	
                                     0000       $EQU	RAB$V_CDK	12
                           0000000C  0000       	RAB$V_CDK=12
                                     0000       	
                                     0000       $EQU	RAB$V_LOA	13
                           0000000D  0000       	RAB$V_LOA=13
                                     0000       	
                                     0000       $EQU	RAB$V_LIM	14
                           0000000E  0000       	RAB$V_LIM=14
                                     0000       	
                                     0000       $EQU	RAB$V_SYNCSTS	15
                           0000000F  0000       	RAB$V_SYNCSTS=15
                                     0000       	
                                     0000       $EQU	RAB$V_LOC	16
                           00000010  0000       	RAB$V_LOC=16
                                     0000       	
                                     0000       $EQU	RAB$V_WAT	17
                           00000011  0000       	RAB$V_WAT=17
                                     0000       	
                                     0000       $EQU	RAB$V_ULK	18
                           00000012  0000       	RAB$V_ULK=18
                                     0000       	
                                     0000       $EQU	RAB$V_RLK	19
                           00000013  0000       	RAB$V_RLK=19
                                     0000       	
                                     0000       $EQU	RAB$V_NLK	20
                           00000014  0000       	RAB$V_NLK=20
                                     0000       	
                                     0000       $EQU	RAB$V_KGE	21
                           00000015  0000       	RAB$V_KGE=21
                                     0000       	
                                     0000       $EQU	RAB$V_KGT	22
                           00000016  0000       	RAB$V_KGT=22
                                     0000       	
                                     0000       $EQU	RAB$V_NXR	23
                           00000017  0000       	RAB$V_NXR=23
                                     0000       	
                                     0000       $EQU	RAB$V_RNE	24
                           00000018  0000       	RAB$V_RNE=24
                                     0000       	
                                     0000       $EQU	RAB$V_TMO	25
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  34
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000019  0000       	RAB$V_TMO=25
                                     0000       	
                                     0000       $EQU	RAB$V_CVT	26
                           0000001A  0000       	RAB$V_CVT=26
                                     0000       	
                                     0000       $EQU	RAB$V_RNF	27
                           0000001B  0000       	RAB$V_RNF=27
                                     0000       	
                                     0000       $EQU	RAB$V_ETO	28
                           0000001C  0000       	RAB$V_ETO=28
                                     0000       	
                                     0000       $EQU	RAB$V_PTA	29
                           0000001D  0000       	RAB$V_PTA=29
                                     0000       	
                                     0000       $EQU	RAB$V_PMT	30
                           0000001E  0000       	RAB$V_PMT=30
                                     0000       	
                                     0000       $EQU	RAB$V_CCO	31
                           0000001F  0000       	RAB$V_CCO=31
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_BITS1	4
                           00000004  0000       	RAB$R_ROP_BITS1=4
                                     0000       	
                                     0000       $EQU	RAB$V_EQNXT	21
                           00000015  0000       	RAB$V_EQNXT=21
                                     0000       	
                                     0000       $EQU	RAB$V_NXT	22
                           00000016  0000       	RAB$V_NXT=22
                                     0000       	
                                     0000       $EQU	RAB$R_ROP_FIELDS	4
                           00000004  0000       	RAB$R_ROP_FIELDS=4
                                     0000       	
                                     0000       $EQU	RAB$B_ROP1	5
                           00000005  0000       	RAB$B_ROP1=5
                                     0000       	
                                     0000       $EQU	RAB$B_ROP2	6
                           00000006  0000       	RAB$B_ROP2=6
                                     0000       	
                                     0000       $EQU	RAB$B_ROP3	7
                           00000007  0000       	RAB$B_ROP3=7
                                     0000       	
                                     0000       $EQU	RAB$L_STS	8
                           00000008  0000       	RAB$L_STS=8
                                     0000       	
                                     0000       $EQU	RAB$R_STV_OVERLAY	12
                           0000000C  0000       	RAB$R_STV_OVERLAY=12
                                     0000       	
                                     0000       $EQU	RAB$L_STV	12
                           0000000C  0000       	RAB$L_STV=12
                                     0000       	
                                     0000       $EQU	RAB$R_STV_FIELDS	12
                           0000000C  0000       	RAB$R_STV_FIELDS=12
                                     0000       	
                                     0000       $EQU	RAB$W_STV0	12
                           0000000C  0000       	RAB$W_STV0=12
                                     0000       	
                                     0000       $EQU	RAB$W_STV2	14
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  35
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           0000000E  0000       	RAB$W_STV2=14
                                     0000       	
                                     0000       $EQU	RAB$R_RFA_OVERLAY	16
                           00000010  0000       	RAB$R_RFA_OVERLAY=16
                                     0000       	
                                     0000       $EQU	RAB$S_RFA	6
                           00000006  0000       	RAB$S_RFA=6
                                     0000       	
                                     0000       $EQU	RAB$W_RFA	16
                           00000010  0000       	RAB$W_RFA=16
                                     0000       	
                                     0000       $EQU	RAB$R_RFA_FIELDS	16
                           00000010  0000       	RAB$R_RFA_FIELDS=16
                                     0000       	
                                     0000       $EQU	RAB$L_RFA0	16
                           00000010  0000       	RAB$L_RFA0=16
                                     0000       	
                                     0000       $EQU	RAB$W_RFA4	20
                           00000014  0000       	RAB$W_RFA4=20
                                     0000       	
                                     0000       $EQU	RAB$L_CTX	24
                           00000018  0000       	RAB$L_CTX=24
                                     0000       	
                                     0000       $EQU	RAB$B_RAC	30
                           0000001E  0000       	RAB$B_RAC=30
                                     0000       	
                                     0000       $EQU	RAB$B_TMO	31
                           0000001F  0000       	RAB$B_TMO=31
                                     0000       	
                                     0000       $EQU	RAB$W_USZ	32
                           00000020  0000       	RAB$W_USZ=32
                                     0000       	
                                     0000       $EQU	RAB$W_RSZ	34
                           00000022  0000       	RAB$W_RSZ=34
                                     0000       	
                                     0000       $EQU	RAB$L_UBF	36
                           00000024  0000       	RAB$L_UBF=36
                                     0000       	
                                     0000       $EQU	RAB$L_RBF	40
                           00000028  0000       	RAB$L_RBF=40
                                     0000       	
                                     0000       $EQU	RAB$L_RHB	44
                           0000002C  0000       	RAB$L_RHB=44
                                     0000       	
                                     0000       $EQU	RAB$R_KBF_OVERLAY	48
                           00000030  0000       	RAB$R_KBF_OVERLAY=48
                                     0000       	
                                     0000       $EQU	RAB$L_KBF	48
                           00000030  0000       	RAB$L_KBF=48
                                     0000       	
                                     0000       $EQU	RAB$L_PBF	48
                           00000030  0000       	RAB$L_PBF=48
                                     0000       	
                                     0000       $EQU	RAB$R_KSZ_OVERLAY	52
                           00000034  0000       	RAB$R_KSZ_OVERLAY=52
                                     0000       	
                                     0000       $EQU	RAB$B_KSZ	52
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  36
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000034  0000       	RAB$B_KSZ=52
                                     0000       	
                                     0000       $EQU	RAB$B_PSZ	52
                           00000034  0000       	RAB$B_PSZ=52
                                     0000       	
                                     0000       $EQU	RAB$B_KRF	53
                           00000035  0000       	RAB$B_KRF=53
                                     0000       	
                                     0000       $EQU	RAB$B_MBF	54
                           00000036  0000       	RAB$B_MBF=54
                                     0000       	
                                     0000       $EQU	RAB$B_MBC	55
                           00000037  0000       	RAB$B_MBC=55
                                     0000       	
                                     0000       $EQU	RAB$R_BKT_OVERLAY	56
                           00000038  0000       	RAB$R_BKT_OVERLAY=56
                                     0000       	
                                     0000       $EQU	RAB$L_BKT	56
                           00000038  0000       	RAB$L_BKT=56
                                     0000       	
                                     0000       $EQU	RAB$L_DCT	56
                           00000038  0000       	RAB$L_DCT=56
                                     0000       	
                                     0000       $EQU	RAB$L_FAB	60
                           0000003C  0000       	RAB$L_FAB=60
                                     0000       	
                                     0000       $EQU	RAB$L_XAB	64
                           00000040  0000       	RAB$L_XAB=64
                                     0000       	
                                     0000       	$DEFEND	RAB,,DEF
                                     0000       	.MACRO	$RABDEF A
                                     0000       	.ENDM	$RABDEF
                                     0000       	.IIF	DIF <> <GLOBAL>,.DISABLE	SUPPRESSION
                                     0000       	.CROSS
                                 000019F8       	.RESTORE
                                     19F8       	
                                     19F8       	
                                     19F8       $$R_TABINIT		RAB$C_BID,RAB$C_BLN
                                     19F8       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           000019F8  19F8       $$.TAB=.
                                 01  19F8       	.BYTE RAB$C_BID
                                 44  19F9       	.BYTE RAB$C_BLN
                           00001A3C  19FA       	.BLKB RAB$C_BLN-2
                           00001A3C  1A3C       $$.TABEND=.
                                     1A3C       
                                     1A3C       	$$R_VBFSET RAB,<rah>
                           00000000  1A3C       $$.TMP=0
                                     1A3C       	.IRP X,<rah>
                                     1A3C       	.IF DF RAB$V_'X
                                     1A3C       		$$.TMP=$$.TMP!<1@RAB$V_'X>
                                     1A3C       	.IFF
                                     1A3C       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1A3C       	.ENDC
                                     1A3C       	.ENDR
                                     1A3C       	.IF DF RAB$V_rah
                           00000200  1A3C       		$$.TMP=$$.TMP!<1@RAB$V_rah>
                                     1A3C       	.IFF
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  37
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1A3C       		.ERROR		; UNDEFINED BIT VALUE CODE: rah;
                                     1A3C       	.ENDC
                                     1A3C       	
                                     1A3C       	
                           000019FC  1A3C       	.=$$.TAB+RAB$L_ROP
                           00000200' 19FC       	.ADDRESS	$$.TMP
                           00001A10  1A00       	.=$$.TAB+RAB$L_CTX
                           00000000' 1A10       	.ADDRESS	0
                           00001A16  1A14       	.=$$.TAB+RAB$B_RAC
                                     1A16       	.IF DF RAB$C_SEQ
                                 00  1A16       	.BYTE	RAB$C_SEQ
                                     1A17       	.IFF
                                     1A17       	.BYTE
                                     1A17       	.ERROR				; UNDEFINED VALUE FOR FIELD: CNST;
                                     1A17       	.ENDC
                                 00  1A17       	.BYTE	0
                               00A0  1A18       	.WORD	c_max_len
                               0000  1A1A       	.WORD	0
                           000018F7' 1A1C       	.ADDRESS	v_inbuf
                           00000000' 1A20       	.ADDRESS	0
                           00000000' 1A24       	.ADDRESS	0
                           00000000' 1A28       	.ADDRESS	0
                                     1A2C       	.IF NB <>
                                     1A2C       	.=$$.TAB+RAB$L_PBF
                                     1A2C       	.ADDRESS	
                                     1A2C       	.ENDC
                                 00  1A2C       	.BYTE	0
                                     1A2D       	.IF NB <>
                                     1A2D       	.=$$.TAB+RAB$B_PSZ
                                     1A2D       	.BYTE	
                                     1A2D       	.ENDC
                                 00  1A2D       	.BYTE	0
                                 00  1A2E       	.BYTE	0
                                 00  1A2F       	.BYTE	0
                           00000000' 1A30       	.ADDRESS	0
                           000019A8' 1A34       	.ADDRESS	v_infab
                           00000000' 1A38       	.ADDRESS	0
                           00001A3C  1A3C       	.=$$.TABEND
                                     1A3C       	
                                     1A3C   420 v_fnamelen:
                                 00  1A3C   421 	.byte	0		; length of file name for { load }
                                     1A3D   422 v_fname:
                           00001ADD  1A3D   423 	.blkb	c_max_len	; buffer for fil ename for {load}
                                     1ADD   424 
                                     1ADD   425 
                                     1ADD   426 ;
                                     1ADD   427 ; rms buffers for VTIL block i/o (which is actually rms record i/o)
                                     1ADD   428 ;
                                     1ADD   429 	.align long
                                     1AE0   430 v_blkfab:
                                     1AE0   431 	$fab	dnm=<vtilblocks.dat>,-	; default input file name
                                     1AE0   432 		fac=<get,upd>,-		; block i/o operations
                                     1AE0   433 		fnm=<vtilblocks>,-	; input file name
                                     1AE0   434 		mrs=c_block_size,-	; maximum record size
                                     1AE0   435 		rfm=<fix>		; fixed length records
                                     1AE0       	$FABDEF
                                     1AE0       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  38
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1AE0       	$$R_TABINIT	FAB$C_BID, FAB$C_BLN
                                     1AE0       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           00001AE0  1AE0       $$.TAB=.
                                 03  1AE0       	.BYTE FAB$C_BID
                                 50  1AE1       	.BYTE FAB$C_BLN
                           00001B30  1AE2       	.BLKB FAB$C_BLN-2
                           00001B30  1B30       $$.TABEND=.
                                     1B30       
                                     1B30       	$$R_VBFSET	FAB,<>
                           00000000  1B30       $$.TMP=0
                                     1B30       	.IRP X,<>
                                     1B30       	.IF DF FAB$V_'X
                                     1B30       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1B30       	.IFF
                                     1B30       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B30       	.ENDC
                                     1B30       	.ENDR
                                     1B30       	
                           00001AE4  1B30       	.=$$.TAB+FAB$L_FOP
                           00000000' 1AE4       	.ADDRESS	$$.TMP
                           00001AF0  1AE8       	.=$$.TAB+FAB$L_ALQ
                           00000000' 1AF0       	.ADDRESS	0
                               0000  1AF4       	.WORD	0
                                     1AF6       	$$R_VBFSET	FAB,<get,upd>
                           00000000  1AF6       $$.TMP=0
                                     1AF6       	.IRP X,<get,upd>
                                     1AF6       	.IF DF FAB$V_'X
                                     1AF6       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AF6       	.ENDC
                                     1AF6       	.ENDR
                                     1AF6       	.IF DF FAB$V_get
                           00000002  1AF6       		$$.TMP=$$.TMP!<1@FAB$V_get>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: get;
                                     1AF6       	.ENDC
                                     1AF6       	
                                     1AF6       	.IF DF FAB$V_upd
                           0000000A  1AF6       		$$.TMP=$$.TMP!<1@FAB$V_upd>
                                     1AF6       	.IFF
                                     1AF6       		.ERROR		; UNDEFINED BIT VALUE CODE: upd;
                                     1AF6       	.ENDC
                                     1AF6       	
                                     1AF6       	
                                 0A  1AF6       	.BYTE	$$.TMP
                                     1AF7       	$$R_VBFSET	FAB,<>
                           00000000  1AF7       $$.TMP=0
                                     1AF7       	.IRP X,<>
                                     1AF7       	.IF DF FAB$V_'X
                                     1AF7       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AF7       	.IFF
                                     1AF7       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AF7       	.ENDC
                                     1AF7       	.ENDR
                                     1AF7       	
                                 00  1AF7       	.BYTE	$$.TMP
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  39
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000000' 1AF8       	.ADDRESS	0
                                 00  1AFC       	.BYTE	0
                                     1AFD       	.IF DF FAB$C_SEQ
                                 00  1AFD       	.BYTE	FAB$C_SEQ
                                     1AFE       	.IFF
                                     1AFE       	.BYTE
                                     1AFE       	.ERROR			; UNDEFINED VALUE FOR FIELD : SEQ;
                                     1AFE       	.ENDC
                                     1AFE       	$$R_VBFSET	FAB,<>
                           00000000  1AFE       $$.TMP=0
                                     1AFE       	.IRP X,<>
                                     1AFE       	.IF DF FAB$V_'X
                                     1AFE       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1AFE       	.IFF
                                     1AFE       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1AFE       	.ENDC
                                     1AFE       	.ENDR
                                     1AFE       	
                                 00  1AFE       	.BYTE	$$.TMP
                                     1AFF       	.IF DF FAB$C_fix
                                 01  1AFF       	.BYTE	FAB$C_fix
                                     1B00       	.IFF
                                     1B00       	.BYTE
                                     1B00       	.ERROR			; UNDEFINED VALUE FOR FIELD : fix;
                                     1B00       	.ENDC
                                     1B00       	$$R_VBFSET	FAB,<>
                           00000000  1B00       $$.TMP=0
                                     1B00       	.IRP X,<>
                                     1B00       	.IF DF FAB$V_'X
                                     1B00       		$$.TMP=$$.TMP!<1@FAB$V_'X>
                                     1B00       	.IFF
                                     1B00       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B00       	.ENDC
                                     1B00       	.ENDR
                                     1B00       	
                                 00  1B00       	.BYTE	$$.TMP
                                 00  1B01       	.BYTE	0
                               0000  1B02       	.WORD
                           00000000' 1B04       	.ADDRESS	0
                           00000000' 1B08       	.ADDRESS	0
                           00000000' 1B0C       	.ADDRESS	0
                           00000000' 1B10       	.ADDRESS	0
                                 00  1B14       	.BYTE	0
                                 00  1B15       	.BYTE	0
                               0400  1B16       	.WORD	c_block_size
                           00000000' 1B18       	.ADDRESS	0
                               0000  1B1C       	.WORD	0
                                 00  1B1E       	.BYTE	0
                                 00  1B1F       	.BYTE	0
                           00001B28  1B20       	.=$$.TAB+FAB$W_GBC
                               0000  1B28       	.WORD	0
                                 00  1B2A       	.BYTE	<<0@FAB$V_LNM_MODE> + <0@FAB$V_CHAN_MODE> + -
                                     1B2B       		<0@FAB$V_FILE_MODE>>
                                     1B2B       	.IIF NE 8-8, .ERROR	; INVALID BYTE SIZE
                                     1B2B       	.IF NB <vtilblocks>
                                     1B2B       	.SAVE
                                 00000000       	.PSECT $RMSNAM
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  40
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000000  0000       	$$.TMPX=.
      73 6B 63 6F 6C 62 6C 69 74 76  0000       	.ASCII %vtilblocks%
                           0000000A  000A       	$$.TMPX1=.-$$.TMPX
                                 00001B2B       	.RESTORE
                           00001B0C  1B2B       	.=$$.TAB+FAB$L_FNA
                           00000000' 1B0C       	.ADDRESS	$$.TMPX
                           00001B14  1B10       	.=$$.TAB+FAB$B_FNS
                                 0A  1B14       	.BYTE	$$.TMPX1
                                     1B15       	.ENDC
                                     1B15       	.IF NB <vtilblocks.dat>
                                     1B15       	.SAVE
                                 0000000A       	.PSECT $RMSNAM
                           0000000A  000A       	$$.TMPX=.
64 2E 73 6B 63 6F 6C 62 6C 69 74 76  000A       	.ASCII %vtilblocks.dat%
                              74 61  0016       
                           0000000E  0018       	$$.TMPX1=.-$$.TMPX
                                 00001B15       	.RESTORE
                           00001B10  1B15       	.=$$.TAB+FAB$L_DNA
                           0000000A' 1B10       	.ADDRESS	$$.TMPX
                           00001B15  1B14       	.=$$.TAB+FAB$B_DNS
                                 0E  1B15       	.BYTE	$$.TMPX1
                                     1B16       	.ENDC
                           00001B30  1B16       	.=$$.TABEND
                                     1B30       	
                                     1B30   436 v_blkrab:
                                     1B30   437 	$rab	fab=v_blkfab,-		; pointer to fab
                                     1B30   438 		kfb=v_blkkey,-		; pointer to key
                                     1B30   439 		ksz=c_keysize,-		; size of key
                                     1B30   440 		rac=<key>,-		; random access by record number
                                     1B30   441 		ubf=v_blkbuff,-		; address of user buffer
                                     1B30   442 		usz=c_block_size	; and the record size
                                     1B30       $RABDEF
                                     1B30       	
                                     1B30       $$R_TABINIT		RAB$C_BID,RAB$C_BLN
                                     1B30       .IIF NE .&3, .print ;%MACRO-I-GENINFO, Generated INFO: RMS BLOCK NOT LONGWORD ALIGNED
                           00001B30  1B30       $$.TAB=.
                                 01  1B30       	.BYTE RAB$C_BID
                                 44  1B31       	.BYTE RAB$C_BLN
                           00001B74  1B32       	.BLKB RAB$C_BLN-2
                           00001B74  1B74       $$.TABEND=.
                                     1B74       
                                     1B74       	$$R_VBFSET RAB,<>
                           00000000  1B74       $$.TMP=0
                                     1B74       	.IRP X,<>
                                     1B74       	.IF DF RAB$V_'X
                                     1B74       		$$.TMP=$$.TMP!<1@RAB$V_'X>
                                     1B74       	.IFF
                                     1B74       		.ERROR		; UNDEFINED BIT VALUE CODE: X;
                                     1B74       	.ENDC
                                     1B74       	.ENDR
                                     1B74       	
                           00001B34  1B74       	.=$$.TAB+RAB$L_ROP
                           00000000' 1B34       	.ADDRESS	$$.TMP
                           00001B48  1B38       	.=$$.TAB+RAB$L_CTX
                           00000000' 1B48       	.ADDRESS	0
                           00001B4E  1B4C       	.=$$.TAB+RAB$B_RAC
                                     1B4E       	.IF DF RAB$C_key
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  41
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 01  1B4E       	.BYTE	RAB$C_key
                                     1B4F       	.IFF
                                     1B4F       	.BYTE
                                     1B4F       	.ERROR				; UNDEFINED VALUE FOR FIELD: CNST;
                                     1B4F       	.ENDC
                                 00  1B4F       	.BYTE	0
                               0400  1B50       	.WORD	c_block_size
                               0000  1B52       	.WORD	0
                           00004000' 1B54       	.ADDRESS	v_blkbuff
                           00000000' 1B58       	.ADDRESS	0
                           00000000' 1B5C       	.ADDRESS	0
                           00000000' 1B60       	.ADDRESS	0
                                     1B64       	.IF NB <>
                                     1B64       	.=$$.TAB+RAB$L_PBF
                                     1B64       	.ADDRESS	
                                     1B64       	.ENDC
                                 04  1B64       	.BYTE	c_keysize
                                     1B65       	.IF NB <>
                                     1B65       	.=$$.TAB+RAB$B_PSZ
                                     1B65       	.BYTE	
                                     1B65       	.ENDC
                                 00  1B65       	.BYTE	0
                                 00  1B66       	.BYTE	0
                                 00  1B67       	.BYTE	0
                           00000000' 1B68       	.ADDRESS	0
                           00001AE0' 1B6C       	.ADDRESS	v_blkfab
                           00000000' 1B70       	.ADDRESS	0
                           00001B74  1B74       	.=$$.TABEND
                                     1B74       	
                                     1B74   443 v_blkkey:
                           00000000  1B74   444 	.long				; buffer for key (longword pos rec #)
                                     1B78   445 v_blockio:
                                 00  1B78   446 	.byte	c_false			; true when block file is open
                                     1B79   447 v_current_buff:				; Buffer # of most recently accessed
                           00000000  1B79   448 	.long	0			; block
                                     1B7D   449 
                                     1B7D   450 v_buf_inuse:
                           00001B80  1B7D   451 	.blkb	c_max_blocks		; flags for inuse and modified
                                     1B80   452 v_buf_blk_nums:
                           00001B8C  1B80   453 	.blkl	c_max_blocks		; block numbers in buffers
                                     1B8C   454 
                                     1B8C   455 ;
                                     1B8C   456 ; Moved the Block i/o buffers away from the rest of the block i/o stuff
                                     1B8C   457 ; to the end of the dictionary because that is safer.  They are away from
                                     1B8C   458 ; other variables that might get overwritten if someone tries to write
                                     1B8C   459 ; too long a string to the buffers, for instance.
                                     1B8C   460 ;
                                     1B8C   461 
                                     1B8C   462 
                                     1B8C   463 ;
                                     1B8C   464 ; variables for terminal input
                                     1B8C   465 ;
                                     1B8C   466 v_readlen:
                               0000  1B8C   467 	.word			; length of returned input
                                     1B8E   468 v_readdsc:
                               00A0  1B8E   469 	.word	c_max_len	; maximum length
                                 00' 1B90   470 	.byte	dsc$k_dtype_t	; data type text
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  42
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 00' 1B91   471 	.byte	dsc$k_class_s	; descriptor class
                                     1B92   472 v_readaddr:
                           00000000  1B92   473 	.long	0		; pointer to the input buffer
                                     1B96   474 ; v_static_dsc is the middle of a descriptor so it can be copied onto ds
                                     1B96   475 ; to make full desciptor when top fo stack is ( addr count )
                                     1B96   476 v_static_dsc:
                                 00' 1B96   477 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1B97   478 	.byte	dsc$k_class_s	; descriptor class
                                     1B98   479 v_outlen:
                               0000  1B98   480 	.word	0		; length of output
                                     1B9A   481 v_outbuf:
                           00001C3A  1B9A   482 	.blkb	c_max_len	; output bufer
                                     1C3A   483 
                                     1C3A   484 
                                     1C3A   485 ;
                                     1C3A   486 ; Variables for calling the EVE editor using its callable interface.
                                     1C3A   487 ;
                                     1C3A   488 v_tpu_com:			; buffer for constant section of command
3D 6E 6F 69 74 63 65 73 2F 75 70 74  1C3A   489 	.ascii	\tpu/section=eve$dir:eve_edt \ ; use my version of eve
5F 65 76 65 3A 72 69 64 24 65 76 65  1C46       
                        20 74 64 65  1C52       
                           0000001C  1C56   490 c_tpu_com_len = . - v_tpu_com	; length of command is a constant
                                     1C56   491 v_tpu_com2:			; buffer for user section of command
                           00001CF6  1C56   492 	.blkb	c_max_len
                                     1CF6   493 v_tpu_dsc:
                               0000  1CF6   494 	.word	0		; descriptor for command to pass to tpu$tpu
                                 00' 1CF8   495 	.byte	dsc$k_dtype_t	; data type text
                                 00' 1CF9   496 	.byte	dsc$k_class_s	; descriptor class
                           00001C3A' 1CFA   497 	.long	 v_tpu_com	; pointer to tpu command buffer
                                     1CFE   498 ;
                                     1CFE   499 ; Buffers for $ASSIGN, $DASSIGN, and $QIO
                                     1CFE   500 ;
                                     1CFE   501 v_input_name:
6F 63 24 73 79 73 00001D06'010E0000' 1CFE   502 	.ascid	/sys$command/
                     64 6E 61 6D 6D  1D0C       
                                     1D11   503 v_input_chan:
                           00001D13  1D11   504 	.blkw	1
                                     1D13   505 ;
                                     1D13   506 ; Buffers for $GETCHN_S
                                     1D13   507 ;
                                     1D13   508 v_getchn_ret_len:		; returned length of buffer info
                           00000000  1D13   509 	.long	0
                                     1D17   510 v_getchn_in_buf:		; input buffer for getchn, tells about output
                                     1D17   511 				; buffer
                           00000008  1D17   512 	.long	8		; length of output buffer
                                     1D1B   513 v_getchn_buf_adr:
                           00001D1F' 1D1B   514 	.long	v_getchn_buf	; address of output buffer
                                     1D1F   515 v_getchn_buf:			; output buffer
                  00000000 00000000  1D1F   516 	.quad	0		; cleared to begin
                                     1D27   517 
                                     1D27   518 ;
                                     1D27   519 ; System Variables
                                     1D27   520 ;
                                     1D27   521 v_trap_depth:		; depth to unwind stack in trap handler
                           00000001  1D27   522 	.long	1	; unwind to establisher, i.e, main body, 1 deep
                                     1D2B   523 v_ctrlc_depth:		; depth to unwind stack in control/c handler
                           00000002  1D2B   524 	.long	2	; unwind to main program, 2 deep (ctrlc and a_start)
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  43
V1.01                           Data Section                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1D2F   525 v_errors:
                           00000000  1D2F   526 	.long	0	; Number of errors caught by condition handler so far
                                     1D33   527 v_returnstack:		; original return stack pointer.  Save it when we
                           00000000  1D33   528 	.long	0	; abort out of jsb's we return from the right spot
                                     1D37   529 v_context:		; points to data field of the word for the vocabulary
                           00000000  1D37   530 	.long	0	; in which words are searched for.
                                     1D3B   531 v_current:		; points to data field of the word for the vocabulary
                           00000000  1D3B   532 	.long	0	; that new words are linked into.
                                     1D3F   533 v_compiler:		; Pointer to most recent word in compiler vocabulary
                           00000000  1D3F   534 	.long	0
                                     1D43   535 v_kernel:		; Pointer to most recnet word in kernel vocabulary
                           00000000  1D43   536 	.long	0	; data field of { kernel }
                                     1D47   537 v_infile:		; Flag.	 If true, reading from an input file.
                                 00  1D47   538 	.byte	c_false	; If false, reading from terminal.  Set by { load }
                                     1D48   539 v_filelinenum:		; number of lines read from input file
                           00000000  1D48   540 	.long	0	; used in error reporting
                                     1D4C   541 v_state:		; Flag.	 True if compiletime word found
                                 00  1D4C   542 	.byte	c_false ; in compile mode (then set to false by ?execute),
                                     1D4D   543 			; otherwise false.
                                     1D4D   544 v_mode:			; Flag.	 True if in compile mode, false if execute mode.
                                 00  1D4D   545 	.byte	c_false ; true => compile word, false => execute word
                                     1D4E   546 v_radix:
                           0000000A  1D4E   547 	.long	10	; base for number conversion on input and output
                                     1D52   548 v_hld:
                           00000000  1D52   549 	.long	0	; pointer to number output conversion buffer
                                     1D56   550 
                                     1D56   551 	newpage <Kernel Built-ins>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  44
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1D56       	.sbttl	Kernel Built-ins
                                     1D56       	
                                 00000000   552 	.psect	vtilcode,exe,nowrt
                                     0000   553 ;******************************************************************************
                                     0000   554 ;
                                     0000   555 ; Kernel Built-Ins -- Original vocabulary of words.  All other vocabularies
                                     0000   556 ;	link into this one, except the compiler (compiletime word) vocabulary.
                                     0000   557 ;
                                     0000   558 ;******************************************************************************
                                     0000   559 _kernel_begin:
                                     0000   560 
                                     0000   561 
                                     0000   562 ;+++t
                                     0000   563 ;k> ! (store) -- ( n a -- ) store longword `n?' at `a'.
                                     0000   564 ;---
                                     0000   565 	header	i_store,<!>
                           00001512' 0000       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000000  0004       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  0004       	.nchr  nchr, ^\!\	; nchr = length( ! )
                           00000001  0004       	.if    le, nchr		; nchr <= 0
                                     0004       	   .ascic \i_store\	; no auxillary !, use principle one
                                     0004       	.if_false		; else
                              21 00' 0004       	  .ascic \!\		; use auxillary !
                                 01  0004       
                                     0006       	.endc			; end if
                                     0006       i_store:			; use ! of word as v1_kernel label
                                     0006       	
                 00 BB   04 AB   D0  0006   566 	movl	4(r11),@(r11)		; store item at what's pointed to by
                                     000B   567 					; top of stack
                       5B   08   C0  000B   568 	addl2	#8,r11			; pop arguments
                                 05  000E   569 	rsb				; end of !
                                     000F   570 
                                     000F   571 
                                     000F   572 ;+++
                                     000F   573 ;k> # -- ( n1 -- n2 ) generate next output character in number conversion.
                                     000F   574 ;	used between { <# } and { #> }.
                                     000F   575 ;---
                                     000F   576 	header	i_sharp,<#>
                           00000000' 000F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000000F  0013       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  0013       	.nchr  nchr, ^\#\	; nchr = length( # )
                           00000001  0013       	.if    le, nchr		; nchr <= 0
                                     0013       	   .ascic \i_sharp\	; no auxillary #, use principle one
                                     0013       	.if_false		; else
                              23 00' 0013       	  .ascic \#\		; use auxillary #
                                 01  0013       
                                     0015       	.endc			; end if
                                     0015       i_sharp:			; use # of word as v1_kernel label
                                     0015       	
              7B   00001D4E'EF   D0  0015   577 	movl	v_radix,-(r11)	; put radix on stack
                   000001CD'EF   16  001C   578 	jsb	i_div_mod	; get next digit
                   000012BD'EF   16  0022   579 	jsb	tochar		; make it appropriate ascii char
                   00000B0F'EF   16  0028   580 	jsb	hold		; put in output string
                                 05  002E   581 	rsb			; end of #
                                     002F   582 
                                     002F   583 
                                     002F   584 ;+++
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  45
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     002F   585 ;k> #> -- ( n1 -- a n2 ) End numeric output.  Leaves length and address of
                                     002F   586 ;	numeric text on stack for { write }.
                                     002F   587 ;---
                                     002F   588 	header	i_sharp_greater,^\#>\
                           0000000F' 002F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000002F  0033       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0033       	.nchr  nchr, ^\#>\	; nchr = length( #> )
                           00000002  0033       	.if    le, nchr		; nchr <= 0
                                     0033       	   .ascic \i_sharp_greater\	; no auxillary #>, use principle one
                                     0033       	.if_false		; else
                           3E 23 00' 0033       	  .ascic \#>\		; use auxillary #>
                                 02  0033       
                                     0036       	.endc			; end if
                                     0036       i_sharp_greater:			; use #> of word as v1_kernel label
                                     0036       	
              6B   00001D52'EF   D0  0036   589 	movl	v_hld,(r11)		; drop number, put address of output
                                     003D   590 					; on stack
         50   00000109 8F   59   C1  003D   591 	addl3	r9,#c_pad_moat,r0	; get address of pad
         7B   50   00001D52'EF   C3  0045   592 	subl3	v_hld,r0,-(r11)		; put count on stack
                                     004D   593 					; count = pad - hld
                                 05  004D   594 	rsb				; end of #>
                                     004E   595 
                                     004E   596 
                                     004E   597 ;+++
                                     004E   598 ;k> #s -- ( n1 -- n2 ) Convert all all digits of n1 to output string.  Leaves 0.
                                     004E   599 ;	Used between { <# } and { #> }.
                                     004E   600 ;---
                                     004E   601 	header	i_sharp_s,<#s>
                           0000002F' 004E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000004E  0052       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0052       	.nchr  nchr, ^\#s\	; nchr = length( #s )
                           00000002  0052       	.if    le, nchr		; nchr <= 0
                                     0052       	   .ascic \i_sharp_s\	; no auxillary #s, use principle one
                                     0052       	.if_false		; else
                           73 23 00' 0052       	  .ascic \#s\		; use auxillary #s
                                 02  0052       
                                     0055       	.endc			; end if
                                     0055       i_sharp_s:			; use #s of word as v1_kernel label
                                     0055       	
                         BD AF   16  0055   602 	jsb	i_sharp			; output at least one character
                            6B   D5  0058   603 	tstl	(r11)			; is top not = 0?
                            F9   12  005A   604 	bneq	i_sharp_s		; yes, do it again
                                 05  005C   605 	rsb				; no, exit
                                     005D   606 					; end of #s
                                     005D   607 
                                     005D   608 
                                     005D   609 ;+++
                                     005D   610 ;k> (# -- ( -- ) Start count of items on the stack.  Used with { #) }.
                                     005D   611 ;	Uses the loop stack!
                                     005D   612 ;---
                                     005D   613 	header	i_count_begin,<(#>
                           0000004E' 005D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000005D  0061       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0061       	.nchr  nchr, ^\(#\	; nchr = length( (# )
                           00000002  0061       	.if    le, nchr		; nchr <= 0
                                     0061       	   .ascic \i_count_begin\	; no auxillary (#, use principle one
                                     0061       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  46
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           23 28 00' 0061       	  .ascic \(#\		; use auxillary (#
                                 02  0061       
                                     0064       	.endc			; end if
                                     0064       i_count_begin:			; use (# of word as v1_kernel label
                                     0064       	
                       7A   5B   D0  0064   614 	movl	r11,-(r10)		; save address of top of stack
                                 05  0067   615 	rsb				; end of (#
                                     0068   616 
                                     0068   617 
                                     0068   618 ;+++
                                     0068   619 ;k> (and) -- ( n1 n2 -- n3 ) bitwise and of n1 and n2.
                                     0068   620 ;---
                                     0068   621 	header	i_bit_and,<(and)>
                           0000005D' 0068       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000068  006C       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  006C       	.nchr  nchr, ^\(and)\	; nchr = length( (and) )
                           00000005  006C       	.if    le, nchr		; nchr <= 0
                                     006C       	   .ascic \i_bit_and\	; no auxillary (and), use principle one
                                     006C       	.if_false		; else
                  29 64 6E 61 28 00' 006C       	  .ascic \(and)\		; use auxillary (and)
                                 05  006C       
                                     0072       	.endc			; end if
                                     0072       i_bit_and:			; use (and) of word as v1_kernel label
                                     0072       	
                       6B   6B   D2  0072   622 	mcoml	(r11),(r11)		; make ones comp because blc ones
                                     0075   623 					; comps mask
                       6B   8B   CA  0075   624 	bicl2	(r11)+,(r11)		; and it
                                 05  0078   625 	rsb				; end of (and)
                                     0079   626 
                                     0079   627 
                                     0079   628 ;+++
                                     0079   629 ;k> (not) -- ( n1 n2 -- n3 ) bitwise not of n1 and n2.
                                     0079   630 ;---
                                     0079   631 	header	i_bit_not,<(not)>
                           00000068' 0079       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000079  007D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  007D       	.nchr  nchr, ^\(not)\	; nchr = length( (not) )
                           00000005  007D       	.if    le, nchr		; nchr <= 0
                                     007D       	   .ascic \i_bit_not\	; no auxillary (not), use principle one
                                     007D       	.if_false		; else
                  29 74 6F 6E 28 00' 007D       	  .ascic \(not)\		; use auxillary (not)
                                 05  007D       
                                     0083       	.endc			; end if
                                     0083       i_bit_not:			; use (not) of word as v1_kernel label
                                     0083       	
                       6B   6B   D2  0083   632 	mcoml	(r11),(r11)		; not it
                                 05  0086   633 	rsb				; end of (not)
                                     0087   634 
                                     0087   635 
                                     0087   636 ;+++
                                     0087   637 ;k> (or) -- ( n1 n2 -- n3 ) bitwise or of n1 and n2.
                                     0087   638 ;---
                                     0087   639 	header	i_bit_or,<(or)>
                           00000079' 0087       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000087  008B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  008B       	.nchr  nchr, ^\(or)\	; nchr = length( (or) )
                           00000004  008B       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  47
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     008B       	   .ascic \i_bit_or\	; no auxillary (or), use principle one
                                     008B       	.if_false		; else
                     29 72 6F 28 00' 008B       	  .ascic \(or)\		; use auxillary (or)
                                 04  008B       
                                     0090       	.endc			; end if
                                     0090       i_bit_or:			; use (or) of word as v1_kernel label
                                     0090       	
                       6B   8B   C8  0090   640 	bisl2	(r11)+,(r11)		; or it
                                 05  0093   641 	rsb				; end of (or)
                                     0094   642 
                                     0094   643 
                                     0094   644 ;+++
                                     0094   645 ;k> (xor) -- ( n1 n2 -- n3) bitwise xor of n1 and n2.
                                     0094   646 ;---
                                     0094   647 	header	i_bit_xor,<(xor)>
                           00000087' 0094       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000094  0098       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  0098       	.nchr  nchr, ^\(xor)\	; nchr = length( (xor) )
                           00000005  0098       	.if    le, nchr		; nchr <= 0
                                     0098       	   .ascic \i_bit_xor\	; no auxillary (xor), use principle one
                                     0098       	.if_false		; else
                  29 72 6F 78 28 00' 0098       	  .ascic \(xor)\		; use auxillary (xor)
                                 05  0098       
                                     009E       	.endc			; end if
                                     009E       i_bit_xor:			; use (xor) of word as v1_kernel label
                                     009E       	
                       6B   8B   CC  009E   648 	xorl2	(r11)+,(r11)		; xor it
                                 05  00A1   649 	rsb				; end of (xor)
                                     00A2   650 
                                     00A2   651 
                                     00A2   652 ;+++t
                                     00A2   653 ;k> * -- ( n1 n2 -- n3) multiply top two stack items, leave result on stack.
                                     00A2   654 ;---
                                     00A2   655 	header	i_multiply,<*>
                           00000094' 00A2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000A2  00A6       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  00A6       	.nchr  nchr, ^\*\	; nchr = length( * )
                           00000001  00A6       	.if    le, nchr		; nchr <= 0
                                     00A6       	   .ascic \i_multiply\	; no auxillary *, use principle one
                                     00A6       	.if_false		; else
                              2A 00' 00A6       	  .ascic \*\		; use auxillary *
                                 01  00A6       
                                     00A8       	.endc			; end if
                                     00A8       i_multiply:			; use * of word as v1_kernel label
                                     00A8       	
                       6B   8B   C4  00A8   656 	mull2	(r11)+,(r11)		; multiply them
                                 05  00AB   657 	rsb				; end of *
                                     00AC   658 
                                     00AC   659 
                                     00AC   660 ;+++
                                     00AC   661 ;k> #) -- ( -- n ) Return number of items on stack since last { (# }.
                                     00AC   662 ;	uses the loop stack!
                                     00AC   663 ;---
                                     00AC   664 	header	i_count_end,<#)>
                           000000A2' 00AC       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000AC  00B0       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  00B0       	.nchr  nchr, ^\#)\	; nchr = length( #) )
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  48
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000002  00B0       	.if    le, nchr		; nchr <= 0
                                     00B0       	   .ascic \i_count_end\	; no auxillary #), use principle one
                                     00B0       	.if_false		; else
                           29 23 00' 00B0       	  .ascic \#)\		; use auxillary #)
                                 02  00B0       
                                     00B3       	.endc			; end if
                                     00B3       i_count_end:			; use #) of word as v1_kernel label
                                     00B3       	
                  7B   8A   5B   C3  00B3   665 	subl3	r11,(r10)+,-(r11)	; number of bytes difference in
                                     00B7   666 					; top of stack then and now.
                       6B   04   C6  00B7   667 	divl2	#4,(r11)		; divide to get number of stack
                                     00BA   668 					; items (longwords)
                                 05  00BA   669 	rsb				; end of #)
                                     00BB   670 
                                     00BB   671 
                                     00BB   672 ;+++t
                                     00BB   673 ;k> + -- ( n1 n2 -- n3 ) add the top two stack items, leave result on stack.
                                     00BB   674 ;---
                                     00BB   675 	header	i_add,<+>
                           000000AC' 00BB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000BB  00BF       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  00BF       	.nchr  nchr, ^\+\	; nchr = length( + )
                           00000001  00BF       	.if    le, nchr		; nchr <= 0
                                     00BF       	   .ascic \i_add\	; no auxillary +, use principle one
                                     00BF       	.if_false		; else
                              2B 00' 00BF       	  .ascic \+\		; use auxillary +
                                 01  00BF       
                                     00C1       	.endc			; end if
                                     00C1       i_add:			; use + of word as v1_kernel label
                                     00C1       	
                       6B   8B   C0  00C1   676 	addl2	(r11)+,(r11)		; add them and leave the result on stack
                                 05  00C4   677 	rsb				; end of +
                                     00C5   678 
                                     00C5   679 
                                     00C5   680 ;+++
                                     00C5   681 ;k> +! -- ( n a -- ) Adds `n' to contents of `a'.
                                     00C5   682 ;---
                                     00C5   683 	header	i_plus_store,<+!>
                           000000BB' 00C5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000C5  00C9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  00C9       	.nchr  nchr, ^\+!\	; nchr = length( +! )
                           00000002  00C9       	.if    le, nchr		; nchr <= 0
                                     00C9       	   .ascic \i_plus_store\	; no auxillary +!, use principle one
                                     00C9       	.if_false		; else
                           21 2B 00' 00C9       	  .ascic \+!\		; use auxillary +!
                                 02  00C9       
                                     00CC       	.endc			; end if
                                     00CC       i_plus_store:			; use +! of word as v1_kernel label
                                     00CC       	
                                     00CC   684 ; Add top of stack to cents of address that is top of stack.
                 00 BB   04 AB   C0  00CC   685 	addl2	   4(r11),@(r11)	;
                       5B   08   C0  00D1   686 	addl2	   #8,r11		; pop arguments
                                 05  00D4   687 	rsb				; end of +!
                                     00D5   688 
                                     00D5   689 
                                     00D5   690 ;+++
                                     00D5   691 ;k> +rot - (n1 n2 n3 -- n3 n1 n2 ) rotate top 3 items on the stack up,
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  49
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     00D5   692 ;	bringing the second to the top.
                                     00D5   693 ;---
                                     00D5   694 	header	i_plus_rot,<+rot>
                           000000C5' 00D5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000D5  00D9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  00D9       	.nchr  nchr, ^\+rot\	; nchr = length( +rot )
                           00000004  00D9       	.if    le, nchr		; nchr <= 0
                                     00D9       	   .ascic \i_plus_rot\	; no auxillary +rot, use principle one
                                     00D9       	.if_false		; else
                     74 6F 72 2B 00' 00D9       	  .ascic \+rot\		; use auxillary +rot
                                 04  00D9       
                                     00DE       	.endc			; end if
                                     00DE       i_plus_rot:			; use +rot of word as v1_kernel label
                                     00DE       	
                       50   6B   D0  00DE   695 	movl	(r11),r0		; t1 = n3
                    6B   04 AB   D0  00E1   696 	movl	4(r11),(r11)		; n3 = n2
                 04 AB   08 AB   D0  00E5   697 	movl	8(r11),4(r11)		; n2 = n1
                    08 AB   50   D0  00EA   698 	movl	r0,8(r11)		; n1 = t1 (old n3)
                                 05  00EE   699 	rsb				; end of +rot
                                     00EF   700 
                                     00EF   701 
                                     00EF   702 ;+++
                                     00EF   703 ;k> , -- ( n -- ) Compile a longword `n' into the dictionary.
                                     00EF   704 ;---
                                     00EF   705 	header	i_comma,<,>
                           000000D5' 00EF       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000EF  00F3       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  00F3       	.nchr  nchr, ^\,\	; nchr = length( , )
                           00000001  00F3       	.if    le, nchr		; nchr <= 0
                                     00F3       	   .ascic \i_comma\	; no auxillary ,, use principle one
                                     00F3       	.if_false		; else
                              2C 00' 00F3       	  .ascic \,\		; use auxillary ,
                                 01  00F3       
                                     00F5       	.endc			; end if
                                     00F5       i_comma:			; use , of word as v1_kernel label
                                     00F5       	
                       89   8B   D0  00F5   706 	movl	(r11)+,(r9)+		; store longword in dictionary
                                 05  00F8   707 	rsb				; end of ,
                                     00F9   708 
                                     00F9   709 
                                     00F9   710 ;+++t
                                     00F9   711 ;k> - -- ( n1 n2 -- n3 ) subtract the top stack item from the next stack item.
                                     00F9   712 ;---
                                     00F9   713 	header	i_subtract,<->
                           000000EF' 00F9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000000F9  00FD       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  00FD       	.nchr  nchr, ^\-\	; nchr = length( - )
                           00000001  00FD       	.if    le, nchr		; nchr <= 0
                                     00FD       	   .ascic \i_subtract\	; no auxillary -, use principle one
                                     00FD       	.if_false		; else
                              2D 00' 00FD       	  .ascic \-\		; use auxillary -
                                 01  00FD       
                                     00FF       	.endc			; end if
                                     00FF       i_subtract:			; use - of word as v1_kernel label
                                     00FF       	
                       6B   8B   C2  00FF   714 	subl2	(r11)+,(r11)		; subract and leave result on stack.
                                 05  0102   715 	rsb				; end of -
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  50
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0103   716 
                                     0103   717 
                                     0103   718 ;+++
                                     0103   719 ;k> -rot -- ( n1 n2 n3 -- n2 n3 n1 ) rotate top 3 items on the stack down,
                                     0103   720 ;	bringing the third to the top.
                                     0103   721 ;---
                                     0103   722 	header	i_minus_rot,<-rot>
                           000000F9' 0103       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000103  0107       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  0107       	.nchr  nchr, ^\-rot\	; nchr = length( -rot )
                           00000004  0107       	.if    le, nchr		; nchr <= 0
                                     0107       	   .ascic \i_minus_rot\	; no auxillary -rot, use principle one
                                     0107       	.if_false		; else
                     74 6F 72 2D 00' 0107       	  .ascic \-rot\		; use auxillary -rot
                                 04  0107       
                                     010C       	.endc			; end if
                                     010C       i_minus_rot:			; use -rot of word as v1_kernel label
                                     010C       	
                    50   08 AB   D0  010C   723 	movl	8(r11),r0		; t1 = n1
                 08 AB   04 AB   D0  0110   724 	movl	4(r11),8(r11)		; n1 = n2
                    04 AB   6B   D0  0115   725 	movl	(r11),4(r11)		; n2 = n3
                       6B   50   D0  0119   726 	movl	r0,(r11)		; n3 = n1
                                 05  011C   727 	rsb				; end of -rot
                                     011D   728 
                                     011D   729 
                                     011D   730 ;+++
                                     011D   731 ;k> . -- ( n -- ) output the top of the stack as a signed number and pop it.
                                     011D   732 ;---
                                     011D   733 	header	i_dot,<.>
                           00000103' 011D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000011D  0121       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  0121       	.nchr  nchr, ^\.\	; nchr = length( . )
                           00000001  0121       	.if    le, nchr		; nchr <= 0
                                     0121       	   .ascic \i_dot\	; no auxillary ., use principle one
                                     0121       	.if_false		; else
                              2E 00' 0121       	  .ascic \.\		; use auxillary .
                                 01  0121       
                                     0123       	.endc			; end if
                                     0123       i_dot:			; use . of word as v1_kernel label
                                     0123       	
                       7A   6B   D0  0123   734 	movl	(r11),-(r10)		; dup ds>ls
                   000003AE'EF   16  0126   735 	jsb	abs			; abs
                   00000239'EF   16  012C   736 	jsb	i_less_sharp		; <#
                       FF1F CF   16  0132   737 	jsb	i_sharp_s		; #s
                       7B   8A   D0  0136   738 	movl	(r10)+,-(r11)		; ls>ds
                   00000FDF'EF   16  0139   739 	jsb	sign			; sign
                       FEF3 CF   16  013F   740 	jsb	i_sharp_greater		; #>
                   0000144C'EF   16  0143   741 	jsb	write			; output it
                       7B   20   D0  0149   742 	movl	#c_blank,-(r11)		; put space on stack
                   00000DEA'EF   16  014C   743 	jsb	putc			; output it
                                 05  0152   744 	rsb				; end of .
                                     0153   745 
                                     0153   746 
                                     0153   747 ;+++
                                     0153   748 ;k> .( -- ( -- ) write the text following until the next `)' to the screen.
                                     0153   749 ;	This word should only be used *OUTSIDE* a definition (i.e.,
                                     0153   750 ;	in execute mode).
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  51
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0153   751 ;---
                                     0153   752 	header	i_dot_lparen,<.(>
                           0000011D' 0153       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000153  0157       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0157       	.nchr  nchr, ^\.(\	; nchr = length( .( )
                           00000002  0157       	.if    le, nchr		; nchr <= 0
                                     0157       	   .ascic \i_dot_lparen\	; no auxillary .(, use principle one
                                     0157       	.if_false		; else
                           28 2E 00' 0157       	  .ascic \.(\		; use auxillary .(
                                 02  0157       
                                     015A       	.endc			; end if
                                     015A       i_dot_lparen:			; use .( of word as v1_kernel label
                                     015A       	
                       7B   29   D0  015A   753 	movl	#^a\)\,-(r11)		; set up for `)' delimited token.
                   000012DE'EF   16  015D   754 	jsb	token			; get the token
                  7B   59   01   C1  0163   755 	addl3	#1,r9,-(r11)		; address of string
                       7B   69   9A  0167   756 	movzbl	(r9),-(r11)		; get count of string on stack
                   0000144C'EF   16  016A   757 	jsb	write			; put it on the screen
                                 05  0170   758 	rsb				; end of .(
                                     0171   759 
                                     0171   760 
                                     0171   761 ;---
                                     0171   762 ;k> .sb -- ( -- ) output the stack from the bottom up without consuming it.
                                     0171   763 ;	The last item printed is the top of the stack.
                                     0171   764 ;---
                                     0171   765 	header	i_dot_sb,<.sb>
                           00000153' 0171       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000171  0175       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  0175       	.nchr  nchr, ^\.sb\	; nchr = length( .sb )
                           00000003  0175       	.if    le, nchr		; nchr <= 0
                                     0175       	   .ascic \i_dot_sb\	; no auxillary .sb, use principle one
                                     0175       	.if_false		; else
                        62 73 2E 00' 0175       	  .ascic \.sb\		; use auxillary .sb
                                 03  0175       
                                     0179       	.endc			; end if
                                     0179       i_dot_sb:			; use .sb of word as v1_kernel label
                                     0179       	
              7A   00001000'8F   D0  0179   766 	movl	#c_ds_start,-(r10)	; save end of stack.
                                     0180   767 10$:
                       6A   5B   D1  0180   768 	cmpl	r11,(r10)		; at top of stack yet?
                            0C   18  0183   769 	bgeq	100$			; yes, leave
                       6A   04   C2  0185   770 	subl2	#4,(r10)		; move to item
                    7B   00 BA   D0  0188   771 	movl	@(r10),-(r11)		; put item on top of stack
                         94 AF   16  018C   772 	jsb	i_dot			; print it
                            EF   11  018F   773 	brb	10$			; do it again
                                     0191   774 100$:
                       5A   04   C0  0191   775 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  0194   776 	rsb				; end of .sb
                                     0195   777 
                                     0195   778 
                                     0195   779 ;+++
                                     0195   780 ;k> .st -- ( -- ) output stack from the top down without consuming it.
                                     0195   781 ;	The last item printed is the bottom of the stack.
                                     0195   782 ;---
                                     0195   783 	header	i_dot_st,<.st>
                           00000171' 0195       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000195  0199       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  52
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000003  0199       	.nchr  nchr, ^\.st\	; nchr = length( .st )
                           00000003  0199       	.if    le, nchr		; nchr <= 0
                                     0199       	   .ascic \i_dot_st\	; no auxillary .st, use principle one
                                     0199       	.if_false		; else
                        74 73 2E 00' 0199       	  .ascic \.st\		; use auxillary .st
                                 03  0199       
                                     019D       	.endc			; end if
                                     019D       i_dot_st:			; use .st of word as v1_kernel label
                                     019D       	
                       7A   5B   D0  019D   784 	movl	r11,-(r10)		; save sp on top of loop stack
                                     01A0   785 10$:
              00001000'8F   6A   D1  01A0   786 	cmpl	(r10),#c_ds_start	; Is stack empty?
                            0D   18  01A7   787 	bgeq	20$			; yes
                    7B   00 BA   D0  01A9   788 	movl	@(r10),-(r11)		; put item on top
                       FF72 CF   16  01AD   789 	jsb	i_dot			; print it
                       6A   04   C0  01B1   790 	addl2	#4,(r10)		; move down stack
                            EA   11  01B4   791 	brb	10$			; do it again
                                     01B6   792 20$:
                       5A   04   C0  01B6   793 	addl2	#4,r10			; pop off stack pointer from loop stack
                                 05  01B9   794 	rsb				; end of .st
                                     01BA   795 
                                     01BA   796 
                                     01BA   797 ;+++t
                                     01BA   798 ;k> / -- ( n1 n2 -- n3 ) divides second stack item by top stack item, leaves
                                     01BA   799 ;	result on stack.  n3 = n1 / n2.
                                     01BA   800 ;---
                                     01BA   801 	header	i_divide,</>
                           00000195' 01BA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000001BA  01BE       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  01BE       	.nchr  nchr, ^\/\	; nchr = length( / )
                           00000001  01BE       	.if    le, nchr		; nchr <= 0
                                     01BE       	   .ascic \i_divide\	; no auxillary /, use principle one
                                     01BE       	.if_false		; else
                              2F 00' 01BE       	  .ascic \/\		; use auxillary /
                                 01  01BE       
                                     01C0       	.endc			; end if
                                     01C0       i_divide:			; use / of word as v1_kernel label
                                     01C0       	
                       6B   8B   C6  01C0   802 	divl2	(r11)+,(r11)
                                 05  01C3   803 	rsb				; end of /
                                     01C4   804 
                                     01C4   805 
                                     01C4   806 ;+++
                                     01C4   807 ;k> /mod -- ( n1 n2 -- n3 n4 ) divides second stack item by top stack item,
                                     01C4   808 ;	leaves ( quotient remainder ) on the stack.  n3 = n1 / n2, n4 = n1 - (n3 * n2).
                                     01C4   809 ;---
                                     01C4   810 	header	i_div_mod,</mod>
                           000001BA' 01C4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000001C4  01C8       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  01C8       	.nchr  nchr, ^\/mod\	; nchr = length( /mod )
                           00000004  01C8       	.if    le, nchr		; nchr <= 0
                                     01C8       	   .ascic \i_div_mod\	; no auxillary /mod, use principle one
                                     01C8       	.if_false		; else
                     64 6F 6D 2F 00' 01C8       	  .ascic \/mod\		; use auxillary /mod
                                 04  01C8       
                                     01CD       	.endc			; end if
                                     01CD       i_div_mod:			; use /mod of word as v1_kernel label
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  53
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     01CD       	
               50   04 AB   6B   C7  01CD   811 	divl3	(r11),4(r11),r0		; r0 = n1 / n2 = n3
                  51   8B   50   C5  01D2   812 	mull3	r0,(r11)+,r1		; tmp = n2 * n3
                  51   8B   51   C3  01D6   813 	subl3	r1,(r11)+,r1		; r1 = n1 - (n2 * n3) = n4
                       7B   50   D0  01DA   814 	movl	r0,-(r11)		; push n3, quotient
                       7B   51   D0  01DD   815 	movl	r1,-(r11)		; push n4, remainder
                                 05  01E0   816 	rsb				; end of /mod
                                     01E1   817 
                                     01E1   818 
                                     01E1   819 ;+++
                                     01E1   820 ;k> 1+ -- ( n -- n+1 ) Add one to the top of the stack.
                                     01E1   821 ;---
                                     01E1   822 	header	i_one_plus,<1+>
                           000001C4' 01E1       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000001E1  01E5       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  01E5       	.nchr  nchr, ^\1+\	; nchr = length( 1+ )
                           00000002  01E5       	.if    le, nchr		; nchr <= 0
                                     01E5       	   .ascic \i_one_plus\	; no auxillary 1+, use principle one
                                     01E5       	.if_false		; else
                           2B 31 00' 01E5       	  .ascic \1+\		; use auxillary 1+
                                 02  01E5       
                                     01E8       	.endc			; end if
                                     01E8       i_one_plus:			; use 1+ of word as v1_kernel label
                                     01E8       	
                            6B   D6  01E8   823 	incl	(r11)			; dd one to the top of the stack.
                                 05  01EA   824 	rsb				; end of 1+
                                     01EB   825 
                                     01EB   826 
                                     01EB   827 ;+++
                                     01EB   828 ;k> 1- -- ( n -- n-1 ) Subtract one from the top of the stack.
                                     01EB   829 ;---
                                     01EB   830 	header	i_one_minus,<1->
                           000001E1' 01EB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000001EB  01EF       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  01EF       	.nchr  nchr, ^\1-\	; nchr = length( 1- )
                           00000002  01EF       	.if    le, nchr		; nchr <= 0
                                     01EF       	   .ascic \i_one_minus\	; no auxillary 1-, use principle one
                                     01EF       	.if_false		; else
                           2D 31 00' 01EF       	  .ascic \1-\		; use auxillary 1-
                                 02  01EF       
                                     01F2       	.endc			; end if
                                     01F2       i_one_minus:			; use 1- of word as v1_kernel label
                                     01F2       	
                            6B   D7  01F2   831 	decl	(r11)			; subtract one from top of stack
                                 05  01F4   832 	rsb				; end of 1-
                                     01F5   833 
                                     01F5   834 
                                     01F5   835 ;+++
                                     01F5   836 ;k> : -- ( -- ) (colon) defining word that starts a word definition.
                                     01F5   837 ;	sets { mode } to true
                                     01F5   838 ;	Note that { : } is a compiling word an so is in compiler vocab.
                                     01F5   839 ;---
                                     01F5   840 	header	i_colon,<:>
                           000001EB' 01F5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000001F5  01F9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  01F9       	.nchr  nchr, ^\:\	; nchr = length( : )
                           00000001  01F9       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  54
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     01F9       	   .ascic \i_colon\	; no auxillary :, use principle one
                                     01F9       	.if_false		; else
                              3A 00' 01F9       	  .ascic \:\		; use auxillary :
                                 01  01F9       
                                     01FB       	.endc			; end if
                                     01FB       i_colon:			; use : of word as v1_kernel label
                                     01FB       	
     00001D37'EF   00001D3B'EF   D0  01FB   841 	movl	v_current,v_context	; search same vocab we are defining into
                   0000083E'EF   16  0206   842 	jsb	create			; create header for new word
                                     020C   843 ;??? Should I now set the high bit in the length byte (To prevent word from
                                     020C   844 ; being found during its own definition)?
                   00000FF6'EF   16  020C   845 	jsb	smudge			; set smudge bit so word isn't found
           00001D4D'EF   FF 8F   90  0212   846 	movb	#c_true,v_mode		; set compiler v_mode
                                 05  021A   847 	rsb				; end of :
                                     021B   848 
                                     021B   849 
                                     021B   850 ;+++t
                                     021B   851 ;k> < -- ( n1 n2 -- f ) true if n1 < n2, false otherwise.
                                     021B   852 ;---
                                     021B   853 	header	i_less,^\<\
                           000001F5' 021B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000021B  021F       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  021F       	.nchr  nchr, ^\<\	; nchr = length( < )
                           00000001  021F       	.if    le, nchr		; nchr <= 0
                                     021F       	   .ascic \i_less\	; no auxillary <, use principle one
                                     021F       	.if_false		; else
                              3C 00' 021F       	  .ascic \<\		; use auxillary <
                                 01  021F       
                                     0221       	.endc			; end if
                                     0221       i_less:			; use < of word as v1_kernel label
                                     0221       	
                       8B   8B   D1  0221   854 	cmpl	(r11)+,(r11)+		; reverse order, so n2 > n1
                            04   14  0224   855 	bgtr	10$			; yes
                       7B   00   D0  0226   856 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0229   857 	rsb				; return
                                     022A   858 10$:
              7B   FFFFFFFF 8F   D0  022A   859 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0231   860 	rsb				; end of <
                                     0232   861 
                                     0232   862 
                                     0232   863 ;+++
                                     0232   864 ;k> <# -- ( -- ) start numeric output conversion.
                                     0232   865 ;---
                                     0232   866 	header	i_less_sharp,^\<#\
                           0000021B' 0232       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000232  0236       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0236       	.nchr  nchr, ^\<#\	; nchr = length( <# )
                           00000002  0236       	.if    le, nchr		; nchr <= 0
                                     0236       	   .ascic \i_less_sharp\	; no auxillary <#, use principle one
                                     0236       	.if_false		; else
                           23 3C 00' 0236       	  .ascic \<#\		; use auxillary <#
                                 02  0236       
                                     0239       	.endc			; end if
                                     0239       i_less_sharp:			; use <# of word as v1_kernel label
                                     0239       	
00001D52'EF   00000109'EF   59   C1  0239   867 	addl3	r9,c_pad_moat,v_hld	; pad hld !
                                 05  0245   868 	rsb				; end of <#
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  55
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0246   869 
                                     0246   870 
                                     0246   871 ;+++t
                                     0246   872 ;k> <= -- ( n1 n2 -- f ) true if n1 <= n2, false otherwise.
                                     0246   873 ;---
                                     0246   874 	header	i_less_equal,^\<=\
                           00000232' 0246       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000246  024A       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  024A       	.nchr  nchr, ^\<=\	; nchr = length( <= )
                           00000002  024A       	.if    le, nchr		; nchr <= 0
                                     024A       	   .ascic \i_less_equal\	; no auxillary <=, use principle one
                                     024A       	.if_false		; else
                           3D 3C 00' 024A       	  .ascic \<=\		; use auxillary <=
                                 02  024A       
                                     024D       	.endc			; end if
                                     024D       i_less_equal:			; use <= of word as v1_kernel label
                                     024D       	
                       8B   8B   D1  024D   875 	cmpl	(r11)+,(r11)+		; reverse order, so n2 >= n1
                            04   18  0250   876 	bgeq	10$			; yes
                       7B   00   D0  0252   877 	movl	#c_false,-(r11)		; no, leave with false
                                 05  0255   878 	rsb				; return
                                     0256   879 10$:
              7B   FFFFFFFF 8F   D0  0256   880 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  025D   881 	rsb				; end of <
                                     025E   882 
                                     025E   883 
                                     025E   884 ;+++t
                                     025E   885 ;k> = -- ( n1 n2 -- f ) true if n1 = n2, false otherwise
                                     025E   886 ;---
                                     025E   887 	header	i_equal,<=>
                           00000246' 025E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000025E  0262       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  0262       	.nchr  nchr, ^\=\	; nchr = length( = )
                           00000001  0262       	.if    le, nchr		; nchr <= 0
                                     0262       	   .ascic \i_equal\	; no auxillary =, use principle one
                                     0262       	.if_false		; else
                              3D 00' 0262       	  .ascic \=\		; use auxillary =
                                 01  0262       
                                     0264       	.endc			; end if
                                     0264       i_equal:			; use = of word as v1_kernel label
                                     0264       	
                       8B   8B   D1  0264   888 	cmpl	(r11)+,(r11)+		; n2 = n1?
                            04   13  0267   889 	beql	10$			; yes
                       7B   00   D0  0269   890 	movl	#c_false,-(r11)		; no, leave with false
                                 05  026C   891 	rsb				; return
                                     026D   892 10$:
              7B   FFFFFFFF 8F   D0  026D   893 	movl	#c_true,-(r11)		; yes, leave with true
                                 05  0274   894 	rsb				; end of =
                                     0275   895 
                                     0275   896 
                                     0275   897 ;+++
                                     0275   898 ;K> =text -- ( a1 a2 n -- f ) compare strings of length `n' at `a1' and `a2',
                                     0275   899 ;	return true if they are equal, false otherwise.
                                     0275   900 ;---
                                     0275   901 	header	i_equal_text,<=text>
                           0000025E' 0275       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000275  0279       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  56
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000005  0279       	.nchr  nchr, ^\=text\	; nchr = length( =text )
                           00000005  0279       	.if    le, nchr		; nchr <= 0
                                     0279       	   .ascic \i_equal_text\	; no auxillary =text, use principle one
                                     0279       	.if_false		; else
                  74 78 65 74 3D 00' 0279       	  .ascic \=text\		; use auxillary =text
                                 05  0279       
                                     027F       	.endc			; end if
                                     027F       i_equal_text:			; use =text of word as v1_kernel label
                                     027F       	
            08 BB   04 BB   6B   29  027F   902 	cmpc3	(r11),@4(r11),@8(r11)	; Are they equal>
                            0B   12  0285   903 	bneq	10$			; no
                       5B   0C   C0  0287   904 	addl2	#12,r11			; pop arguments
              7B   FFFFFFFF 8F   D0  028A   905 	movl	#c_true,-(r11)		; yes, leave true
                                 05  0291   906 	rsb				; return
                                     0292   907 10$:
                       5B   0C   C0  0292   908 	addl2	#12,r11			; pop arguments
                       7B   00   D0  0295   909 	movl	#c_false,-(r11)		; no, they aren't equal, leave false.
                                 05  0298   910 	rsb				; end of =text
                                     0299   911 
                                     0299   912 
                                     0299   913 ;+++t
                                     0299   914 ;k> > -- ( n1 n2 -- f ) true if n1 > n2, false otherwise.
                                     0299   915 ;---
                                     0299   916 	header	i_greter,^\>\
                           00000275' 0299       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000299  029D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  029D       	.nchr  nchr, ^\>\	; nchr = length( > )
                           00000001  029D       	.if    le, nchr		; nchr <= 0
                                     029D       	   .ascic \i_greter\	; no auxillary >, use principle one
                                     029D       	.if_false		; else
                              3E 00' 029D       	  .ascic \>\		; use auxillary >
                                 01  029D       
                                     029F       	.endc			; end if
                                     029F       i_greter:			; use > of word as v1_kernel label
                                     029F       	
                       8B   8B   D1  029F   917 	cmpl	(r11)+,(r11)+		; reverse order, so n2 < n1
                            04   19  02A2   918 	blss	10$			; yes
                       7B   00   D0  02A4   919 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02A7   920 	rsb				; return
                                     02A8   921 10$:
                       7B   00   D0  02A8   922 	movl	#c_false,-(r11)		; yes, leave with false
                                 05  02AB   923 	rsb				; end of >
                                     02AC   924 
                                     02AC   925 
                                     02AC   926 ;+++t
                                     02AC   927 ;k> >= -- ( n1 n2 -- f ) true if n1 >= n2; false otherwise.
                                     02AC   928 ;---
                                     02AC   929 	header	i_greater_equal,^\>=\
                           00000299' 02AC       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000002AC  02B0       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  02B0       	.nchr  nchr, ^\>=\	; nchr = length( >= )
                           00000002  02B0       	.if    le, nchr		; nchr <= 0
                                     02B0       	   .ascic \i_greater_equal\	; no auxillary >=, use principle one
                                     02B0       	.if_false		; else
                           3D 3E 00' 02B0       	  .ascic \>=\		; use auxillary >=
                                 02  02B0       
                                     02B3       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  57
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     02B3       i_greater_equal:			; use >= of word as v1_kernel label
                                     02B3       	
                       8B   8B   D1  02B3   930 	cmpl	(r11)+,(r11)+		; reverse order, so n2 <= n1
                            04   15  02B6   931 	bleq	10$			; yes
                       7B   00   D0  02B8   932 	movl	#c_false,-(r11)		; no, leave with false
                                 05  02BB   933 	rsb				; return
                                     02BC   934 10$:
              7B   FFFFFFFF 8F   D0  02BC   935 	movl	#c_true,-(r11)		; yes, leave with false
                                 05  02C3   936 	rsb				; end of >=
                                     02C4   937 
                                     02C4   938 
                                     02C4   939 ;+++
                                     02C4   940 ;k> ? -- ( a -- ) Output contents of `a' as a long in current radix.
                                     02C4   941 ;---
                                     02C4   942 ; Remark on the internal name of this word: { header q_,<?> } is aesthetically
                                     02C4   943 ; displeasing, so make it i_question by analogoy with i_dot for { . }.
                                     02C4   944 	header	i_question,<?>
                           000002AC' 02C4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000002C4  02C8       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  02C8       	.nchr  nchr, ^\?\	; nchr = length( ? )
                           00000001  02C8       	.if    le, nchr		; nchr <= 0
                                     02C8       	   .ascic \i_question\	; no auxillary ?, use principle one
                                     02C8       	.if_false		; else
                              3F 00' 02C8       	  .ascic \?\		; use auxillary ?
                                 01  02C8       
                                     02CA       	.endc			; end if
                                     02CA       i_question:			; use ? of word as v1_kernel label
                                     02CA       	
                    6B   00 BB   D0  02CA   945 	movl	@(r11),(r11)		; get contents of `a'.
                       FE51 CF   16  02CE   946 	jsb	i_dot			; print contents
                                 05  02D2   947 	rsb				; end of ?
                                     02D3   948 
                                     02D3   949 
                                     02D3   950 ;+++
                                     02D3   951 ;k> ?cr -- ( -- ) start a new line unless already at beginning of line.
                                     02D3   952 ;---
                                     02D3   953 	header	q_cr,<?cr>
                           000002C4' 02D3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000002D3  02D7       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  02D7       	.nchr  nchr, ^\?cr\	; nchr = length( ?cr )
                           00000003  02D7       	.if    le, nchr		; nchr <= 0
                                     02D7       	   .ascic \q_cr\	; no auxillary ?cr, use principle one
                                     02D7       	.if_false		; else
                        72 63 3F 00' 02D7       	  .ascic \?cr\		; use auxillary ?cr
                                 03  02D7       
                                     02DB       	.endc			; end if
                                     02DB       q_cr:			; use ?cr of word as v1_kernel label
                                     02DB       	
                   00001B98'EF   B5  02DB   954 	tstw	v_outlen		; At beginning of line?
                            06   13  02E1   955 	beql	10$			; yes, exit
                   0000080A'EF   16  02E3   956 	jsb	cr			; no, start new line
                                     02E9   957 10$:
                                 05  02E9   958 	rsb				; end of ?cr
                                     02EA   959 
                                     02EA   960 
                                     02EA   961 ;+++
                                     02EA   962 ;k> ?dup -- ( f -- f ? f ) Duplicate top of stack only if it is true (non-zero).
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  58
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     02EA   963 ;	Used so don't always have to drop 0 in else.
                                     02EA   964 ;---
                                     02EA   965 	header	q_dup,<?dup>
                           000002D3' 02EA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000002EA  02EE       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  02EE       	.nchr  nchr, ^\?dup\	; nchr = length( ?dup )
                           00000004  02EE       	.if    le, nchr		; nchr <= 0
                                     02EE       	   .ascic \q_dup\	; no auxillary ?dup, use principle one
                                     02EE       	.if_false		; else
                     70 75 64 3F 00' 02EE       	  .ascic \?dup\		; use auxillary ?dup
                                 04  02EE       
                                     02F3       	.endc			; end if
                                     02F3       q_dup:			; use ?dup of word as v1_kernel label
                                     02F3       	
                            6B   D5  02F3   966 	tstl	(r11)			; is it zero?
                            03   13  02F5   967 	beql	10$			; yes, don't duplicate it.
                       7B   6B   D0  02F7   968 	movl	(r11),-(r11)		; no, duplicate it.
                                     02FA   969 10$:
                                 05  02FA   970 	rsb				; end of ?dup
                                     02FB   971 
                                     02FB   972 
                                     02FB   973 ;+++
                                     02FB   974 ;k> ?n-cr -- ( n -- ) starts new line on terminal if < n chars left on line.
                                     02FB   975 ;---
                                     02FB   976 	header	q_n_cr,<?n-cr>
                           000002EA' 02FB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000002FB  02FF       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  02FF       	.nchr  nchr, ^\?n-cr\	; nchr = length( ?n-cr )
                           00000005  02FF       	.if    le, nchr		; nchr <= 0
                                     02FF       	   .ascic \q_n_cr\	; no auxillary ?n-cr, use principle one
                                     02FF       	.if_false		; else
                  72 63 2D 6E 3F 00' 02FF       	  .ascic \?n-cr\		; use auxillary ?n-cr
                                 05  02FF       
                                     0305       	.endc			; end if
                                     0305       q_n_cr:			; use ?n-cr of word as v1_kernel label
                                     0305       	
              50   00001B98'EF   3C  0305   977 	movzwl	v_outlen,r0		; get current length of line.
         50   00000050 8F   50   C3  030C   978 	subl3	r0,#c_screen_len,r0	; get current length of line
                       50   8B   D1  0314   979 	cmpl	(r11)+,r0		; enough characers left?
                            06   19  0317   980 	blss	10$			; yes, go to return
                                     0319   981 ; no, not enough characters left on line.
                   0000080A'EF   16  0319   982 	jsb	cr			; start a new line
                                     031F   983 10$:
                                 05  031F   984 	rsb				; end of ?n-cr
                                     0320   985 
                                     0320   986 
                                     0320   987 ;+++t
                                     0320   988 ;k> ?number -- ( -- n ? f ) Convert token at eodp to a number, and if compiling
                                     0320   989 ;	enclose it as a literal in the current word.  If executing, push on
                                     0320   990 ;	the  stack.  If not a number, leave false on stack.  If a number leave
                                     0320   991 ;	a true on stack.
                                     0320   992 ;---
                                     0320   993 	header	q_number,<?number>
                           000002FB' 0320       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000320  0324       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000007  0324       	.nchr  nchr, ^\?number\	; nchr = length( ?number )
                           00000007  0324       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  59
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0324       	   .ascic \q_number\	; no auxillary ?number, use principle one
                                     0324       	.if_false		; else
            72 65 62 6D 75 6E 3F 00' 0324       	  .ascic \?number\		; use auxillary ?number
                                 07  0324       
                                     032C       	.endc			; end if
                                     032C       q_number:			; use ?number of word as v1_kernel label
                                     032C       	
                   00000D1C'EF   16  032C   994 	jsb	number			; try to make it a number
                            6B   D5  0332   995 	tstl	(r11)			; is it a number?
                            18   13  0334   996 	beql	10$			; no, exit leaving false on the stack
                       5B   04   C0  0336   997 	addl2	#4,r11			; yes.	pop flag
                   00001D4D'EF   95  0339   998 	tstb	v_mode			; are we compiling?
                            06   13  033F   999 	beql	20$			; no, leaving it on stack
                   0000179F'EF   16  0341  1000 	jsb	literal			; yes, include in dictionary as
                                     0347  1001 					; a literal
                                     0347  1002 20$:
              7B   FFFFFFFF 8F   D0  0347  1003 	movl	#c_true,-(r11)		; leave with true on stack
                                     034E  1004 10$:
                                 05  034E  1005 	rsb				; end of ?number
                                     034F  1006 
                                     034F  1007 
                                     034F  1008 ;+++t
                                     034F  1009 ;k> ?search -- ( -- a ? f )  search context vocabulary for most recent token,
                                     034F  1010 ;	return false if not found, or ( addr true ) if found.  If compiling,
                                     034F  1011 ;	search compiler vocab if not found in context and set { state }
                                     034F  1012 ;	true.  Compare byte-counted string at eodp to find.
                                     034F  1013 ;---
                                     034F  1014 	header	q_search,<?search>
                           00000320' 034F       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000034F  0353       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000007  0353       	.nchr  nchr, ^\?search\	; nchr = length( ?search )
                           00000007  0353       	.if    le, nchr		; nchr <= 0
                                     0353       	   .ascic \q_search\	; no auxillary ?search, use principle one
                                     0353       	.if_false		; else
            68 63 72 61 65 73 3F 00' 0353       	  .ascic \?search\		; use auxillary ?search
                                 07  0353       
                                     035B       	.endc			; end if
                                     035B       q_search:			; use ?search of word as v1_kernel label
                                     035B       	
                                     035B  1015 ;??? this next perhaps should have been
                                     035B  1016 ;	movl	@v_context,(r11)
                                     035B  1017 ;	tstb	v_mode
                                     035B  1018 ;	beql	5$
                                     035B  1019 ;	movl	@(r11),(r11)
                                     035B  1020 ;5$:
                                     035B  1021 ; which would (during compilation of new words)
                                     035B  1022 ; start the search at the word before the one currently being compiled;
                                     035B  1023 ; this would allow use of older definition of word `x' in new definition
                                     035B  1024 ; of word `x'.	However, as it stands it allows easy recursion.
                                     035B  1025 ;??? changed to eliminate recusion by default, as that is probably more
                                     035B  1026 ; useful, since RECURSE is a simple way to get recusion.
                                     035B  1027 ;??? The problem with this is that if you switch ocabularies while defining
                                     035B  1028 ; a word, the new vocab (which you want to search from the first) also is
                                     035B  1029 ; searched from the second word.  Perhaps I should set the smudge bit (gasp!
                                     035B  1030 ; Horrors!).
                                     035B  1031 ; get pointer to pointer to start of vocab
              7B   00001D37'FF   D0  035B  1032 	movl @v_context,-(r11)		; get address of current word
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  60
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0362  1033 ;??? took out to test smudge bit
                                     0362  1034 ;	tstb  v_mode			; Are we compiling?
                                     0362  1035 ;	beql  5$			; no, go on.
                                     0362  1036 ; yes, so skip address of word we are defining, so we can use
                                     0362  1037 ; previous definitions of this word.
                                     0362  1038 ;	movl	@(r11),(r11)		; get address of previous word
                                     0362  1039 5$:
                   00000F82'EF   16  0362  1040 	jsb	search			; search it
                            6B   D5  0368  1041 	tstl	(r11)			; Was it found?
                            21   12  036A  1042 	bneq	10$			; yes, exit with ( addr true ) on dstack
                   00001D4D'EF   95  036C  1043 	tstb	v_mode			; no. Are we compiling?
                            19   13  0372  1044 	beql	10$			; no, exit leaving false on dstack
              6B   00001D3F'EF   D0  0374  1045 	movl	v_compiler,(r11)	; yes, get adddress of compiler vocab
                   00000F82'EF   16  037B  1046 	jsb	search			; search it
                            6B   D5  0381  1047 	tstl	(r11)			; Was it found?
                            08   13  0383  1048 	beql	10$			; no, exit with false on dstack
           00001D4C'EF   FF 8F   90  0385  1049 	movb	#c_true,v_state		; yes, set v_state flag
                                     038D  1050 					; exit with ( addr true ) on dstack
                                     038D  1051 10$:
                                 05  038D  1052 	rsb				; end of ?search
                                     038E  1053 ;??? Should the compiler vocabulary be searched *before* the context vocabulary
                                     038E  1054 ; when we are compiling?  This would allow defining new versions in compiler
                                     038E  1055 ; of words in context that would be more efficient during compilation (or
                                     038E  1056 ; have a different effect, or allow immediate and noimmediate words that
                                     038E  1057 ; should do the same thing, like { % }).
                                     038E  1058 
                                     038E  1059 
                                     038E  1060 
                                     038E  1061 ;+++t
                                     038E  1062 ;k> @ -- (fetch) ( a -- l ) Fetches contents of longword at `a'.
                                     038E  1063 ;---
                                     038E  1064 	header	i_fetch,<@>
                           0000034F' 038E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000038E  0392       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  0392       	.nchr  nchr, ^\@\	; nchr = length( @ )
                           00000001  0392       	.if    le, nchr		; nchr <= 0
                                     0392       	   .ascic \i_fetch\	; no auxillary @, use principle one
                                     0392       	.if_false		; else
                              40 00' 0392       	  .ascic \@\		; use auxillary @
                                 01  0392       
                                     0394       	.endc			; end if
                                     0394       i_fetch:			; use @ of word as v1_kernel label
                                     0394       	
                    6B   00 BB   D0  0394  1065 	movl	@(r11),(r11)		; get contents of address at top-of-ds
                                 05  0398  1066 	rsb				; end of @
                                     0399  1067 
                                     0399  1068 
                                     0399  1069 ;+++
                                     0399  1070 ;k> abort -- ( -- ) clear data stack and restart VTIL.
                                     0399  1071 ;---
                                     0399  1072 	header	abort
                           0000038E' 0399       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000399  039D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  039D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  039D       	.if    le, nchr		; nchr <= 0
                  74 72 6F 62 61 00' 039D       	   .ascic \abort\	; no auxillary , use principle one
                                 05  039D       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  61
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     03A3       	.if_false		; else
                                     03A3       	  .ascic \\		; use auxillary 
                                     03A3       	.endc			; end if
                                     03A3       abort:			; use  of word as v1_kernel label
                                     03A3       	
                          16A1   31  03A3  1073 	brw	r_warm_start		; end of abort
                                     03A6  1074 
                                     03A6  1075 
                                     03A6  1076 ;+++
                                     03A6  1077 ;k> abs -- ( n1 -- n2 ) Takes the absolute value of top of stack.
                                     03A6  1078 ;---
                                     03A6  1079 	header	abs
                           00000399' 03A6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000003A6  03AA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  03AA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03AA       	.if    le, nchr		; nchr <= 0
                        73 62 61 00' 03AA       	   .ascic \abs\	; no auxillary , use principle one
                                 03  03AA       
                                     03AE       	.if_false		; else
                                     03AE       	  .ascic \\		; use auxillary 
                                     03AE       	.endc			; end if
                                     03AE       abs:			; use  of word as v1_kernel label
                                     03AE       	
                            6B   D5  03AE  1080 	tstl	(r11)			; is top of stack < 0?
                            03   18  03B0  1081 	bgeq	10$			; no, go on
                       6B   6B   CE  03B2  1082 	mnegl	(r11),(r11)		; yes, negate it
                                     03B5  1083 10$:
                                 05  03B5  1084 	rsb				; end of abs
                                     03B6  1085 
                                     03B6  1086 
                                     03B6  1087 ;+++t
                                     03B6  1088 ;k> ac: -- ( b -- ) assembler constant (makes opcode & operand defintions)
                                     03B6  1089 ;	ac creates a word that compiles the byte on the top of the stack at
                                     03B6  1090 ;	definition into the dictionary.
                                     03B6  1091 ;---
                                     03B6  1092 	header	i_ac_colon,<ac:>
                           000003A6' 03B6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000003B6  03BA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  03BA       	.nchr  nchr, ^\ac:\	; nchr = length( ac: )
                           00000003  03BA       	.if    le, nchr		; nchr <= 0
                                     03BA       	   .ascic \i_ac_colon\	; no auxillary ac:, use principle one
                                     03BA       	.if_false		; else
                        3A 63 61 00' 03BA       	  .ascic \ac:\		; use auxillary ac:
                                 03  03BA       
                                     03BE       	.endc			; end if
                                     03BE       i_ac_colon:			; use ac: of word as v1_kernel label
                                     03BE       	
                   0000083E'EF   16  03BE  1093 	jsb	create			; enclose name in dictionary
                    89   90 8F   90  03C4  1094 	movb	#op_movb,(r9)+		; `movb'
                    89   AF 8F   90  03C8  1095 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  03CC  1096 	movb	#2,(r9)+		; (pc+2)
                    89   89 8F   90  03CF  1097 	movb	#adm_ainc_r9,(r9)+	; (r9)+
                       89   05   90  03D3  1098 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  03D6  1099 	movb	(r11),(r9)+		; enclose byte value in dictionary
                       5B   04   C0  03D9  1100 	addl	#4,r11			; pop argument
                                     03DC  1101 ; Make it an compiletime word so it will compile the machine language into the
                                     03DC  1102 ; dictionary when defining a new word and will not be found otherwise.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  62
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                   000007BD'EF   16  03DC  1103 	jsb	compiletime
                                 05  03E2  1104 	rsb				; end of ac:
                                     03E3  1105 
                                     03E3  1106 
                                     03E3  1107 ;+++t
                                     03E3  1108 ;k> and -- ( f1 f2 -- f ) logical and f1 and f2
                                     03E3  1109 ;---
                                     03E3  1110 	header	and
                           000003B6' 03E3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000003E3  03E7       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  03E7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  03E7       	.if    le, nchr		; nchr <= 0
                        64 6E 61 00' 03E7       	   .ascic \and\	; no auxillary , use principle one
                                 03  03E7       
                                     03EB       	.if_false		; else
                                     03EB       	  .ascic \\		; use auxillary 
                                     03EB       	.endc			; end if
                                     03EB       and:			; use  of word as v1_kernel label
                                     03EB       	
                            8B   D5  03EB  1111 	tstl	(r11)+			; is first false?
                            0C   13  03ED  1112 	beql	10$			; yes
                            8B   D5  03EF  1113 	tstl	(r11)+			; no, is second false?
                            0B   13  03F1  1114 	beql	20$			; yes
              7B   FFFFFFFF 8F   D0  03F3  1115 	movl	#c_true,-(r11)		; no, both true, leave with true
                                 05  03FA  1116 	rsb				; return
                                     03FB  1117 10$:
                       6B   04   C0  03FB  1118 	addl2	#4,(r11)		; pop second item off, don't need
                                     03FE  1119 					; to check
                                     03FE  1120 20$:
                       7B   00   D0  03FE  1121 	movl	#c_false,-(r11)		; leave with false
                                 05  0401  1122 	rsb				; end of and
                                     0402  1123 
                                     0402  1124 
                                     0402  1125 ;+++
                                     0402  1126 ;k> array -- ( n -- ) create word that pushes addres of `n' bytes
                                     0402  1127 ;	which are saved in the dictionary.
                                     0402  1128 ;---
                                     0402  1129 	header	array
                           000003E3' 0402       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000402  0406       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0406       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0406       	.if    le, nchr		; nchr <= 0
                  79 61 72 72 61 00' 0406       	   .ascic \array\	; no auxillary , use principle one
                                 05  0406       
                                     040C       	.if_false		; else
                                     040C       	  .ascic \\		; use auxillary 
                                     040C       	.endc			; end if
                                     040C       array:			; use  of word as v1_kernel label
                                     040C       	
                   0000083E'EF   16  040C  1130 	jsb	create			; enclose next token in dictinary
                    89   9E 8F   90  0412  1131 	movb	#op_movab,(r9)+		; `moval'
                    89   AF 8F   90  0416  1132 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  041A  1133 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  041D  1134 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0421  1135 	movb	#op_rsb,(r9)+		; `rsb'
                       59   8B   C0  0424  1136 	addl2	(r11)+,r9		; save `n' bytes in dictionary
                                 05  0427  1137 	rsb				; end of array
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  63
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0428  1138 
                                     0428  1139 
                                     0428  1140 ;+++
                                     0428  1141 ;k> ascii -- ( -- n ) put ascii value of first character of next token on stack.
                                     0428  1142 ;	Note that this cannot be used in colon definitions!  (See { [ascii] }.)
                                     0428  1143 ;---
                                     0428  1144 	header	ascii
                           00000402' 0428       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000428  042C       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  042C       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  042C       	.if    le, nchr		; nchr <= 0
                  69 69 63 73 61 00' 042C       	   .ascic \ascii\	; no auxillary , use principle one
                                 05  042C       
                                     0432       	.if_false		; else
                                     0432       	  .ascic \\		; use auxillary 
                                     0432       	.endc			; end if
                                     0432       ascii:			; use  of word as v1_kernel label
                                     0432       	
                       7B   20   D0  0432  1145 	movl	#c_blank,-(r11)		; set up for blank separated token
                   000012DE'EF   16  0435  1146 	jsb	token			; get it
                    7B   01 A9   9A  043B  1147 	movzbl	1(r9),-(r11)		; put ascii value of token on stack
                                 05  043F  1148 	rsb				; end of ascii
                                     0440  1149 
                                     0440  1150 
                                     0440  1151 ;+++
                                     0440  1152 ;k> b! -- ( b a -- ) store 8 bits of `b' at address `a'.
                                     0440  1153 ;---
                                     0440  1154 	header	i_b_store,<b!>
                           00000428' 0440       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000440  0444       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0444       	.nchr  nchr, ^\b!\	; nchr = length( b! )
                           00000002  0444       	.if    le, nchr		; nchr <= 0
                                     0444       	   .ascic \i_b_store\	; no auxillary b!, use principle one
                                     0444       	.if_false		; else
                           21 62 00' 0444       	  .ascic \b!\		; use auxillary b!
                                 02  0444       
                                     0447       	.endc			; end if
                                     0447       i_b_store:			; use b! of word as v1_kernel label
                                     0447       	
                 00 BB   04 AB   90  0447  1155 	movb	4(r11),@(r11)		; store byte at what's pointed to by
                                     044C  1156 					; top of stack
                       5B   08   C0  044C  1157 	addl2	#8,r11			; pop arguments
                                 05  044F  1158 	rsb				; end of b!
                                     0450  1159 
                                     0450  1160 
                                     0450  1161 ;+++
                                     0450  1162 ;k> b, -- ( b -- ) store low byte of top stack entry into dictionary.
                                     0450  1163 ;---
                                     0450  1164 	header	i_b_comma,<b,>
                           00000440' 0450       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000450  0454       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0454       	.nchr  nchr, ^\b,\	; nchr = length( b, )
                           00000002  0454       	.if    le, nchr		; nchr <= 0
                                     0454       	   .ascic \i_b_comma\	; no auxillary b,, use principle one
                                     0454       	.if_false		; else
                           2C 62 00' 0454       	  .ascic \b,\		; use auxillary b,
                                 02  0454       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  64
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0457       	.endc			; end if
                                     0457       i_b_comma:			; use b, of word as v1_kernel label
                                     0457       	
                       89   6B   90  0457  1165 	movb	(r11),(r9)+		; store in dictinary
                       5B   04   C0  045A  1166 	addl2	#4,r11			; pop argument
                                 05  045D  1167 	rsb				; end of b,
                                     045E  1168 
                                     045E  1169 
                                     045E  1170 ;+++
                                     045E  1171 ;k> b@ -- ( a -- b ) Fetch byte from address `a'.
                                     045E  1172 ;---
                                     045E  1173 	header	i_b_fetch,<b@>.
                           0000045E' 045E       	.long	.		; back link to the previous word in this .
                           0000045E  0462       	. = . - 4		; where to link the next word to in this .
                           00000002  045E       	.nchr  nchr, ^\b@\	; nchr = length( b@ )
                           00000002  045E       	.if    le, nchr		; nchr <= 0
                                     045E       	   .ascic \i_b_fetch\	; no auxillary b@, use principle one
                                     045E       	.if_false		; else
                           40 62 00' 045E       	  .ascic \b@\		; use auxillary b@
                                 02  045E       
                                     0461       	.endc			; end if
                                     0461       i_b_fetch:			; use b@ of word as . label
                                     0461       	
                    6B   00 BB   9A  0461  1174 	movzbl	@(r11),(r11)
                                 05  0465  1175 	rsb				; end of b@
                                     0466  1176 
                                     0466  1177 
                                     0466  1178 ;+++
                                     0466  1179 ;k> bcount -- ( a -- a n ) Given the address of a byte-counted
                                     0466  1180 ;	string, leave address of first character in string and the
                                     0466  1181 ;	count of the string on the stack.
                                     0466  1182 ;---
                                     0466  1183 	header	bcount
                           00000450' 0466       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000466  046A       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  046A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  046A       	.if    le, nchr		; nchr <= 0
               74 6E 75 6F 63 62 00' 046A       	   .ascic \bcount\	; no auxillary , use principle one
                                 06  046A       
                                     0471       	.if_false		; else
                                     0471       	  .ascic \\		; use auxillary 
                                     0471       	.endc			; end if
                                     0471       bcount:			; use  of word as v1_kernel label
                                     0471       	
                    50   00 BB   9A  0471  1184 	movzbl	@(r11),r0		; get length of string
                            6B   D6  0475  1185 	incl	(r11)			; move over byte-count
                       7B   50   D0  0477  1186 	movl	r0,-(r11)		; put count on stack
                                 05  047A  1187 	rsb				; end of bcount
                                     047B  1188 
                                     047B  1189 
                                     047B  1190 ;+++
                                     047B  1191 ;k> binary -- ( -- ) Set the base to binary
                                     047B  1192 ;---
                                     047B  1193 	header	binary
                           00000466' 047B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000047B  047F       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  047F       	.nchr  nchr, ^\\	; nchr = length(  )
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  65
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000000  047F       	.if    le, nchr		; nchr <= 0
               79 72 61 6E 69 62 00' 047F       	   .ascic \binary\	; no auxillary , use principle one
                                 06  047F       
                                     0486       	.if_false		; else
                                     0486       	  .ascic \\		; use auxillary 
                                     0486       	.endc			; end if
                                     0486       binary:			; use  of word as v1_kernel label
                                     0486       	
              00001D4E'EF   02   D0  0486  1194 	movl	#2,v_radix		; switch to base 2
                                 05  048D  1195 	rsb				; end of binary
                                     048E  1196 
                                     048E  1197 
                                     048E  1198 ;+++
                                     048E  1199 ;k> (bl) -- ( -- c ) Pushes ascii value of a blank on the stack.
                                     048E  1200 ;---
                                     048E  1201 	header	i_bl,<(bl)>
                           0000047B' 048E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000048E  0492       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  0492       	.nchr  nchr, ^\(bl)\	; nchr = length( (bl) )
                           00000004  0492       	.if    le, nchr		; nchr <= 0
                                     0492       	   .ascic \i_bl\	; no auxillary (bl), use principle one
                                     0492       	.if_false		; else
                     29 6C 62 28 00' 0492       	  .ascic \(bl)\		; use auxillary (bl)
                                 04  0492       
                                     0497       	.endc			; end if
                                     0497       i_bl:			; use (bl) of word as v1_kernel label
                                     0497       	
                       7B   20   D0  0497  1202 	movl	#c_blank,-(r11)		; put on stack
                                 05  049A  1203 	rsb				; end of (bl)
                                     049B  1204 
                                     049B  1205 
                                     049B  1206 ;+++
                                     049B  1207 ;k> blank --- ( a w -- ) fill `w' bytes from `a' with blanks.
                                     049B  1208 ;---
                                     049B  1209 	header	blank
                           0000048E' 049B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000049B  049F       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  049F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  049F       	.if    le, nchr		; nchr <= 0
                  6B 6E 61 6C 62 00' 049F       	   .ascic \blank\	; no auxillary , use principle one
                                 05  049F       
                                     04A5       	.if_false		; else
                                     04A5       	  .ascic \\		; use auxillary 
                                     04A5       	.endc			; end if
                                     04A5       blank:			; use  of word as v1_kernel label
                                     04A5       	
                       69   00   2C  04A5  1210 	movc5	#0,(r9),-		; srclen,src  use (r9) to be safe
                            20       04A8  1211 		#c_blank,-		; fill with blanks
                    04 BB   6B       04A9  1212 		(r11),@4(r11)		; destlen, dest
                       5B   08   C0  04AC  1213 	addl2	#8,r11			; pop arguments
                                 05  04AF  1214 	rsb				; end of blank
                                     04B0  1215 
                                     04B0  1216 
                                     04B0  1217 ;+++
                                     04B0  1218 ;k> block -- ( l -- a ) Get block `l' into buffer at address `a'.
                                     04B0  1219 ;---
                                     04B0  1220 	header	block
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  66
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           0000049B' 04B0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000004B0  04B4       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  04B4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  04B4       	.if    le, nchr		; nchr <= 0
                  6B 63 6F 6C 62 00' 04B4       	   .ascic \block\	; no auxillary , use principle one
                                 05  04B4       
                                     04BA       	.if_false		; else
                                     04BA       	  .ascic \\		; use auxillary 
                                     04BA       	.endc			; end if
                                     04BA       block:			; use  of word as v1_kernel label
                                     04BA       	
                                     04BA  1221 ; Is the block already in memory?
                            50   D4  04BA  1222 	clrl   r0			; start with buffer 0
                                     04BC  1223 10$:
                            6B   D1  04BC  1224 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       04BE  1225 		v_buf_blk_nums[r0]	;   block we are looking for?
                            4E   13  04C4  1226 	beql	100$			; yes, go on
                    F2 50   03   F2  04C6  1227 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     04CA  1228 ;
                                     04CA  1229 ; not in memory, so we have to get it in
                                     04CA  1230 ;
                                     04CA  1231 ; Are there any unused buffers?
                            50   D4  04CA  1232 	clrl	r0			; start with buffer 0
                                     04CC  1233 20$:
                 00001B7D'EF40   95  04CC  1234 	tstb	v_buf_inuse[r0]		; is it in use?
                            25   13  04D3  1235 	beql	90$			; no, read block into it
                    F3 50   03   F2  04D5  1236 	aoblss	#c_max_blocks,r0,20$	; move to next buffer, if any
                                     04D9  1237 ; Are there any unmodified buffers?
                            50   D4  04D9  1238 	clrl	r0
                                     04DB  1239 30$:
                            02   91  04DB  1240 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       04DD  1241 		v_buf_inuse[r0]		;   been modified?
                            15   12  04E3  1242 	bneq	90$			; no, read block into it
                    F2 50   03   F2  04E5  1243 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     04E9  1244 ; all buffers are modified, so we must write out out and use it.
                            50   D4  04E9  1245 	clrl	r0			; for now, always use the zero'th one
                       7A   50   D0  04EB  1246 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  04EE  1247 	movl	r0,-(r11)		; set up for buffer-write
                   000006F4'EF   16  04F1  1248 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  04F7  1249 	movl	(r10)+,r0		; get the buffer number back
                                     04FA  1250 ; read block into buffer
                                     04FA  1251 90$:
                            6B   D0  04FA  1252 	movl	(r11),-			; Save the new block number in
                 FFFFE480'EF40       04FC  1253 		-v_buf_blk_nums[r0]	;   buffer
                            01   90  0502  1254 	movb	#c_inuse,-		; flag that buffer is in use
                 00001B7D'EF40       0504  1255 		v_buf_inuse[r0]
                       6B   50   D0  050A  1256 	movl	r0,(r11)		; set up for buffer-read
                   000006B8'EF   16  050D  1257 	jsb	i_buffer_read		; read block into buffer
                                 05  0513  1258 	rsb				; return
                                     0514  1259 ;
                                     0514  1260 ; block already in memory
                                     0514  1261 ;
                                     0514  1262 100$:
                                     0514  1263 ; Comes here if block already in memory, with buffers in r0, block# on stack
         6B   00000400 8F   50   C5  0514  1264 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  051C  1265 	addl2	#v_blkbuff,(r11)	; calcualte addressof `r0'th buffer
              00001B79'EF   50   D0  0523  1266 	movl	r0,v_current_buff	; mark this as most current block
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  67
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 05  052A  1267 	rsb				; end of block
                                     052B  1268 
                                     052B  1269 
                                     052B  1270 
                                     052B  1271 ;+++
                                     052B  1272 ;k> block-close -- ( -- ) Close the block file
                                     052B  1273 ;---
                                     052B  1274 	header	i_block_close,<block-close>
                           000004B0' 052B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000052B  052F       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000B  052F       	.nchr  nchr, ^\block-close\	; nchr = length( block-close )
                           0000000B  052F       	.if    le, nchr		; nchr <= 0
                                     052F       	   .ascic \i_block_close\	; no auxillary block-close, use principle one
                                     052F       	.if_false		; else
65 73 6F 6C 63 2D 6B 63 6F 6C 62 00' 052F       	  .ascic \block-close\		; use auxillary block-close
                                 0B  052F       
                                     053B       	.endc			; end if
                                     053B       i_block_close:			; use block-close of word as v1_kernel label
                                     053B       	
                   00001B78'EF   95  053B  1275 	tstb	v_blockio		; is the block file open?
                            1A   13  0541  1276 	beql	100$			; no, return
                                     0543  1277 	$close	fab=v_blkfab		; Yes, close block file
                                     0543       		$RMSCALL	CLOSE,v_blkfab,,
                                     0543       	.GLOBL	SYS$CLOSE
                                     0543       	.IF	B <v_blkfab>
                                     0543       	CALLG	(AP),G^SYS$CLOSE
                                     0543       	$$.TMP=0
                                     0543       	.IF	NB <>
                                     0543       	$$.TMP=1
                                     0543       	.ENDC
                                     0543       	.IF	NB <>
                                     0543       	$$.TMP=1
                                     0543       	.ENDC
                                     0543       	.IF	NE $$.TMP
                                     0543       	.ERROR				; v_blkfab= parameter missing;
                                     0543       	.ENDC
                                     0543       	.ENDC
                                     0543       	.IF	NB <v_blkfab>
                           00000001  0543       	$$.TMP1=1
                                     0543       	.IF	NB <>
                                     0543       	PUSHAL	
                                     0543       	$$.TMP1=3
                                     0543       	.ENDC
                                     0543       	.IF	NB <>
                                     0543       	PUSHAL	
                                     0543       	.IF	EQ <$$.TMP1-1>
                                     0543       	$$.TMP1=2
                                     0543       	.ENDC
                                     0543       	.IFF
                           FFFFFFFE  0543       	.IF	EQ <$$.TMP1-3>
                                     0543       	PUSHL	#0
                                     0543       	.ENDC
                                     0543       	.ENDC
                           000000CF  0543       	.NTYPE	$$.TMP2,v_blkfab
                           00000070  0543       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0543       	PUSHL	v_blkfab
                                     0543       	.IFF
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  68
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           000000B0  0543       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0543       	PUSHL	v_blkfab
                                     0543       	.IFF
                   00001AE0'EF   DF  0543       	PUSHAL	v_blkfab
                                     0549       	.ENDC
                                     0549       	.ENDC
              00000000'GF   01   FB  0549       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     0550       	.ENDC
                                     0550       	
                                     0550       	
                         03 50   E8  0550  1278 	blbs	r0,10$			; go on if no error
                          1677   31  0553  1279 	brw	_error_exit		; exit with error message
                                     0556  1280 10$:
              00001B78'EF   00   90  0556  1281 	movb	#c_false,v_blockio	; we're not using block file
                                     055D  1282 100$:
                                 05  055D  1283 	rsb				; end of block-close
                                     055E  1284 
                                     055E  1285 
                                     055E  1286 ;+++
                                     055E  1287 ;k> blocok-open -- ( -- ) Open the block file.
                                     055E  1288 ;---
                                     055E  1289 	header	i_block_open,<block-open>
                           0000052B' 055E       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000055E  0562       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000A  0562       	.nchr  nchr, ^\block-open\	; nchr = length( block-open )
                           0000000A  0562       	.if    le, nchr		; nchr <= 0
                                     0562       	   .ascic \i_block_open\	; no auxillary block-open, use principle one
                                     0562       	.if_false		; else
   6E 65 70 6F 2D 6B 63 6F 6C 62 00' 0562       	  .ascic \block-open\		; use auxillary block-open
                                 0A  0562       
                                     056D       	.endc			; end if
                                     056D       i_block_open:			; use block-open of word as v1_kernel label
                                     056D       	
                   00001B78'EF   95  056D  1290 	tstb	v_blockio		; Is block file open?
                            2E   12  0573  1291 	bneq	100$			; Yes, don't open again
                                     0575  1292 ; no, open it
                                     0575  1293 	$open	fab=v_blkfab		; open block file
                                     0575       		$RMSCALL	OPEN,v_blkfab,,
                                     0575       	.GLOBL	SYS$OPEN
                                     0575       	.IF	B <v_blkfab>
                                     0575       	CALLG	(AP),G^SYS$OPEN
                                     0575       	$$.TMP=0
                                     0575       	.IF	NB <>
                                     0575       	$$.TMP=1
                                     0575       	.ENDC
                                     0575       	.IF	NB <>
                                     0575       	$$.TMP=1
                                     0575       	.ENDC
                                     0575       	.IF	NE $$.TMP
                                     0575       	.ERROR				; v_blkfab= parameter missing;
                                     0575       	.ENDC
                                     0575       	.ENDC
                                     0575       	.IF	NB <v_blkfab>
                           00000001  0575       	$$.TMP1=1
                                     0575       	.IF	NB <>
                                     0575       	PUSHAL	
                                     0575       	$$.TMP1=3
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  69
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0575       	.ENDC
                                     0575       	.IF	NB <>
                                     0575       	PUSHAL	
                                     0575       	.IF	EQ <$$.TMP1-1>
                                     0575       	$$.TMP1=2
                                     0575       	.ENDC
                                     0575       	.IFF
                           FFFFFFFE  0575       	.IF	EQ <$$.TMP1-3>
                                     0575       	PUSHL	#0
                                     0575       	.ENDC
                                     0575       	.ENDC
                           000000CF  0575       	.NTYPE	$$.TMP2,v_blkfab
                           00000070  0575       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0575       	PUSHL	v_blkfab
                                     0575       	.IFF
                           000000B0  0575       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0575       	PUSHL	v_blkfab
                                     0575       	.IFF
                   00001AE0'EF   DF  0575       	PUSHAL	v_blkfab
                                     057B       	.ENDC
                                     057B       	.ENDC
              00000000'GF   01   FB  057B       	CALLS	#$$.TMP1,G^SYS$OPEN
                                     0582       	.ENDC
                                     0582       	
                                     0582       	
                         03 50   E8  0582  1294 	blbs	r0,10$			; no error, go on
                          1645   31  0585  1295 	brw	_error_exit		; quit on error
                                     0588  1296 10$:
                                     0588  1297 	$connect rab=v_blkrab		; connect to block file
                                     0588       		$RMSCALL	CONNECT,v_blkrab,,
                                     0588       	.GLOBL	SYS$CONNECT
                                     0588       	.IF	B <v_blkrab>
                                     0588       	CALLG	(AP),G^SYS$CONNECT
                                     0588       	$$.TMP=0
                                     0588       	.IF	NB <>
                                     0588       	$$.TMP=1
                                     0588       	.ENDC
                                     0588       	.IF	NB <>
                                     0588       	$$.TMP=1
                                     0588       	.ENDC
                                     0588       	.IF	NE $$.TMP
                                     0588       	.ERROR				; v_blkrab= parameter missing;
                                     0588       	.ENDC
                                     0588       	.ENDC
                                     0588       	.IF	NB <v_blkrab>
                           00000001  0588       	$$.TMP1=1
                                     0588       	.IF	NB <>
                                     0588       	PUSHAL	
                                     0588       	$$.TMP1=3
                                     0588       	.ENDC
                                     0588       	.IF	NB <>
                                     0588       	PUSHAL	
                                     0588       	.IF	EQ <$$.TMP1-1>
                                     0588       	$$.TMP1=2
                                     0588       	.ENDC
                                     0588       	.IFF
                           FFFFFFFE  0588       	.IF	EQ <$$.TMP1-3>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  70
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0588       	PUSHL	#0
                                     0588       	.ENDC
                                     0588       	.ENDC
                           000000CF  0588       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  0588       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0588       	PUSHL	v_blkrab
                                     0588       	.IFF
                           000000B0  0588       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0588       	PUSHL	v_blkrab
                                     0588       	.IFF
                   00001B30'EF   DF  0588       	PUSHAL	v_blkrab
                                     058E       	.ENDC
                                     058E       	.ENDC
              00000000'GF   01   FB  058E       	CALLS	#$$.TMP1,G^SYS$CONNECT
                                     0595       	.ENDC
                                     0595       	
                                     0595       	
                         03 50   E8  0595  1298 	blbs	 r0,20$			; no error, go on
                          1632   31  0598  1299 	brw	 _error_exit		; quit on error
                                     059B  1300 20$:
           00001B78'EF   FF 8F   90  059B  1301 	movb	#c_true,v_blockio	; yes, we are using the block file
                                     05A3  1302 100$:
                                 05  05A3  1303 	rsb				; end of block-open
                                     05A4  1304 
                                     05A4  1305 
                                     05A4  1306 ;+++
                                     05A4  1307 ;k> block-read -- ( l a -- ) Read block `l' from buffer at address `a'.
                                     05A4  1308 ;---
                                     05A4  1309 	header	i_block_read,<block-read>
                           0000055E' 05A4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000005A4  05A8       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000A  05A8       	.nchr  nchr, ^\block-read\	; nchr = length( block-read )
                           0000000A  05A8       	.if    le, nchr		; nchr <= 0
                                     05A8       	   .ascic \i_block_read\	; no auxillary block-read, use principle one
                                     05A8       	.if_false		; else
   64 61 65 72 2D 6B 63 6F 6C 62 00' 05A8       	  .ascic \block-read\		; use auxillary block-read
                                 0A  05A8       
                                     05B3       	.endc			; end if
                                     05B3       i_block_read:			; use block-read of word as v1_kernel label
                                     05B3       	
                            8B   D0  05B3  1310 	movl	(r11)+,-		; get address of buffer
                   00001B54'EF       05B5  1311 		v_blkrab+rab$l_ubf	;   into  rab
                            8B   D0  05BA  1312 	movl	(r11)+,-		; get VTIL block (rms record) number
                   00001B74'EF       05BC  1313 		v_blkkey		;   into rab's key
                                     05C1  1314 	$get	rab=v_blkrab		; read the block
                                     05C1       		$RMSCALL	GET,v_blkrab,,
                                     05C1       	.GLOBL	SYS$GET
                                     05C1       	.IF	B <v_blkrab>
                                     05C1       	CALLG	(AP),G^SYS$GET
                                     05C1       	$$.TMP=0
                                     05C1       	.IF	NB <>
                                     05C1       	$$.TMP=1
                                     05C1       	.ENDC
                                     05C1       	.IF	NB <>
                                     05C1       	$$.TMP=1
                                     05C1       	.ENDC
                                     05C1       	.IF	NE $$.TMP
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  71
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     05C1       	.ERROR				; v_blkrab= parameter missing;
                                     05C1       	.ENDC
                                     05C1       	.ENDC
                                     05C1       	.IF	NB <v_blkrab>
                           00000001  05C1       	$$.TMP1=1
                                     05C1       	.IF	NB <>
                                     05C1       	PUSHAL	
                                     05C1       	$$.TMP1=3
                                     05C1       	.ENDC
                                     05C1       	.IF	NB <>
                                     05C1       	PUSHAL	
                                     05C1       	.IF	EQ <$$.TMP1-1>
                                     05C1       	$$.TMP1=2
                                     05C1       	.ENDC
                                     05C1       	.IFF
                           FFFFFFFE  05C1       	.IF	EQ <$$.TMP1-3>
                                     05C1       	PUSHL	#0
                                     05C1       	.ENDC
                                     05C1       	.ENDC
                           000000CF  05C1       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  05C1       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     05C1       	PUSHL	v_blkrab
                                     05C1       	.IFF
                           000000B0  05C1       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     05C1       	PUSHL	v_blkrab
                                     05C1       	.IFF
                   00001B30'EF   DF  05C1       	PUSHAL	v_blkrab
                                     05C7       	.ENDC
                                     05C7       	.ENDC
              00000000'GF   01   FB  05C7       	CALLS	#$$.TMP1,G^SYS$GET
                                     05CE       	.ENDC
                                     05CE       	
                                     05CE       	
                         03 50   E8  05CE  1315 	blbs	r0,100$			; no errors, go on
                          15F9   31  05D1  1316 	brw	_error_exit		; exit and signal error
                                     05D4  1317 100$:
                                 05  05D4  1318 	rsb				; end of block-read
                                     05D5  1319 
                                     05D5  1320 
                                     05D5  1321 ;+++
                                     05D5  1322 ;k> block-write -- ( l a -- ) Write block `l' from buffer at address `a'.
                                     05D5  1323 ;---
                                     05D5  1324 	header	i_block_write,<block-write>
                           000005A4' 05D5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000005D5  05D9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000B  05D9       	.nchr  nchr, ^\block-write\	; nchr = length( block-write )
                           0000000B  05D9       	.if    le, nchr		; nchr <= 0
                                     05D9       	   .ascic \i_block_write\	; no auxillary block-write, use principle one
                                     05D9       	.if_false		; else
65 74 69 72 77 2D 6B 63 6F 6C 62 00' 05D9       	  .ascic \block-write\		; use auxillary block-write
                                 0B  05D9       
                                     05E5       	.endc			; end if
                                     05E5       i_block_write:			; use block-write of word as v1_kernel label
                                     05E5       	
                            8B   D0  05E5  1325 	movl	(r11)+,-		; get buffer address
                   00001B58'EF       05E7  1326 		v_blkrab+rab$l_rbf	;   into rab
                            8B   D0  05EC  1327 	movl	(r11)+,-		; get VTIL block (rms record) number
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  72
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                   00001B74'EF       05EE  1328 		v_blkkey		;   into key buffer
                       0400 8F   B0  05F3  1329 	movw	#c_block_size,-		; get proper VTIL block (rms record)
                   00001B52'EF       05F7  1330 		v_blkrab+rab$w_rsz	;   size into fab
                                     05FC  1331 	$find	rab=v_blkrab		; find the correct block
                                     05FC       		$RMSCALL	FIND,v_blkrab,,
                                     05FC       	.GLOBL	SYS$FIND
                                     05FC       	.IF	B <v_blkrab>
                                     05FC       	CALLG	(AP),G^SYS$FIND
                                     05FC       	$$.TMP=0
                                     05FC       	.IF	NB <>
                                     05FC       	$$.TMP=1
                                     05FC       	.ENDC
                                     05FC       	.IF	NB <>
                                     05FC       	$$.TMP=1
                                     05FC       	.ENDC
                                     05FC       	.IF	NE $$.TMP
                                     05FC       	.ERROR				; v_blkrab= parameter missing;
                                     05FC       	.ENDC
                                     05FC       	.ENDC
                                     05FC       	.IF	NB <v_blkrab>
                           00000001  05FC       	$$.TMP1=1
                                     05FC       	.IF	NB <>
                                     05FC       	PUSHAL	
                                     05FC       	$$.TMP1=3
                                     05FC       	.ENDC
                                     05FC       	.IF	NB <>
                                     05FC       	PUSHAL	
                                     05FC       	.IF	EQ <$$.TMP1-1>
                                     05FC       	$$.TMP1=2
                                     05FC       	.ENDC
                                     05FC       	.IFF
                           FFFFFFFE  05FC       	.IF	EQ <$$.TMP1-3>
                                     05FC       	PUSHL	#0
                                     05FC       	.ENDC
                                     05FC       	.ENDC
                           000000CF  05FC       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  05FC       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     05FC       	PUSHL	v_blkrab
                                     05FC       	.IFF
                           000000B0  05FC       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     05FC       	PUSHL	v_blkrab
                                     05FC       	.IFF
                   00001B30'EF   DF  05FC       	PUSHAL	v_blkrab
                                     0602       	.ENDC
                                     0602       	.ENDC
              00000000'GF   01   FB  0602       	CALLS	#$$.TMP1,G^SYS$FIND
                                     0609       	.ENDC
                                     0609       	
                                     0609       	
                                     0609  1332 	$update	rab=v_blkrab		; write the block
                                     0609       		$RMSCALL	UPDATE,v_blkrab,,
                                     0609       	.GLOBL	SYS$UPDATE
                                     0609       	.IF	B <v_blkrab>
                                     0609       	CALLG	(AP),G^SYS$UPDATE
                                     0609       	$$.TMP=0
                                     0609       	.IF	NB <>
                                     0609       	$$.TMP=1
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  73
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0609       	.ENDC
                                     0609       	.IF	NB <>
                                     0609       	$$.TMP=1
                                     0609       	.ENDC
                                     0609       	.IF	NE $$.TMP
                                     0609       	.ERROR				; v_blkrab= parameter missing;
                                     0609       	.ENDC
                                     0609       	.ENDC
                                     0609       	.IF	NB <v_blkrab>
                           00000001  0609       	$$.TMP1=1
                                     0609       	.IF	NB <>
                                     0609       	PUSHAL	
                                     0609       	$$.TMP1=3
                                     0609       	.ENDC
                                     0609       	.IF	NB <>
                                     0609       	PUSHAL	
                                     0609       	.IF	EQ <$$.TMP1-1>
                                     0609       	$$.TMP1=2
                                     0609       	.ENDC
                                     0609       	.IFF
                           FFFFFFFE  0609       	.IF	EQ <$$.TMP1-3>
                                     0609       	PUSHL	#0
                                     0609       	.ENDC
                                     0609       	.ENDC
                           000000CF  0609       	.NTYPE	$$.TMP2,v_blkrab
                           00000070  0609       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0609       	PUSHL	v_blkrab
                                     0609       	.IFF
                           000000B0  0609       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0609       	PUSHL	v_blkrab
                                     0609       	.IFF
                   00001B30'EF   DF  0609       	PUSHAL	v_blkrab
                                     060F       	.ENDC
                                     060F       	.ENDC
              00000000'GF   01   FB  060F       	CALLS	#$$.TMP1,G^SYS$UPDATE
                                     0616       	.ENDC
                                     0616       	
                                     0616       	
                         03 50   E8  0616  1333 	blbs	r0,100$			; no errors, go on
                          15B1   31  0619  1334 	brw	_error_exit		; exit and signal error
                                     061C  1335 100$:
                                 05  061C  1336 	rsb				; end of block-write
                                     061D  1337 
                                     061D  1338 
                                     061D  1339 ;+++
                                     061D  1340 ;k> break -- ( -- ) Breakpoint!	 For use in debugging kernel and compiler.
                                     061D  1341 ;	This word should only be executed when running in the VAX/VMS Debugger.
                                     061D  1342 ;---
                                     061D  1343 	header	break
                           000005D5' 061D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000061D  0621       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0621       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0621       	.if    le, nchr		; nchr <= 0
                  6B 61 65 72 62 00' 0621       	   .ascic \break\	; no auxillary , use principle one
                                 05  0621       
                                     0627       	.if_false		; else
                                     0627       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  74
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0627       	.endc			; end if
                                     0627       break:			; use  of word as v1_kernel label
                                     0627       	
                                 03  0627  1344 	bpt				; breakpoint
                                 05  0628  1345 	rsb				; end of break
                                     0629  1346 
                                     0629  1347 
                                     0629  1348 ;+++
                                     0629  1349 ;k> bs@ -- ( a -- l ) Fetch byte at `a' and sign extend it to longword on stack.
                                     0629  1350 ;---
                                     0629  1351 	header	i_bs_fetch,<bs@>
                           0000061D' 0629       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000629  062D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  062D       	.nchr  nchr, ^\bs@\	; nchr = length( bs@ )
                           00000003  062D       	.if    le, nchr		; nchr <= 0
                                     062D       	   .ascic \i_bs_fetch\	; no auxillary bs@, use principle one
                                     062D       	.if_false		; else
                        40 73 62 00' 062D       	  .ascic \bs@\		; use auxillary bs@
                                 03  062D       
                                     0631       	.endc			; end if
                                     0631       i_bs_fetch:			; use bs@ of word as v1_kernel label
                                     0631       	
                    6B   00 BB   98  0631  1352 	cvtbl	@(r11),(r11)		; sign extend it
                                 05  0635  1353 	rsb				; end of bs@
                                     0636  1354 
                                     0636  1355 
                                     0636  1356 ;+++
                                     0636  1357 ;k> buffer -- ( l -- a ) Get buffer at `a' that will be written to block `l'.
                                     0636  1358 ;---
                                     0636  1359 	header	buffer
                           00000629' 0636       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000636  063A       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  063A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  063A       	.if    le, nchr		; nchr <= 0
               72 65 66 66 75 62 00' 063A       	   .ascic \buffer\	; no auxillary , use principle one
                                 06  063A       
                                     0641       	.if_false		; else
                                     0641       	  .ascic \\		; use auxillary 
                                     0641       	.endc			; end if
                                     0641       buffer:			; use  of word as v1_kernel label
                                     0641       	
                                     0641  1360 ; Is the block already in memory?
                            50   D4  0641  1361 	clrl   r0			; start with buffer 0
                                     0643  1362 10$:
                            6B   D1  0643  1363 	cmpl	(r11),-			; does this buffer contain the
                 00001B80'EF40       0645  1364 		v_buf_blk_nums[r0]	;   block we are looking for?
                            44   13  064B  1365 	beql	100$			; yes, go on
                    F2 50   03   F2  064D  1366 	aoblss	#c_max_blocks,r0,10$	; move to next buffer, if any
                                     0651  1367 ;
                                     0651  1368 ; not in memory, so we have to get it in
                                     0651  1369 ;
                                     0651  1370 ; Are there unused buffers?
                            50   D4  0651  1371 	clrl	r0			; start with buffer 0
                                     0653  1372 20$:
                 00001B7D'EF40   95  0653  1373 	tstb	v_buf_inuse[r0]		; Is it in use?
                            25   13  065A  1374 	beql	90$			; no, read block into it
                    F3 50   03   F2  065C  1375 	aoblss	#c_max_blocks,r0,20$	; move to the next buffer, if any
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  75
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0660  1376 ; Are there any unmodified buffers?
                            50   D4  0660  1377 	clrl	r0
                                     0662  1378 30$:
                            02   91  0662  1379 	cmpb	#c_modified,-		; Has this buffer
                 00001B7D'EF40       0664  1380 		v_buf_inuse[r0]		;   been modified?
                            15   12  066A  1381 	bneq	90$			; no, read block into it
                    F2 50   03   F2  066C  1382 	aoblss	#c_max_blocks,r0,30$	; move to next buffer if any
                                     0670  1383 ; all buffers are modified, so we must write one out and use it.
                            50   D4  0670  1384 	clrl	r0			; for now, always use zero'th one
                       7A   50   D0  0672  1385 	movl	r0,-(r10)		; save buffer number
                       7B   50   D0  0675  1386 	movl	r0,-(r11)		; set up for buffer-write
                   000006F4'EF   16  0678  1387 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  067E  1388 	movl	(r10)+,r0		; get the buffer number back
                                     0681  1389 ;
                                     0681  1390 ; come here with bloc## on stack and buffer# in r0.
                                     0681  1391 ;
                                     0681  1392 90$:
                                     0681  1393 ; save block info
                            6B   D0  0681  1394 	movl	(r11),-			; Save the new block number in
                 00001B80'EF40       0683  1395 		v_buf_blk_nums[r0]	;   buffer
                            01   90  0689  1396 	movb	#c_inuse,-		; Flag that buffer is in use
                 00001B7D'EF40       068B  1397 		v_buf_inuse[r0]
                                     0691  1398 
                                     0691  1399 100$:
                                     0691  1400 ; leave address of buffer on stack
         6B   00000400 8F   50   C5  0691  1401 	mull3	r0,#c_block_size,(r11)	; offset to `r0'th buffer in buffer array
              6B   00004000'8F   C0  0699  1402 	addl2	#v_blkbuff,(r11)	; calculate address of `r0'th buffer
              00001B79'EF   50   D0  06A0  1403 	movl	r0,v_current_buff	; mark this as most current block
                                 05  06A7  1404 	rsb				; end of buffer
                                     06A8  1405 
                                     06A8  1406 
                                     06A8  1407 ;+++
                                     06A8  1408 ;k> buffer-read -- ( n -- a ) read into a block into buffer `n'.  The block
                                     06A8  1409 ;	number is already in the buffer.  Leave `a', the address of the
                                     06A8  1410 ;	block buffer.  This word assumes that buffer is correctly set up
                                     06A8  1411 ;	(block number, etc).
                                     06A8  1412 ;---
                                     06A8  1413 	header	i_buffer_read,<buffer-read>
                           00000636' 06A8       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000006A8  06AC       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000B  06AC       	.nchr  nchr, ^\buffer-read\	; nchr = length( buffer-read )
                           0000000B  06AC       	.if    le, nchr		; nchr <= 0
                                     06AC       	   .ascic \i_buffer_read\	; no auxillary buffer-read, use principle one
                                     06AC       	.if_false		; else
64 61 65 72 2D 72 65 66 66 75 62 00' 06AC       	  .ascic \buffer-read\		; use auxillary buffer-read
                                 0B  06AC       
                                     06B8       	.endc			; end if
                                     06B8       i_buffer_read:			; use buffer-read of word as v1_kernel label
                                     06B8       	
                       50   8B   D0  06B8  1414 	movl	(r11)+,r0		; get buffer number
              00001B79'EF   50   D0  06BB  1415 	movl	r0,v_current_buff	; save buffer number as most current
         51   00000400 8F   50   C5  06C2  1416 	mull3	r0,#c_block_size,r1	; offset to `r0'th buffer
         7B   00004000'8F   51   C1  06CA  1417 	addl3	r1,#v_blkbuff,-(r11)	; put address of buffer on stack
                                     06D2  1418 					; this is left after exit
            7B   00001B80'EF40   D0  06D2  1419 	movl	v_buf_blk_nums[r0],-	; number of block
                                     06DA  1420 		-(r11)			;   to read
                    7B   04 AB   D0  06DA  1421 	movl	4(r11),-(r11)		; get another copy of the buffer address
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  76
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       FED1 CF   16  06DE  1422 	jsb	i_block_read		; read the block
                                 05  06E2  1423 	rsb				; end of buffer-read
                                     06E3  1424 
                                     06E3  1425 
                                     06E3  1426 ;+++
                                     06E3  1427 ;k> buffer-write -- ( n -- ) write block in buffer number n to file.
                                     06E3  1428 ;	Note that the block number is in the buffer already.
                                     06E3  1429 ;---
                                     06E3  1430 	header	i_buffer_write,<buffer-write>
                           000006A8' 06E3       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000006E3  06E7       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000C  06E7       	.nchr  nchr, ^\buffer-write\	; nchr = length( buffer-write )
                           0000000C  06E7       	.if    le, nchr		; nchr <= 0
                                     06E7       	   .ascic \i_buffer_write\	; no auxillary buffer-write, use principle one
                                     06E7       	.if_false		; else
74 69 72 77 2D 72 65 66 66 75 62 00' 06E7       	  .ascic \buffer-write\		; use auxillary buffer-write
                                 65  06F3       
                                 0C  06E7       
                                     06F4       	.endc			; end if
                                     06F4       i_buffer_write:			; use buffer-write of word as v1_kernel label
                                     06F4       	
                       50   8B   D0  06F4  1431 	movl	(r11)+,r0		; get buffer number
            7B   00001B80'EF40   D0  06F7  1432 	movl	v_buf_blk_nums[r0],-	; number of block
                                     06FF  1433 		-(r11)			;   to write
         51   00000400 8F   50   C5  06FF  1434 	mull3	r0,#c_block_size,r1	; offset into the buffer buffer
         7B   00004000'8F   51   C1  0707  1435 	addl3	r1,#v_blkbuff,-(r11)	; address of buffer to write
                                     070F  1436 					; this is left after exit
                       FED2 CF   16  070F  1437 	jsb	i_block_write		; write the block
                                 05  0713  1438 	rsb				; end of buffer-write
                                     0714  1439 
                                     0714  1440 
                                     0714  1441 ;+++
                                     0714  1442 ;k> byte -- ( n -- ) Creates word that pushes address of byte on stack.
                                     0714  1443 ;---
                                     0714  1444 	header	byte,<byte>
                           000006E3' 0714       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000714  0718       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  0718       	.nchr  nchr, ^\byte\	; nchr = length( byte )
                           00000004  0718       	.if    le, nchr		; nchr <= 0
                                     0718       	   .ascic \byte\	; no auxillary byte, use principle one
                                     0718       	.if_false		; else
                     65 74 79 62 00' 0718       	  .ascic \byte\		; use auxillary byte
                                 04  0718       
                                     071D       	.endc			; end if
                                     071D       byte:			; use byte of word as v1_kernel label
                                     071D       	
                   0000083E'EF   16  071D  1445 	jsb	create			; enclose next token in dictionary
                    89   9E 8F   90  0723  1446 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  0727  1447 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  072B  1448 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  072E  1449 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0732  1450 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   90  0735  1451 	movb	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  0738  1452 	addl2	#4,r11			; pop argument
                                 05  073B  1453 	rsb				; end of byte
                                     073C  1454 
                                     073C  1455 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  77
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     073C  1456 ;+++t
                                     073C  1457 ;k> cfa -- ( a -- a ) given addrss of header of word, return the address of
                                     073C  1458 ;	the code for that word (i.e., the Code Field Address).
                                     073C  1459 ;---
                                     073C  1460 ;??? the smudge bit makes this one a little harder.
                                     073C  1461 	header	cfa
                           00000714' 073C       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000073C  0740       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0740       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0740       	.if    le, nchr		; nchr <= 0
                        61 66 63 00' 0740       	   .ascic \cfa\	; no auxillary , use principle one
                                 03  0740       
                                     0744       	.if_false		; else
                                     0744       	  .ascic \\		; use auxillary 
                                     0744       	.endc			; end if
                                     0744       cfa:			; use  of word as v1_kernel label
                                     0744       	
                       6B   04   C0  0744  1462 	addl2	#4,(r11)		; skip over link field
                    50   00 BB   9A  0747  1463 	movzbl	@(r11),r0		; get unsigned byte-count of name
                    50   80 8F   8A  074B  1464 	bicb2	#^b10000000,r0		; clear smudge bit of count
                            6B   D6  074F  1465 	incl	(r11)			; skip over count byte
                       6B   50   C0  0751  1466 	addl2	r0,(r11)		; skip over name field
                                 05  0754  1467 	rsb				; end of cfa
                                     0755  1468 
                                     0755  1469 
                                     0755  1470 ;+++
                                     0755  1471 ;k> clist -- ( -- ) list compiler vocabulary.
                                     0755  1472 ;---
                                     0755  1473 	header	clist
                           0000073C' 0755       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000755  0759       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0759       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0759       	.if    le, nchr		; nchr <= 0
                  74 73 69 6C 63 00' 0759       	   .ascic \clist\	; no auxillary , use principle one
                                 05  0759       
                                     075F       	.if_false		; else
                                     075F       	  .ascic \\		; use auxillary 
                                     075F       	.endc			; end if
                                     075F       clist:			; use  of word as v1_kernel label
                                     075F       	
              7B   00001D3F'EF   D0  075F  1474 	movl	v_compiler,-(r11)	; get address of most recent word
                                     0766  1475 					;   in compiler vocabulary
                                     0766  1476 10$:
                            6B   D5  0766  1477 	tstl	(r11)			; nil pointer?
                            24   13  0768  1478 	beql	100$			; yes, exit loop
                  7B   04   6B   C1  076A  1479 	addl3	(r11),#4,-(r11)		; get address of name field
                       FCFF CF   16  076E  1480 	jsb	bcount			; set up for write
                       7B   6B   D0  0772  1481 	movl	(r11),-(r11)		; set up for ?cr
                       FB8C CF   16  0775  1482 	jsb	q_n_cr			; start new line if word is too long
                   0000144C'EF   16  0779  1483 	jsb	write			; tell user
                       71   20   D0  077F  1484 	movl	#c_blank,-(r1)		; blank to separate words
                   00000DEA'EF   16  0782  1485 	jsb	putc			; output it
                    6B   00 BB   D0  0788  1486 	movl	@(r11),(r11)		; get previous word's lfa
                            D8   11  078C  1487 	brb	10$			; try it again
                                     078E  1488 100$:
                       5B   04   C0  078E  1489 	addl2	#4,r11			; pop pointer off stack
                                 05  0791  1490 	rsb				; end of clist
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  78
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0792  1491 
                                     0792  1492 
                                     0792  1493 ;+++t
                                     0792  1494 ;k> compile-jsb ( a -- ) compile a jump to subroutine to location `a'.
                                     0792  1495 ;---
                                     0792  1496 ;??? At the moment this uses absolute mode.  Should it use displacment
                                     0792  1497 ; off a register so that it can be ?relocatable (like stoic)?  Or should it
                                     0792  1498 ; use a brw (which I'm not sure would work in { defer< ... >defer }.
                                     0792  1499 	header	   i_compile_jsb,<compile-jsb>
                           00000755' 0792       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000792  0796       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000B  0796       	.nchr  nchr, ^\compile-jsb\	; nchr = length( compile-jsb )
                           0000000B  0796       	.if    le, nchr		; nchr <= 0
                                     0796       	   .ascic \i_compile_jsb\	; no auxillary compile-jsb, use principle one
                                     0796       	.if_false		; else
62 73 6A 2D 65 6C 69 70 6D 6F 63 00' 0796       	  .ascic \compile-jsb\		; use auxillary compile-jsb
                                 0B  0796       
                                     07A2       	.endc			; end if
                                     07A2       i_compile_jsb:			; use compile-jsb of word as v1_kernel label
                                     07A2       	
                       89   16   90  07A2  1500 	movb	   #op_jsb,(r9)+	; `jsb'
                    69   9F 8F   90  07A5  1501 	movb	   #adm_absolute,(r9)	; absolute mode
                       89   8B   D0  07A9  1502 	movl	   (r11)+,(r9)+		; save place to jump to in dictionary
                                 05  07AC  1503 	rsb				; end of compile-jsb
                                     07AD  1504 
                                     07AD  1505 
                                     07AD  1506 ;+++
                                     07AD  1507 ;k> compiletime -- ( -- ) move word defined to the compiler vocabulary.
                                     07AD  1508 ;	This word unlinks the last word in the current vocabulary and
                                     07AD  1509 ;	links it to the compiler vocabulary.  Compiiler words are *never*
                                     07AD  1510 ;	executed during execute mode.
                                     07AD  1511 ;---
                                     07AD  1512 	header	compiletime
                           00000792' 07AD       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000007AD  07B1       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  07B1       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07B1       	.if    le, nchr		; nchr <= 0
65 6D 69 74 65 6C 69 70 6D 6F 63 00' 07B1       	   .ascic \compiletime\	; no auxillary , use principle one
                                 0B  07B1       
                                     07BD       	.if_false		; else
                                     07BD       	  .ascic \\		; use auxillary 
                                     07BD       	.endc			; end if
                                     07BD       compiletime:			; use  of word as v1_kernel label
                                     07BD       	
              50   00001D3B'FF   D0  07BD  1513 	movl	@v_current,r0		; save pointer to word we a unlinking
              00001D3B'FF   60   D0  07C4  1514 	movl	(r0),@v_current		; make current previous word in vocab
              60   00001D3F'EF   D0  07CB  1515 	movl	v_compiler,(r0)		; link word to prev in compiler vocab
              00001D3F'EF   50   D0  07D2  1516 	movl	r0,v_compiler		; make v_compiler point to new word
                                 05  07D9  1517 	rsb				; end of compiletime
                                     07DA  1518 ;??? Should I also have immediate words, that execute in *both* compile
                                     07DA  1519 ; mode and execute mode?  This would require some sort of attribute flag,
                                     07DA  1520 ; which would have to be checked during compilation.  It would allow
                                     07DA  1521 ; considerably more flexibility (remember how % started out a word and ended
                                     07DA  1522 ; up part of _interpreter because it was either compiletime or runtime?).
                                     07DA  1523 ;??? Much beter idea.  Have a compile buffer like STOIC and have only
                                     07DA  1524 ; compiletime and runtime words, both of which are in the same vocabulary.
                                     07DA  1525 ; If not inside a { : ... ; }, do a jsb at the end of the line? if in colon
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  79
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     07DA  1526 ; definition, copy it to the dictionary and update dictionary links.
                                     07DA  1527 ; Have to think about this.
                                     07DA  1528 
                                     07DA  1529 
                                     07DA  1530 ;+++
                                     07DA  1531 ;k> context -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     07DA  1532 ;	vocabulary in which we currently search for words (the `context').
                                     07DA  1533 ;---
                                     07DA  1534 	header	context
                           000007AD' 07DA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000007DA  07DE       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  07DE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07DE       	.if    le, nchr		; nchr <= 0
            74 78 65 74 6E 6F 63 00' 07DE       	   .ascic \context\	; no auxillary , use principle one
                                 07  07DE       
                                     07E6       	.if_false		; else
                                     07E6       	  .ascic \\		; use auxillary 
                                     07E6       	.endc			; end if
                                     07E6       context:			; use  of word as v1_kernel label
                                     07E6       	
              7B   00001D37'EF   DE  07E6  1535 	moval	v_context,-(r11)	; move address of pointer to vocab
                                     07ED  1536 					; that is searched when defining
                                     07ED  1537 					; to stack
                                 05  07ED  1538 	rsb				; end of context
                                     07EE  1539 
                                     07EE  1540 
                                     07EE  1541 ;+++
                                     07EE  1542 ;k> count -- ( a1 -- a2 n ) Given word-counted string at `a' returns
                                     07EE  1543 ;	address of characters in string and string's length on top of stack.
                                     07EE  1544 ;---
                                     07EE  1545 	header	count
                           000007DA' 07EE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000007EE  07F2       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  07F2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  07F2       	.if    le, nchr		; nchr <= 0
                  74 6E 75 6F 63 00' 07F2       	   .ascic \count\	; no auxillary , use principle one
                                 05  07F2       
                                     07F8       	.if_false		; else
                                     07F8       	  .ascic \\		; use auxillary 
                                     07F8       	.endc			; end if
                                     07F8       count:			; use  of word as v1_kernel label
                                     07F8       	
                    50   00 BB   3C  07F8  1546 	movzwl	@(r11),r0		; get length of string
                       6B   02   C0  07FC  1547 	addl2	#2,(r11)		; move pointer to first character
                       7B   50   D0  07FF  1548 	movl	r0,-(r11)		; put count on top of stack
                                 05  0802  1549 	rsb				; end of count
                                     0803  1550 
                                     0803  1551 
                                     0803  1552 ;+++
                                     0803  1553 ;k> cr -- ( -- )  Start new output line (C_arriage R_eturn).
                                     0803  1554 ;---
                                     0803  1555 	header	cr
                           000007EE' 0803       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000803  0807       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0807       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0807       	.if    le, nchr		; nchr <= 0
                           72 63 00' 0807       	   .ascic \cr\	; no auxillary , use principle one
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  80
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 02  0807       
                                     080A       	.if_false		; else
                                     080A       	  .ascic \\		; use auxillary 
                                     080A       	.endc			; end if
                                     080A       cr:			; use  of word as v1_kernel label
                                     080A       	
              7B   00001B9A'EF   9E  080A  1556 	movab	v_outbuf,-(r11)		; move address of output buffer on stack
              7B   00001B9A'EF   3C  0811  1557 	movzwl	v_outbuf,-(r11)		; put count on stack
           02 AB   00001B96'EF   B0  0818  1558 	movw	v_static_dsc,2(r11)	; put middle of descriptor on ~~~ Is this correct?
                            5B   DD  0820  1559 	pushl	r11			; push address of output descriptor
              00000000'GF   01   FB  0822  1560 	calls	#1,g^lib$put_output	; output it
                       5B   08   C0  0829  1561 	addl2	#8,r11			; pop descriptor off stack
                   00001B98'EF   B4  082C  1562 	clrw	v_outlen		; clear output length
                                 05  0832  1563 	rsb				; end of cr
                                     0833  1564 
                                     0833  1565 
                                     0833  1566 ;+++t
                                     0833  1567 ;k> create -- ( -- ) Enclose next token in input stream in the dictionary,
                                     0833  1568 ;	truncating it if it is too long.
                                     0833  1569 ;---
                                     0833  1570 	header	create
                           00000803' 0833       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000833  0837       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0837       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0837       	.if    le, nchr		; nchr <= 0
               65 74 61 65 72 63 00' 0837       	   .ascic \create\	; no auxillary , use principle one
                                 06  0837       
                                     083E       	.if_false		; else
                                     083E       	  .ascic \\		; use auxillary 
                                     083E       	.endc			; end if
                                     083E       create:			; use  of word as v1_kernel label
                                     083E       	
              69   00001D3B'FF   D0  083E  1571 	movl	@v_current,(r9)		; make link field
              00001D3B'FF   59   D0  0845  1572 	movl	r9,@v_current		; make vocab point to here, newest word
                       59   04   C0  084C  1573 	addl2	#4,r9			; move eodp over link field
                       7B   20   D0  084F  1574 	movl	#c_blank,-(r11)		; set up to get blank separated token
                   000012DE'EF   16  0852  1575 	jsb	token			; get token
              69   00000050 8F   D1  0858  1576 	cmpl	#c_max_name_len,(r9)	; is the name over the maximum length?
                            46   12  085F  1577 	bneq	10$			; no, go on
              7B   000018D8'EF   9E  0861  1578 	movab	v_nametoolong,-(r11)	; address of error message on stack
                       FC05 CF   16  0868  1579 	jsb	bcount			; get ( addr count )
                   0000144C'EF   16  086C  1580 	jsb	write			; write out message
                  7B   59   01   C1  0872  1581 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9E  0876  1582 	movab	(r9),-(r11)		; count of name
                   0000144C'EF   16  0879  1583 	jsb	write			; write out untruncated name
                         88 AF   16  087F  1584 	jsb	cr			; start new line
              69   00000050 8F   D0  0882  1585 	movl	#c_max_name_len,(r9)	; truncate name
              7B   000018E8'EF   9E  0889  1586 	movab	v_nametrunc,-(r11)	; get address of stack
                       FBDD CF   16  0890  1587 	jsb	bcount			; get ( addr count )
                   0000144C'EF   16  0894  1588 	jsb	write			; write out message
                  7B   59   01   C1  089A  1589 	addl3	#1,r9,-(r11)		; address of name
                       7B   69   9A  089E  1590 	movzbl	(r9),-(r11)		; count of name
                   0000144C'EF   16  08A1  1591 	jsb	write			; write out truncated name
                                     08A7  1592 10$:
                       50   89   9A  08A7  1593 	movzbl	(r9)+,r0		; get byte length and move over it
                       59   50   C0  08AA  1594 	addl2	r0,r9			; move over string
                       69   05   90  08AD  1595 	movb	#op_rsb,(r9)		; stick a `rsb' in just in case
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  81
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 05  08B0  1596 	rsb				; end of create
                                     08B1  1597 
                                     08B1  1598 
                                     08B1  1599 ;+++
                                     08B1  1600 ;k> current -- ( -- a ) Leaves address of the vocabulary pointer of the
                                     08B1  1601 ;	vocabulary we link new words into.
                                     08B1  1602 ;---
                                     08B1  1603 	header	current
                           00000833' 08B1       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000008B1  08B5       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  08B5       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08B5       	.if    le, nchr		; nchr <= 0
            74 6E 65 72 72 75 63 00' 08B5       	   .ascic \current\	; no auxillary , use principle one
                                 07  08B5       
                                     08BD       	.if_false		; else
                                     08BD       	  .ascic \\		; use auxillary 
                                     08BD       	.endc			; end if
                                     08BD       current:			; use  of word as v1_kernel label
                                     08BD       	
              7B   00001D3B'EF   DE  08BD  1604 	moval	v_current,-(r11)	; move address (of pointer to vocab
                                     08C4  1605 					; that new words are linked to when
                                     08C4  1606 					; defining) to stack
                                 05  08C4  1607 	rsb				; end of current
                                     08C5  1608 
                                     08C5  1609 
                                     08C5  1610 ;+++
                                     08C5  1611 ;k> decimal -- ( -- ) Set base to decimal.
                                     08C5  1612 ;---
                                     08C5  1613 	header	decimal
                           000008B1' 08C5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000008C5  08C9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  08C9       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08C9       	.if    le, nchr		; nchr <= 0
            6C 61 6D 69 63 65 64 00' 08C9       	   .ascic \decimal\	; no auxillary , use principle one
                                 07  08C9       
                                     08D1       	.if_false		; else
                                     08D1       	  .ascic \\		; use auxillary 
                                     08D1       	.endc			; end if
                                     08D1       decimal:			; use  of word as v1_kernel label
                                     08D1       	
              00001D4E'EF   0A   D0  08D1  1614 	movl	#10,v_radix		; switch to base 10
                                 05  08D8  1615 	rsb				; end of decimal
                                     08D9  1616 
                                     08D9  1617 
                                     08D9  1618 ;+++
                                     08D9  1619 ;k> definitions -- ( -- )  Sets curren to context. { <name> definitions }
                                     08D9  1620 ;	makes all new words link into vocabulary { <name> }
                                     08D9  1621 ;	(i.e., new operators will be linked dictionary currently being searched).
                                     08D9  1622 ;---
                                     08D9  1623 	header	definitions
                           000008C5' 08D9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000008D9  08DD       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  08DD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08DD       	.if    le, nchr		; nchr <= 0
73 6E 6F 69 74 69 6E 69 66 65 64 00' 08DD       	   .ascic \definitions\	; no auxillary , use principle one
                                 0B  08DD       
                                     08E9       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  82
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     08E9       	  .ascic \\		; use auxillary 
                                     08E9       	.endc			; end if
                                     08E9       definitions:			; use  of word as v1_kernel label
                                     08E9       	
     00001D3B'EF   00001D37'EF   D0  08E9  1624 	movl	v_context, v_current
                                 05  08F4  1625 	rsb				; end of definitions
                                     08F5  1626 
                                     08F5  1627 
                                     08F5  1628 ;+++
                                     08F5  1629 ;k> drop -- ( n -- ) Drop the top stack item.
                                     08F5  1630 ;---
                                     08F5  1631 	header	drop
                           000008D9' 08F5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000008F5  08F9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  08F9       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  08F9       	.if    le, nchr		; nchr <= 0
                     70 6F 72 64 00' 08F9       	   .ascic \drop\	; no auxillary , use principle one
                                 04  08F9       
                                     08FE       	.if_false		; else
                                     08FE       	  .ascic \\		; use auxillary 
                                     08FE       	.endc			; end if
                                     08FE       drop:			; use  of word as v1_kernel label
                                     08FE       	
                       5B   04   C0  08FE  1632 	addl2	#4,r11			; pop argument, dropping top item
                                 05  0901  1633 	rsb				; end of drop
                                     0902  1634 
                                     0902  1635 
                                     0902  1636 ;+++
                                     0902  1637 ;k> ds>ls -- ( n -- ) move `n' to loop stack.
                                     0902  1638 ;---
                                     0902  1639 	header	i_ds_to_ls,^/ds>ls/
                           000008F5' 0902       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000902  0906       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  0906       	.nchr  nchr, ^\ds>ls\	; nchr = length( ds>ls )
                           00000005  0906       	.if    le, nchr		; nchr <= 0
                                     0906       	   .ascic \i_ds_to_ls\	; no auxillary ds>ls, use principle one
                                     0906       	.if_false		; else
                  73 6C 3E 73 64 00' 0906       	  .ascic \ds>ls\		; use auxillary ds>ls
                                 05  0906       
                                     090C       	.endc			; end if
                                     090C       i_ds_to_ls:			; use ds>ls of word as v1_kernel label
                                     090C       	
                       7A   8B   D0  090C  1640 	movl	(r11)+,-(r10)		; pop from dstack, move to lstack.
                                 05  090F  1641 	rsb				; end of ds>ls
                                     0910  1642 
                                     0910  1643 
                                     0910  1644 ;+++
                                     0910  1645 ;k> dup -- ( n -- n n ) Duplicated the top stack entry.
                                     0910  1646 ;---
                                     0910  1647 	header	dup
                           00000902' 0910       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000910  0914       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0914       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0914       	.if    le, nchr		; nchr <= 0
                        70 75 64 00' 0914       	   .ascic \dup\	; no auxillary , use principle one
                                 03  0914       
                                     0918       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  83
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0918       	  .ascic \\		; use auxillary 
                                     0918       	.endc			; end if
                                     0918       dup:			; use  of word as v1_kernel label
                                     0918       	
                       7B   6B   D0  0918  1648 	movl	(r11),-(r11)
                                 05  091B  1649 	rsb				; end of dup
                                     091C  1650 
                                     091C  1651 
                                     091C  1652 ;+++
                                     091C  1653 ;k> empty-buffers -- ( -- ) Mark all buffers unmodified without writing.
                                     091C  1654 ;---
                                     091C  1655 	header	i_empty_buffers,<empty-buffers>
                           00000910' 091C       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000091C  0920       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000D  0920       	.nchr  nchr, ^\empty-buffers\	; nchr = length( empty-buffers )
                           0000000D  0920       	.if    le, nchr		; nchr <= 0
                                     0920       	   .ascic \i_empty_buffers\	; no auxillary empty-buffers, use principle one
                                     0920       	.if_false		; else
65 66 66 75 62 2D 79 74 70 6D 65 00' 0920       	  .ascic \empty-buffers\		; use auxillary empty-buffers
                              73 72  092C       
                                 0D  0920       
                                     092E       	.endc			; end if
                                     092E       i_empty_buffers:			; use empty-buffers of word as v1_kernel label
                                     092E       	
                            50   D4  092E  1656 	clrl	r0			; buffer number
                                     0930  1657 10$:
                            00   90  0930  1658 	movb	#c_false,-		; mark with c_false to show
                 00001B7D'EF40       0932  1659 		v_buf_inuse[r0]		;   emptied, not in use
                            00   D0  0938  1660 	movl	#c_false,-		; mark with c_false to show
                 00001B80'EF40       093A  1661 		v_buf_blk_nums[r0]	;  holds no block number
                            02   F1  0940  1662 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFEA 50   01       0942  1663 		#1,r0,10$		; move to next buffer number, if any
                                 05  0946  1664 	rsb				; end of empty buffers
                                     0947  1665 
                                     0947  1666 
                                     0947  1667 ;
                                     0947  1668 ;??? Note: the `eodp' words are supplied so that the user can work with the
                                     0947  1669 ;	dictionary without having to know if eodp is a register or a variable.
                                     0947  1670 ;
                                     0947  1671 
                                     0947  1672 
                                     0947  1673 ;+++
                                     0947  1674 ;k> eodp -- ( -- a ) Return address of next free byte in dictionary.
                                     0947  1675 ;	Means "end of dictinary pointer".
                                     0947  1676 ;---
                                     0947  1677 	header	eodp
                           0000091C' 0947       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000947  094B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  094B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  094B       	.if    le, nchr		; nchr <= 0
                     70 64 6F 65 00' 094B       	   .ascic \eodp\	; no auxillary , use principle one
                                 04  094B       
                                     0950       	.if_false		; else
                                     0950       	  .ascic \\		; use auxillary 
                                     0950       	.endc			; end if
                                     0950       eodp:			; use  of word as v1_kernel label
                                     0950       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  84
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       7B   59   D0  0950  1678 	movl	r9,-(r11)		; get
                                 05  0953  1679 	rsb				; end of eodp
                                     0954  1680 
                                     0954  1681 
                                     0954  1682 ;+++
                                     0954  1683 ;k> eodp! -- ( a -- ) Make `a' new value of end of dictionary  pointer.
                                     0954  1684 ;---
                                     0954  1685 	header	i_eod_store,<eodp!>
                           00000947' 0954       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000954  0958       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  0958       	.nchr  nchr, ^\eodp!\	; nchr = length( eodp! )
                           00000005  0958       	.if    le, nchr		; nchr <= 0
                                     0958       	   .ascic \i_eod_store\	; no auxillary eodp!, use principle one
                                     0958       	.if_false		; else
                  21 70 64 6F 65 00' 0958       	  .ascic \eodp!\		; use auxillary eodp!
                                 05  0958       
                                     095E       	.endc			; end if
                                     095E       i_eod_store:			; use eodp! of word as v1_kernel label
                                     095E       	
                       59   8B   D0  095E  1686 	movl	(r11)+,r9		; make eodp = top of stack
                                 05  0961  1687 	rsb				; end of edop!
                                     0962  1688 
                                     0962  1689 
                                     0962  1690 ;+++
                                     0962  1691 ;k> eodp+! -- ( n -- ) Add `n' to end of dictionary pointer.
                                     0962  1692 ;---
                                     0962  1693 	header	i_eodp_plus_store,<eodp+!>
                           00000954' 0962       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000962  0966       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000006  0966       	.nchr  nchr, ^\eodp+!\	; nchr = length( eodp+! )
                           00000006  0966       	.if    le, nchr		; nchr <= 0
                                     0966       	   .ascic \i_eodp_plus_store\	; no auxillary eodp+!, use principle one
                                     0966       	.if_false		; else
               21 2B 70 64 6F 65 00' 0966       	  .ascic \eodp+!\		; use auxillary eodp+!
                                 06  0966       
                                     096D       	.endc			; end if
                                     096D       i_eodp_plus_store:			; use eodp+! of word as v1_kernel label
                                     096D       	
                       59   8B   C0  096D  1694 	addl2	(r11)+,r9		; add top of stack to eodp
                                 05  0970  1695 	rsb				; end of eodp+!
                                     0971  1696 
                                     0971  1697 
                                     0971  1698 ;+++
                                     0971  1699 ;k> eve -- call up eve editor.	Format: { eve filename }.
                                     0971  1700 ;---
                                     0971  1701 	header	eve
                           00000962' 0971       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000971  0975       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0975       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0975       	.if    le, nchr		; nchr <= 0
                        65 76 65 00' 0975       	   .ascic \eve\	; no auxillary , use principle one
                                 03  0975       
                                     0979       	.if_false		; else
                                     0979       	  .ascic \\		; use auxillary 
                                     0979       	.endc			; end if
                                     0979       eve:			; use  of word as v1_kernel label
                                     0979       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  85
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       7B   20   D0  0979  1702 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012DE'EF   16  097C  1703 	jsb	token			; get the token
                       56   69   9A  0982  1704 	movzbl	(r9),r6			; save length
                  57   59   01   C1  0985  1705 	addl3	#1,r9,r7		; start of string
         00001C56'EF   67   56   28  0989  1706 	movc3	r6,(r7),v_tpu_com2	; move string into buffer
         00001CF6'EF   56   1C   A1  0991  1707 	addw3	#c_tpu_com_len,r6,-	; put length in descriptor
                                     0999  1708 		v_tpu_dsc
                   00001CF6'EF   7F  0999  1709 	pushaq	v_tpu_dsc		; push address of command
              00000000'GF   01   FB  099F  1710 	calls	#1,g^tpu$tpu		; call tpu
                         01 50   E9  09A6  1711 	blbc	r0,10$			; ?error
                                 05  09A9  1712 	rsb				; no, exit
                                     09AA  1713 10$:					; yes, signal and patch
                            50   DD  09AA  1714 	pushl	r0			; set up for signal
              00000000'GF   01   FB  09AC  1715 	calls	#1,g^lib$signal		; signal it
                          1091   31  09B3  1716 	brw	r_warm_start		; patch VTIL to run
                                     09B6  1717 					; end of eve
                                     09B6  1718 
                                     09B6  1719 
                                     09B6  1720 ;+++
                                     09B6  1721 ;k> exit -- ( -- ) Exit VTIL.  Never returns.
                                     09B6  1722 ;---
                                     09B6  1723 	header	i_exit,<exit>
                           00000971' 09B6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000009B6  09BA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  09BA       	.nchr  nchr, ^\exit\	; nchr = length( exit )
                           00000004  09BA       	.if    le, nchr		; nchr <= 0
                                     09BA       	   .ascic \i_exit\	; no auxillary exit, use principle one
                                     09BA       	.if_false		; else
                     74 69 78 65 00' 09BA       	  .ascic \exit\		; use auxillary exit
                                 04  09BA       
                                     09BF       	.endc			; end if
                                     09BF       i_exit:			; use exit of word as v1_kernel label
                                     09BF       	
                          123E   31  09BF  1724 	brw	_exit			; exit silently
                                     09C2  1725 
                                     09C2  1726 
                                     09C2  1727 ;+++
                                     09C2  1728 ;k> fill -- ( a w c -- l ) Fill `w' bytes from `a' with character `c'.
                                     09C2  1729 ;---
                                     09C2  1730 	header	fill
                           000009B6' 09C2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000009C2  09C6       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  09C6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  09C6       	.if    le, nchr		; nchr <= 0
                     6C 6C 69 66 00' 09C6       	   .ascic \fill\	; no auxillary , use principle one
                                 04  09C6       
                                     09CB       	.if_false		; else
                                     09CB       	  .ascic \\		; use auxillary 
                                     09CB       	.endc			; end if
                                     09CB       fill:			; use  of word as v1_kernel label
                                     09CB       	
                       69   00   2C  09CB  1731 	movc5	#0,(r9),-		; srclen,src (use eodp just to be safe)
                            6B       09CE  1732 		(r11),-			; fill character
                 08 BB   04 AB       09CF  1733 		4(r11),@8(r11)		; destlen, dest
                       5B   0C   C0  09D3  1734 	addl2	#12,r11			; pop arguments
                                 05  09D6  1735 	rsb				; end of fill
                                     09D7  1736 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  86
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     09D7  1737 
                                     09D7  1738 ;+++
                                     09D7  1739 ;k> flush-buffers -- ( -- ) wite all modified buffers and mark them unmodified.
                                     09D7  1740 ;---
                                     09D7  1741 	header	i_flush_buffers,<flush-buffers>
                           000009C2' 09D7       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000009D7  09DB       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000D  09DB       	.nchr  nchr, ^\flush-buffers\	; nchr = length( flush-buffers )
                           0000000D  09DB       	.if    le, nchr		; nchr <= 0
                                     09DB       	   .ascic \i_flush_buffers\	; no auxillary flush-buffers, use principle one
                                     09DB       	.if_false		; else
65 66 66 75 62 2D 68 73 75 6C 66 00' 09DB       	  .ascic \flush-buffers\		; use auxillary flush-buffers
                              73 72  09E7       
                                 0D  09DB       
                                     09E9       	.endc			; end if
                                     09E9       i_flush_buffers:			; use flush-buffers of word as v1_kernel label
                                     09E9       	
                            50   D4  09E9  1742 	clrl	r0			; bufffer number
                                     09EB  1743 10$:
                            02   91  09EB  1744 	cmpb	#c_modified,-		; Has the buffer
                 00001B7D'EF40       09ED  1745 		v_buf_inuse[r0]		;   been modified?
                            15   12  09F3  1746 	bneq	20$			; no, skip it
                       7A   50   D0  09F5  1747 	movl	r0,-(r10)		; save the buffer name
                       7B   50   D0  09F8  1748 	movl	r0,-(r11)		; set up for buffer-write
                       FCF5 CF   16  09FB  1749 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  09FF  1750 	movl	(r10)+,r0		; get the buffer number back
                            00   90  0A02  1751 	movb	#c_false,-		; mark the buffer as
                 00001B7D'EF40       0A04  1752 		v_buf_inuse[r0]		;   flushed, not in use
                                     0A0A  1753 20$:
                            02   F1  0A0A  1754 	acbl	#c_max_blocks-1,-	; buffer #'s in [0 .. c_max_blocks-1]
                  FFDB 50   01       0A0C  1755 		#1,r0,10$		; move to next buffer number, if any
                                 05  0A10  1756 	rsb				; end of flush-buffers
                                     0A11  1757 
                                     0A11  1758 
                                     0A11  1759 ;+++
                                     0A11  1760 ;k> forget -- ( -- ) reset content vocab back to word before word forgotten.
                                     0A11  1761 ;	Note that while this makes the forgotten word and any words
                                     0A11  1762 ;	defined after it unavailale, it does not reclaim an space,
                                     0A11  1763 ;	since the other vocabularies can be threaded through in the
                                     0A11  1764 ;	dictionary between words of this vocabulary.
                                     0A11  1765 ;---
                                     0A11  1766 ;??? Should I make { forget } = { forget/erase }?  Why did I make both
                                     0A11  1767 ; in the first place?
                                     0A11  1768 	header	forget
                           000009D7' 0A11       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000A11  0A15       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0A15       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0A15       	.if    le, nchr		; nchr <= 0
               74 65 67 72 6F 66 00' 0A15       	   .ascic \forget\	; no auxillary , use principle one
                                 06  0A15       
                                     0A1C       	.if_false		; else
                                     0A1C       	  .ascic \\		; use auxillary 
                                     0A1C       	.endc			; end if
                                     0A1C       forget:			; use  of word as v1_kernel label
                                     0A1C       	
                       7B   20   D0  0A1C  1769 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012DE'EF   16  0A1F  1770 	jsb	token			; get token
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  87
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

              7B   00001D37'FF   D0  0A25  1771 	movl	@v_context,-(r11)	; start search at context
                   00000F82'EF   16  0A2C  1772 	jsb	search			; search it
                            8B   D5  0A32  1773 	tstl	(r11)+			; Was it found?
                            0C   13  0A34  1774 	beql	100$			; No, tell user
                                     0A36  1775 ; make vocab point to word before the forgotten one.
           00001D37'FF   00 BB   D0  0A36  1776 	movl	@(r11),@v_context	;
                       5B   04   C0  0A3E  1777 	addl2	#4,r11			; pop address of found word
                                 05  0A41  1778 	rsb				; exit
                                     0A42  1779 100$:
              7B   000018C7'EF   9E  0A42  1780 	movab	v_wordnotfound,-(r11)	; put address of error message on stack
                       FA24 CF   16  0A49  1781 	jsb	bcount			; get address of text and length
                   0000144C'EF   16  0A4D  1782 	jsb	write			; write error message
                       7B   59   D0  0A53  1783 	movl	r9,-(r11)		; address of token not found in search
                       FA17 CF   16  0A56  1784 	jsb	bcount			; get address of text and length
                   0000144C'EF   16  0A5A  1785 	jsb	write			; write the name of the word
                          0FE4   31  0A60  1786 	brw	r_warm_start		; end of forget
                                     0A63  1787 
                                     0A63  1788 
                                     0A63  1789 ;+++
                                     0A63  1790 ;k> forget/erase -- ( -- ) rset context vocab to word before word forgotten
                                     0A63  1791 ;	and move the dictinary back to header address of word forgotten.
                                     0A63  1792 ;	In other words, dictinary is truncated BEFORE the word forgotten. ~~~Add warning
                                     0A63  1793 ;---
                                     0A63  1794 	header	i_forget_erase,<forget/erase>
                           00000A11' 0A63       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000A63  0A67       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000C  0A67       	.nchr  nchr, ^\forget/erase\	; nchr = length( forget/erase )
                           0000000C  0A67       	.if    le, nchr		; nchr <= 0
                                     0A67       	   .ascic \i_forget_erase\	; no auxillary forget/erase, use principle one
                                     0A67       	.if_false		; else
73 61 72 65 2F 74 65 67 72 6F 66 00' 0A67       	  .ascic \forget/erase\		; use auxillary forget/erase
                                 65  0A73       
                                 0C  0A67       
                                     0A74       	.endc			; end if
                                     0A74       i_forget_erase:			; use forget/erase of word as v1_kernel label
                                     0A74       	
                       7B   20   D0  0A74  1795 	movl	#c_blank,-(r11)		; set up for blank delimited token
                   000012DE'EF   16  0A77  1796 	jsb	token			; get token
              7B   00001D37'FF   D0  0A7D  1797 	movl	@v_context,-(r11)	; start search at contxt
                   00000F82'EF   16  0A84  1798 	jsb	search			; search it
                            8B   D5  0A8A  1799 	tstl	(r11)+			; Was it found?
                            0F   13  0A8C  1800 	beql	100$			; No, tell user
                                     0A8E  1801 ; make vocab point to word before the forgotten one.
           00001D37'FF   00 BB   D0  0A8E  1802 	movl	@(r11),@v_context
                       59   6B   D0  0A96  1803 	movl	(r11),r9		; truncate dictionary
                       6B   04   C0  0A99  1804 	addl2	#4,(r11)		; pop address of found word
                                 05  0A9C  1805 	rsb				; return
                                     0A9D  1806 100$:
              7B   000018C7'EF   9E  0A9D  1807 	movab	v_wordnotfound,-(r11)	;
                       F9C9 CF   16  0AA4  1808 	jsb	bcount			; get address of text and length
                   0000144C'EF   16  0AA8  1809 	jsb	write			; write error message
                       7B   59   D0  0AAE  1810 	movl	r9,-(r11)		; address of token not found in search
                       F9BC CF   16  0AB1  1811 	jsb	bcount			; get addres of text and length
                   0000144C'EF   16  0AB5  1812 	jsb	write			; write the name of the word ~~ not found
                          0F89   31  0ABB  1813 	brw	r_warm_start		; end of forget/erase
                                     0ABE  1814 
                                     0ABE  1815 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  88
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0ABE  1816 ;+++
                                     0ABE  1817 ;k> freemem -- ( -- l ) print amount of memory left in dictionary
                                     0ABE  1818 ;--- ~~~ does it really leave a longword on the stack?
                                     0ABE  1819 	header	freemem
                           00000A63' 0ABE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000ABE  0AC2       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0AC2       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0AC2       	.if    le, nchr		; nchr <= 0
            6D 65 6D 65 65 72 66 00' 0AC2       	   .ascic \freemem\	; no auxillary , use principle one
                                 07  0AC2       
                                     0ACA       	.if_false		; else
                                     0ACA       	  .ascic \\		; use auxillary 
                                     0ACA       	.endc			; end if
                                     0ACA       freemem:			; use  of word as v1_kernel label
                                     0ACA       	
         7B   00004000'8F   59   C3  0ACA  1820 	subl3	r9,#c_dict_end,-(r11)	; put free space on stack
                       F64D CF   16  0AD2  1821 	jsb	i_dot			; print it
                                 05  0AD6  1822 	rsb				; end of freemem
                                     0AD7  1823 
                                     0AD7  1824 
                                     0AD7  1825 ;+++
                                     0AD7  1826 ;k> halt -- ( l -- ) halt VTIL, use `l' as returned value.  Never returns. ~~~ Change "returned value" to "exit status?
                                     0AD7  1827 ;---
                                     0AD7  1828 	header	i_halt,<halt>
                           00000ABE' 0AD7       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000AD7  0ADB       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  0ADB       	.nchr  nchr, ^\halt\	; nchr = length( halt )
                           00000004  0ADB       	.if    le, nchr		; nchr <= 0
                                     0ADB       	   .ascic \i_halt\	; no auxillary halt, use principle one
                                     0ADB       	.if_false		; else
                     74 6C 61 68 00' 0ADB       	  .ascic \halt\		; use auxillary halt
                                 04  0ADB       
                                     0AE0       	.endc			; end if
                                     0AE0       i_halt:			; use halt of word as v1_kernel label
                                     0AE0       	
                       50   8B   D0  0AE0  1829 	movl	(r11)+,r0		; put error number in right place
                          10E7   31  0AE3  1830 	brw	_error_exit		; go to error exit routine
                                     0AE6  1831 					; end of halt
                                     0AE6  1832 
                                     0AE6  1833 
                                     0AE6  1834 ;+++
                                     0AE6  1835 ;k> hex -- ( -- ) Set the base to hexidecimal.
                                     0AE6  1836 ;---
                                     0AE6  1837 	header	hex
                           00000AD7' 0AE6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000AE6  0AEA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0AEA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0AEA       	.if    le, nchr		; nchr <= 0
                        78 65 68 00' 0AEA       	   .ascic \hex\	; no auxillary , use principle one
                                 03  0AEA       
                                     0AEE       	.if_false		; else
                                     0AEE       	  .ascic \\		; use auxillary 
                                     0AEE       	.endc			; end if
                                     0AEE       hex:			; use  of word as v1_kernel label
                                     0AEE       	
              00001D4E'EF   10   D0  0AEE  1838 	movl	#16,v_radix		; switch to base 16 (hexadecimal)
                                 05  0AF5  1839 	rsb				; end of hex
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  89
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0AF6  1840 
                                     0AF6  1841 
                                     0AF6  1842 ;+++
                                     0AF6  1843 ;k> hld -- ( -- a ) Variable hld, return address of hld.
                                     0AF6  1844 ;---
                                     0AF6  1845 	header	hld
                           00000AE6' 0AF6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000AF6  0AFA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0AFA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0AFA       	.if    le, nchr		; nchr <= 0
                        64 6C 68 00' 0AFA       	   .ascic \hld\	; no auxillary , use principle one
                                 03  0AFA       
                                     0AFE       	.if_false		; else
                                     0AFE       	  .ascic \\		; use auxillary 
                                     0AFE       	.endc			; end if
                                     0AFE       hld:			; use  of word as v1_kernel label
                                     0AFE       	
              7B   00001D52'EF   DE  0AFE  1846 	moval	v_hld,-(r11)		; leave address on stack
                                 05  0B05  1847 	rsb				; end of hld
                                     0B06  1848 
                                     0B06  1849 
                                     0B06  1850 ;+++
                                     0B06  1851 ;k> hold -- ( -- ) Insert `c' in current numeric output string.
                                     0B06  1852 ;---
                                     0B06  1853 	header	hold
                           00000AF6' 0B06       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000B06  0B0A       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0B0A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B0A       	.if    le, nchr		; nchr <= 0
                     64 6C 6F 68 00' 0B0A       	   .ascic \hold\	; no auxillary , use principle one
                                 04  0B0A       
                                     0B0F       	.if_false		; else
                                     0B0F       	  .ascic \\		; use auxillary 
                                     0B0F       	.endc			; end if
                                     0B0F       hold:			; use  of word as v1_kernel label
                                     0B0F       	
                   00001D52'EF   D7  0B0F  1854 	decl	v_hld			; move pointer down one char
              00001D52'FF   6B   90  0B15  1855 	movb	(r11),@v_hld		; fill new char w/top of stack
                       5B   04   C0  0B1C  1856 	addl2	#4,r11			; pop char off stack
                                 05  0B1F  1857 	rsb				; end of hold
                                     0B20  1858 
                                     0B20  1859 
                                     0B20  1860 ;+++
                                     0B20  1861 ;k> i> -- ( -- ) Copy the top of the loop stack to the data stack.
                                     0B20  1862 ;	This word is used inside of { do ... loop }'s to get the index
                                     0B20  1863 ;	of the innermost loop onto the top of the stack.
                                     0B20  1864 ;---
                                     0B20  1865 	header	i_i_to,^\i>\
                           00000B06' 0B20       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000B20  0B24       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0B24       	.nchr  nchr, ^\i>\	; nchr = length( i> )
                           00000002  0B24       	.if    le, nchr		; nchr <= 0
                                     0B24       	   .ascic \i_i_to\	; no auxillary i>, use principle one
                                     0B24       	.if_false		; else
                           3E 69 00' 0B24       	  .ascic \i>\		; use auxillary i>
                                 02  0B24       
                                     0B27       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  90
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0B27       i_i_to:			; use i> of word as v1_kernel label
                                     0B27       	
                       7B   6A   D0  0B27  1866 	movl	(r10),-(r11)		; copy w/o consuming ~~~ from loop stack.
                                 05  0B2A  1867 	rsb				; end of i>
                                     0B2B  1868 
                                     0B2B  1869 
                                     0B2B  1870 ;+++
                                     0B2B  1871 ;k> kernel -- ( -- ) Set context to kernel vocabulary.
                                     0B2B  1872 ;---
                                     0B2B  1873 	header	kernel
                           00000B20' 0B2B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000B2B  0B2F       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0B2F       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B2F       	.if    le, nchr		; nchr <= 0
               6C 65 6E 72 65 6B 00' 0B2F       	   .ascic \kernel\	; no auxillary , use principle one
                                 06  0B2F       
                                     0B36       	.if_false		; else
                                     0B36       	  .ascic \\		; use auxillary 
                                     0B36       	.endc			; end if
                                     0B36       kernel:			; use  of word as v1_kernel label
                                     0B36       	
     00001D37'EF   00001D43'EF   DE  0B36  1874 	moval	v_kernel,v_context
                                 05  0B41  1875 	rsb				; end of kernel
                                     0B42  1876 
                                     0B42  1877 
                                     0B42  1878 ;+++
                                     0B42  1879 ;k> leave -- ( -- ) Leave a { do } loop at end of this iteration.
                                     0B42  1880 ;---
                                     0B42  1881 	header	leave
                           00000B2B' 0B42       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000B42  0B46       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0B46       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B46       	.if    le, nchr		; nchr <= 0
                  65 76 61 65 6C 00' 0B46       	   .ascic \leave\	; no auxillary , use principle one
                                 05  0B46       
                                     0B4C       	.if_false		; else
                                     0B4C       	  .ascic \\		; use auxillary 
                                     0B4C       	.endc			; end if
                                     0B4C       leave:			; use  of word as v1_kernel label
                                     0B4C       	
                    04 AA   6A   D0  0B4C  1882 	movl	(r10),4(r10)		; make limit = index so loop will exit
                                 05  0B50  1883 	rsb				; end of leave
                                     0B51  1884 
                                     0B51  1885 
                                     0B51  1886 ;+++
                                     0B51  1887 ;k> load -- ( -- ) Take input from file instead of the terminal.
                                     0B51  1888 ;	Format: { load filename }
                                     0B51  1889 ;---
                                     0B51  1890 	header	load
                           00000B42' 0B51       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000B51  0B55       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0B55       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0B55       	.if    le, nchr		; nchr <= 0
                     64 61 6F 6C 00' 0B55       	   .ascic \load\	; no auxillary , use principle one
                                 04  0B55       
                                     0B5A       	.if_false		; else
                                     0B5A       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  91
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0B5A       	.endc			; end if
                                     0B5A       load:			; use  of word as v1_kernel label
                                     0B5A       	
                       7B   20   D0  0B5A  1891 	movl	#c_blank,-(r11)		; set up for blank terminated file name
                   000012DE'EF   16  0B5D  1892 	jsb	token			; get v_fname
                       56   69   9A  0B63  1893 	movzbl	(r9),r6			; get count of v_fname
      00001A3D'EF   01 A9   56   28  0B66  1894 	movc3	r6,1(r9),v_fname	; move to name buffer
              00001A3C'EF   56   90  0B6F  1895 	movb	r6,v_fnamelen		; save length
                   00001A3D'EF   DE  0B76  1896 	moval	v_fname,-
                   000019D4'EF       0B7C  1897 		v_infab+fab$l_fna	; tell it where filespec is
                   00001A3C'EF   90  0B81  1898 	movb	v_fnamelen,-
                   000019DC'EF       0B87  1899 		v_infab+fab$b_fns	; tell it what size filespec is
                                     0B8C  1900 	$open	fab=v_infab		; open input file
                                     0B8C       		$RMSCALL	OPEN,v_infab,,
                                     0B8C       	.GLOBL	SYS$OPEN
                                     0B8C       	.IF	B <v_infab>
                                     0B8C       	CALLG	(AP),G^SYS$OPEN
                                     0B8C       	$$.TMP=0
                                     0B8C       	.IF	NB <>
                                     0B8C       	$$.TMP=1
                                     0B8C       	.ENDC
                                     0B8C       	.IF	NB <>
                                     0B8C       	$$.TMP=1
                                     0B8C       	.ENDC
                                     0B8C       	.IF	NE $$.TMP
                                     0B8C       	.ERROR				; v_infab= parameter missing;
                                     0B8C       	.ENDC
                                     0B8C       	.ENDC
                                     0B8C       	.IF	NB <v_infab>
                           00000001  0B8C       	$$.TMP1=1
                                     0B8C       	.IF	NB <>
                                     0B8C       	PUSHAL	
                                     0B8C       	$$.TMP1=3
                                     0B8C       	.ENDC
                                     0B8C       	.IF	NB <>
                                     0B8C       	PUSHAL	
                                     0B8C       	.IF	EQ <$$.TMP1-1>
                                     0B8C       	$$.TMP1=2
                                     0B8C       	.ENDC
                                     0B8C       	.IFF
                           FFFFFFFE  0B8C       	.IF	EQ <$$.TMP1-3>
                                     0B8C       	PUSHL	#0
                                     0B8C       	.ENDC
                                     0B8C       	.ENDC
                           000000CF  0B8C       	.NTYPE	$$.TMP2,v_infab
                           00000070  0B8C       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0B8C       	PUSHL	v_infab
                                     0B8C       	.IFF
                           000000B0  0B8C       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0B8C       	PUSHL	v_infab
                                     0B8C       	.IFF
                   000019A8'EF   DF  0B8C       	PUSHAL	v_infab
                                     0B92       	.ENDC
                                     0B92       	.ENDC
              00000000'GF   01   FB  0B92       	CALLS	#$$.TMP1,G^SYS$OPEN
                                     0B99       	.ENDC
                                     0B99       	
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  92
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0B99       	
                         12 50   E9  0B99  1901 	blbc	r0,10$			; Quit on error
                                     0B9C  1902 	$connect rab=v_inrab		; connect to input
                                     0B9C       		$RMSCALL	CONNECT,v_inrab,,
                                     0B9C       	.GLOBL	SYS$CONNECT
                                     0B9C       	.IF	B <v_inrab>
                                     0B9C       	CALLG	(AP),G^SYS$CONNECT
                                     0B9C       	$$.TMP=0
                                     0B9C       	.IF	NB <>
                                     0B9C       	$$.TMP=1
                                     0B9C       	.ENDC
                                     0B9C       	.IF	NB <>
                                     0B9C       	$$.TMP=1
                                     0B9C       	.ENDC
                                     0B9C       	.IF	NE $$.TMP
                                     0B9C       	.ERROR				; v_inrab= parameter missing;
                                     0B9C       	.ENDC
                                     0B9C       	.ENDC
                                     0B9C       	.IF	NB <v_inrab>
                           00000001  0B9C       	$$.TMP1=1
                                     0B9C       	.IF	NB <>
                                     0B9C       	PUSHAL	
                                     0B9C       	$$.TMP1=3
                                     0B9C       	.ENDC
                                     0B9C       	.IF	NB <>
                                     0B9C       	PUSHAL	
                                     0B9C       	.IF	EQ <$$.TMP1-1>
                                     0B9C       	$$.TMP1=2
                                     0B9C       	.ENDC
                                     0B9C       	.IFF
                           FFFFFFFE  0B9C       	.IF	EQ <$$.TMP1-3>
                                     0B9C       	PUSHL	#0
                                     0B9C       	.ENDC
                                     0B9C       	.ENDC
                           000000CF  0B9C       	.NTYPE	$$.TMP2,v_inrab
                           00000070  0B9C       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     0B9C       	PUSHL	v_inrab
                                     0B9C       	.IFF
                           000000B0  0B9C       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     0B9C       	PUSHL	v_inrab
                                     0B9C       	.IFF
                   000019F8'EF   DF  0B9C       	PUSHAL	v_inrab
                                     0BA2       	.ENDC
                                     0BA2       	.ENDC
              00000000'GF   01   FB  0BA2       	CALLS	#$$.TMP1,G^SYS$CONNECT
                                     0BA9       	.ENDC
                                     0BA9       	
                                     0BA9       	
                         23 50   E9  0BA9  1903 	blbc	r0,20$			; Quit on error
                            2B   11  0BAC  1904 	brb	40$			; branch to read loop
                                     0BAE  1905 10$:
              00000000'8F   50   D1  0BAE  1906 	cmpl	r0,#rms$_fnf		; is it file not found?
                            0E   12  0BB5  1907 	bneq	15$			; no
                   0000189A'EF   7F  0BB7  1908 	pushaq	v_filenotfound		;
              00000000'GF   01   FB  0BBD  1909 	calls	#1,g^lib$put_output	; Tell user file not found
                                 05  0BC4  1910 	rsb				; return
                                     0BC5  1911 15$:
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  93
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

              56   000019A8'EF   DE  0BC5  1912 	moval	v_infab,r6		; error: keep fab address
                          1008   31  0BCC  1913 	brw	_f_err			; signal file error
                                     0BCF  1914 20$:
              56   000019F8'EF   DE  0BCF  1915 	moval	v_inrab,r6		; keep rab address
                          100D   31  0BD6  1916 	brw	_r_err			; signal record error
                                     0BD9  1917 40$:
           00001D47'EF   FF 8F   90  0BD9  1918 	movb	#c_true,v_infile	; set input from file flag
              00001D48'EF   00   D0  0BE1  1919 	movl	#0,v_filelinenum	; reinitialize number of lines read
                                 05  0BE8  1920 	rsb				; end of load
                                     0BE9  1921 
                                     0BE9  1922 
                                     0BE9  1923 ;+++t
                                     0BE9  1924 ;k> long -- ( n -- ) Create a word that pushed address of longword on stack,
                                     0BE9  1925 ;	save space in dictionary, and initialize to `n'.
                                     0BE9  1926 ;---
                                     0BE9  1927 	header	i_long,<long>
                           00000B51' 0BE9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000BE9  0BED       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000004  0BED       	.nchr  nchr, ^\long\	; nchr = length( long )
                           00000004  0BED       	.if    le, nchr		; nchr <= 0
                                     0BED       	   .ascic \i_long\	; no auxillary long, use principle one
                                     0BED       	.if_false		; else
                     67 6E 6F 6C 00' 0BED       	  .ascic \long\		; use auxillary long
                                 04  0BED       
                                     0BF2       	.endc			; end if
                                     0BF2       i_long:			; use long of word as v1_kernel label
                                     0BF2       	
                       FC48 CF   16  0BF2  1928 	jsb	create			; enclose next token in dictionary
                    89   DE 8F   90  0BF6  1929 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  0BFA  1930 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0BFE  1931 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0C01  1932 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0C05  1933 	movb	#op_rsb,(r9)+		; `rsb'
                       89   8B   D0  0C08  1934 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                                 05  0C0B  1935 	rsb				; end of long
                                     0C0C  1936 
                                     0C0C  1937 
                                     0C0C  1938 ;+++t
                                     0C0C  1939 ;k> longconst -- ( n -- ) Create a word that pushed a `n' to the stack.
                                     0C0C  1940 ;---
                                     0C0C  1941 	header	longconst
                           00000BE9' 0C0C       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000C0C  0C10       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0C10       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C10       	.if    le, nchr		; nchr <= 0
      74 73 6E 6F 63 67 6E 6F 6C 00' 0C10       	   .ascic \longconst\	; no auxillary , use principle one
                                 09  0C10       
                                     0C1A       	.if_false		; else
                                     0C1A       	  .ascic \\		; use auxillary 
                                     0C1A       	.endc			; end if
                                     0C1A       longconst:			; use  of word as v1_kernel label
                                     0C1A       	
                       FC20 CF   16  0C1A  1942 	jsb	create			; enclose next token in dictionary
                   0000179F'EF   16  0C1E  1943 	jsb	literal			; enclose code in dictionary
                       89   05   90  0C24  1944 	movb	#op_rsb,(r9)+		; stick `rsb' into dictionary to
                                     0C27  1945 					;   end constant word
                                 05  0C27  1946 	rsb				; end of longconst
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  94
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0C28  1947 
                                     0C28  1948 
                                     0C28  1949 ;+++
                                     0C28  1950 ;k> ls>ds -- ( -- n ) Remove `n' from loop stack.
                                     0C28  1951 ;---
                                     0C28  1952 	header	i_ls_to_ds,^/ls>ds/
                           00000C0C' 0C28       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000C28  0C2C       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  0C2C       	.nchr  nchr, ^\ls>ds\	; nchr = length( ls>ds )
                           00000005  0C2C       	.if    le, nchr		; nchr <= 0
                                     0C2C       	   .ascic \i_ls_to_ds\	; no auxillary ls>ds, use principle one
                                     0C2C       	.if_false		; else
                  73 64 3E 73 6C 00' 0C2C       	  .ascic \ls>ds\		; use auxillary ls>ds
                                 05  0C2C       
                                     0C32       	.endc			; end if
                                     0C32       i_ls_to_ds:			; use ls>ds of word as v1_kernel label
                                     0C32       	
                       7B   8A   D0  0C32  1953 	movl	(r10)+,-(r11)		; pop from loop stack, move to dstack
                                 05  0C35  1954 	rsb				; end of ls>ds
                                     0C36  1955 
                                     0C36  1956 
                                     0C36  1957 ;+++
                                     0C36  1958 ;k> match -- ( a1 n1 a2 n2 -- a3 ? f ) Search for string of length `n2' at
                                     0C36  1959 ;	`a2' in string of length `n' at `a'.
                                     0C36  1960 ;---
                                     0C36  1961 	header	i_match,<match>
                           00000C28' 0C36       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000C36  0C3A       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  0C3A       	.nchr  nchr, ^\match\	; nchr = length( match )
                           00000005  0C3A       	.if    le, nchr		; nchr <= 0
                                     0C3A       	   .ascic \i_match\	; no auxillary match, use principle one
                                     0C3A       	.if_false		; else
                  68 63 74 61 6D 00' 0C3A       	  .ascic \match\		; use auxillary match
                                 05  0C3A       
                                     0C40       	.endc			; end if
                                     0C40       i_match:			; use match of word as v1_kernel label
                                     0C40       	
                    04 BB   6B   39  0C40  1962 	matchc	(r11),@4(r11),-		; object string (one we're looking for)
                 0C BB   08 AB       0C44  1963 		8(r11),@12(r11)		; source string (one we're looking in)
                            12   12  0C48  1964 	bneq	100$			; no match found
                                     0C4A  1965 ; match found, calcualte its address.  matchc leaves in r3 the address of the
                                     0C4A  1966 ; byte after last byte matched in the source string, so address of matched
                                     0C4A  1967 ; string is r3 - objectlen.
                  50   53   61   C3  0C4A  1968 	subl3  (r1),r3,r0		; calculate address of matched string
                       5B   10   C0  0C4E  1969 	addl2  #16,r11			; pop arguments
                       7B   50   D0  0C51  1970 	movl   r0,-(r11)		; put address of matched string on stack
              7B   FFFFFFFF 8F   D0  0C54  1971 	movl   #c_true,-(r11)		; leave true on top of stack
                                 05  0C5B  1972 	rsb				; return
                                     0C5C  1973 100$:
                                     0C5C  1974 ; no match found
                       5B   10   C0  0C5C  1975 	addl2	#16,r11			; pop arguments
                       7B   00   D0  0C5F  1976 	movl	#c_false,-(r11)		; leave a false ~~~ on top of stack
                                 05  0C62  1977 	rsb				; end of match
                                     0C63  1978 
                                     0C63  1979 
                                     0C63  1980 ;+++
                                     0C63  1981 ;k> max -- ( n1 n2 -- n2 ) Leave larger of n1 and n2 on stack.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  95
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0C63  1982 ;---
                                     0C63  1983 	header	max
                           00000C36' 0C63       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000C63  0C67       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0C67       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C67       	.if    le, nchr		; nchr <= 0
                        78 61 6D 00' 0C67       	   .ascic \max\	; no auxillary , use principle one
                                 03  0C67       
                                     0C6B       	.if_false		; else
                                     0C6B       	  .ascic \\		; use auxillary 
                                     0C6B       	.endc			; end if
                                     0C6B       max:			; use  of word as v1_kernel label
                                     0C6B       	
                    04 AB   6B   D1  0C6B  1984 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   15  0C6F  1985 	bleq	10$			; Top less than under item?
                                     0C71  1986 ; no, top greater
                    04 AB   6B   D0  0C71  1987 	movl	(r11),4(r11)		; move greater down stack
                                     0C75  1988 10$:
                       5B   04   C0  0C75  1989 	addl2	#4,r11			; pop first argument, since
                                     0C78  1990 					;   great is in second item now
                                 05  0C78  1991 	rsb				; end of max
                                     0C79  1992 
                                     0C79  1993 
                                     0C79  1994 ;+++
                                     0C79  1995 ;k> message -- ( a -- ) writes word-counted string at `a' to terminal.
                                     0C79  1996 ;---
                                     0C79  1997 	header	message
                           00000C63' 0C79       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000C79  0C7D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0C7D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C7D       	.if    le, nchr		; nchr <= 0
            65 67 61 73 73 65 6D 00' 0C7D       	   .ascic \message\	; no auxillary , use principle one
                                 07  0C7D       
                                     0C85       	.if_false		; else
                                     0C85       	  .ascic \\		; use auxillary 
                                     0C85       	.endc			; end if
                                     0C85       message:			; use  of word as v1_kernel label
                                     0C85       	
                       FB6F CF   16  0C85  1998 	jsb	count			; set up for write
                   0000144C'EF   16  0C89  1999 	jsb	write			; write it out
                                 05  0C8F  2000 	rsb				; end of message
                                     0C90  2001 
                                     0C90  2002 
                                     0C90  2003 ;+++
                                     0C90  2004 ;k> min -- ( n1 n2 -- n2 ) Leaves small or n1 and n2 on stack.
                                     0C90  2005 ;---
                                     0C90  2006 	header	min
                           00000C79' 0C90       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000C90  0C94       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0C94       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0C94       	.if    le, nchr		; nchr <= 0
                        6E 69 6D 00' 0C94       	   .ascic \min\	; no auxillary , use principle one
                                 03  0C94       
                                     0C98       	.if_false		; else
                                     0C98       	  .ascic \\		; use auxillary 
                                     0C98       	.endc			; end if
                                     0C98       min:			; use  of word as v1_kernel label
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  96
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0C98       	
                    04 AB   6B   D1  0C98  2007 	cmpl	(r11),4(r11)		; compare top two stack items
                            04   18  0C9C  2008 	bgeq	10$			; Top is greater than under item
                    04 AB   6B   D0  0C9E  2009 	movl	(r11),4(r11)		;
                                     0CA2  2010 10$:
                       5B   04   C0  0CA2  2011 	addl2	#4,r11			; pop top stack item since lesser is
                                     0CA5  2012 					;   in second line.
                                 05  0CA5  2013 	rsb				; end of min
                                     0CA6  2014 
                                     0CA6  2015 
                                     0CA6  2016 ;+++
                                     0CA6  2017 ;k> mod -- ( n1 n2 -- n3 ) Leave remainder of n1 / n2 on stack.
                                     0CA6  2018 ;---
                                     0CA6  2019 	header	mod
                           00000C90' 0CA6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000CA6  0CAA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0CAA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CAA       	.if    le, nchr		; nchr <= 0
                        64 6F 6D 00' 0CAA       	   .ascic \mod\	; no auxillary , use principle one
                                 03  0CAA       
                                     0CAE       	.if_false		; else
                                     0CAE       	  .ascic \\		; use auxillary 
                                     0CAE       	.endc			; end if
                                     0CAE       mod:			; use  of word as v1_kernel label
                                     0CAE       	
               50   04 AB   6B   C7  0CAE  2020 	divl3	(r11),4(r11),r0		; r0 = n1 / n2
                  51   8B   50   C5  0CB3  2021 	mull3	r0,(r11)+,r1		; temp = n2 * n3
                       6B   51   C2  0CB7  2022 	subl2	r1,(r11)		; n3 = n1 - quotient
                                 05  0CBA  2023 	rsb				; end of mod
                                     0CBB  2024 
                                     0CBB  2025 
                                     0CBB  2026 ;+++
                                     0CBB  2027 ;k> move -- ( a1 a2 w -- ) Copies `w' bytes from `a1' to `a2'.
                                     0CBB  2028 ;---
                                     0CBB  2029 	header	move
                           00000CA6' 0CBB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000CBB  0CBF       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0CBF       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CBF       	.if    le, nchr		; nchr <= 0
                     65 76 6F 6D 00' 0CBF       	   .ascic \move\	; no auxillary , use principle one
                                 04  0CBF       
                                     0CC4       	.if_false		; else
                                     0CC4       	  .ascic \\		; use auxillary 
                                     0CC4       	.endc			; end if
                                     0CC4       move:			; use  of word as v1_kernel label
                                     0CC4       	
            04 BB   08 BB   6B   28  0CC4  2030 	movc3	(r11),@8(r11),@4(r11)	;
                       5B   0C   C0  0CCA  2031 	addl2	#12,r11			; pop arguments
                                 05  0CCD  2032 	rsb				; end of move
                                     0CCE  2033 
                                     0CCE  2034 
                                     0CCE  2035 ;+++
                                     0CCE  2036 ;k> move&fill -- ( a1 w1 a2 w2 c -- ) copies bytes from `a1' to `a2'.
                                     0CCE  2037 ;	If `w2' > `wl', fill with c.  If `w2' < `w1', truncate.
                                     0CCE  2038 ;---
                                     0CCE  2039 	header	i_move_fill,<move&fill>
                           00000CBB' 0CCE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  97
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000CCE  0CD2       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000009  0CD2       	.nchr  nchr, ^\move&fill\	; nchr = length( move&fill )
                           00000009  0CD2       	.if    le, nchr		; nchr <= 0
                                     0CD2       	   .ascic \i_move_fill\	; no auxillary move&fill, use principle one
                                     0CD2       	.if_false		; else
      6C 6C 69 66 26 65 76 6F 6D 00' 0CD2       	  .ascic \move&fill\		; use auxillary move&fill
                                 09  0CD2       
                                     0CDC       	.endc			; end if
                                     0CDC       i_move_fill:			; use move&fill of word as v1_kernel label
                                     0CDC       	
                 10 BB   0C AB   2C  0CDC  2040 	movc5	12(r11),@16(r11),-	; sourcelen, source
                            6B       0CE1  2041 		(r11),-			; fill character
                 08 BB   04 AB       0CE2  2042 		4(r11),@8(r11)		; destlen, destination
                       5B   14   C0  0CE6  2043 	addl2	#20,r11			; pop arguments
                                 05  0CE9  2044 	rsb				; end of move/fill
                                     0CEA  2045 
                                     0CEA  2046 
                                     0CEA  2047 ;+++
                                     0CEA  2048 ;k> negate -- ( n -- -n )  Leave two's complement of top stack item on stack.
                                     0CEA  2049 ;---
                                     0CEA  2050 	header	negage
                           00000CCE' 0CEA       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000CEA  0CEE       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0CEE       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CEE       	.if    le, nchr		; nchr <= 0
               65 67 61 67 65 6E 00' 0CEE       	   .ascic \negage\	; no auxillary , use principle one
                                 06  0CEE       
                                     0CF5       	.if_false		; else
                                     0CF5       	  .ascic \\		; use auxillary 
                                     0CF5       	.endc			; end if
                                     0CF5       negage:			; use  of word as v1_kernel label
                                     0CF5       	
                       6B   6B   CE  0CF5  2051 	mnegl	(r11),(r11)		; negate it
                                 05  0CF8  2052 	rsb				; end of negate
                                     0CF9  2053 
                                     0CF9  2054 
                                     0CF9  2055 ;+++
                                     0CF9  2056 ;k> not -- ( f1 -- f2 ) Logical not of top  of stack; not f1.
                                     0CF9  2057 ;---
                                     0CF9  2058 	header	not
                           00000CEA' 0CF9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000CF9  0CFD       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0CFD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0CFD       	.if    le, nchr		; nchr <= 0
                        74 6F 6E 00' 0CFD       	   .ascic \not\	; no auxillary , use principle one
                                 03  0CFD       
                                     0D01       	.if_false		; else
                                     0D01       	  .ascic \\		; use auxillary 
                                     0D01       	.endc			; end if
                                     0D01       not:			; use  of word as v1_kernel label
                                     0D01       	
                            8B   D5  0D01  2059 	tstl	(r11)+			; Is it false?
                            04   13  0D03  2060 	beql	10$			; yes
                       7B   00   D0  0D05  2061 	movl	#c_false,-(r11)		; no, leave with false on stack
                                 05  0D08  2062 	rsb				; return
                                     0D09  2063 10$:
              7B   FFFFFFFF 8F   D0  0D09  2064 	movl	#c_true,-(r11)		; it is false, leave with true on stack
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  98
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 05  0D10  2065 	rsb				; end of not
                                     0D11  2066 
                                     0D11  2067 
                                     0D11  2068 ;+++t
                                     0D11  2069 ;k> number -- ( -- n ? f ) Try to turn token at eodp into a number.  If
                                     0D11  2070 ;	it is a number, leave ( number true ) on stack.  If it is not a number
                                     0D11  2071 ;	leave ( false ) on stack.
                                     0D11  2072 ;---
                                     0D11  2073 	header	number
                           00000CF9' 0D11       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000D11  0D15       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0D15       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D15       	.if    le, nchr		; nchr <= 0
               72 65 62 6D 75 6E 00' 0D15       	   .ascic \number\	; no auxillary , use principle one
                                 06  0D15       
                                     0D1C       	.if_false		; else
                                     0D1C       	  .ascic \\		; use auxillary 
                                     0D1C       	.endc			; end if
                                     0D1C       number:			; use  of word as v1_kernel label
                                     0D1C       	
                            50   D4  0D1C  2074 	clrl	r0			; clear result
                            51   D4  0D1E  2075 	clrl	r1			; clear sign
                       56   59   D0  0D20  2076 	movl	r9, r6			; get pointer to token
                       57   86   9A  0D23  2077 	movzbl	(r6)+,r7		; get byte count
                       66   2D   91  0D26  2078 	cmpb	#^a/-/,(r6)		; does it have a leading minus sign?
                            07   12  0D29  2079 	bneq	_number_top		; no, go on
                       51   01   D0  0D2B  2080 	movl	#1,r1			; yes, set flag
                            56   D6  0D2E  2081 	incl	r6			; advance over sign
                            57   D7  0D30  2082 	decl	r7			; length = length - 1
                                     0D32  2083 _number_top:
                       52   66   9A  0D32  2084 	movzbl	(r6),r2			; get byte
                       52   30   C2  0D35  2085 	subl2	#^x30,r2			; check in range 0...9
                            52   D5  0D38  2086 	tstl	r2			; Is it negative?
                            52   19  0D3A  2087 	blss	_invalid_number		; yes, leave with false
                       09   52   D1  0D3C  2088 	cmpl	r2,#9			; r2 <= 9
                            20   15  0D3F  2089 	bleq	_check_base		; yes, continue
                       11   52   D1  0D41  2090 	cmpl	r2,#^x11		; Is it A or greater?
                            48   19  0D44  2091 	blss	_invalid_number		; no, leave with false
                       2A   52   D1  0D46  2092 	cmpl	r2,#^x2a		; is it Z or less
                            05   14  0D49  2093 	bgtr	_check_lowercase	; no, go check if lower case
                       52   07   C2  0D4B  2094 	subl2	#7,r2			; convert to ^xA...^xZ
                            11   11  0D4E  2095 	brb	_check_base		; now check if it is valid in current
                                     0D50  2096 					; base
                                     0D50  2097 _check_lowercase:
                       31   52   D1  0D50  2098 	cmpl	r2,#^x31		; Is it a or greater?
                            39   19  0D53  2099 	blss	_invalid_number		; no, leave with false
              0000004A 8F   52   D1  0D55  2100 	cmpl	r2,#^x4a		; Is it z or less?
                            30   14  0D5C  2101 	bgtr	_invalid_number		; no, leave with false.
                       52   27   C2  0D5E  2102 	subl2	#^x27,r2		; convert to ^xA...^xZ
                                     0D61  2103 _check_base:
              00001D4E'EF   52   D1  0D61  2104 	cmpl	r2,v_radix		; is it in set 0... base-1?
                            24   18  0D68  2105 	bgeq	_invalid_number		; no, leave w/false
              50   00001D4E'EF   C4  0D6A  2106 	mull2	v_radix,r0		; result = result * base
                       50   52   C0  0D71  2107 	addl2	r2,r0			; result = result + num
                            57   D7  0D74  2108 	decl	r7			; count = count - 1
                            56   D6  0D76  2109 	incl	r6			; move to next byte in number
                            57   D5  0D78  2110 	tstl	r7			; count = 0?
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page  99
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                            B6   14  0D7A  2111 	bgtr	_number_top		; no, do it again
                            51   D5  0D7C  2112 	tstl	r1			; negative?
                            03   14  0D7E  2113 	bgtr	20$			; no
                       50   50   CE  0D80  2114 	mnegl	r0,r0			; yes, negate it.
                                     0D83  2115 20$:
                       7B   50   D0  0D83  2116 	movl	r0,-(r11)		; put result on stack
              7B   FFFFFFFF 8F   D0  0D86  2117 	movl	#c_true,-(r11)		; put true on stack
                                 05  0D8D  2118 	rsb				; exit with ( number true ) on dstack
                                     0D8E  2119 _invalid_number:
                       7B   00   D0  0D8E  2120 	movl	#c_false,-(r11)		; exit with ( false ) on dstack
                                 05  0D91  2121 	rsb				; end of number
                                     0D92  2122 
                                     0D92  2123 
                                     0D92  2124 ;+++
                                     0D92  2125 ;,> octal -- ( -- ) Set the base to octal.
                                     0D92  2126 ;---
                                     0D92  2127 	header	octal
                           00000D11' 0D92       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000D92  0D96       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0D96       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0D96       	.if    le, nchr		; nchr <= 0
                  6C 61 74 63 6F 00' 0D96       	   .ascic \octal\	; no auxillary , use principle one
                                 05  0D96       
                                     0D9C       	.if_false		; else
                                     0D9C       	  .ascic \\		; use auxillary 
                                     0D9C       	.endc			; end if
                                     0D9C       octal:			; use  of word as v1_kernel label
                                     0D9C       	
              00001D4E'EF   08   D0  0D9C  2128 	movl	#8,v_radix		; Switch to base 8
                                 05  0DA3  2129 	rsb				; end of octal
                                     0DA4  2130 
                                     0DA4  2131 
                                     0DA4  2132 ;+++t
                                     0DA4  2133 ;k> or -- ( f1 f2 -- f ) Logical or, f1 or f2.
                                     0DA4  2134 ;---
                                     0DA4  2135 	header	or
                           00000D92' 0DA4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000DA4  0DA8       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0DA8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DA8       	.if    le, nchr		; nchr <= 0
                           72 6F 00' 0DA8       	   .ascic \or\	; no auxillary , use principle one
                                 02  0DA8       
                                     0DAB       	.if_false		; else
                                     0DAB       	  .ascic \\		; use auxillary 
                                     0DAB       	.endc			; end if
                                     0DAB       or:			; use  of word as v1_kernel label
                                     0DAB       	
                            8B   D5  0DAB  2136 	tstl	(r11)+			; is first true?
                            08   12  0DAD  2137 	bneq	10$			; Yes
                            8B   D5  0DAF  2138 	tstl	(r11)+			; Is seconed true?
                            07   12  0DB1  2139 	bneq	20$			; Yes
                       7B   00   D0  0DB3  2140 	movl	#c_false,-(r11)		; Both false, leave with false on stack
                                 05  0DB6  2141 	rsb				; return
                                     0DB7  2142 10$:
                       5B   04   C0  0DB7  2143 	addl2	#4,r11			; pop second item off, don't need
                                     0DBA  2144 					;   to check
                                     0DBA  2145 20$:
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 100
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

              7B   FFFFFFFF 8F   D0  0DBA  2146 	movl	#c_true,-(r11)		; Yes, one or both true.  Leave with
                                     0DC1  2147 					;   true on stack.
                                 05  0DC1  2148 	rsb				; end of or
                                     0DC2  2149 
                                     0DC2  2150 
                                     0DC2  2151 ;+++
                                     0DC2  2152 ;k> over -- ( n1 n2 -- n1 n2 n1 ) Leave a copy of the second item on the stack.
                                     0DC2  2153 ;+++
                                     0DC2  2154 	header	over			; push copy of n1 on top of stack
                           00000DA4' 0DC2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000DC2  0DC6       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0DC6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DC6       	.if    le, nchr		; nchr <= 0
                     72 65 76 6F 00' 0DC6       	   .ascic \over\	; no auxillary , use principle one
                                 04  0DC6       
                                     0DCB       	.if_false		; else
                                     0DCB       	  .ascic \\		; use auxillary 
                                     0DCB       	.endc			; end if
                                     0DCB       over:			; use  of word as v1_kernel label
                                     0DCB       	
                    7B   04 AB   D0  0DCB  2155 	movl	4(r11),-(r11)
                                 05  0DCF  2156 	rsb				; end of over
                                     0DD0  2157 
                                     0DD0  2158 
                                     0DD0  2159 ;+++
                                     0DD0  2160 ;k> pad -- ( -- a ) Leave address of (edop + c_pad_moat) on stack.
                                     0DD0  2161 ;	This is a good area to use for temporary storage of such things
                                     0DD0  2162 ;	as strings.
                                     0DD0  2163 ;---
                                     0DD0  2164 	header	pad
                           00000DC2' 0DD0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000DD0  0DD4       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0DD4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DD4       	.if    le, nchr		; nchr <= 0
                        64 61 70 00' 0DD4       	   .ascic \pad\	; no auxillary , use principle one
                                 03  0DD4       
                                     0DD8       	.if_false		; else
                                     0DD8       	  .ascic \\		; use auxillary 
                                     0DD8       	.endc			; end if
                                     0DD8       pad:			; use  of word as v1_kernel label
                                     0DD8       	
         7B   00000109 8F   59   C1  0DD8  2165 	addl3	r9,#c_pad_moat,-(r11)	;
                                 05  0DE0  2166 	rsb				; end of pad
                                     0DE1  2167 
                                     0DE1  2168 
                                     0DE1  2169 ;+++
                                     0DE1  2170 ;k> putc -- ( c -- ) Output character `c'.
                                     0DE1  2171 ;---
                                     0DE1  2172 	header	putc
                           00000DD0' 0DE1       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000DE1  0DE5       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0DE5       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0DE5       	.if    le, nchr		; nchr <= 0
                     63 74 75 70 00' 0DE5       	   .ascic \putc\	; no auxillary , use principle one
                                 04  0DE5       
                                     0DEA       	.if_false		; else
                                     0DEA       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 101
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0DEA       	.endc			; end if
                                     0DEA       putc:			; use  of word as v1_kernel label
                                     0DEA       	
         00A0 8F   00001B98'EF   B1  0DEA  2173 	cmpw	v_outlen,#c_max_len	; is output buffer full?
                            04   19  0DF3  2174 	blss	10$			; no, go on
                       FA11 CF   16  0DF5  2175 	jsb	cr			; yes output it
                                     0DF9  2176 10$:
              50   00001B9A'EF   9E  0DF9  2177 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  0E00  2178 	movzwl	v_outlen,r1		; index into buffer
                       50   51   C0  0E07  2179 	addl2	r1,r0			; pointer to next available char
                       60   6B   90  0E0A  2180 	movb	(r11),(r0)		; move char into buffer
                       5B   04   C0  0E0D  2181 	addl2	#4,r11			; pop char off stack
                   00001B98'EF   B6  0E10  2182 	incw	v_outlen		; increment index (or length)
                                 05  0E16  2183 	rsb				; end of putc
                                     0E17  2184 
                                     0E17  2185 
                                     0E17  2186 ;+++
                                     0E17  2187 ;k> radix ( -- a ) leave address of system radix longword on stack.
                                     0E17  2188 ;---
                                     0E17  2189 	header	radix
                           00000DE1' 0E17       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000E17  0E1B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0E1B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E1B       	.if    le, nchr		; nchr <= 0
                  78 69 64 61 72 00' 0E1B       	   .ascic \radix\	; no auxillary , use principle one
                                 05  0E1B       
                                     0E21       	.if_false		; else
                                     0E21       	  .ascic \\		; use auxillary 
                                     0E21       	.endc			; end if
                                     0E21       radix:			; use  of word as v1_kernel label
                                     0E21       	
              7B   00001D4E'EF   DE  0E21  2190 	moval	v_radix,-(r11)		; leave address on dstack
                                 05  0E28  2191 	rsb				; end of radix
                                     0E29  2192 
                                     0E29  2193 
                                     0E29  2194 ;+++
                                     0E29  2195 ;k> read ( a -- ) return a byte-counted string from terminal at `a'
                                     0E29  2196 ;---
                                     0E29  2197 	header	read
                           00000E17' 0E29       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000E29  0E2D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0E2D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E2D       	.if    le, nchr		; nchr <= 0
                     64 61 65 72 00' 0E2D       	   .ascic \read\	; no auxillary , use principle one
                                 04  0E2D       
                                     0E32       	.if_false		; else
                                     0E32       	  .ascic \\		; use auxillary 
                                     0E32       	.endc			; end if
                                     0E32       read:			; use  of word as v1_kernel label
                                     0E32       	
              00001B92'EF   6B   D0  0E32  2198 	movl	(r11),v_readaddr	; v_readaddr = address to write to
                   00001B92'EF   D6  0E39  2199 	incl	v_readaddr		; allow for byte count before string
                   00001B8C'EF   3F  0E3F  2200 	pushaw	v_readlen		; where to put returned length
                                     0E45  2201 ; Is there any outstanding output?
                   00001B98'EF   B5  0E45  2202 	tstw   v_outlen			;
                            04   12  0E4B  2203 	bneq   10$			; yes~~~, branch to output prompt
                            00   DD  0E4D  2204 	pushl  #0			; omit prompt since no output
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 102
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                            1B   11  0E4F  2205 	brb    20$			; skip over prompting
                                     0E51  2206 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0E51  2207 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0E58  2208 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0E5F  2209 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                            5B   DD  0E67  2210 	pushl	r11			; put address of descriptor on rstack
                       5B   08   C0  0E69  2211 	addl2	#8,r11			; move stack ptr back over descriptor
                                     0E6C  2212 20$:
                   00001B8E'EF   7F  0E6C  2213 	pushaq	v_readdsc		; push address of descriptor
              00000000'GF   03   FB  0E72  2214 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0E79  2215 	isstrerr
              50   00000000'8F   D1  0E79       	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                            06   13  0E80       	beql	30000$		; yes, ignore and go on
                         03 50   E8  0E82       	blbs	r0,30000$		; no error, go on
                          0D45   31  0E85       	brw	_error_exit		; error, branch to error handler
                                     0E88       30000$:
                                     0E88       	
                                     0E88  2216 30$:
                   00001B98'EF   B4  0E88  2217 	clrw	v_outlen		; clean output length, since any
                                     0E8E  2218 					;   outstanding was just output
           00 BB   00001B8C'EF   33  0E8E  2219 	cvtwb	v_readlen,@(r11)	; save byte-count at address on stack
                       5B   04   C0  0E96  2220 	addl2	#4,r11			; pop address off stack
                                 05  0E99  2221 	rsb				; end of read
                                     0E9A  2222 
                                     0E9A  2223 
                                     0E9A  2224 ;+++t
                                     0E9A  2225 ;k> readstr ( a n -- ) Read line from terminal into word-counted string.
                                     0E9A  2226 ;	`a' is address of word-counted string.
                                     0E9A  2227 ;	'n' is maximum length.
                                     0E9A  2228 ;---
                                     0E9A  2229 	header	readstr
                           00000E29' 0E9A       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000E9A  0E9E       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0E9E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0E9E       	.if    le, nchr		; nchr <= 0
            72 74 73 64 61 65 72 00' 0E9E       	   .ascic \readstr\	; no auxillary , use principle one
                                 07  0E9E       
                                     0EA6       	.if_false		; else
                                     0EA6       	  .ascic \\		; use auxillary 
                                     0EA6       	.endc			; end if
                                     0EA6       readstr:			; use  of word as v1_kernel label
                                     0EA6       	
                         04 AB   DD  0EA6  2230 	pushl	4(r11)			; where to put returned length
                    04 AB   02   C0  0EA9  2231 	addl2	#2,4(r11)		; move pointer over length word
           02 AB   00001B96'EF   B0  0EAD  2232 	movw	v_static_dsc,2(r11)	; move middle of descriptor on dstack
                   00001B98'EF   B5  0EB5  2233 	tstw	v_outlen		; Is there any outstanding output?
                            04   12  0EBB  2234 	bneq	10$			; yes
                            00   DD  0EBD  2235 	pushl	#0			; omit prompt since no output
                            21   11  0EBF  2236 	brb	20$			; skip over prompting
                                     0EC1  2237 10$:					; yes, construct a descriptor on stack
              7B   00001B9A'EF   9E  0EC1  2238 	movab	v_outbuf,-(r11)		; put address of buffer on stack
              7B   00001B98'EF   3C  0EC8  2239 	movzwl	v_outlen,-(r11)		; move count on stack
           02 AB   00001B96'EF   B0  0ECF  2240 	movw	v_static_dsc,2(r11)	; move middle of descriptor on stack
                   00001B98'EF   B4  0ED7  2241 	clrw	v_outlen		; clear output length, since any
                                     0EDD  2242 					;   outstanding will be saved.
                            5B   DD  0EDD  2243 	pushl	r11			; put addrss of descriptor on rstack
                       5B   08   C0  0EDF  2244 	addl2	#8,r11			; move stack ptr back over descriptor
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 103
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0EE2  2245 20$:
                            5B   DD  0EE2  2246 	pushl	r11			; push address of descriptor
              00000000'GF   03   FB  0EE4  2247 	calls	#3,g^lib$get_input	; get a line from terminal
                                     0EEB  2248 	isstrerr
              50   00000000'8F   D1  0EEB       	cmpl	#lib$_inpstrtru,r0	; string truncation on error?
                            06   13  0EF2       	beql	30001$		; yes, ignore and go on
                         03 50   E8  0EF4       	blbs	r0,30001$		; no error, go on
                          0CD3   31  0EF7       	brw	_error_exit		; error, branch to error handler
                                     0EFA       30001$:
                                     0EFA       	
                       5B   08   C0  0EFA  2249 	addl2	#8,r11			; pop arguments
                                 05  0EFD  2250 	rsb				; end of readstr
                                     0EFE  2251 
                                     0EFE  2252 
                                     0EFE  2253 ;+++
                                     0EFE  2254 ;k> restart -- ( -- ) Restart VTIL, patching it to run again.
                                     0EFE  2255 ;	Used in cases of error.  Never RETURNs.
                                     0EFE  2256 ;---
                                     0EFE  2257 	header	restart
                           00000E9A' 0EFE       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000EFE  0F02       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0F02       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F02       	.if    le, nchr		; nchr <= 0
            74 72 61 74 73 65 72 00' 0F02       	   .ascic \restart\	; no auxillary , use principle one
                                 07  0F02       
                                     0F0A       	.if_false		; else
                                     0F0A       	  .ascic \\		; use auxillary 
                                     0F0A       	.endc			; end if
                                     0F0A       restart:			; use  of word as v1_kernel label
                                     0F0A       	
                          0B3A   31  0F0A  2258 	brw	r_warm_start		; patch it
                                     0F0D  2259 					; end of restart
                                     0F0D  2260 
                                     0F0D  2261 
                                     0F0D  2262 ;+++
                                     0F0D  2263 ;k> s! -- ( n a -- ) Store a short integer (first 16 bits of `n' at `a'.~~~ `n' should be a `s'.
                                     0F0D  2264 ;---
                                     0F0D  2265 	header	i_word_store,<s!>
                           00000EFE' 0F0D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000F0D  0F11       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0F11       	.nchr  nchr, ^\s!\	; nchr = length( s! )
                           00000002  0F11       	.if    le, nchr		; nchr <= 0
                                     0F11       	   .ascic \i_word_store\	; no auxillary s!, use principle one
                                     0F11       	.if_false		; else
                           21 73 00' 0F11       	  .ascic \s!\		; use auxillary s!
                                 02  0F11       
                                     0F14       	.endc			; end if
                                     0F14       i_word_store:			; use s! of word as v1_kernel label
                                     0F14       	
                 00 BB   04 AB   B0  0F14  2266 	movw	4(r11),@(r11)		; store the first 16 bits
                       5B   08   C0  0F19  2267 	addl2	#8,r11			; pop arguments
                                 05  0F1C  2268 	rsb				; end of s!
                                     0F1D  2269 
                                     0F1D  2270 
                                     0F1D  2271 ;+++
                                     0F1D  2272 ;k> s, -- ( s -- ) Store low word of `s' in dictinary.
                                     0F1D  2273 ;---
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 104
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0F1D  2274 	header	i_w_comma,<s,>
                           00000F0D' 0F1D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000F1D  0F21       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0F21       	.nchr  nchr, ^\s,\	; nchr = length( s, )
                           00000002  0F21       	.if    le, nchr		; nchr <= 0
                                     0F21       	   .ascic \i_w_comma\	; no auxillary s,, use principle one
                                     0F21       	.if_false		; else
                           2C 73 00' 0F21       	  .ascic \s,\		; use auxillary s,
                                 02  0F21       
                                     0F24       	.endc			; end if
                                     0F24       i_w_comma:			; use s, of word as v1_kernel label
                                     0F24       	
                       89   6B   B0  0F24  2275 	movw	(r11),(r9)+		; store short in dictinary
                       5B   08   C0  0F27  2276 	addl2	#8,r11			; pop arguments
                                 05  0F2A  2277 	rsb				; end of s,
                                     0F2B  2278 
                                     0F2B  2279 
                                     0F2B  2280 ;+++
                                     0F2B  2281 ;k> s@ -- ( a -- n ) Fetch 16 bits from `a' and zero-extend to longword.
                                     0F2B  2282 ;---
                                     0F2B  2283 	header	i_word_fetch,<s@>
                           00000F1D' 0F2B       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000F2B  0F2F       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000002  0F2F       	.nchr  nchr, ^\s@\	; nchr = length( s@ )
                           00000002  0F2F       	.if    le, nchr		; nchr <= 0
                                     0F2F       	   .ascic \i_word_fetch\	; no auxillary s@, use principle one
                                     0F2F       	.if_false		; else
                           40 73 00' 0F2F       	  .ascic \s@\		; use auxillary s@
                                 02  0F2F       
                                     0F32       	.endc			; end if
                                     0F32       i_word_fetch:			; use s@ of word as v1_kernel label
                                     0F32       	
                    6B   00 BB   3C  0F32  2284 	movzwl	@(r11),(r11)		; get contents
                                 05  0F36  2285 	rsb				; end of s@
                                     0F37  2286 
                                     0F37  2287 
                                     0F37  2288 ;+++
                                     0F37  2289 ;k> ss@ -- ( a -- n ) Fetch short at `a' and sign extend it to longword.
                                     0F37  2290 ;---
                                     0F37  2291 	header	i_ws_fetch,<ss@>
                           00000F2B' 0F37       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000F37  0F3B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  0F3B       	.nchr  nchr, ^\ss@\	; nchr = length( ss@ )
                           00000003  0F3B       	.if    le, nchr		; nchr <= 0
                                     0F3B       	   .ascic \i_ws_fetch\	; no auxillary ss@, use principle one
                                     0F3B       	.if_false		; else
                        40 73 73 00' 0F3B       	  .ascic \ss@\		; use auxillary ss@
                                 03  0F3B       
                                     0F3F       	.endc			; end if
                                     0F3F       i_ws_fetch:			; use ss@ of word as v1_kernel label
                                     0F3F       	
                    6B   00 BB   32  0F3F  2292 	cvtwl	@(r11),(r11)		; get contents, sign extend it
                                 05  0F43  2293 	rsb				; end of ss@
                                     0F44  2294 
                                     0F44  2295 
                                     0F44  2296 ;+++
                                     0F44  2297 ;k> save-buffers -- ( -- ) Write all modified buffers and mark them unmodified.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 105
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     0F44  2298 ;---
                                     0F44  2299 	header	i_save_buffers,<save-buffers>
                           00000F37' 0F44       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000F44  0F48       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           0000000C  0F48       	.nchr  nchr, ^\save-buffers\	; nchr = length( save-buffers )
                           0000000C  0F48       	.if    le, nchr		; nchr <= 0
                                     0F48       	   .ascic \i_save_buffers\	; no auxillary save-buffers, use principle one
                                     0F48       	.if_false		; else
72 65 66 66 75 62 2D 65 76 61 73 00' 0F48       	  .ascic \save-buffers\		; use auxillary save-buffers
                                 73  0F54       
                                 0C  0F48       
                                     0F55       	.endc			; end if
                                     0F55       i_save_buffers:			; use save-buffers of word as v1_kernel label
                                     0F55       	
                            50   D4  0F55  2300 	clrl	r0			; buffer number
                                     0F57  2301 10$:
                            02   91  0F57  2302 	cmpb	#c_modified,-		; Has the buffer
                       1B7D'C0       0F59  2303 		v_buf_inuse(r0)		;   been modified? ~~~ Why not [r0]?
                            12   12  0F5C  2304 	bneq	20$			; no, skip it
                       7A   50   D0  0F5E  2305 	movl	r0,-(r10)		; save the buffer number
                       7B   50   D0  0F61  2306 	movl	r0,-(r11)		; set up for buffer-write
                       F78C CF   16  0F64  2307 	jsb	i_buffer_write		; write the buffer
                       50   8A   D0  0F68  2308 	movl	(r10)+,r0		; get the buffer number back
                            01   90  0F6B  2309 	movb	#c_inuse,-		; mark the buffer as
                       1B7D'C0       0F6D  2310 		v_buf_inuse(r0)		;   in use, but not modified.
                                     0F70  2311 20$:
                            02   F1  0F70  2312 	acbl	#c_max_blocks-1,-	; buffer # is in [0 .. c_max_blocks-1]
                  FFE1 50   01       0F72  2313 		#1,r0,10$		; move to next buffer number, if any
                                 05  0F76  2314 	rsb				; end of save-buffers
                                     0F77  2315 
                                     0F77  2316 
                                     0F77  2317 ;+++t
                                     0F77  2318 ;k> search -- ( a1 -- a2 ? f )  Search vocabulary at `a1' for a match with
                                     0F77  2319 ;	byte-counted string at eodp.  Return  ( false ) if not found, or
                                     0F77  2320 ;	( addr true ) if found.
                                     0F77  2321 ;---
                                     0F77  2322 	header	search
                           00000F44' 0F77       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000F77  0F7B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0F7B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0F7B       	.if    le, nchr		; nchr <= 0
               68 63 72 61 65 73 00' 0F7B       	   .ascic \search\	; no auxillary , use principle one
                                 06  0F7B       
                                     0F82       	.if_false		; else
                                     0F82       	  .ascic \\		; use auxillary 
                                     0F82       	.endc			; end if
                                     0F82       search:			; use  of word as v1_kernel label
                                     0F82       	
                            6B   D5  0F82  2323 	tstl	(r11)			; Is it nil pointer on top of stack?
                            29   13  0F84  2324 	beql	10$			; yes, stop search, leave false on stack
                  56   6B   04   C1  0F86  2325 	addl3	#4,(r11),r6		; r6 = Address of byte-count
                       69   66   91  0F8A  2326 	cmpb	(r6),(r9)		; no, ?equal length
                            1A   12  0F8D  2327 	bneq	20$			; no
                       56   69   99  0F8F  2328 	cvtbw	(r9),r6			; yes, get string length
                  57   6B   05   C1  0F92  2329 	addl3	#5,(r11),r7		; get address of word name
                  58   59   01   C1  0F96  2330 	addl3	#1,r9,r8		; get address of token
                  68   67   56   29  0F9A  2331 	cmpc3	r6,(r7),(r8)		; compare strings
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 106
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                            09   12  0F9E  2332 	bneq	20$			; strings don't match
                                     0FA0  2333 ; string match
              7B   FFFFFFFF 8F   D0  0FA0  2334 	movl	#c_true,-(r11)		; move true to top of stack
                            06   11  0FA7  2335 	brb	10$			; exit leaving ( addr true ) on dstack.
                                     0FA9  2336 20$:
                    6B   00 BB   D0  0FA9  2337 	movl	@(r11),(r11)		; get address of next word
                            D3   11  0FAD  2338 	brb	search			; try it again
                                     0FAF  2339 10$:
                                 05  0FAF  2340 	rsb				; end of search
                                     0FB0  2341 
                                     0FB0  2342 
                                     0FB0  2343 ;+++
                                     0FB0  2344 ;k> short -- ( n -- ) Create a word that pushed the address of two bytes
                                     0FB0  2345 ;	(a VAX memory `word') on the stack, reserves space in the dictionary
                                     0FB0  2346 ;	for those two bytes, and initializes it to the value of `n'.
                                     0FB0  2347 ;---
                                     0FB0  2348 	header	i_short,<short>
                           00000F77' 0FB0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000FB0  0FB4       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000005  0FB4       	.nchr  nchr, ^\short\	; nchr = length( short )
                           00000005  0FB4       	.if    le, nchr		; nchr <= 0
                                     0FB4       	   .ascic \i_short\	; no auxillary short, use principle one
                                     0FB4       	.if_false		; else
                  74 72 6F 68 73 00' 0FB4       	  .ascic \short\		; use auxillary short
                                 05  0FB4       
                                     0FBA       	.endc			; end if
                                     0FBA       i_short:			; use short of word as v1_kernel label
                                     0FBA       	
                       F880 CF   16  0FBA  2349 	jsb	create			; enclose next token in dictionary
                       89   3E   90  0FBE  2350 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  0FC1  2351 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   02   90  0FC5  2352 	movb	#2,(r9)+		; (pc+2)
                    89   7B 8F   90  0FC8  2353 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  0FCC  2354 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  0FCF  2355 	movw	(r11),(r9)+		; move top of stack into dictionary
                       5B   04   C0  0FD2  2356 	addl2	#4,r11			; pop aruments
                                 05  0FD5  2357 	rsb				; end of short
                                     0FD6  2358 
                                     0FD6  2359 
                                     0FD6  2360 ;+++
                                     0FD6  2361 ;k> sign -- ( n -- ) Output minus in pictured numeric if top of stack is < 0.
                                     0FD6  2362 ;---
                                     0FD6  2363 	header	sign
                           00000FB0' 0FD6       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000FD6  0FDA       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0FDA       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0FDA       	.if    le, nchr		; nchr <= 0
                     6E 67 69 73 00' 0FDA       	   .ascic \sign\	; no auxillary , use principle one
                                 04  0FDA       
                                     0FDF       	.if_false		; else
                                     0FDF       	  .ascic \\		; use auxillary 
                                     0FDF       	.endc			; end if
                                     0FDF       sign:			; use  of word as v1_kernel label
                                     0FDF       	
                            8B   D5  0FDF  2364 	tstl	(r11)+			; tos < 0?
                            07   18  0FE1  2365 	bgeq	10$			; no, exit
                       7B   2D   D0  0FE3  2366 	movl	#^a\-\,-(r11)		; put ascii for minus sign on stack
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 107
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       FB25 CF   16  0FE6  2367 	jsb	hold			; put it in output string
                                     0FEA  2368 10$:
                                 05  0FEA  2369 	rsb				; end of sign
                                     0FEB  2370 
                                     0FEB  2371 
                                     0FEB  2372 ;+++
                                     0FEB  2373 ;k> smudge -- ( -- ) Sets the smudge (high) bit in the length byte as the word
                                     0FEB  2374 ;	that is currently being defined won't be found in itself.
                                     0FEB  2375 ;---
                                     0FEB  2376 	header	smudge
                           00000FD6' 0FEB       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00000FEB  0FEF       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  0FEF       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  0FEF       	.if    le, nchr		; nchr <= 0
               65 67 64 75 6D 73 00' 0FEF       	   .ascic \smudge\	; no auxillary , use principle one
                                 06  0FEF       
                                     0FF6       	.if_false		; else
                                     0FF6       	  .ascic \\		; use auxillary 
                                     0FF6       	.endc			; end if
                                     0FF6       smudge:			; use  of word as v1_kernel label
                                     0FF6       	
              50   00001D3B'FF   D0  0FF6  2377 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  0FFD  2378 	addl2	#4,r0			; move over link field
                    60   40 8F   88  1000  2379 	bisb2	#^b1000000,(r0)		; set smudge bit
                                 05  1004  2380 	rsb				; end of smudge
                                     1005  2381 
                                     1005  2382 
                                     1005  2383 ;+++
                                     1005  2384 ;k> sp@ -- ( -- l ) Returns the address of the top fo the data stack before
                                     1005  2385 ;	{ sp@ } is executed.
                                     1005  2386 ;---
                                     1005  2387 	header	i_sp_fetch,<sp@>
                           00000FEB' 1005       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001005  1009       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  1009       	.nchr  nchr, ^\sp@\	; nchr = length( sp@ )
                           00000003  1009       	.if    le, nchr		; nchr <= 0
                                     1009       	   .ascic \i_sp_fetch\	; no auxillary sp@, use principle one
                                     1009       	.if_false		; else
                        40 70 73 00' 1009       	  .ascic \sp@\		; use auxillary sp@
                                 03  1009       
                                     100D       	.endc			; end if
                                     100D       i_sp_fetch:			; use sp@ of word as v1_kernel label
                                     100D       	
                       7B   5B   D0  100D  2388 	movl	r11,-(r11)		; put address of top of stack on stack
                                 05  1010  2389 	rsb				; end of sp@
                                     1011  2390 
                                     1011  2391 
                                     1011  2392 ;+++
                                     1011  2393 ;k> sp0 -- ( -- l ) Returns the address of the bottom of the data stack.
                                     1011  2394 ;	Note that the stack grows downward, so this is actually the
                                     1011  2395 ;	top in memory of the data-stack structure's space.
                                     1011  2396 ;___
                                     1011  2397 	header	i_sp_0,<sp0>
                           00001005' 1011       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001011  1015       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000003  1015       	.nchr  nchr, ^\sp0\	; nchr = length( sp0 )
                           00000003  1015       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 108
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1015       	   .ascic \i_sp_0\	; no auxillary sp0, use principle one
                                     1015       	.if_false		; else
                        30 70 73 00' 1015       	  .ascic \sp0\		; use auxillary sp0
                                 03  1015       
                                     1019       	.endc			; end if
                                     1019       i_sp_0:			; use sp0 of word as v1_kernel label
                                     1019       	
              7B   00001000'EF   DE  1019  2398 	moval	c_ds_start,-(r11)	; put address on stack
                                 05  1020  2399 	rsb				; end of sp0
                                     1021  2400 
                                     1021  2401 
                                     1021  2402 ;+++
                                     1021  2403 ;k> space -- ( -- ) Output a space to terminal.
                                     1021  2404 ;---
                                     1021  2405 	header	space
                           00001011' 1021       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001021  1025       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  1025       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1025       	.if    le, nchr		; nchr <= 0
                  65 63 61 70 73 00' 1025       	   .ascic \space\	; no auxillary , use principle one
                                 05  1025       
                                     102B       	.if_false		; else
                                     102B       	  .ascic \\		; use auxillary 
                                     102B       	.endc			; end if
                                     102B       space:			; use  of word as v1_kernel label
                                     102B       	
         00A0 8F   00001B98'EF   B1  102B  2406 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            04   19  1034  2407 	blss	10$			; no, go on
                       F7D0 CF   16  1036  2408 	jsb	cr			; yes, output it
                                     103A  2409 10$:
              50   00001B9A'EF   9E  103A  2410 	movab	v_outbuf,r0		; pointer to start of buffer
              51   00001B98'EF   3C  1041  2411 	movzwl	v_outlen,r1		; index into buffer
              00000028'EF   51   C0  1048  2412 	addl2	r1,40			; pointer to next available buffer
                       60   20   90  104F  2413 	movb	#c_blank,(r0)		; move char into buffer
                   00001B98'EF   B6  1052  2414 	incw	v_outlen		; increment index (or length)
                                 05  1058  2415 	rsb				; end of space
                                     1059  2416 
                                     1059  2417 
                                     1059  2418 ;+++
                                     1059  2419 ;,> spaces -- ( n -- ) Output `n' spaces to terminal
                                     1059  2420 ;---
                                     1059  2421 	header	spaces
                           00001021' 1059       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001059  105D       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  105D       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  105D       	.if    le, nchr		; nchr <= 0
               73 65 63 61 70 73 00' 105D       	   .ascic \spaces\	; no auxillary , use principle one
                                 06  105D       
                                     1064       	.if_false		; else
                                     1064       	  .ascic \\		; use auxillary 
                                     1064       	.endc			; end if
                                     1064       spaces:			; use  of word as v1_kernel label
                                     1064       	
                            6B   D5  1064  2422 	tstl	(r11)			; Is it less than or equal to zero?
                            0E   15  1066  2423 	bleq	100$			; yes, exit
                       7B   01   D0  1068  2424 	movl	#1,-(r11)		; no, save space on stack for index
                                     106B  2425 10$:
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 109
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                         BD AF   16  106B  2426 	jsb	space			; output one space
                 F8 6B   04 AB   F2  106E  2427 	aoblss	4(r11),(r11),10$	; (r11) += 1, repeat if (r11) < 4(r11)
                       5B   04   C0  1073  2428 	addl2	#4,r11			; pop index
                                     1076  2429 100$:
                       5B   04   C0  1076  2430 	addl2	#4,r11			; pop argument
                                 05  1079  2431 	rsb				; end of spaces
                                     107A  2432 
                                     107A  2433 
                                     107A  2434 ;+++t
                                     107A  2435 ;k> sread ( -- ) Read a line from terminal or file into input stream,
                                     107A  2436 ;	depending on value of { infile }.  if { infile } is true, read
                                     107A  2437 ;	from file; otherwise, read from terminal.
                                     107A  2438 ;---
                                     107A  2439 	header	sread
                           00001059' 107A       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000107A  107E       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  107E       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  107E       	.if    le, nchr		; nchr <= 0
                  64 61 65 72 73 00' 107E       	   .ascic \sread\	; no auxillary , use principle one
                                 05  107E       
                                     1084       	.if_false		; else
                                     1084       	  .ascic \\		; use auxillary 
                                     1084       	.endc			; end if
                                     1084       sread:			; use  of word as v1_kernel label
                                     1084       	
                   00001B98'EF   B5  1084  2440 	tstw	v_outlen		; Is there any outstanding output?
                            04   13  108A  2441 	beql	5$			; no
                       F77A CF   16  108C  2442 	jsb	cr			; yes, output it
                                     1090  2443 5$:
     0000199B'EF   000018F7'EF   DE  1090  2444 	moval	v_inbuf,v_inptr		; start at beginning of line
                   00001D47'EF   95  109B  2445 	tstb	v_infile		; getting input from file?
                            37   12  10A1  2446 	bneq	10$			; yes, go do it
                                     10A3  2447 ; no, get from terminal
                   00001999'EF   3F  10A3  2448 	pushaw	v_inlen			; save returned length
                   0000182A'EF   7F  10A9  2449 	pushaq	v_vtilprompt		; use vtil prompt
                   0000199F'EF   7F  10AF  2450 	pushaq	v_in_dsc		; address of input descriptor
              00000000'GF   03   FB  10B5  2451 	calls	#3,g^lib$get_input	; get a line from terminal
                         0F 50   E8  10BC  2452 	blbs	r0,8$			; no error, go on
              50   00000000'8F   D1  10BF  2453 	cmpl	#rms$_eof,r0		; Is it eof from terminal?
                            03   12  10C6  2454 	bneq	7$			; no, go die messily
                          0B35   31  10C8  2455 	brw	_exit			; yes, exit silently
                                     10CB  2456 7$:
                          0AFF   31  10CB  2457 	brw	_error_exit		; die messily
                                     10CE  2458 8$:
     00001997'EF   00001999'EF   B0  10CE  2459 	movw	v_inlen,v_org_inlen	; save original length
                                 05  10D9  2460 	rsb				; success read from terminal, return
                                     10DA  2461 10$:
                                     10DA  2462 	$get	rab=v_inrab		; get a record
                                     10DA       		$RMSCALL	GET,v_inrab,,
                                     10DA       	.GLOBL	SYS$GET
                                     10DA       	.IF	B <v_inrab>
                                     10DA       	CALLG	(AP),G^SYS$GET
                                     10DA       	$$.TMP=0
                                     10DA       	.IF	NB <>
                                     10DA       	$$.TMP=1
                                     10DA       	.ENDC
                                     10DA       	.IF	NB <>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 110
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     10DA       	$$.TMP=1
                                     10DA       	.ENDC
                                     10DA       	.IF	NE $$.TMP
                                     10DA       	.ERROR				; v_inrab= parameter missing;
                                     10DA       	.ENDC
                                     10DA       	.ENDC
                                     10DA       	.IF	NB <v_inrab>
                           00000001  10DA       	$$.TMP1=1
                                     10DA       	.IF	NB <>
                                     10DA       	PUSHAL	
                                     10DA       	$$.TMP1=3
                                     10DA       	.ENDC
                                     10DA       	.IF	NB <>
                                     10DA       	PUSHAL	
                                     10DA       	.IF	EQ <$$.TMP1-1>
                                     10DA       	$$.TMP1=2
                                     10DA       	.ENDC
                                     10DA       	.IFF
                           FFFFFFFE  10DA       	.IF	EQ <$$.TMP1-3>
                                     10DA       	PUSHL	#0
                                     10DA       	.ENDC
                                     10DA       	.ENDC
                           000000CF  10DA       	.NTYPE	$$.TMP2,v_inrab
                           00000070  10DA       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     10DA       	PUSHL	v_inrab
                                     10DA       	.IFF
                           000000B0  10DA       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     10DA       	PUSHL	v_inrab
                                     10DA       	.IFF
                   000019F8'EF   DF  10DA       	PUSHAL	v_inrab
                                     10E0       	.ENDC
                                     10E0       	.ENDC
              00000000'GF   01   FB  10E0       	CALLS	#$$.TMP1,G^SYS$GET
                                     10E7       	.ENDC
                                     10E7       	
                                     10E7       	
                         13 50   E8  10E7  2463 	blbs	r0,20$			; write the record
              00000000'8F   50   D1  10EA  2464 	cmpl	r0,#rms$_eof		; was error end-of-file
                            27   13  10F1  2465 	beql	30$			; successful completion
                                     10F3  2466 ; error otherwize
              56   000019F8'EF   DE  10F3  2467 	moval	v_inrab,r6		; keep rab address
                          0AE9   31  10FA  2468 	brw	_r_err			; signal record error
                                     10FD  2469 20$:
                   00001A1A'EF   B0  10FD  2470 	movw	v_inrab+rab$w_rsz,-	; input rab set record size
                   00001999'EF       1103  2471 		v_inlen
                   00001A1A'EF   B0  1108  2472 	movw	v_inrab+rab$w_rsz,-
                   00001997'EF       110E  2473 		v_org_inlen
                   00001D48'EF   D6  1113  2474 	incl	v_filelinenum		; increment line number in file
                                 05  1119  2475 	rsb				; success read from file, return
                                     111A  2476 30$:
                                     111A  2477 	$close	fab=v_infab		; close input
                                     111A       		$RMSCALL	CLOSE,v_infab,,
                                     111A       	.GLOBL	SYS$CLOSE
                                     111A       	.IF	B <v_infab>
                                     111A       	CALLG	(AP),G^SYS$CLOSE
                                     111A       	$$.TMP=0
                                     111A       	.IF	NB <>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 111
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     111A       	$$.TMP=1
                                     111A       	.ENDC
                                     111A       	.IF	NB <>
                                     111A       	$$.TMP=1
                                     111A       	.ENDC
                                     111A       	.IF	NE $$.TMP
                                     111A       	.ERROR				; v_infab= parameter missing;
                                     111A       	.ENDC
                                     111A       	.ENDC
                                     111A       	.IF	NB <v_infab>
                           00000001  111A       	$$.TMP1=1
                                     111A       	.IF	NB <>
                                     111A       	PUSHAL	
                                     111A       	$$.TMP1=3
                                     111A       	.ENDC
                                     111A       	.IF	NB <>
                                     111A       	PUSHAL	
                                     111A       	.IF	EQ <$$.TMP1-1>
                                     111A       	$$.TMP1=2
                                     111A       	.ENDC
                                     111A       	.IFF
                           FFFFFFFE  111A       	.IF	EQ <$$.TMP1-3>
                                     111A       	PUSHL	#0
                                     111A       	.ENDC
                                     111A       	.ENDC
                           000000CF  111A       	.NTYPE	$$.TMP2,v_infab
                           00000070  111A       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     111A       	PUSHL	v_infab
                                     111A       	.IFF
                           000000B0  111A       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     111A       	PUSHL	v_infab
                                     111A       	.IFF
                   000019A8'EF   DF  111A       	PUSHAL	v_infab
                                     1120       	.ENDC
                                     1120       	.ENDC
              00000000'GF   01   FB  1120       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     1127       	.ENDC
                                     1127       	
                                     1127       	
              00001D47'EF   00   90  1127  2478 	movb	#c_false,v_infile	; set v_infile flag false
              00001D48'EF   00   D0  112E  2479 	movl	#0,v_filelinenum	; zero file line as well
                                 05  1135  2480 	rsb				; end of sread
                                     1136  2481 
                                     1136  2482 
                                     1136  2483 ;+++
                                     1136  2484 ;k> strcat -- ( a1 a2 -- ) Catenate string at `a`' to string at `a2'.
                                     1136  2485 ;	Works only with strings defined by { string } or { string" }
                                     1136  2486 ;	since it uses maxlen of string at `a2'.
                                     1136  2487 ;---
                                     1136  2488 	header	strcat
                           0000107A' 1136       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001136  113A       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  113A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  113A       	.if    le, nchr		; nchr <= 0
               74 61 63 72 74 73 00' 113A       	   .ascic \strcat\	; no auxillary , use principle one
                                 06  113A       
                                     1141       	.if_false		; else
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 112
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1141       	  .ascic \\		; use auxillary 
                                     1141       	.endc			; end if
                                     1141       strcat:			; use  of word as v1_kernel label
                                     1141       	
                    50   04 BB   3C  1141  2489 	movzwl	@4(r11),r0		; length of src
                    57   00 BB   3C  1145  2490 	movzwl	@(r11),r7		; length of dest
               53   04 AB   02   C1  1149  2491 	addl3	#2,4(r11),r3		; address of src characters
                       52   6B   D0  114E  2492 	movl	(r11),r2		; address of dest
                  54   52   02   C3  1151  2493 	subl3	#2,r2,r4		; address of maxlen of dest
                  52   52   02   C1  1155  2494 	addl3	#2,r2,r2		; address of dest char
                       55   64   3C  1159  2495 	movzwl	(r4),r5			; maxlen of dest
                  56   55   57   C3  115C  2496 	subl3	r7,r5,r6		; space available in dest
                       50   56   D1  1160  2497 	cmpl	r6,r0			; less space available than to copy
                            03   15  1163  2498 	bleq	10$			; yes, use space available in dest as len
                       56   50   D0  1165  2499 	movl	r0,r6			; no, move all characters in src
                                     1168  2500 10$:
                       52   57   C0  1168  2501 	addl2	r7,r2			; start at end of dest chars
                  62   63   56   28  116B  2502 	movc3	r6,(r3),(r2)		; copy the string
                    00 BB   56   A0  116F  2503 	addw2	r6,@(r11)		; store the new length
                       5B   08   C0  1173  2504 	addl2	#8,r11			; pop arguments
                                 05  1176  2505 	rsb				; end of strcat
                                     1177  2506 
                                     1177  2507 
                                     1177  2508 ;+++
                                     1177  2509 ;k> strcmp -- ( a1 a2 -- n ) Compare word-counted strings.
                                     1177  2510 ;	Return 0 if string at `a`' = string at `a2'.
                                     1177  2511 ;	Return >0 if string at `a`' > string at `a2'.
                                     1177  2512 ;	Return <0 if string at `a1' < string at `a2'.
                                     1177  2513 ;---
                                     1177  2514 	header	strcmp
                           00001136' 1177       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001177  117B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  117B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  117B       	.if    le, nchr		; nchr <= 0
               70 6D 63 72 74 73 00' 117B       	   .ascic \strcmp\	; no auxillary , use principle one
                                 06  117B       
                                     1182       	.if_false		; else
                                     1182       	  .ascic \\		; use auxillary 
                                     1182       	.endc			; end if
                                     1182       strcmp:			; use  of word as v1_kernel label
                                     1182       	
                    50   04 BB   3C  1182  2515 	movzwl	@4(r11),r0		; length of str1
               51   04 AB   02   C1  1186  2516 	addl3	#2,4(r11),r1		; address of chars in str1
                    52   00 BB   3C  118B  2517 	movzwl	@(r11),r2		; length of str2
                  53   6B   02   C1  118F  2518 	addl3	#2,(r11),r3		; address of chars in str2
                       5B   08   C0  1193  2519 	addl2	#8,r11			; pop top two stack items
        63   52   00   61   50   2D  1196  2520 	cmpc5	r0,(r1),#0,r2,(r3)	; compare chars with 0 fill
                            0A   13  119C  2521 	beql	10$			; str1 = str2
                            0C   14  119E  2522 	bgtr	20$			; str1 > str2
              7B   FFFFFFFF 8F   D0  11A0  2523 	movl	#-1,-(r11)		; str1 < str2
                                 05  11A7  2524 	rsb				; exit
                                     11A8  2525 10$:
                       7B   00   D0  11A8  2526 	movl	#0,-(r11)		; str1 = str2
                                 05  11AB  2527 	rsb				; exit
                                     11AC  2528 20$:
                       7B   01   D0  11AC  2529 	movl	#1,-(r11)		; str1 > str2
                                 05  11AF  2530 	rsb				; end of strcmp
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 113
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     11B0  2531 
                                     11B0  2532 
                                     11B0  2533 ;+++
                                     11B0  2534 ;k> strcpy -- ( a1 a2 -- ) copy word counted string at `a1' to w-string at `a2'.
                                     11B0  2535 ;	Both must be word-counted, and string at `a2' must have maxlen 2bytes
                                     11B0  2536 ;	(i.e., defined by { string } or { string" }).
                                     11B0  2537 ;---
                                     11B0  2538 	header	strcpy
                           00001177' 11B0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000011B0  11B4       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  11B4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  11B4       	.if    le, nchr		; nchr <= 0
               79 70 63 72 74 73 00' 11B4       	   .ascic \strcpy\	; no auxillary , use principle one
                                 06  11B4       
                                     11BB       	.if_false		; else
                                     11BB       	  .ascic \\		; use auxillary 
                                     11BB       	.endc			; end if
                                     11BB       strcpy:			; use  of word as v1_kernel label
                                     11BB       	
                       50   6B   D0  11BB  2539 	movl	(r11),r0		; get address of destination
                    51   04 AB   D0  11BE  2540 	movl	4(r11),r1		; get address of source
                       56   61   3C  11C2  2541 	movzwl	(r1),r6			; length of source
                  52   50   02   C3  11C5  2542 	subl3	#2,r0,r2		; address of destination max len
                       52   62   3C  11C9  2543 	movzwl	(r2),r2			; dest max len
                       56   52   D1  11CC  2544 	cmpl	r2,r6			; max len < source len?
                            03   18  11CF  2545 	bgeq	10$			; no
                       56   52   D0  11D1  2546 	movl	r2,r6			; yes, use max len for src len
                                     11D4  2547 10$:
            02 A0   02 AB   56   28  11D4  2548 	movc3	r6,2(r11),2(r0)		; move the strings
                    00 BB   56   B0  11DA  2549 	movw	r6,@(r11)		; save the new length of dest
                       5B   08   C0  11DE  2550 	addl2	#8,r11			; pop arguments
                                 05  11E1  2551 	rsb				; end of strcpy
                                     11E2  2552 
                                     11E2  2553 
                                     11E2  2554 ;+++
                                     11E2  2555 ;k> string -- ( n -- ) Create a string variable with maximum length of `n'.
                                     11E2  2556 ;	The first 2 bytes of the string contains its length.
                                     11E2  2557 ;	The 2 bytes previous to the string contains its maximum length.
                                     11E2  2558 ;---
                                     11E2  2559 	header	string,<string>
                           000011B0' 11E2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000011E2  11E6       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000006  11E6       	.nchr  nchr, ^\string\	; nchr = length( string )
                           00000006  11E6       	.if    le, nchr		; nchr <= 0
                                     11E6       	   .ascic \string\	; no auxillary string, use principle one
                                     11E6       	.if_false		; else
               67 6E 69 72 74 73 00' 11E6       	  .ascic \string\		; use auxillary string
                                 06  11E6       
                                     11ED       	.endc			; end if
                                     11ED       string:			; use string of word as v1_kernel label
                                     11ED       	
                       F64D CF   16  11ED  2560 	jsb	create			; make the header
                       89   3E   90  11F1  2561 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  11F4  2562 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  11F8  2563 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  11FB  2564 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  11FF  2565 	movb	#op_rsb,(r9)+		; rsb
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 114
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       89   6B   B0  1202  2566 	movw	(r11),(r9)+		; maximum length
                       89   00   B0  1205  2567 	movw	#0,(r9)+		; make high byte of current count
                       59   8B   C0  1208  2568 	addl2	(r11)+,r9		; save space for characters
                                 05  120B  2569 	rsb				; end of string
                                     120C  2570 
                                     120C  2571 
                                     120C  2572 ;+++
                                     120C  2573 ;k> string" -- ( n -- ) Create a string variable with maximum length of `n',
                                     120C  2574 ;	and initialize with string from input stream up until next `"'.
                                     120C  2575 ;	The first 2 bytes of the string contain its length.
                                     120C  2576 ;	The 2 bytes previous to the string contains its maximum length.
                                     120C  2577 ;---
                                     120C  2578 	header	i_string_quote,<string">
                           000011E2' 120C       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000120C  1210       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000007  1210       	.nchr  nchr, ^\string"\	; nchr = length( string" )
                           00000007  1210       	.if    le, nchr		; nchr <= 0
                                     1210       	   .ascic \i_string_quote\	; no auxillary string", use principle one
                                     1210       	.if_false		; else
            22 67 6E 69 72 74 73 00' 1210       	  .ascic \string"\		; use auxillary string"
                                 07  1210       
                                     1218       	.endc			; end if
                                     1218       i_string_quote:			; use string" of word as v1_kernel label
                                     1218       	
                       F622 CF   16  1218  2579 	jsb	create			; make the header
                       89   3E   90  121C  2580 	movb	#op_movaw,(r9)+		; `movaw'
                    89   AF 8F   90  121F  2581 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  1223  2582 	movb	#4,(r9)+		; (pc+4)
                    89   7B 8F   90  1226  2583 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  122A  2584 	movb	#op_rsb,(r9)+		; `rsb'
                       89   6B   B0  122D  2585 	movw	(r11),(r9)+		; maximum length
                       7A   59   D0  1230  2586 	movl	r9,-(r10)		; save address of current length on lstack
                       89   00   90  1233  2587 	movb	#0,(r9)+		; make high byte of current count
                                     1236  2588 					;   zero since token returns a b-counted
                                     1236  2589 					;   string
                       7B   22   D0  1236  2590 	movl	#^a\"\,-(r11)		; set up for quote terminated token
                   000012DE'EF   16  1239  2591 	jsb	token			; get the token
                       50   89   9A  123F  2592 	movzbl	(r9)+,r0		; get count and move over to first char
                       50   6B   B1  1242  2593 	cmpw	(r11),r0		; is max length < token length
                            03   18  1245  2594 	bgeq	10$			; no
                       50   6B   D0  1247  2595 	movl	(r11),r0		; yes, only allow maxlen chars from
                                     124A  2596 					;   token
                                     124A  2597 10$:
                    00 BA   50   B0  124A  2598 	movw	r0,@(r10)		; save current length
                       5A   04   C0  124E  2599 	addl2	#4,r10			; pop temp storage from loop stack.
                       59   8B   C0  1251  2600 	addl2	(r11)+,r9		; save space for characters
                                 05  1254  2601 	rsb				; end of string"
                                     1255  2602 
                                     1255  2603 
                                     1255  2604 ;+++
                                     1255  2605 ;k> strmax -- ( -- ) Return maximum length of string at `a'.
                                     1255  2606 ;---
                                     1255  2607 	header	strmax
                           0000120C' 1255       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001255  1259       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  1259       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1259       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 115
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

               78 61 6D 72 74 73 00' 1259       	   .ascic \strmax\	; no auxillary , use principle one
                                 06  1259       
                                     1260       	.if_false		; else
                                     1260       	  .ascic \\		; use auxillary 
                                     1260       	.endc			; end if
                                     1260       strmax:			; use  of word as v1_kernel label
                                     1260       	
                       6B   02   C2  1260  2608 	subl2	#2,(r11)		; get address of max len
                    6B   00 BB   3C  1263  2609 	movzwl	@(r11),(r11)		; get maximum length
                                 05  1267  2610 	rsb				; end of strmax
                                     1268  2611 
                                     1268  2612 
                                     1268  2613 ;+++
                                     1268  2614 ;k> strpos -- ( a1 n1 a2 n2 -- a3 n3 ? f ) Find pos and len of substring in str.
                                     1268  2615 ;	Searches string whose text is at `a2' and length is `n2' for substring
                                     1268  2616 ;	whose text is at `a`' and whose length is `n1'.  Returns true on top of
                                     1268  2617 ;	stack if found and under that { a3 n3 }, address and length of located
                                     1268  2618 ;	substring.  Otherwise returns false.
                                     1268  2619 ;---
                                     1268  2620 	header	strpos
                           00001255' 1268       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001268  126C       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  126C       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  126C       	.if    le, nchr		; nchr <= 0
               73 6F 70 72 74 73 00' 126C       	   .ascic \strpos\	; no auxillary , use principle one
                                 06  126C       
                                     1273       	.if_false		; else
                                     1273       	  .ascic \\		; use auxillary 
                                     1273       	.endc			; end if
                                     1273       strpos:			; use  of word as v1_kernel label
                                     1273       	
                         08 AB   39  1273  2621 	matchc	8(r11),-		; length of object string (to find)
                         0C BB       1276  2622 		@12(r11),-		; address of object string
                            6B       1278  2623 		(r11),-			; length of source string (to search in)
                         04 BB       1279  2624 		@4(r11)			; address of source string
                            19   12  127B  2625 	bneq	10$			; match not found
                    50   08 AB   D0  127D  2626 	movl	8(r11),r0		; save length of object string
                  51   53   50   C3  1281  2627 	subl3	r0,r3,r1		; calculate start addr of found string
                       5B   10   C0  1285  2628 	addl2	#16,r11			; pop arguments
                       7B   51   D0  1288  2629 	movl	r1,-(r11)		; put address of found string on stack
                       7B   50   D0  128B  2630 	movl	r0,-(r11)		; put length of found string on stack
              7B   FFFFFFFF 8F   D0  128E  2631 	movl	#c_true,-(r11)		; put true on stack
                                 05  1295  2632 	rsb				; rturn
                                     1296  2633 10$:
                       5B   10   C0  1296  2634 	addl2	#16,r11			; pop arguments
                       7B   00   D0  1299  2635 	movl	#c_false,-(r11)
                                 05  129C  2636 	rsb				; end of strpos
                                     129D  2637 
                                     129D  2638 
                                     129D  2639 ;+++
                                     129D  2640 ;k> swap -- ( n1 n2 -- n2 n1 ) exchange the top two items on the stack.
                                     129D  2641 ;---
                                     129D  2642 	header	swap
                           00001268' 129D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000129D  12A1       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  12A1       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12A1       	.if    le, nchr		; nchr <= 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 116
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                     70 61 77 73 00' 12A1       	   .ascic \swap\	; no auxillary , use principle one
                                 04  12A1       
                                     12A6       	.if_false		; else
                                     12A6       	  .ascic \\		; use auxillary 
                                     12A6       	.endc			; end if
                                     12A6       swap:			; use  of word as v1_kernel label
                                     12A6       	
                       50   6B   D0  12A6  2643 	movl	(r11),r0		; temp = n2
                    6B   04 AB   D0  12A9  2644 	movl	4(r11),(r11)		; n2 = n1
                    04 AB   50   D0  12AD  2645 	movl	r0,4(r11)		; n1 = saved n2
                                 05  12B1  2646 	rsb				; end of swap
                                     12B2  2647 
                                     12B2  2648 
                                     12B2  2649 ;+++
                                     12B2  2650 ;k> tochar -- convert top fo stack from 0..9, A..Z to '0'..'9','A'..'Z'
                                     12B2  2651 ;	( n -- c ) where n is a number and c is a char.
                                     12B2  2652 ;	If not in rnage leave alow.
                                     12B2  2653 ;---
                                     12B2  2654 	header	tochar
                           0000129D' 12B2       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000012B2  12B6       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  12B6       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12B6       	.if    le, nchr		; nchr <= 0
               72 61 68 63 6F 74 00' 12B6       	   .ascic \tochar\	; no auxillary , use principle one
                                 06  12B6       
                                     12BD       	.if_false		; else
                                     12BD       	  .ascic \\		; use auxillary 
                                     12BD       	.endc			; end if
                                     12BD       tochar:			; use  of word as v1_kernel label
                                     12BD       	
                                     12BD  2655 ; with 10 numbers and 26 letters, largest base is 36.
                                     12BD  2656 ; didgits go from 0 to 35.
                            6B   D5  12BD  2657 	tstl	(r11)			; n < 0?
                            12   19  12BF  2658 	blss	100$			; yes, exit
                       23   6B   D1  12C1  2659 	cmpl	(r11),#35		; n > 35
                            0D   14  12C4  2660 	bgtr	100$			; yes, exit
                       09   6B   D1  12C6  2661 	cmpl	(r11),#9		; n > 9 (not a `number') ~~~base 10 digit
                            05   14  12C9  2662 	bgtr	10$			; yes, make it 'A' .. 'Z'
                       6B   30   C0  12CB  2663 	addl2	#48,(r11)		; no, make it a '1' .. '9'
                            03   11  12CE  2664 	brb	100$			; exit
                                     12D0  2665 10$:
                       6B   37   C0  12D0  2666 	addl2	#55,(r11)		; make it 'A' .. 'Z'
                                     12D3  2667 100$:
                                 05  12D3  2668 	rsb				; end of tochar.
                                     12D4  2669 
                                     12D4  2670 
                                     12D4  2671 ;+++t
                                     12D4  2672 ;k> token -- ( c -- ) Get next token from input stream and put it in dictionary.
                                     12D4  2673 ;	Note that this dos NOT increment the dictionary pointer!
                                     12D4  2674 ;---
                                     12D4  2675 	header	token
                           000012B2' 12D4       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000012D4  12D8       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  12D8       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  12D8       	.if    le, nchr		; nchr <= 0
                  6E 65 6B 6F 74 00' 12D8       	   .ascic \token\	; no auxillary , use principle one
                                 05  12D8       
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 117
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     12DE       	.if_false		; else
                                     12DE       	  .ascic \\		; use auxillary 
                                     12DE       	.endc			; end if
                                     12DE       token:			; use  of word as v1_kernel label
                                     12DE       	
                       6B   20   91  12DE  2676 	cmpb	#c_blank,(r11)		; ?c = ' '~~~, an ascii blank
                            22   12  12E1  2677 	bneq	_gettoken		; if anything but space, don't skip
                                     12E3  2678 _skipwhitespace:
0000199B'FF   00001999'EF   6B   3B  12E3  2679 	skpc	(r11),v_inlen,@v_inptr	; skip whitespace
                            06   12  12EF  2680 	bneq	_startfound		; if something other than whitespace
                                     12F1  2681 					; found
                       FD8F CF   16  12F1  2682 	jsb     sread                   ; get a new line, only whitespace found
                            EC   11  12F5  2683 	brb	_skipwhitespace		; do it over
                                     12F7  2684 _startfound:
              0000199B'EF   51   D0  12F7  2685 	movl	r1,v_inptr		; where non-whitespcae found
              00001999'EF   50   B0  12FE  2686 	movw	r0,v_inlen		; bytes remaining in string
                                     1305  2687 _gettoken:
                            56   D4  1305  2688 	clrl	r6
                            57   D4  1307  2689 	clrl	r7
0000199B'FF   00001999'EF   6B   3A  1309  2690 	locc	(r11),v_inlen,@v_inptr	; locate character
         56   00001999'EF   50   A3  1315  2691 	subw3	r0,v_inlen,r6		; (v_inlen = r0) = number of chars
                                     131D  2692 					;   to copy
              00001999'EF   50   B0  131D  2693 	movw    r0,v_inlen              ; these are only bytes left (including one
                                     1324  2694 					; located~~~close paren?
                       57   51   D0  1324  2695 	movl	r1,r7			; save address of found char
                       69   56   33  1327  2696 	cvtwb	r6,(r9)			; store byte length
                  58   59   01   C1  132A  2697 	addl3	#1,r9,r8		; where to put in dictinary
         68   0000199B'FF   56   28  132E  2698 	movc3	r6,@v_inptr,(r8)	; move string to dictinary
              0000199B'EF   57   D0  1336  2699 	movl	r7,v_inptr		; v_inptr points into string
                   00001999'EF   B5  133D  2700 	tstw	v_inlen			; Are any more char?  (including
                                     1343  2701 					;   located one)
                            0E   13  1343  2702 	beql	10$			; no, exit
              00001999'EF   01   A2  1345  2703 	subw2	#1,v_inlen		; yes, move over terminator
                                     134C  2704 					;   (located char)
              0000199B'EF   01   C0  134C  2705 	addl2	#1,v_inptr
                                     1353  2706 10$:
                       5B   04   C0  1353  2707 	addl2	#4,r11			; pop terminator off stack
                                 05  1356  2708 	rsb				; end of token
                                     1357  2709 
                                     1357  2710 
                                     1357  2711 ;+++t
                                     1357  2712 ;k> unlink -- ( -- ) Unlink the most current word from the current vocab.  Used
                                     1357  2713 ;	when a definition is aborted by an unknown token.
                                     1357  2714 ;---
                                     1357  2715 	header	unlink
                           000012D4' 1357       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001357  135B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  135B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  135B       	.if    le, nchr		; nchr <= 0
               6B 6E 69 6C 6E 75 00' 135B       	   .ascic \unlink\	; no auxillary , use principle one
                                 06  135B       
                                     1362       	.if_false		; else
                                     1362       	  .ascic \\		; use auxillary 
                                     1362       	.endc			; end if
                                     1362       unlink:			; use  of word as v1_kernel label
                                     1362       	
              58   00001D3B'FF   D0  1362  2716 	movl	@v_current,r8		; reclaim directory space
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 118
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

              00001D3B'FF   69   D0  1369  2717 	movl	(r9),@v_current		; get pointer to last word in current
                                     1370  2718 					; vocab from link field of word
                                     1370  2719 					; we just deleted
                                 05  1370  2720 	rsb				; end of unlink
                                     1371  2721 
                                     1371  2722 
                                     1371  2723 ;+++
                                     1371  2724 ;k> unsmudge -- clear the smudge (high) bit in the word being defined, so
                                     1371  2725 ;	that it can be found again.
                                     1371  2726 ;---
                                     1371  2727 	header	unsmudge
                           00001357' 1371       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001371  1375       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  1375       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1375       	.if    le, nchr		; nchr <= 0
         65 67 64 75 6D 73 6E 75 00' 1375       	   .ascic \unsmudge\	; no auxillary , use principle one
                                 08  1375       
                                     137E       	.if_false		; else
                                     137E       	  .ascic \\		; use auxillary 
                                     137E       	.endc			; end if
                                     137E       unsmudge:			; use  of word as v1_kernel label
                                     137E       	
              50   00001D3B'FF   D0  137E  2728 	movl	@v_current,r0		; address of word being defined
                       50   04   C0  1385  2729 	addl2	#4,r0			; move over link field
                    60   80 8F   8A  1388  2730 	bicb2	#^b10000000,(r0)	; clear smudge bit
                                 05  138C  2731 	rsb				; end of unsmudge
                                     138D  2732 
                                     138D  2733 
                                     138D  2734 ;+++
                                     138D  2735 ;k> update -- ( -- ) Mark the most recent block as updated.
                                     138D  2736 ;---
                                     138D  2737 	header	update
                           00001371' 138D       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           0000138D  1391       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  1391       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1391       	.if    le, nchr		; nchr <= 0
               65 74 61 64 70 75 00' 1391       	   .ascic \update\	; no auxillary , use principle one
                                 06  1391       
                                     1398       	.if_false		; else
                                     1398       	  .ascic \\		; use auxillary 
                                     1398       	.endc			; end if
                                     1398       update:			; use  of word as v1_kernel label
                                     1398       	
              50   00001B79'EF   D0  1398  2738 	movl	v_current_buff,r0	; get buffer number of current block
                            02   90  139F  2739 	movb	#c_modified,-		;
                       1B7D'C0       13A1  2740 		v_buf_inuse(r0)		; mark buffer as updated
                                 05  13A4  2741 	rsb				; end of update
                                     13A5  2742 
                                     13A5  2743 
                                     13A5  2744 ;+++
                                     13A5  2745 ;k> variable -- ( -- ) Create a word that pushed its PFA on the stack.
                                     13A5  2746 ;	Doesn't reserve any space.  Use for making initialized arrays.
                                     13A5  2747 ;	PF = parameter field address = address of data following end
                                     13A5  2748 ;	of code body of work.
                                     13A5  2749 ;---
                                     13A5  2750 ;??? This concept is fuzzy.  Work on it.
                                     13A5  2751 	header	  variable
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 119
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           0000138D' 13A5       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000013A5  13A9       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  13A9       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13A9       	.if    le, nchr		; nchr <= 0
         65 6C 62 61 69 72 61 76 00' 13A9       	   .ascic \variable\	; no auxillary , use principle one
                                 08  13A9       
                                     13B2       	.if_false		; else
                                     13B2       	  .ascic \\		; use auxillary 
                                     13B2       	.endc			; end if
                                     13B2       variable:			; use  of word as v1_kernel label
                                     13B2       	
                       F488 CF   16  13B2  2752 	jsb	  create		; enclose next token in dictionary
                    89   90 8F   90  13B6  2753 	movb	  #op_movb,(r9)+	; `movb'
                    89   AF 8F   90  13BA  2754 	movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  13BE  2755 	movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  13C1  2756 	movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  13C5  2757 	movb	  #op_rsb,(r9)+		; `rsb'
                                 05  13C8  2758 	rsb				; end of variable
                                     13C9  2759 
                                     13C9  2760 
                                     13C9  2761 ;+++
                                     13C9  2762 ;k> vlist -- ( -- ) List context vocabulary
                                     13C9  2763 ;---
                                     13C9  2764 	header	vlist
                           000013A5' 13C9       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000013C9  13CD       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  13CD       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  13CD       	.if    le, nchr		; nchr <= 0
                  74 73 69 6C 76 00' 13CD       	   .ascic \vlist\	; no auxillary , use principle one
                                 05  13CD       
                                     13D3       	.if_false		; else
                                     13D3       	  .ascic \\		; use auxillary 
                                     13D3       	.endc			; end if
                                     13D3       vlist:			; use  of word as v1_kernel label
                                     13D3       	
              50   00001D37'FF   D0  13D3  2765 	movl	@v_context,r0		; get address of context vocabulary
                       7B   50   D0  13DA  2766 	movl	r0,-(r11)		; get address of most recent word
                                     13DD  2767 10$:
                            6B   D5  13DD  2768 	tstl	(r11)			; nil pointer?
                            22   13  13DF  2769 	beql	100$			; yes, exit
                  7B   04   6B   C1  13E1  2770 	addl3	(r11),#4,-(r11)		; get address of name field
                       F088 CF   16  13E5  2771 	jsb	bcount			; set up for write
                       7B   6B   D0  13E9  2772 	movl	(r11),-(r11)		; set up for ?cr
                       EF15 CF   16  13EC  2773 	jsb	q_n_cr			; start new line if word too long
                   0000144C'EF   16  13F0  2774 	jsb	write			; tell user
                       7B   20   D0  13F6  2775 	movl	#c_blank,-(r11)		; blank to separate words
                       F9ED CF   16  13F9  2776 	jsb	putc			; output it
                    6B   00 BB   D0  13FD  2777 	movl	@(r11),(r11)		; get previous word's LFA
                            DA   11  1401  2778 	brb	10$			; try it again
                                     1403  2779 100$:
                       5A   04   C0  1403  2780 	addl2	#4,r10			; pop pointer off stack
                                 05  1406  2781 	rsb				; end of vlist
                                     1407  2782 
                                     1407  2783 
                                     1407  2784 ;+++
                                     1407  2785 ;k> vocabulary -- ( -- ) Defining word.  Creates a new vocabulary. When the word
                                     1407  2786 ;	defined by this is executed, context is set to the new vocabulary.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 120
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1407  2787 ;---
                                     1407  2788 	header	vocabulary
                           000013C9' 1407       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001407  140B       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  140B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  140B       	.if    le, nchr		; nchr <= 0
   79 72 61 6C 75 62 61 63 6F 76 00' 140B       	   .ascic \vocabulary\	; no auxillary , use principle one
                                 0A  140B       
                                     1416       	.if_false		; else
                                     1416       	  .ascic \\		; use auxillary 
                                     1416       	.endc			; end if
                                     1416       vocabulary:			; use  of word as v1_kernel label
                                     1416       	
              7A   00001D37'FF   D0  1416  2789 	movl	@v_context,-(r10)	; save LFA of word to link to
                       F41D CF   16  141D  2790 	jsb	create			;   make header for new vocab~~~ word
                    89   DE 8F   90  1421  2791 	movb	#op_moval,(r9)+		; `moval'
                    89   AF 8F   90  1425  2792 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   06   90  1429  2793 	movb	#6,(r9)+		; (pc+2) ~~~ isn't this (pc+6)?
              89   0000009F'EF   90  142C  2794 	movb	adm_absolute,(r9)+	; absolute mode (address in next lword)
              89   00001D37'EF   DE  1433  2795 	moval	v_context,(r9)+		; context
                    89   05 8F   9E  143A  2796 	movab	#op_rsb,(r9)+		; rsb
                       89   8A   D0  143E  2797 	movl	(r10)+,(r9)+		; initialize link
                                 05  1441  2798 	rsb				; end of vocabulary
                                     1442  2799 
                                     1442  2800 
                                     1442  2801 ;+++t
                                     1442  2802 ;k> write -- ( a w -- ) Write string of length `w' at address `a' out to  terminal.
                                     1442  2803 ;---
                                     1442  2804 	header	write
                           00001407' 1442       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001442  1446       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  1446       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1446       	.if    le, nchr		; nchr <= 0
                  65 74 69 72 77 00' 1446       	   .ascic \write\	; no auxillary , use principle one
                                 05  1446       
                                     144C       	.if_false		; else
                                     144C       	  .ascic \\		; use auxillary 
                                     144C       	.endc			; end if
                                     144C       write:			; use  of word as v1_kernel label
                                     144C       	
         00A0 8F   00001B98'EF   B1  144C  2805 	cmpw	v_outlen,#c_max_len	; Is output buffer full?
                            28   19  1455  2806 	blss	10$			; no, go get some
                                     1457  2807 ; yes, output it
              7B   00001B9A'EF   DE  1457  2808 	moval	v_outbuf,-(r11)		; put address on stack
              7B   00001B98'EF   3C  145E  2809 	movzwl	v_outlen,-(r11)		; put length on stack
           02 AB   00001B96'EF   B0  1465  2810 	movw	v_static_dsc,2(r11)	; put rest of descriptor in
                            5B   DD  146D  2811 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  146F  2812 	calls	#1,g^lib$put_output	; output it
                       5B   08   C0  1476  2813 	addl2	#8,r11			; pop top two entries (descriptor)
                   00001B98'EF   B4  1479  2814 	clrw	v_outlen		; nothing left in buffer
                                     147F  2815 10$:
              56   00001B98'EF   3C  147F  2816 	movzwl	v_outlen,r6		; get length
         57   000000A0 8F   56   C3  1486  2817 	subl3	r6,#c_max_len,r7	; space available in output buffer
              50   00001B9A'EF   9E  148E  2818 	movab	v_outbuf,r0		; pointer into buffer
                       50   56   C0  1495  2819 	addl2	r6,r0			; next available byte
                       57   6B   D1  1498  2820 	cmpl	(r11),r7		; chars to output <= available
                            10   14  149B  2821 	bgtr	20$			; no, do a part
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 121
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

               60   04 BB   6B   28  149D  2822 	movc3	(r11),@4(r11),(r0)	; move the string into the output buffer
              00001B98'EF   6B   A0  14A2  2823 	addw2	(r11),v_outlen		; save the new # of chars in buffer
                       5B   08   C0  14A9  2824 	addl2	#8,r11			; pop top two entries off stack
                                 05  14AC  2825 	rsb				; return
                                     14AD  2826 20$:					; more chars to output than buffer space
               60   04 BB   57   28  14AD  2827 	movc3	r7,@4(r11),(r0)		; move some into buffer
                       6B   57   C2  14B2  2828 	subl2	r7,(r11)		; new length to output
                    04 AB   57   C0  14B5  2829 	addl2	r7,4(r11)		; new place to start in chars to output
              00001B98'EF   57   A0  14B9  2830 	addw2	r7,v_outlen		; new # of chars in buffer
              7B   00001B9A'EF   9E  14C0  2831 	movab	v_outbuf,-(r11)		; address of buffer on stack
              7B   00001B98'EF   9A  14C7  2832 	movzbl	v_outlen,-(r11)		; count on stack
           02 AB   00001B96'EF   B0  14CE  2833 	movw	v_static_dsc,2(r11)	; put middle of descriptor in
                            5B   DD  14D6  2834 	pushl	r11			; address of descriptor
              00000000'GF   01   FB  14D8  2835 	calls	#1,g^lib$put_output	; display it
                   00001B98'EF   B4  14DF  2836 	clrw	v_outlen		; nothing in buffer now
                       5B   08   C0  14E5  2837 	addl2	#8,r11			; pop descriptor off stack
                            6B   D5  14E8  2838 	tstl	(r11)			; Are there any remaining characters?
                            93   14  14EA  2839 	bgtr	10$			; yes, try it again
                       5B   08   C0  14EC  2840 	addl2	#8,r11			; pop arguments
                                 05  14EF  2841 	rsb				; end of write
                                     14F0  2842 
                                     14F0  2843 
                                     14F0  2844 ;+++
                                     14F0  2845 ;k> xor -- ( f1 f2 -- f ) logical xor; f1 xor f2.
                                     14F0  2846 ;---
                                     14F0  2847 	header	xor
                           00001442' 14F0       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           000014F0  14F4       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000000  14F4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  14F4       	.if    le, nchr		; nchr <= 0
                        72 6F 78 00' 14F4       	   .ascic \xor\	; no auxillary , use principle one
                                 03  14F4       
                                     14F8       	.if_false		; else
                                     14F8       	  .ascic \\		; use auxillary 
                                     14F8       	.endc			; end if
                                     14F8       xor:			; use  of word as v1_kernel label
                                     14F8       	
                            8B   D5  14F8  2848 	tstl	(r11)+			; is the first one false?
                            06   13  14FA  2849 	beql	10$			; yes
                            8B   D5  14FC  2850 	tstl	(r11)+			; no, is the second one false?
                            0A   13  14FE  2851 	beql	30$			; yes, leave with true
                            04   11  1500  2852 	brb	20$			; no leave with false
                                     1502  2853 10$:					; first one false
                            8B   D5  1502  2854 	tstl	(r11)+			; Is the second one true?
                            04   12  1504  2855 	bneq	30$			; yes, leave with true
                                     1506  2856 20$:					; leave with false
                       7B   00   D0  1506  2857 	movl	#c_false,-(r11)		; leave with false
                                 05  1509  2858 	rsb				; return
                                     150A  2859 30$:
              7B   FFFFFFFF 8F   D0  150A  2860 	movl	#c_true,-(r11)		; leave with true
                                 05  1511  2861 	rsb				; end of xor
                                     1512  2862 
                                     1512  2863 
                                     1512  2864 ;+++
                                     1512  2865 ;k> ] -- ( -- ) enter compile mode.  Used with { [ } in definitions.
                                     1512  2866 ;---
                                     1512  2867 	header i_right_back,<]>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 122
V1.01                           Kernel Built-ins                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           000014F0' 1512       	.long	v1_kernel		; back link to the previous word in this v1_kernel
                           00001512  1516       	v1_kernel = . - 4		; where to link the next word to in this v1_kernel
                           00000001  1516       	.nchr  nchr, ^\]\	; nchr = length( ] )
                           00000001  1516       	.if    le, nchr		; nchr <= 0
                                     1516       	   .ascic \i_right_back\	; no auxillary ], use principle one
                                     1516       	.if_false		; else
                              5D 00' 1516       	  .ascic \]\		; use auxillary ]
                                 01  1516       
                                     1518       	.endc			; end if
                                     1518       i_right_back:			; use ] of word as v1_kernel label
                                     1518       	
           00001D4D'EF   FF 8F   90  1518  2868 	movb   #c_true,v_mode		; enter compile mode
                                 05  1520  2869 	rsb				; end of l
                                     1521  2870 
                                     1521  2871 
                                     1521  2872 _kernel_end:
                                     1521  2873 	newpage <cCompiler Built-ins>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 123
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1521       	.sbttl	cCompiler Built-ins
                                     1521       	
                                     1521  2874 ;*******************************************************************************
                                     1521  2875 ;
                                     1521  2876 ; Compiler Built-ins -- a new word is unlinked from the current vocabulary
                                     1521  2877 ;	and linked into the compilier vocabulary by the word { compiletime }.
                                     1521  2878 ;	Computer (or compiletime} words are only search for during the
                                     1521  2879 ;	definition of new words, which prevents them from mucking about with
                                     1521  2880 ;	the stacks and the dictionary when we are interpreting the user's
                                     1521  2881 ;	commands.
                                     1521  2882 ;
                                     1521  2883 ;*******************************************************************************
                                     1521  2884 compiler_begin:
                                     1521  2885 
                                     1521  2886 
                                     1521  2887 ;+++
                                     1521  2888 ;c> (variable) - ( -- ) compiles the code body of a word that pushes the
                                     1521  2889 ;	address of its parameter field on the stack.  Must be the last word
                                     1521  2890 ;	in the word...
                                     1521  2891 ;---
                                     1521  2892 ;??? This concept is fuzzy.  Work on it.
                                     1521  2893      header	  i_variable,<(variable)>,vl_compiler
                           00000000  1521       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001521  1525       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           0000000A  1525       	.nchr  nchr, ^\(variable)\	; nchr = length( (variable) )
                           0000000A  1525       	.if    le, nchr		; nchr <= 0
                                     1525       	   .ascic \i_variable\	; no auxillary (variable), use principle one
                                     1525       	.if_false		; else
   29 65 6C 62 61 69 72 61 76 28 00' 1525       	  .ascic \(variable)\		; use auxillary (variable)
                                 0A  1525       
                                     1530       	.endc			; end if
                                     1530       i_variable:			; use (variable) of word as vl_compiler label
                                     1530       	
                    89   9E 8F   90  1530  2894      movb	  #op_movab,(r9)+	; `movab'
                    89   AF 8F   90  1534  2895      movb	  #adm_b_rel,(r9)+	; byte relative
                       89   02   90  1538  2896      movb	  #2,(r9)+		; (pc+2)
                    89   7B 8F   90  153B  2897      movb	  #adm_adec_r11,(r9)+	; -(r11)
                       89   05   90  153F  2898      movb	  #op_rsb,(r9)+		; `rsb'
                                 05  1542  2899      rsb				; end of (variable)
                                     1543  2900 
                                     1543  2901 
                                     1543  2902 ;+++
                                     1543  2903 ;c> +loop -- ( n -- ) where n is an increment.  Edns { do .. +loop }.  Adds top
                                     1543  2904 ;	of stack to loop index and branches to { do } if ((index > 0) and
                                     1543  2905 ;	(index < limit)), or if ((index < 0) and (index > limit)).~~~ WTF: and should be or???
                                     1543  2906 ;	In other words, { +loop } with a positive argument is like Pascal's
                                     1543  2907 ;	{ for index := start to finish do ... } and with a negative argument
                                     1543  2908 ;	it is like { for index := start downto finish do }.
                                     1543  2909 ;---
                                     1543  2910 	header	i_plus_loop,<+loop>,vl_compiler
                           00001521' 1543       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001543  1547       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000005  1547       	.nchr  nchr, ^\+loop\	; nchr = length( +loop )
                           00000005  1547       	.if    le, nchr		; nchr <= 0
                                     1547       	   .ascic \i_plus_loop\	; no auxillary +loop, use principle one
                                     1547       	.if_false		; else
                  70 6F 6F 6C 2B 00' 1547       	  .ascic \+loop\		; use auxillary +loop
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 124
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 05  1547       
                                     154D       	.endc			; end if
                                     154D       i_plus_loop:			; use +loop of word as vl_compiler label
                                     154D       	
                    89   F1 8F   90  154D  2911 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  1551  2912 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  1555  2913 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8B 8F   90  1558  2914 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   6A 8F   90  155C  2915 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  1560  2916 	movl	r9,r0			; save address of branch word
                       89   00   B0  1563  2917 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  1566  2918 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  156A  2919 	movw	r1,(r0)			; save displacement
                  89   00C0 8F   B0  156D  2920 	movw	#op_addl2,(r9)+		; `addl2'	pop index&limit from ls
                       89   08   90  1572  2921 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  1575  2922 	movb	#adm_r10,(r9)+		; r10
                                 05  1579  2923 	rsb				; end of +loop
                                     157A  2924 
                                     157A  2925 
                                     157A  2926 ;+++
                                     157A  2927 ;c> ." -- ( -- ) compile text until netx `"' into dictinary to be printed when
                                     157A  2928 ;	the current word is executed.
                                     157A  2929 ;---
                                     157A  2930 	header	i_dot_quote,<.">,vl_compiler
                           00001543' 157A       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000157A  157E       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  157E       	.nchr  nchr, ^\."\	; nchr = length( ." )
                           00000002  157E       	.if    le, nchr		; nchr <= 0
                                     157E       	   .ascic \i_dot_quote\	; no auxillary .", use principle one
                                     157E       	.if_false		; else
                           22 2E 00' 157E       	  .ascic \."\		; use auxillary ."
                                 02  157E       
                                     1581       	.endc			; end if
                                     1581       i_dot_quote:			; use ." of word as vl_compiler label
                                     1581       	
                    89   9E 8F   90  1581  2931 	movb	#op_movab,(r9)+		; `movab'
                    89   AF 8F   90  1585  2932 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   05   90  1589  2933 	movb	#5,(r9)+		; (pc+5)	skip length byte too
                    89   7B 8F   90  158C  2934 	movb	#adm_adec_r11,(r9)+	; -(r11)
                       89   31   90  1590  2935 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1593  2936 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  1596  2937 	movw	#0,(r9)+		; save space for displacement
                       7B   22   D0  1599  2938 	movl	#^a\"\,-(r11)		; set up for `"' delimited tokens
                       FD3E CF   16  159C  2939 	jsb	token			; get token
                       50   69   9A  15A0  2940 	movzbl	(r9),r0			; get length of token
                  51   50   01   C1  15A3  2941 	addl3	#1,r0,r1		; calc displacement (count length too)
                    00 B1   51   B0  15A7  2942 	movw	r1,@(r1)		; fill in displacement
                       5A   04   C0  15AB  2943 	addl2	#4,r10			; pop item off loop stack
                       59   51   C0  15AE  2944 	addl2	r1,r9			; save string in dictionary
                    89   D0 8F   90  15B1  2945 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  15B5  2946 	movb	#adm_immediate,(r9)+	; immeidate mode
                       89   50   D0  15B9  2947 	movl	r0,(r9)+		; length of string
                    89   7B 8F   90  15BC  2948 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                     15C0  2949 ; we now have ( address count ) on stack (when new word executed)
                       89   16   90  15C0  2950 	movb	#op_jsb,(r9)+		; `jsb'
                    89   9F 8F   90  15C3  2951 	movb	#adm_absolute,(r9)+	; absolute mode
                  89   FE81 CF   DE  15C7  2952 	moval	write,(r9)+		; address of subroutine to jsb to
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 125
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 05  15CC  2953 	rsb				; end of ."
                                     15CD  2954 
                                     15CD  2955 
                                     15CD  2956 ;+++
                                     15CD  2957 ;c> ; (semicolon) -- ( -- ) Terminate a definition started by { : }.
                                     15CD  2958 ;	Sets { mode } to false and adds an rsb to the definition.
                                     15CD  2959 ;---
                                     15CD  2960 	header	i_semicolon,<;>,vl_compiler
                           0000157A' 15CD       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000015CD  15D1       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000001  15D1       	.nchr  nchr, ^\;\	; nchr = length( ; )
                           00000001  15D1       	.if    le, nchr		; nchr <= 0
                                     15D1       	   .ascic \i_semicolon\	; no auxillary ;, use principle one
                                     15D1       	.if_false		; else
                              3B 00' 15D1       	  .ascic \;\		; use auxillary ;
                                 01  15D1       
                                     15D3       	.endc			; end if
                                     15D3       i_semicolon:			; use ; of word as vl_compiler label
                                     15D3       	
                       89   05   90  15D3  2961 	movb	#op_rsb,(r9)+		; put an rsb in to end word
              00001D4D'EF   00   90  15D6  2962 	movb	#c_false,v_mode		; switch off compiler v_mode
                                     15DD  2963 ;??? might need to unset high bit in count of name (smudge) bit
                       FD9D CF   16  15DD  2964 	jsb	unsmudge      	     	; clear smudge bit so word is found
                                 05  15E1  2965 	rsb				; end of ;
                                     15E2  2966 
                                     15E2  2967 
                                     15E2  2968 ;+++
                                     15E2  2969 ;c> >defer -- ( -- ) ends a section of code that is to copied to the
                                     15E2  2970 ;	dictionary whenever this word is executed (i.e., { >defer } ends code
                                     15E2  2971 ;	to be executed by all words defined by the word we are now compiling).
                                     15E2  2972 ;	{ >defer } is used to define words that define words.
                                     15E2  2973 ;---
                                     15E2  2974 ;???  This concept is fuzzy.  Work on it.  May be fuzzy, but it works...
                                     15E2  2975 	header	   i_defer_end,^\>defer\,vl_compiler
                           000015CD' 15E2       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000015E2  15E6       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000006  15E6       	.nchr  nchr, ^\>defer\	; nchr = length( >defer )
                           00000006  15E6       	.if    le, nchr		; nchr <= 0
                                     15E6       	   .ascic \i_defer_end\	; no auxillary >defer, use principle one
                                     15E6       	.if_false		; else
               72 65 66 65 64 3E 00' 15E6       	  .ascic \>defer\		; use auxillary >defer
                                 06  15E6       
                                     15ED       	.endc			; end if
                                     15ED       i_defer_end:			; use >defer of word as vl_compiler label
                                     15ED       	
                  50   59   8A   C3  15ED  2976 	subl3	   (r10)+,r9,r0		; calculate length and displacement
                       9A   50   B0  15F1  2977 	movw	   r0,@(r10)+		; store displacement
                       9A   50   B0  15F4  2978 	movw	   r0,@(r10)+		; store length
                                     15F7  2979 ; make new word advance dictionary pointer over just added code
                    89   C0 8F   90  15F7  2980 	movb	#op_addl2,(r9)+		; `addl2'
                    89   8F 8F   90  15FB  2981 	movb	#adm_immediate,(r9)+	; i^#
                       80   50   D0  15FF  2982 	movl	r0,(r0)+		; amount to advance
                    89   59 8F   90  1602  2983 	movb	#adm_r9,(r9)+		; r9
                                 05  1606  2984 	rsb				; end of >defer
                                     1607  2985 
                                     1607  2986 
                                     1607  2987 ;+++
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 126
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1607  2988 ;c> again -- ( -- ) Terminate a { repeat ... if ... again } loop.  { agin }
                                     1607  2989 ;	unconditionally branches back to the { repeat }.
                                     1607  2990 ;---
                                     1607  2991 	header	again,,vl_compiler
                           000015E2' 1607       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001607  160B       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  160B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  160B       	.if    le, nchr		; nchr <= 0
                  6E 69 61 67 61 00' 160B       	   .ascic \again\	; no auxillary , use principle one
                                 05  160B       
                                     1611       	.if_false		; else
                                     1611       	  .ascic \\		; use auxillary 
                                     1611       	.endc			; end if
                                     1611       again:			; use  of word as vl_compiler label
                                     1611       	
                                     1611  2992 ; save values for calculating displacement in if.
                       50   8A   D0  1611  2993 	movl  (r10)+,r0			; save address to displace from if
                       51   8A   D0  1614  2994 	movl  (r10)+,r1			; save address for displacement
                                     1617  2995 ; construct negative branch from { again } to { repeat }
                       89   31   90  1617  2996 	movb	#op_brw,(r9)+		; `brw'
                       52   59   D0  161A  2997 	movl	r9,r2			; save address for negative displacement
                       89   00   B0  161D  2998 	movw	#0,(r9)+		; save space for displacement
                  53   8A   59   C3  1620  2999 	subl3	r9,(r10)+,r3		; calculate negative displacment
                       62   53   B0  1624  3000 	movw	r3,(r2)			; save negative displacement
                                     1627  3001 ; construct forward branch from { if } to after { again }
                  54   59   50   C3  1627  3002 	subl3	r0,r9,r4		; calculate { if }'s displacment
                       61   54   B0  162B  3003 	movw	r4,(r1)			; save displacement
                                 05  162E  3004 	rsb				; end of again
                                     162F  3005 
                                     162F  3006 
                                     162F  3007 ;+++
                                     162F  3008 ;c> b^ -- ( -- ) Convert next token to number and enclose low byte in dictionary.~~~ byte immediate???
                                     162F  3009 ;---
                                     162F  3010 	header	i_b_up,<b^>,vl_compiler
                           00001607' 162F       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000162F  1633       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1633       	.nchr  nchr, ^\b^\	; nchr = length( b^ )
                           00000002  1633       	.if    le, nchr		; nchr <= 0
                                     1633       	   .ascic \i_b_up\	; no auxillary b^, use principle one
                                     1633       	.if_false		; else
                           5E 62 00' 1633       	  .ascic \b^\		; use auxillary b^
                                 02  1633       
                                     1636       	.endc			; end if
                                     1636       i_b_up:			; use b^ of word as vl_compiler label
                                     1636       	
                       7B   20   D0  1636  3011 	movl	#c_blank,-(r11)		; set up for blank delimeted token
                       FCA1 CF   16  1639  3012 	jsb	token			; get it
                       F6DB CF   16  163D  3013 	jsb	number			; try to make it a number
                            8B   D5  1641  3014 	tstl	(r11)+			; is it a number?
                            01   12  1643  3015 	bneq	10$			; yes
                                 05  1645  3016 	rsb				; no, for now just exit~~~??? FIXME!
                                     1646  3017 10$:
                       89   6B   90  1646  3018 	movb	(r11),(r9)+		; save byte in dictionary
                       5B   04   C0  1649  3019 	addl2	#4,r11			; pop value from dstack
                                 05  164C  3020 	rsb				; end of b^
                                     164D  3021 
                                     164D  3022 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 127
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     164D  3023 ;+++
                                     164D  3024 ;c> defer< -- ( -- ) start a section of code that is to be copied to dictionary
                                     164D  3025 ;	whenever this word is executed (i.e., { defer< } starts code to be
                                     164D  3026 ;	executed by all words defined by the word we are now compiling).
                                     164D  3027 ;	Used in defining words that are to define words.
                                     164D  3028 ;---
                                     164D  3029 ;??? This concept is fuzzy.  Work on it.
                                     164D  3030 	header	i_defer_begin,^\defer<\,vl_compiler
                           0000162F' 164D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000164D  1651       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000006  1651       	.nchr  nchr, ^\defer<\	; nchr = length( defer< )
                           00000006  1651       	.if    le, nchr		; nchr <= 0
                                     1651       	   .ascic \i_defer_begin\	; no auxillary defer<, use principle one
                                     1651       	.if_false		; else
               3C 72 65 66 65 64 00' 1651       	  .ascic \defer<\		; use auxillary defer<
                                 06  1651       
                                     1658       	.endc			; end if
                                     1658       i_defer_begin:			; use defer< of word as vl_compiler label
                                     1658       	
                       89   28   90  1658  3031 	movb	#op_movc3,(r9)+		; `movc3'
                    89   8F 8F   90  165B  3032 	movb	#adm_immediate,(r9)+	; I^x immediate mode
                       7A   59   D0  165F  3033 	movl	r9,-(r10)		; save address to put length in on
                                     1662  3034 					;   the loop stack
                       89   00   B0  1662  3035 	movw	#0,(r9)+		; save space for length
                    89   AF 8F   90  1665  3036 	movb	#adm_b_rel,(r9)+	; byte relative
                       89   04   90  1669  3037 	movb	#4,(r9)+		; (pc+4)
                    89   69 8F   90  166C  3038 	movb	#adm_def_r9,(r9)+	; (r9)
                       89   31   90  1670  3039 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1673  3040 	movl	r9,-(r10)		; save address to put branch
                                     1676  3041 					;   displacement at on loop stack
                       89   00   B0  1676  3042 	movw	#0,(r9)+		; save space for the displacement
              7A   00000031'EF   D0  1679  3043 	movl	49,-(r10)		; save address of data start on loop
                                     1680  3044 					;   stack to calculate data length
                                 05  1680  3045 	rsb				; end of defer<
                                     1681  3046 
                                     1681  3047 
                                     1681  3048 ;+++
                                     1681  3049 ;c> do -- ( n1 n2 -- ) Program control structure; starts { do ... +loop },
                                     1681  3050 ;	{ do ... downloop }, and { do ... loop }.  Note that all do
                                     1681  3051 ;	loops execute at least once.  `n1' is the limit and `n2' is the
                                     1681  3052 ;	number to start the index at.
                                     1681  3053 ;---
                                     1681  3054 	header	i_do,<do>,vl_compiler	; VAX/VMS debug thinks do is a command
                           0000164D' 1681       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001681  1685       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1685       	.nchr  nchr, ^\do\	; nchr = length( do )
                           00000002  1685       	.if    le, nchr		; nchr <= 0
                                     1685       	   .ascic \i_do\	; no auxillary do, use principle one
                                     1685       	.if_false		; else
                           6F 64 00' 1685       	  .ascic \do\		; use auxillary do
                                 02  1685       
                                     1688       	.endc			; end if
                                     1688       i_do:			; use do of word as vl_compiler label
                                     1688       	
                    89   D0 8F   90  1688  3055 	movb	#op_movl,(r9)+		; `movl'	save index
                    89   8B 8F   90  168C  3056 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   50 8F   90  1690  3057 	movb	#adm_r0,(r9)+		; r0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 128
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                    89   D0 8F   90  1694  3058 	movb	#op_movl,(r9)+		; `movl'	put limit on lstack
                    89   8B 8F   90  1698  3059 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                    89   7A 8F   90  169C  3060 	movb	#adm_adec_r10,(r9)+	; -(r10)
                    89   D0 8F   90  16A0  3061 	movb	#op_movl,(r9)+		; `movl'	put index on lstack
                    89   50 8F   90  16A4  3062 	movb	#adm_r0,(r9)+		; r0
                    89   7A 8F   90  16A8  3063 	movb	#adm_adec_r10,(r9)+	; -(r10)
                       7A   59   D0  16AC  3064 	movl	r9,-(r10)		; save address to branch to
                                 05  16AF  3065 	rsb				; end of do
                                     16B0  3066 
                                     16B0  3067 
                                     16B0  3068 ;+++
                                     16B0  3069 ;c> downloop -- ( -- ) Ends a { do ... downloop }.  Adds -1 to the loop index
                                     16B0  3070 ;	and branches to { do } if ((index < 0) and (index > limit)).~~~ inverted?
                                     16B0  3071 ;	In other words, { downloop } is like Pascal's
                                     16B0  3072 ;	{ for index := start downto finish do }.
                                     16B0  3073 ;---
                                     16B0  3074 	header	downloop,,vl_compiler
                           00001681' 16B0       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000016B0  16B4       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  16B4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  16B4       	.if    le, nchr		; nchr <= 0
         70 6F 6F 6C 6E 77 6F 64 00' 16B4       	   .ascic \downloop\	; no auxillary , use principle one
                                 08  16B4       
                                     16BD       	.if_false		; else
                                     16BD       	  .ascic \\		; use auxillary 
                                     16BD       	.endc			; end if
                                     16BD       downloop:			; use  of word as vl_compiler label
                                     16BD       	
                    89   F1 8F   90  16BD  3075 	movb	#op_acbl,(r9)+		; `acbl'
                    89   AA 8F   90  16C1  3076 	movb	#adm_b_dis_r10,(r9)+	; b^(r10)
                       89   04   90  16C5  3077 	movb	#4,(r9)+		; 4 byte displacement for previous adm
                    89   8F 8F   90  16C8  3078 	movb	#adm_immediate,(r9)+	; immediate mode
              89   FFFFFFFF 8F   D0  16CC  3079 	movl	#-1,(r9)+		; -1 is addend
                    89   6A 8F   90  16D3  3080 	movb	#adm_def_r10,(r9)+	; (r10)
                       50   59   D0  16D7  3081 	movl	r9,r0			; save address of branch word
                       89   00   B0  16DA  3082 	movw	#0,(r9)+		; save space for branch displacement
                  51   8A   59   C3  16DD  3083 	subl3	r9,(r10)+,r1		; calculate displacement
                       60   51   B0  16E1  3084 	movw	r1,(r0)			; save displacement
                    89   C0 8F   90  16E4  3085 	movb	#op_addl2,(r9)+		; `addl2'	pop index&limit from lstack
                       89   08   90  16E8  3086 	movb	#^x08,(r9)+		; s^#8
                    89   5A 8F   90  16EB  3087 	movb	#adm_r10,(r9)+		; r10
                                 05  16EF  3088 	rsb				; end of downloop
                                     16F0  3089 
                                     16F0  3090 
                                     16F0  3091 ;+++
                                     16F0  3092 ;c> else -- ( -- ) In control structure { if ... else ... endif } { else }
                                     16F0  3093 ;	else ends the true branch and starts the false branch.
                                     16F0  3094 ;---
                                     16F0  3095 	header	else,,vl_compiler
                           000016B0' 16F0       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000016F0  16F4       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  16F4       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  16F4       	.if    le, nchr		; nchr <= 0
                     65 73 6C 65 00' 16F4       	   .ascic \else\	; no auxillary , use principle one
                                 04  16F4       
                                     16F9       	.if_false		; else
                                     16F9       	  .ascic \\		; use auxillary 
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 129
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     16F9       	.endc			; end if
                                     16F9       else:			; use  of word as vl_compiler label
                                     16F9       	
                       89   31   90  16F9  3096 	movb	#op_brw,(r9)+		; branch over false part
                       50   59   D0  16FC  3097 	movl	r9,r0			; save address of displacement
                       89   00   B0  16FF  3098 	movw	#0,(r9)+		; save space for displacement
                       51   59   D0  1702  3099 	movl	r9,r1			; save address to calculate
                                     1705  3100 					;   displacement from
                                     1705  3101 ; make branch to false part (fill in displacement in if)
                  52   59   8A   C3  1705  3102 	subl3	(r10)+,r9,r2		; calculate displacement
                    00 BA   52   B0  1709  3103 	movw	r2,@(r10)		; save displacment
                       5A   04   C0  170D  3104 	addl2	#4,r10			; pop address of displacement off lstack
                       7A   50   D0  1710  3105 	movl	r0,-(r10)		; save address of displacement
                       7A   51   D0  1713  3106 	movl	r1,-(r10)		; save address to displace from
                                 05  1716  3107 	rsb				; end of else
                                     1717  3108 
                                     1717  3109 
                                     1717  3110 ;+++
                                     1717  3111 ;c> endif -- ( -- ) { endif } ends either of { if } or { else } branches.
                                     1717  3112 ;	{ if ... else ... endif } and { if ... endif } are both legal.
                                     1717  3113 ;---
                                     1717  3114 	header	endif,,vl_compiler
                           000016F0' 1717       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001717  171B       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  171B       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  171B       	.if    le, nchr		; nchr <= 0
                  66 69 64 6E 65 00' 171B       	   .ascic \endif\	; no auxillary , use principle one
                                 05  171B       
                                     1721       	.if_false		; else
                                     1721       	  .ascic \\		; use auxillary 
                                     1721       	.endc			; end if
                                     1721       endif:			; use  of word as vl_compiler label
                                     1721       	
                  50   59   8A   C3  1721  3115 	subl3	(r10)+,r9,r0		; calculate displacement
                    00 BA   50   B0  1725  3116 	movw	r0,@(r10)		; save displacement
                       5A   04   C0  1729  3117 	addl2	#4,r10			; pop address of displacement off lstack
                                 05  172C  3118 	rsb				; end of endif
                                     172D  3119 
                                     172D  3120 
                                     172D  3121 ;+++
                                     172D  3122 ;c> endwhile -- ( -- ) ends a { while ... endwhile }.  Unconditionally branches
                                     172D  3123 ;	back to { while }.
                                     172D  3124 ;---
                                     172D  3125 	header	endwhile,,vl_compiler
                           00001717' 172D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000172D  1731       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1731       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1731       	.if    le, nchr		; nchr <= 0
         65 6C 69 68 77 64 6E 65 00' 1731       	   .ascic \endwhile\	; no auxillary , use principle one
                                 08  1731       
                                     173A       	.if_false		; else
                                     173A       	  .ascic \\		; use auxillary 
                                     173A       	.endc			; end if
                                     173A       endwhile:			; use  of word as vl_compiler label
                                     173A       	
                       89   31   90  173A  3126 	movb	#op_brw,(r9)+		; brw back to test
                       50   59   D0  173D  3127 	movl	r9,r0			; address to put displacement in
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 130
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       89   00   B0  1740  3128 	movw	#0,(r9)+		; save space for displacement
                  51   59   8A   C3  1743  3129 	subl3	(r10)+,r9,r1		; displacement to after loop
                    00 BA   51   B0  1747  3130 	movw	r1,@(r10)		; fill in displacement to after loop
                       5A   04   C0  174B  3131 	addl2	#4,r10			; pop off address of displacement
                  51   8A   59   C3  174E  3132 	subl3	r9,(r10)+,r1		; displacement back to beginning
                       60   51   B0  1752  3133 	movw	r1,(r0)			; save displacement
                                 05  1755  3134 	rsb				; end of endwhile
                                     1756  3135 
                                     1756  3136 
                                     1756  3137 ;+++
                                     1756  3138 ;c> if -- ( n -- ) In { if ... else ... endif } or { if ... endif },
                                     1756  3139 ;	if the top of the stack is true, execute the code following
                                     1756  3140 ;	the { if } until an { endif } or an { else }.  At an { else } skip to
                                     1756  3141 ;	the code after the { endif }.  If the top of the stack
                                     1756  3142 ;	is false, skip to the { endif } or { else }.
                                     1756  3143 ;	In the { repeat ... if ... again } if the top fo the stack is true the
                                     1756  3144 ;	code up to the { again } is executed and then a branch back to
                                     1756  3145 ;	{ repeat } is done.  If the top of the stack is false, execution jumps
                                     1756  3146 ;	to the code after the { again }.
                                     1756  3147 ;---
                                     1756  3148 	header	if,,vl_compiler
                           0000172D' 1756       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001756  175A       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  175A       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  175A       	.if    le, nchr		; nchr <= 0
                           66 69 00' 175A       	   .ascic \if\	; no auxillary , use principle one
                                 02  175A       
                                     175D       	.if_false		; else
                                     175D       	  .ascic \\		; use auxillary 
                                     175D       	.endc			; end if
                                     175D       if:			; use  of word as vl_compiler label
                                     175D       	
                    89   D5 8F   90  175D  3149 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  1761  3150 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  1765  3151 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  1768  3152 	movb	#^x03,(r9)+		; to (pc+3)
                       89   31   90  176B  3153 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  176E  3154 	movl	r9,-(r10)		; save address of displacement
                       89   00   B0  1771  3155 	movw	#0,(r9)+		; save space for displacmnent
                       7A   59   D0  1774  3156 	movl	r9,-(r10)		; save address to calculate
                                     1777  3157 					;   displacement from
                                 05  1777  3158 	rsb				; end of if
                                     1778  3159 
                                     1778  3160 
                                     1778  3161 ;+++
                                     1778  3162 ;c> l^ -- ( -- ) Convert next token to number and enclose in dictionary.
                                     1778  3163 ;---
                                     1778  3164 	header	i_l_up,<l^>,vl_compiler
                           00001756' 1778       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001778  177C       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  177C       	.nchr  nchr, ^\l^\	; nchr = length( l^ )
                           00000002  177C       	.if    le, nchr		; nchr <= 0
                                     177C       	   .ascic \i_l_up\	; no auxillary l^, use principle one
                                     177C       	.if_false		; else
                           5E 6C 00' 177C       	  .ascic \l^\		; use auxillary l^
                                 02  177C       
                                     177F       	.endc			; end if
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 131
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     177F       i_l_up:			; use l^ of word as vl_compiler label
                                     177F       	
                       7B   20   D0  177F  3165 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FB58 CF   16  1782  3166 	jsb	token			; get it
                       F592 CF   16  1786  3167 	jsb	number			; try to make it a number
                            8B   D5  178A  3168 	tstl	(r11)+			; Is it a number>
                            01   12  178C  3169 	bneq	10$			; yes
                                 05  178E  3170 	rsb				; no, for now just exit~~~ WTF, no error?
                                     178F  3171 10$:
                       89   8B   D0  178F  3172 	movl	(r11)+,(r9)+		; save long in dictionary
                                 05  1792  3173 	rsb				; end of l^
                                     1793  3174 
                                     1793  3175 
                                     1793  3176 ;+++
                                     1793  3177 ;c> literal -- ( n -- ) convert top of stack to a literal in current word.
                                     1793  3178 ;---
                                     1793  3179 	header	literal,,vl_compiler
                           00001778' 1793       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001793  1797       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1797       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1797       	.if    le, nchr		; nchr <= 0
            6C 61 72 65 74 69 6C 00' 1797       	   .ascic \literal\	; no auxillary , use principle one
                                 07  1797       
                                     179F       	.if_false		; else
                                     179F       	  .ascic \\		; use auxillary 
                                     179F       	.endc			; end if
                                     179F       literal:			; use  of word as vl_compiler label
                                     179F       	
                    89   D0 8F   90  179F  3180 	movb	#op_movl,(r9)+		; `movl'
                    89   8F 8F   90  17A3  3181 	movb	#adm_immediate,(r9)+	; immediate mode
                       89   8B   D0  17A7  3182 	movl	(r11)+,(r9)+		; move top of stack into dictionary
                    89   7B 8F   90  17AA  3183 	movb	#adm_adec_r11,(r9)+	; -(r11)
                                 05  17AE  3184 	rsb				; end of literal
                                     17AF  3185 
                                     17AF  3186 
                                     17AF  3187 ;+++
                                     17AF  3188 ;c> loop -- ( -- ) Ends a { do ... loop }.  Adds 1 to loop index and branches
                                     17AF  3189 ;	to { do } if ((index >= 0) and (index < limit)).  In other words,
                                     17AF  3190 ;	{ loop } is like Pascal's { for index := start to finish do ... }.
                                     17AF  3191 ;---
                                     17AF  3192 	header	i_loop,<loop>,vl_compiler ; VAX/VMS debuffer thinks loop is a a command
                           00001793' 17AF       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000017AF  17B3       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000004  17B3       	.nchr  nchr, ^\loop\	; nchr = length( loop )
                           00000004  17B3       	.if    le, nchr		; nchr <= 0
                                     17B3       	   .ascic \i_loop\	; no auxillary loop, use principle one
                                     17B3       	.if_false		; else
                     70 6F 6F 6C 00' 17B3       	  .ascic \loop\		; use auxillary loop
                                 04  17B3       
                                     17B8       	.endc			; end if
                                     17B8       i_loop:			; use loop of word as vl_compiler label
                                     17B8       	
                    89   F1 8F   90  17B8  3193 	movb	#op_acbl,(r9)+		  ; `acbl'
                    89   AA 8F   90  17BC  3194 	movb	#adm_b_dis_r10,(r9)+	  ; b^(r10)
                       89   04   90  17C0  3195 	movb	#4,(r9)+		  ; 4 byte displacement for previous adm
                       89   01   90  17C3  3196 	movb	#^x01,(r9)+		  ; s^#1
                    89   6A 8F   90  17C6  3197 	movb	#adm_def_r10,(r9)+	  ; (r10)
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 132
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                       50   59   D0  17CA  3198 	movl	r9,r0			  ; save address of branch word
                       89   00   B0  17CD  3199 	movw	#0,(r9)+		  ; save space for branch displacement
                  51   8A   59   C3  17D0  3200 	subl3	r9,(r10)+,r1		  ; calculate displacement
                       60   51   B0  17D4  3201 	movw	r1,(r0)			  ; save displacement
                    89   C0 8F   90  17D7  3202 	movb	#op_addl2,(r9)+		  ; `addl2'	pop index&limit from lstack
                       89   08   90  17DB  3203 	movb	#^x08,(r9)+		  ; s^#8
                    89   5A 8F   90  17DE  3204 	movb	#adm_r10,(r9)+		  ; r10
                                 05  17E2  3205 	rsb				  ; end of loop
                                     17E3  3206 
                                     17E3  3207 
                                     17E3  3208 ;+++
                                     17E3  3209 ;c> recurse -- ( -- ) Compile a jsb to the word that is currently being defined,
                                     17E3  3210 ;	allowing recursion.
                                     17E3  3211 ;---
                                     17E3  3212 	header	recurse,,vl_compiler
                           000017AF' 17E3       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000017E3  17E7       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  17E7       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  17E7       	.if    le, nchr		; nchr <= 0
            65 73 72 75 63 65 72 00' 17E7       	   .ascic \recurse\	; no auxillary , use principle one
                                 07  17E7       
                                     17EF       	.if_false		; else
                                     17EF       	  .ascic \\		; use auxillary 
                                     17EF       	.endc			; end if
                                     17EF       recurse:			; use  of word as vl_compiler label
                                     17EF       	
              7B   00001D37'FF   D0  17EF  3213 	movl	@v_context,-(r11)	; get address of current word
                       EF4A CF   16  17F6  3214 	jsb	cfa			; get the code field address
                       EFA4 CF   16  17FA  3215 	jsb	i_compile_jsb		; compile it into current word
                                 05  17FE  3216 	rsb				; end of recurse
                                     17FF  3217 
                                     17FF  3218 
                                     17FF  3219 ;+++
                                     17FF  3220 ;c> repeat -- ( -- ) Start { repeat ... until } and { repeat ... if ... again }
                                     17FF  3221 ;	loops.
                                     17FF  3222 ;---
                                     17FF  3223 	header	repeat,,vl_compiler
                           000017E3' 17FF       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           000017FF  1803       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1803       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1803       	.if    le, nchr		; nchr <= 0
               74 61 65 70 65 72 00' 1803       	   .ascic \repeat\	; no auxillary , use principle one
                                 06  1803       
                                     180A       	.if_false		; else
                                     180A       	  .ascic \\		; use auxillary 
                                     180A       	.endc			; end if
                                     180A       repeat:			; use  of word as vl_compiler label
                                     180A       	
                       7A   59   D0  180A  3224 	movl	r9,-(r10)		; save address to branch to
                                 05  180D  3225 	rsb				; end of repeat
                                     180E  3226 
                                     180E  3227 
                                     180E  3228 ;+++
                                     180E  3229 ;c> w^ -- ( -- ) Convert next token to number, enclose low 16 bits in dictionary.
                                     180E  3230 ;	This is used with the assembler, mainly, which is why it is w^ instead
                                     180E  3231 ;	of  s^.
                                     180E  3232 ;---
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 133
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     180E  3233 	header	i_s_up,<w^>,vl_compiler
                           000017FF' 180E       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000180E  1812       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000002  1812       	.nchr  nchr, ^\w^\	; nchr = length( w^ )
                           00000002  1812       	.if    le, nchr		; nchr <= 0
                                     1812       	   .ascic \i_s_up\	; no auxillary w^, use principle one
                                     1812       	.if_false		; else
                           5E 77 00' 1812       	  .ascic \w^\		; use auxillary w^
                                 02  1812       
                                     1815       	.endc			; end if
                                     1815       i_s_up:			; use w^ of word as vl_compiler label
                                     1815       	
                       7B   20   D0  1815  3234 	movl	#c_blank,-(r11)		; set up for blank delimited token
                       FAC2 CF   16  1818  3235 	jsb	token			; get it
                       F4FC CF   16  181C  3236 	jsb	number			; try to make it a number
                            8B   D5  1820  3237 	tstl	(r11)+			; Is it a number?
                            01   12  1822  3238 	bneq	10$			; yes
                                 05  1824  3239 	rsb				; no, for now just exit~~~ WTF, no error?
                                     1825  3240 10$:
                       89   6B   B0  1825  3241 	movw	(r11),(r9)+		; save word in dictionary
                       5B   04   C0  1828  3242 	addl2	#4,r11			; pop value from dstack
                                 05  182B  3243 	rsb				; end of w^
                                     182C  3244 
                                     182C  3245 
                                     182C  3246 ;+++
                                     182C  3247 ;c> until -- ( f -- ) End a { repeat ... until } loop.  If top of stack is
                                     182C  3248 ;	false, branch back to the { repeat }, else fall out of loop.
                                     182C  3249 ;---
                                     182C  3250 	header	until,,v1_compiler
                           0000182C' 182C       	.long	v1_compiler		; back link to the previous word in this v1_compiler
                           0000182C  1830       	v1_compiler = . - 4		; where to link the next word to in this v1_compiler
                           00000000  1830       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1830       	.if    le, nchr		; nchr <= 0
                  6C 69 74 6E 75 00' 1830       	   .ascic \until\	; no auxillary , use principle one
                                 05  1830       
                                     1836       	.if_false		; else
                                     1836       	  .ascic \\		; use auxillary 
                                     1836       	.endc			; end if
                                     1836       until:			; use  of word as v1_compiler label
                                     1836       	
                    89   D5 8F   90  1836  3251 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  183A  3252 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  183E  3253 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  1841  3254 	movb	#3,(r9)+		; (pc+3)
                       89   31   90  1844  3255 	movb	#op_brw,(r9)+		; `brw'
                       50   59   D0  1847  3256 	movl	r9,r0			; save address of displacement
                       89   00   B0  184A  3257 	movw	#0,(r9)+		; save space for displacement
                  51   8A   59   C3  184D  3258 	subl3	r9,(r10)+,r1		; calcualte negative displacement
                       6A   51   B0  1851  3259 	movw	r1,(r10)		; save negative displacement
                                 05  1854  3260 	rsb				; end of until
                                     1855  3261 
                                     1855  3262 
                                     1855  3263 ;+++
                                     1855  3264 ;c> while -- ( f -- ) Start a { while ... endwhile } loop.  If top of stack
                                     1855  3265 ;	is true, execute code to { endwhile }, which loops back to { while }.
                                     1855  3266 ;	If false, skip to after the { endwhile }.
                                     1855  3267 ;---
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 134
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1855  3268 	header	while,,vl_compiler
                           0000180E' 1855       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           00001855  1859       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000000  1859       	.nchr  nchr, ^\\	; nchr = length(  )
                           00000000  1859       	.if    le, nchr		; nchr <= 0
                  65 6C 69 68 77 00' 1859       	   .ascic \while\	; no auxillary , use principle one
                                 05  1859       
                                     185F       	.if_false		; else
                                     185F       	  .ascic \\		; use auxillary 
                                     185F       	.endc			; end if
                                     185F       while:			; use  of word as vl_compiler label
                                     185F       	
                       7A   59   D0  185F  3269 	movl	r9,-(r10)		; save address to branch to at endwhile
                    89   D5 8F   90  1862  3270 	movb	#op_tstl,(r9)+		; `tstl'
                    89   8B 8F   90  1866  3271 	movb	#adm_ainc_r11,(r9)+	; (r11)+
                       89   12   90  186A  3272 	movb	#op_bneq,(r9)+		; `bneq'
                       89   03   90  186D  3273 	movb	#3,(r9)+		; over brw false_part
                       89   31   90  1870  3274 	movb	#op_brw,(r9)+		; `brw'
                       7A   59   D0  1873  3275 	movl	r9,-(r10)		; save address of displacement to
                                     1876  3276 					;   statements after loop
                       89   00   B0  1876  3277 	movw	#0,(r9)+		; save space for displacement
                       7A   59   D0  1879  3278 	movl	r9,-(r10)		; address to make diplacement to
                                     187C  3279 					;   after loop from~~~ awkward phrasing
                                 05  187C  3280 	rsb				; end of while
                                     187D  3281 
                                     187D  3282 
                                     187D  3283 ;+++
                                     187D  3284 ;c> [ -- ( -- ) leave compile mode without terminating definition.
                                     187D  3285 ;	Must be followed by { ] }.
                                     187D  3286 ;---
                                     187D  3287 	header	i_left_brack,<[>,vl_compiler
                           00001855' 187D       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000187D  1881       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000001  1881       	.nchr  nchr, ^\[\	; nchr = length( [ )
                           00000001  1881       	.if    le, nchr		; nchr <= 0
                                     1881       	   .ascic \i_left_brack\	; no auxillary [, use principle one
                                     1881       	.if_false		; else
                              5B 00' 1881       	  .ascic \[\		; use auxillary [
                                 01  1881       
                                     1883       	.endc			; end if
                                     1883       i_left_brack:			; use [ of word as vl_compiler label
                                     1883       	
              00001D4D'EF   00   90  1883  3288 	movb	#c_false,v_mode
                                 05  188A  3289 	rsb				; end of [
                                     188B  3290 
                                     188B  3291 
                                     188B  3292 ;+++
                                     188B  3293 ;c> [ascii] -- ( -- ) compile ascii value of 1st char of next token into word.
                                     188B  3294 ;---
                                     188B  3295 	header	i_compile_ascii,<[ascii]>,vl_compiler
                           0000187D' 188B       	.long	vl_compiler		; back link to the previous word in this vl_compiler
                           0000188B  188F       	vl_compiler = . - 4		; where to link the next word to in this vl_compiler
                           00000007  188F       	.nchr  nchr, ^\[ascii]\	; nchr = length( [ascii] )
                           00000007  188F       	.if    le, nchr		; nchr <= 0
                                     188F       	   .ascic \i_compile_ascii\	; no auxillary [ascii], use principle one
                                     188F       	.if_false		; else
            5D 69 69 63 73 61 5B 00' 188F       	  .ascic \[ascii]\		; use auxillary [ascii]
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 135
V1.01                           cCompiler Built-ins                      12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                 07  188F       
                                     1897       	.endc			; end if
                                     1897       i_compile_ascii:			; use [ascii] of word as vl_compiler label
                                     1897       	
                       7B   20   D0  1897  3296 	movl	#c_blank,-(r11)		; set up for blank separated token
                       FA40 CF   16  189A  3297 	jsb	token			; get it
                    7B   01 A9   9A  189E  3298 	movzbl	1(r9),-(r11)		; put ascii value of 1st char of token on stack
                       FEF9 CF   16  18A2  3299 	jsb	literal			; compile it into the dictionary
                                 05  18A6  3300 	rsb				; end of ascii
                                     18A7  3301 
                                     18A7  3302 
                                     18A7  3303 _compiler_end:
                                     18A7  3304 	newpage <Enter VTIL>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 136
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     18A7       	.sbttl	Enter VTIL
                                     18A7       	
                                     18A7  3305 ;*******************************************************************************
                                     18A7  3306 ;
                                     18A7  3307 ; Enter VTIL -- Set up condition handler and call main program.
                                     18A7  3308 ;
                                     18A7  3309 ;*******************************************************************************
                                     18A7  3310 
                                     18A7  3311 
                                     18A7  3312 ;+++
                                     18A7  3313 ;s> vtil -- entry procedure of vtil
                                     18A7  3314 ;---
                               0FC0  18A7  3315 	.entry	vtil,^m<r6,r7,r8,r9,r10,r11>
                                     18A9  3316     .if defined ca_trapping
                                     18A9  3317         .print ; Trapping is enabled

              6D   00001970'EF   DE  18A9  3318 	moval	s_trap,(fp)		; set up condition handler
                                     18B0  3319     .if_false
                                     18B0  3320         .print ; Trapping is not enabled
                                     18B0  3321     .endc
                                     18B0  3322     .if defined ca_controlc
                                     18B0  3323         .print ; Control/C Trapping is enabled

                                     18B0  3324 ; If a terminal, set up control/c trap
                                     18B0  3325 	$assign_s chan=v_input_chan,-	; connect to sys$command
                                     18B0  3326 		devnam=v_input_name
                                     18B0       		.GLOBL	SYS$ASSIGN
                            00   DD  18B0       		PUSHL	#0
                                     18B2       		$ASNPUSH 0,#0
                           00000000  18B2       		$$T1 = 0
                                     18B2       		.IF IDN,<0>,<0>
                                     18B2       		.IF IDN,<#0>,<#0>
                           00000001  18B2       		$$T1 = 1
                                     18B2       		.ENDC
                                     18B2       		.ENDC
                           00000001  18B2       		.IF NE $$T1
                            7E   7C  18B2       		CLRQ	-(SP)
                                     18B4       		.IFF
                                     18B4       		$PUSHADR 0,CONTEXT=Q
                                     18B4       		PUSHL	#0
                                     18B4       		.ENDC
                                     18B4       	
                                     18B4       		$PUSHADR v_input_chan,CONTEXT=W
                                     18B4       		.IF	IDN,0,v_input_chan
                                     18B4       		PUSHL	#0
                                     18B4       		.IFF
                           00000000  18B4       		.IF EQ	12-12
                           00000000  18B4       		.IF NE	12-12
                                     18B4       		PUSHAW	v_input_chan
                                     18B4       		.MEXIT
                                     18B4       		.ENDC
                                     18B4       		.ENDC
                           000000CF  18B4       		.NTYPE	$$$ADR, v_input_chan
                           000000C0  18B4       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  18B4       		.IF GT	$$$ADR - ^XFF
                                     18B4       		PUSHAW	v_input_chan
                                     18B4       		.MEXIT
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 137
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     18B4       		.ENDC
                           00000040  18B4       		.IF EQ	$$$ADR - ^X80
                                     18B4       		PUSHAW	v_input_chan
                                     18B4       		.MEXIT
                                     18B4       		.ENDC
                           00000050  18B4       		.IF EQ	$$$ADR - ^X70
                                     18B4       		PUSHAW	v_input_chan
                                     18B4       		.MEXIT
                                     18B4       		.ENDC
                   00001D11'EF   9F  18B4       		PUSHAB	v_input_chan
                                     18BA       		.ENDC
                                     18BA       	
                                     18BA       		$PUSHADR v_input_name,CONTEXT=Q
                                     18BA       		.IF	IDN,0,v_input_name
                                     18BA       		PUSHL	#0
                                     18BA       		.IFF
                           00000000  18BA       		.IF EQ	12-12
                           00000000  18BA       		.IF NE	12-12
                                     18BA       		PUSHAQ	v_input_name
                                     18BA       		.MEXIT
                                     18BA       		.ENDC
                                     18BA       		.ENDC
                           000000CF  18BA       		.NTYPE	$$$ADR, v_input_name
                           000000C0  18BA       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  18BA       		.IF GT	$$$ADR - ^XFF
                                     18BA       		PUSHAQ	v_input_name
                                     18BA       		.MEXIT
                                     18BA       		.ENDC
                           00000040  18BA       		.IF EQ	$$$ADR - ^X80
                                     18BA       		PUSHAQ	v_input_name
                                     18BA       		.MEXIT
                                     18BA       		.ENDC
                           00000050  18BA       		.IF EQ	$$$ADR - ^X70
                                     18BA       		PUSHAQ	v_input_name
                                     18BA       		.MEXIT
                                     18BA       		.ENDC
                   00001CFE'EF   9F  18BA       		PUSHAB	v_input_name
                                     18C0       		.ENDC
                                     18C0       	
              00000000'GF   05   FB  18C0       		CALLS	#5,G^SYS$ASSIGN
                                     18C7       	
                         03 50   E8  18C7  3327 	blbs	r0,1$			; exit on error~~~Success, so branch over error exit
                          0065   31  18CA  3328 	brw	vtil_exit		; exit vtil
                                     18CD  3329 1$:
                                     18CD  3330 	$getchn_s chan=v_input_chan,-	; find out if it is a terminal
                                     18CD  3331 		prilen=v_getchn_ret_len,- ; where to put length
                                     18CD  3332 		pribuf=v_getchn_in_buf  ; where to find input buffer
                                     18CD       		.GLOBL	SYS$GETCHN
                                     18CD       		$PUSHADR 0,CONTEXT=Q
                                     18CD       		.IF	IDN,0,0
                            00   DD  18CD       		PUSHL	#0
                                     18CF       		.IFF
                                     18CF       		.IF EQ	1-1
                                     18CF       		.IF NE	1-1
                                     18CF       		PUSHAQ	0
                                     18CF       		.MEXIT
                                     18CF       		.ENDC
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 138
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     18CF       		.ENDC
                                     18CF       		.NTYPE	$$$ADR, 0
                                     18CF       $$$ADR	=	$$$ADR & ^XFFF0
                                     18CF       		.IF GT	$$$ADR - ^XFF
                                     18CF       		PUSHAQ	0
                                     18CF       		.MEXIT
                                     18CF       		.ENDC
                                     18CF       		.IF EQ	$$$ADR - ^X80
                                     18CF       		PUSHAQ	0
                                     18CF       		.MEXIT
                                     18CF       		.ENDC
                                     18CF       		.IF EQ	$$$ADR - ^X70
                                     18CF       		PUSHAQ	0
                                     18CF       		.MEXIT
                                     18CF       		.ENDC
                                     18CF       		PUSHAB	0
                                     18CF       		.ENDC
                                     18CF       	
                                     18CF       		$PUSHADR 0,CONTEXT=W
                                     18CF       		.IF	IDN,0,0
                            00   DD  18CF       		PUSHL	#0
                                     18D1       		.IFF
                                     18D1       		.IF EQ	1-1
                                     18D1       		.IF NE	1-1
                                     18D1       		PUSHAW	0
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                                     18D1       		.ENDC
                                     18D1       		.NTYPE	$$$ADR, 0
                                     18D1       $$$ADR	=	$$$ADR & ^XFFF0
                                     18D1       		.IF GT	$$$ADR - ^XFF
                                     18D1       		PUSHAW	0
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                                     18D1       		.IF EQ	$$$ADR - ^X80
                                     18D1       		PUSHAW	0
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                                     18D1       		.IF EQ	$$$ADR - ^X70
                                     18D1       		PUSHAW	0
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                                     18D1       		PUSHAB	0
                                     18D1       		.ENDC
                                     18D1       	
                                     18D1       		$PUSHADR v_getchn_in_buf,CONTEXT=Q
                                     18D1       		.IF	IDN,0,v_getchn_in_buf
                                     18D1       		PUSHL	#0
                                     18D1       		.IFF
                           00000000  18D1       		.IF EQ	15-15
                           00000000  18D1       		.IF NE	15-15
                                     18D1       		PUSHAQ	v_getchn_in_buf
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                                     18D1       		.ENDC
                           000000CF  18D1       		.NTYPE	$$$ADR, v_getchn_in_buf
                           000000C0  18D1       $$$ADR	=	$$$ADR & ^XFFF0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 139
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           FFFFFFC1  18D1       		.IF GT	$$$ADR - ^XFF
                                     18D1       		PUSHAQ	v_getchn_in_buf
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                           00000040  18D1       		.IF EQ	$$$ADR - ^X80
                                     18D1       		PUSHAQ	v_getchn_in_buf
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                           00000050  18D1       		.IF EQ	$$$ADR - ^X70
                                     18D1       		PUSHAQ	v_getchn_in_buf
                                     18D1       		.MEXIT
                                     18D1       		.ENDC
                   00001D17'EF   9F  18D1       		PUSHAB	v_getchn_in_buf
                                     18D7       		.ENDC
                                     18D7       	
                                     18D7       		$PUSHADR v_getchn_ret_len,CONTEXT=W
                                     18D7       		.IF	IDN,0,v_getchn_ret_len
                                     18D7       		PUSHL	#0
                                     18D7       		.IFF
                           00000000  18D7       		.IF EQ	16-16
                           00000000  18D7       		.IF NE	16-16
                                     18D7       		PUSHAW	v_getchn_ret_len
                                     18D7       		.MEXIT
                                     18D7       		.ENDC
                                     18D7       		.ENDC
                           000000CF  18D7       		.NTYPE	$$$ADR, v_getchn_ret_len
                           000000C0  18D7       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  18D7       		.IF GT	$$$ADR - ^XFF
                                     18D7       		PUSHAW	v_getchn_ret_len
                                     18D7       		.MEXIT
                                     18D7       		.ENDC
                           00000040  18D7       		.IF EQ	$$$ADR - ^X80
                                     18D7       		PUSHAW	v_getchn_ret_len
                                     18D7       		.MEXIT
                                     18D7       		.ENDC
                           00000050  18D7       		.IF EQ	$$$ADR - ^X70
                                     18D7       		PUSHAW	v_getchn_ret_len
                                     18D7       		.MEXIT
                                     18D7       		.ENDC
                   00001D13'EF   9F  18D7       		PUSHAB	v_getchn_ret_len
                                     18DD       		.ENDC
                                     18DD       	
              7E   00001D11'EF   3C  18DD       		MOVZWL	v_input_chan,-(SP)
              00000000'GF   05   FB  18E4       		CALLS	#5,G^SYS$GETCHN
                                     18EB       	
                                     18EB  3333 
           00001D23'EF   00'8F   91  18EB  3334 	cmpb	#dc$_term,v_getchn_buf+4 ; is it a terminal?
                            2D   12  18F3  3335 	bneq	5$			; not a terminal, so don't enable ctr-c
                                     18F5  3336 ; enable control-c trapping
                                     18F5  3337 	.show	   meb,me
                                     18F5  3338 	$qio_s	chan=v_input_chan,-
                                     18F5  3339 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     18F5  3340 		p1=enable_ctrlc,-
                                     18F5  3341 		p3=#3
                                     18F5       		.GLOBL	SYS$QIO
                                     18F5       		$PUSHTWO #0,#0
                           00000000  18F5       		$$T1 = 0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 140
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     18F5       		.IF	IDN,<#0>,<#0>
                                     18F5       		.IF	IDN,<#0>,<#0>
                           00000001  18F5       		$$T1 = 1
                                     18F5       		.ENDC
                                     18F5       		.ENDC
                           00000001  18F5       		.IF	NE	$$T1
                            7E   7C  18F5       		CLRQ	-(SP)
                                     18F7       		.IFF
                                     18F7       		PUSHL	#0
                                     18F7       		PUSHL	#0
                                     18F7       		.ENDC
                                     18F7       	
                                     18F7       		$PUSHTWO #0,#3
                           00000000  18F7       		$$T1 = 0
                                     18F7       		.IF	IDN,<#0>,<#0>
                                     18F7       		.IF	IDN,<#0>,<#3>
                                     18F7       		$$T1 = 1
                                     18F7       		.ENDC
                                     18F7       		.ENDC
                           00000000  18F7       		.IF	NE	$$T1
                                     18F7       		CLRQ	-(SP)
                                     18F7       		.IFF
                            00   DD  18F7       		PUSHL	#0
                            03   DD  18F9       		PUSHL	#3
                                     18FB       		.ENDC
                                     18FB       	
                            00   DD  18FB       		PUSHL	#0
                                     18FD       		$PUSHADR enable_ctrlc
                                     18FD       		.IF	IDN,0,enable_ctrlc
                                     18FD       		PUSHL	#0
                                     18FD       		.IFF
                           00000000  18FD       		.IF EQ	12-12
                           00000000  18FD       		.IF NE	12-12
                                     18FD       		PUSHAL	enable_ctrlc
                                     18FD       		.MEXIT
                                     18FD       		.ENDC
                                     18FD       		.ENDC
                           000000EF  18FD       		.NTYPE	$$$ADR, enable_ctrlc
                           000000E0  18FD       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFE1  18FD       		.IF GT	$$$ADR - ^XFF
                                     18FD       		PUSHAL	enable_ctrlc
                                     18FD       		.MEXIT
                                     18FD       		.ENDC
                           00000060  18FD       		.IF EQ	$$$ADR - ^X80
                                     18FD       		PUSHAL	enable_ctrlc
                                     18FD       		.MEXIT
                                     18FD       		.ENDC
                           00000070  18FD       		.IF EQ	$$$ADR - ^X70
                                     18FD       		PUSHAL	enable_ctrlc
                                     18FD       		.MEXIT
                                     18FD       		.ENDC
                   0000193C'EF   9F  18FD       		PUSHAB	enable_ctrlc
                                     1903       		.ENDC
                                     1903       	
                                     1903       		$QIOPUSH #0,0
                           00000000  1903       		$$T1 = 0
                                     1903       		.IF	IDN,<#0>,<#0>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 141
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1903       		.IF	IDN,<0>,<0>
                           00000001  1903       		$$T1 = 1
                                     1903       		.ENDC
                                     1903       		.ENDC
                           00000001  1903       		.IF	NE $$T1
                            7E   7C  1903       		CLRQ	-(SP)
                                     1905       		.IFF
                                     1905       		PUSHL	#0
                                     1905       		$PUSHADR 0
                                     1905       		.ENDC
                                     1905       	
                                     1905       		$PUSHADR 0,CONTEXT=Q
                                     1905       		.IF	IDN,0,0
                            00   DD  1905       		PUSHL	#0
                                     1907       		.IFF
                                     1907       		.IF EQ	1-1
                                     1907       		.IF NE	1-1
                                     1907       		PUSHAQ	0
                                     1907       		.MEXIT
                                     1907       		.ENDC
                                     1907       		.ENDC
                                     1907       		.NTYPE	$$$ADR, 0
                                     1907       $$$ADR	=	$$$ADR & ^XFFF0
                                     1907       		.IF GT	$$$ADR - ^XFF
                                     1907       		PUSHAQ	0
                                     1907       		.MEXIT
                                     1907       		.ENDC
                                     1907       		.IF EQ	$$$ADR - ^X80
                                     1907       		PUSHAQ	0
                                     1907       		.MEXIT
                                     1907       		.ENDC
                                     1907       		.IF EQ	$$$ADR - ^X70
                                     1907       		PUSHAQ	0
                                     1907       		.MEXIT
                                     1907       		.ENDC
                                     1907       		PUSHAB	0
                                     1907       		.ENDC
                                     1907       	
                  7E   0000'8F   3C  1907       		MOVZWL	#IO$_SETMODE!IO$M_CTRLCAST,-(SP)
              7E   00001D11'EF   3C  190C       		MOVZWL	v_input_chan,-(SP)
                            00   DD  1913       		PUSHL	#0
              00000000'GF   0C   FB  1915       		CALLS	#12,G^SYS$QIO
                                     191C       	
                         03 50   E8  191C  3342 	blbs	r0,6$			; no error, go on, don't deassign channel
                          0010   31  191F  3343 	brw	vtil_exit
                                     1922  3344 5$:
                                     1922  3345 ;	$dassign_s chan=v_input_chan    ; channel not a terminal, deassign it.
                                     1922  3346 6$:
                                     1922  3347     .if_false
                                     1922  3348         print ; Control/c trapping not enabled
                                     1922  3349     .endc
                                     1922  3350 
              000019DA'EF   00   FB  1922  3351 	calls	#0,s_cold_start		; call subroutine to start from scratch
                                     1929  3352 ; If we have returned from cold start there was an error caught by the
                                     1929  3353 ; trap subroutine and we want to a warm start.
                                     1929  3354 10$:
              00001A22'EF   00   FB  1929  3355 	calls	#0,s_warm_start		; call subroutine to do warm start.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 142
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1930  3356 ; If we have returned from warm start there was an error caught by the
                                     1930  3357 ; trap subroutine and we want to do another warm start.
                            F7   11  1930  3358 	brb	10$
                                     1932  3359 
                                     1932  3360 ;+++
                                     1932  3361 ;r> vtil_exit -- exit if errors in setting up control-c ast or traps
                                     1932  3362 ;---
                                     1932  3363 vtil_exit:
                            50   DD  1932  3364 	pushl	r0
              00000000'GF   01   FB  1934  3365 	calls	#1,g^lib$signal
                                 04  193B  3366 	ret				; this is return from main program.
                                     193C  3367 
                                     193C  3368 
                                     193C  3369 ;+++
                                     193C  3370 ;s> enable_ctrlc -- enable controlc trapping.
                                     193C  3371 ;---
                               0000  193C  3372 	.entry	enable_ctrlc,^m<>
                                     193E  3373 ; reenable ctrlc handler...
                                     193E  3374 	$qio_s	chan=v_input_chan,-
                                     193E  3375 		func=#IO$_SETMODE!IO$M_CTRLCAST,-
                                     193E  3376 		p1=enable_ctrlc,-
                                     193E  3377 		p3=#3
                                     193E       		.GLOBL	SYS$QIO
                                     193E       		$PUSHTWO #0,#0
                           00000000  193E       		$$T1 = 0
                                     193E       		.IF	IDN,<#0>,<#0>
                                     193E       		.IF	IDN,<#0>,<#0>
                           00000001  193E       		$$T1 = 1
                                     193E       		.ENDC
                                     193E       		.ENDC
                           00000001  193E       		.IF	NE	$$T1
                            7E   7C  193E       		CLRQ	-(SP)
                                     1940       		.IFF
                                     1940       		PUSHL	#0
                                     1940       		PUSHL	#0
                                     1940       		.ENDC
                                     1940       	
                                     1940       		$PUSHTWO #0,#3
                           00000000  1940       		$$T1 = 0
                                     1940       		.IF	IDN,<#0>,<#0>
                                     1940       		.IF	IDN,<#0>,<#3>
                                     1940       		$$T1 = 1
                                     1940       		.ENDC
                                     1940       		.ENDC
                           00000000  1940       		.IF	NE	$$T1
                                     1940       		CLRQ	-(SP)
                                     1940       		.IFF
                            00   DD  1940       		PUSHL	#0
                            03   DD  1942       		PUSHL	#3
                                     1944       		.ENDC
                                     1944       	
                            00   DD  1944       		PUSHL	#0
                                     1946       		$PUSHADR enable_ctrlc
                                     1946       		.IF	IDN,0,enable_ctrlc
                                     1946       		PUSHL	#0
                                     1946       		.IFF
                           00000000  1946       		.IF EQ	12-12
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 143
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000000  1946       		.IF NE	12-12
                                     1946       		PUSHAL	enable_ctrlc
                                     1946       		.MEXIT
                                     1946       		.ENDC
                                     1946       		.ENDC
                           000000AF  1946       		.NTYPE	$$$ADR, enable_ctrlc
                           000000A0  1946       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFA1  1946       		.IF GT	$$$ADR - ^XFF
                                     1946       		PUSHAL	enable_ctrlc
                                     1946       		.MEXIT
                                     1946       		.ENDC
                           00000020  1946       		.IF EQ	$$$ADR - ^X80
                                     1946       		PUSHAL	enable_ctrlc
                                     1946       		.MEXIT
                                     1946       		.ENDC
                           00000030  1946       		.IF EQ	$$$ADR - ^X70
                                     1946       		PUSHAL	enable_ctrlc
                                     1946       		.MEXIT
                                     1946       		.ENDC
                         F3 AF   9F  1946       		PUSHAB	enable_ctrlc
                                     1949       		.ENDC
                                     1949       	
                                     1949       		$QIOPUSH #0,0
                           00000000  1949       		$$T1 = 0
                                     1949       		.IF	IDN,<#0>,<#0>
                                     1949       		.IF	IDN,<0>,<0>
                           00000001  1949       		$$T1 = 1
                                     1949       		.ENDC
                                     1949       		.ENDC
                           00000001  1949       		.IF	NE $$T1
                            7E   7C  1949       		CLRQ	-(SP)
                                     194B       		.IFF
                                     194B       		PUSHL	#0
                                     194B       		$PUSHADR 0
                                     194B       		.ENDC
                                     194B       	
                                     194B       		$PUSHADR 0,CONTEXT=Q
                                     194B       		.IF	IDN,0,0
                            00   DD  194B       		PUSHL	#0
                                     194D       		.IFF
                                     194D       		.IF EQ	1-1
                                     194D       		.IF NE	1-1
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		.ENDC
                                     194D       		.NTYPE	$$$ADR, 0
                                     194D       $$$ADR	=	$$$ADR & ^XFFF0
                                     194D       		.IF GT	$$$ADR - ^XFF
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		.IF EQ	$$$ADR - ^X80
                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		.IF EQ	$$$ADR - ^X70
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 144
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     194D       		PUSHAQ	0
                                     194D       		.MEXIT
                                     194D       		.ENDC
                                     194D       		PUSHAB	0
                                     194D       		.ENDC
                                     194D       	
                  7E   0000'8F   3C  194D       		MOVZWL	#IO$_SETMODE!IO$M_CTRLCAST,-(SP)
              7E   00001D11'EF   3C  1952       		MOVZWL	v_input_chan,-(SP)
                            00   DD  1959       		PUSHL	#0
              00000000'GF   0C   FB  195B       		CALLS	#12,G^SYS$QIO
                                     1962       	
                   00000000'8F   DD  1962  3378 	pushl	#vtil_ctrlc
              00000000'GF   01   FB  1968  3379 	calls	#1,g^lib$signal		; this should NOT return!
                                 05  196F  3380 	rsb				; end of enable_ctrlc
                                     1970  3381 
                                     1970  3382 
                                     1970  3383 ;+++
                                     1970  3384 ;s> trap --  trap routine.  Don't exit VTIL unless maximum number of errors
                                     1970  3385 ;	has been exceeded.
                                     1970  3386 ;---
                               0000  1970  3387 	.entry	s_trap,^m<>
                                     1972  3388 ; output some sort of error message
                    51   04 AC   D0  1972  3389 	movl	chf$l_sigarglst(ap),r1
                            01   DD  1976  3390 	pushl	#1
                         04 A1   DD  1978  3391 	pushl	chf$l_sig_name(r1)
                                     197B  3392 	$putmsg_s msgvec=(r1)
                                     197B       		.GLOBL	SYS$PUTMSG
                            00   DD  197B       		PUSHL	#0
                                     197D       		$PUSHADR 0,CONTEXT=Q
                                     197D       		.IF	IDN,0,0
                            00   DD  197D       		PUSHL	#0
                                     197F       		.IFF
                                     197F       		.IF EQ	1-1
                                     197F       		.IF NE	1-1
                                     197F       		PUSHAQ	0
                                     197F       		.MEXIT
                                     197F       		.ENDC
                                     197F       		.ENDC
                                     197F       		.NTYPE	$$$ADR, 0
                                     197F       $$$ADR	=	$$$ADR & ^XFFF0
                                     197F       		.IF GT	$$$ADR - ^XFF
                                     197F       		PUSHAQ	0
                                     197F       		.MEXIT
                                     197F       		.ENDC
                                     197F       		.IF EQ	$$$ADR - ^X80
                                     197F       		PUSHAQ	0
                                     197F       		.MEXIT
                                     197F       		.ENDC
                                     197F       		.IF EQ	$$$ADR - ^X70
                                     197F       		PUSHAQ	0
                                     197F       		.MEXIT
                                     197F       		.ENDC
                                     197F       		PUSHAB	0
                                     197F       		.ENDC
                                     197F       	
                                     197F       		$PUSHADR 0
                                     197F       		.IF	IDN,0,0
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 145
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                            00   DD  197F       		PUSHL	#0
                                     1981       		.IFF
                                     1981       		.IF EQ	1-1
                                     1981       		.IF NE	1-1
                                     1981       		PUSHAL	0
                                     1981       		.MEXIT
                                     1981       		.ENDC
                                     1981       		.ENDC
                                     1981       		.NTYPE	$$$ADR, 0
                                     1981       $$$ADR	=	$$$ADR & ^XFFF0
                                     1981       		.IF GT	$$$ADR - ^XFF
                                     1981       		PUSHAL	0
                                     1981       		.MEXIT
                                     1981       		.ENDC
                                     1981       		.IF EQ	$$$ADR - ^X80
                                     1981       		PUSHAL	0
                                     1981       		.MEXIT
                                     1981       		.ENDC
                                     1981       		.IF EQ	$$$ADR - ^X70
                                     1981       		PUSHAL	0
                                     1981       		.MEXIT
                                     1981       		.ENDC
                                     1981       		PUSHAB	0
                                     1981       		.ENDC
                                     1981       	
                                     1981       		$PUSHADR (r1)
                                     1981       		.IF	IDN,0,(r1)
                                     1981       		PUSHL	#0
                                     1981       		.IFF
                           00000000  1981       		.IF EQ	4-4
                           00000000  1981       		.IF NE	4-4
                                     1981       		PUSHAL	(r1)
                                     1981       		.MEXIT
                                     1981       		.ENDC
                                     1981       		.ENDC
                           00000061  1981       		.NTYPE	$$$ADR, (r1)
                           00000060  1981       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFF61  1981       		.IF GT	$$$ADR - ^XFF
                                     1981       		PUSHAL	(r1)
                                     1981       		.MEXIT
                                     1981       		.ENDC
                           FFFFFFE0  1981       		.IF EQ	$$$ADR - ^X80
                                     1981       		PUSHAL	(r1)
                                     1981       		.MEXIT
                                     1981       		.ENDC
                           FFFFFFF0  1981       		.IF EQ	$$$ADR - ^X70
                                     1981       		PUSHAL	(r1)
                                     1981       		.MEXIT
                                     1981       		.ENDC
                            61   9F  1981       		PUSHAB	(r1)
                                     1983       		.ENDC
                                     1983       	
              00000000'GF   04   FB  1983       		CALLS	#4,G^SYS$PUTMSG
                                     198A       	
                                     198A  3393 ; somewhere we need to figure out how to message this as well
                   00001D2F'EF   D6  198A  3394 	incl	v_errors		; increment number of errors
              14   00001D2F'EF   D1  1990  3395 	cmpl	v_errors,#c_max_errs	; the max number of errors exceeded?
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 146
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                            1C   14  1997  3396 	bgtr	10$			; yes, go exit
                    50   08 AC   D0  1999  3397 	movl	chf$l_mcharglst(ap),r0	; get address of mechanism array
                         08 A0   D0  199D  3398 	movl	chf$l_mch_depth(r0),-	; get depth, so we will unwind to
                   00001D27'EF       19A0  3399 		v_trap_depth		;   the main program
                                     19A5  3400 	$unwind_s depadr=v_trap_depth	; unwind stack
                                     19A5       		.GLOBL	SYS$UNWIND
                                     19A5       		$PUSHADR 0
                                     19A5       		.IF	IDN,0,0
                            00   DD  19A5       		PUSHL	#0
                                     19A7       		.IFF
                                     19A7       		.IF EQ	1-1
                                     19A7       		.IF NE	1-1
                                     19A7       		PUSHAL	0
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                                     19A7       		.ENDC
                                     19A7       		.NTYPE	$$$ADR, 0
                                     19A7       $$$ADR	=	$$$ADR & ^XFFF0
                                     19A7       		.IF GT	$$$ADR - ^XFF
                                     19A7       		PUSHAL	0
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                                     19A7       		.IF EQ	$$$ADR - ^X80
                                     19A7       		PUSHAL	0
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                                     19A7       		.IF EQ	$$$ADR - ^X70
                                     19A7       		PUSHAL	0
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                                     19A7       		PUSHAB	0
                                     19A7       		.ENDC
                                     19A7       	
                                     19A7       		$PUSHADR v_trap_depth
                                     19A7       		.IF	IDN,0,v_trap_depth
                                     19A7       		PUSHL	#0
                                     19A7       		.IFF
                           00000000  19A7       		.IF EQ	12-12
                           00000000  19A7       		.IF NE	12-12
                                     19A7       		PUSHAL	v_trap_depth
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                                     19A7       		.ENDC
                           000000CF  19A7       		.NTYPE	$$$ADR, v_trap_depth
                           000000C0  19A7       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFFC1  19A7       		.IF GT	$$$ADR - ^XFF
                                     19A7       		PUSHAL	v_trap_depth
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                           00000040  19A7       		.IF EQ	$$$ADR - ^X80
                                     19A7       		PUSHAL	v_trap_depth
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
                           00000050  19A7       		.IF EQ	$$$ADR - ^X70
                                     19A7       		PUSHAL	v_trap_depth
                                     19A7       		.MEXIT
                                     19A7       		.ENDC
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 147
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                   00001D27'EF   9F  19A7       		PUSHAB	v_trap_depth
                                     19AD       		.ENDC
                                     19AD       	
              00000000'GF   02   FB  19AD       		CALLS	#2,G^SYS$UNWIND
                                     19B4       	
                                 04  19B4  3401 	ret				; return to main progam
                                     19B5  3402 10$:
                            00   DD  19B5  3403 	pushl	#0			; number of fao parameters
                   00000000'8F   DD  19B7  3404 	pushl	#vtil_maxerrors		; message number
                            02   DD  19BD  3405 	pushl	#2			; number of longs in message vecor,
                                     19BF  3406 					; not including this one.
                       50   5E   D0  19BF  3407 	movl	sp,r0			; save address of buffer
                                     19C2  3408 	$putmsg_s msgvec=(r0)		; write message
                                     19C2       		.GLOBL	SYS$PUTMSG
                            00   DD  19C2       		PUSHL	#0
                                     19C4       		$PUSHADR 0,CONTEXT=Q
                                     19C4       		.IF	IDN,0,0
                            00   DD  19C4       		PUSHL	#0
                                     19C6       		.IFF
                                     19C6       		.IF EQ	1-1
                                     19C6       		.IF NE	1-1
                                     19C6       		PUSHAQ	0
                                     19C6       		.MEXIT
                                     19C6       		.ENDC
                                     19C6       		.ENDC
                                     19C6       		.NTYPE	$$$ADR, 0
                                     19C6       $$$ADR	=	$$$ADR & ^XFFF0
                                     19C6       		.IF GT	$$$ADR - ^XFF
                                     19C6       		PUSHAQ	0
                                     19C6       		.MEXIT
                                     19C6       		.ENDC
                                     19C6       		.IF EQ	$$$ADR - ^X80
                                     19C6       		PUSHAQ	0
                                     19C6       		.MEXIT
                                     19C6       		.ENDC
                                     19C6       		.IF EQ	$$$ADR - ^X70
                                     19C6       		PUSHAQ	0
                                     19C6       		.MEXIT
                                     19C6       		.ENDC
                                     19C6       		PUSHAB	0
                                     19C6       		.ENDC
                                     19C6       	
                                     19C6       		$PUSHADR 0
                                     19C6       		.IF	IDN,0,0
                            00   DD  19C6       		PUSHL	#0
                                     19C8       		.IFF
                                     19C8       		.IF EQ	1-1
                                     19C8       		.IF NE	1-1
                                     19C8       		PUSHAL	0
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                                     19C8       		.ENDC
                                     19C8       		.NTYPE	$$$ADR, 0
                                     19C8       $$$ADR	=	$$$ADR & ^XFFF0
                                     19C8       		.IF GT	$$$ADR - ^XFF
                                     19C8       		PUSHAL	0
                                     19C8       		.MEXIT
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 148
V1.01                           Enter VTIL                               12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     19C8       		.ENDC
                                     19C8       		.IF EQ	$$$ADR - ^X80
                                     19C8       		PUSHAL	0
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                                     19C8       		.IF EQ	$$$ADR - ^X70
                                     19C8       		PUSHAL	0
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                                     19C8       		PUSHAB	0
                                     19C8       		.ENDC
                                     19C8       	
                                     19C8       		$PUSHADR (r0)
                                     19C8       		.IF	IDN,0,(r0)
                                     19C8       		PUSHL	#0
                                     19C8       		.IFF
                           00000000  19C8       		.IF EQ	4-4
                           00000000  19C8       		.IF NE	4-4
                                     19C8       		PUSHAL	(r0)
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                                     19C8       		.ENDC
                           00000060  19C8       		.NTYPE	$$$ADR, (r0)
                           00000060  19C8       $$$ADR	=	$$$ADR & ^XFFF0
                           FFFFFF61  19C8       		.IF GT	$$$ADR - ^XFF
                                     19C8       		PUSHAL	(r0)
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                           FFFFFFE0  19C8       		.IF EQ	$$$ADR - ^X80
                                     19C8       		PUSHAL	(r0)
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                           FFFFFFF0  19C8       		.IF EQ	$$$ADR - ^X70
                                     19C8       		PUSHAL	(r0)
                                     19C8       		.MEXIT
                                     19C8       		.ENDC
                            60   9F  19C8       		PUSHAB	(r0)
                                     19CA       		.ENDC
                                     19CA       	
              00000000'GF   04   FB  19CA       		CALLS	#4,G^SYS$PUTMSG
                                     19D1       	
                                     19D1  3409 	$exit_s				; exit
                                     19D1       		.GLOBL	SYS$EXIT
                            01   DD  19D1       		PUSHL	#1
              00000000'GF   01   FB  19D3       		CALLS	#1,G^SYS$EXIT
                                     19DA       	
                                     19DA  3410 					; end of trap
                                     19DA  3411 
                                     19DA  3412 	newpage <Initialization>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 149
V1.01                           Initialization                           12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     19DA       	.sbttl	Initialization
                                     19DA       	
                                     19DA  3413 ;*******************************************************************************
                                     19DA  3414 ;
                                     19DA  3415 ; Initialization
                                     19DA  3416 ;
                                     19DA  3417 ;*******************************************************************************
                                     19DA  3418 
                                     19DA  3419 ;+++
                                     19DA  3420 ;s> cold_start -- do all initial setup
                                     19DA  3421 ;+++
                               0000  19DA  3422 	.entry	s_cold_start,^m<>
              00001D33'EF   5E   D0  19DC  3423 	movl	sp,v_returnstack	; save original return stack pointer
              59   00000000'8F   D0  19E3  3424 	movl	#c_dict_begin,r9	; initialize dictionary pointer
                                     19EA  3425 ; vl_compiler and vl_kernel are symbols that contain location of last word in
                                     19EA  3426 ; these vocabularies, which are built-in.
     00001D3F'EF   0000188B'8F   D0  19EA  3427 	movl	#vl_compiler,v_compiler	; Initialize compiler vocabulary
              00001D43'EF   00   D0  19F5  3428 	movl	#vl_kernel,v_kernel	; Initialize kernel vocabulary
                                     19FC  3429 ; greet user
                   00001800'EF   7F  19FC  3430 	pushaq	v_greeting
              00000000'GF   01   FB  1A02  3431 	calls	#1,g^lib$put_output	; greet user
     00001D37'EF   00001D43'EF   DE  1A09  3432 	moval	v_kernel,v_context	; Initialize context
     00001D3B'EF   00001D43'EF   DE  1A14  3433 	moval	v_kernel,v_current	; Initialize current
                          009C   31  1A1F  3434 	brw	_initialize		; skip patching stuff
                                     1A22  3435 
                                     1A22  3436 
                                     1A22  3437 ;+++
                                     1A22  3438 ;s> warm_start -- do a warm start.  Called from main program.  Branched to
                                     1A22  3439 ;	internally.
                                     1A22  3440 ;---
                               0000  1A22  3441 	.entry	s_warm_start,^m<>
                                     1A24  3442 ; only greet user if entered from main program.  Otherwise we are recovering
                                     1A24  3443 ; from an internal error and are only patching, not recovering from a trap.
                   00001800'EF   7F  1A24  3444 	pushaq	   v_greeting
              00000000'GF   01   FB  1A2A  3445 	calls	   #1,g^lib$put_output	; greet user
     00001D37'EF   00001D43'EF   DE  1A31  3446 	moval	   v_kernel,v_context	; Initialize context
     00001D3B'EF   00001D43'EF   DE  1A3C  3447 	moval	   v_kernel,v_current	; Initialize current
                                     1A47  3448 ;+++
                                     1A47  3449 ;r> warm_start -- so we can brw to it as well as call it
                                     1A47  3450 ;---
                                     1A47  3451 r_warm_start:
                                     1A47  3452 
                                     1A47  3453 ; The following patches system variables and delivers error messages to the user
                                     1A47  3454 ; about the cause of the boom.
                   00001D4D'EF   95  1A47  3455 	tstb	v_mode		        ; were we compiling before error?
                            04   13  1A4D  3456 	beql	10$			; no
                       F90F CF   16  1A4F  3457 	jsb	unlink			; yes, unlink unfinished word
                                     1A53  3458 10$:
              00001D4D'EF   00   90  1A53  3459 	movb	#c_false,v_mode		; put in execute mode
              00001D4C'EF   00   90  1A5A  3460 	movb	#c_false,v_state	;   just in case
              00001999'EF   00   B0  1A61  3461 	movw	#0,v_inlen		; so start with new line
              00001997'EF   00   B0  1A68  3462 	movw	#0,v_org_inlen		;   just in case
                   00001D47'EF   95  1A6F  3463 	tstb	v_infile		; Are we getting from file?
                            3C   13  1A75  3464 	beql	20$			; no
                                     1A77  3465 	$close	fab=v_infab		; yes, close file
                                     1A77       		$RMSCALL	CLOSE,v_infab,,
                                     1A77       	.GLOBL	SYS$CLOSE
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 150
V1.01                           Initialization                           12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1A77       	.IF	B <v_infab>
                                     1A77       	CALLG	(AP),G^SYS$CLOSE
                                     1A77       	$$.TMP=0
                                     1A77       	.IF	NB <>
                                     1A77       	$$.TMP=1
                                     1A77       	.ENDC
                                     1A77       	.IF	NB <>
                                     1A77       	$$.TMP=1
                                     1A77       	.ENDC
                                     1A77       	.IF	NE $$.TMP
                                     1A77       	.ERROR				; v_infab= parameter missing;
                                     1A77       	.ENDC
                                     1A77       	.ENDC
                                     1A77       	.IF	NB <v_infab>
                           00000001  1A77       	$$.TMP1=1
                                     1A77       	.IF	NB <>
                                     1A77       	PUSHAL	
                                     1A77       	$$.TMP1=3
                                     1A77       	.ENDC
                                     1A77       	.IF	NB <>
                                     1A77       	PUSHAL	
                                     1A77       	.IF	EQ <$$.TMP1-1>
                                     1A77       	$$.TMP1=2
                                     1A77       	.ENDC
                                     1A77       	.IFF
                           FFFFFFFE  1A77       	.IF	EQ <$$.TMP1-3>
                                     1A77       	PUSHL	#0
                                     1A77       	.ENDC
                                     1A77       	.ENDC
                           000000CF  1A77       	.NTYPE	$$.TMP2,v_infab
                           00000070  1A77       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     1A77       	PUSHL	v_infab
                                     1A77       	.IFF
                           000000B0  1A77       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     1A77       	PUSHL	v_infab
                                     1A77       	.IFF
                   000019A8'EF   DF  1A77       	PUSHAL	v_infab
                                     1A7D       	.ENDC
                                     1A7D       	.ENDC
              00000000'GF   01   FB  1A7D       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     1A84       	.ENDC
                                     1A84       	
                                     1A84       	
              00001D47'EF   00   90  1A84  3466 	movb	#c_false,v_infile	; set infile flag false
              00001D48'EF   00   D0  1A8B  3467 	movl	#0,v_filelinenum	; zero file line as well
              7B   00001890'EF   9E  1A92  3468 	movab	v_infilemess,-(r11)	; put address of 'In file:' on stack
                       E9D4 CF   16  1A99  3469 	jsb 	bcount			; convert from ascic to write format ( address count )
                       F9AB CF   16  1A9D  3470 	jsb	write			; put in output
              7B   00001A3D'EF   DE  1AA1  3471 	moval	v_fname,-(r11)		; put address of filename on stack
              7B   00001A3C'EF   9A  1AA8  3472 	movzbl	v_fnamelen,-(r11)	; put count of filename on stack
                       F999 CF   16  1AAF  3473 	jsb	write			; write filename out to terminal
                                     1AB3  3474 20$:
                       E824 CF   16  1AB3  3475 	jsb	q_cr			; finish off outstanding input, if any
              5E   00001D33'EF   D0  1AB7  3476 	movl	v_returnstack,sp	; restore original return stack pointer
                                     1ABE  3477 
                                     1ABE  3478 ;
                                     1ABE  3479 ; The following is also done during a cold start.
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 151
V1.01                           Initialization                           12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1ABE  3480 ;
                                     1ABE  3481 _initialize:
                                     1ABE  3482 	; Initialize stacks.
              5B   00001000'EF   DE  1ABE  3483 	moval	c_ds_start,r11 		; move address of data stack to ds pointer
              5A   00001800'EF   DE  1AC5  3484 	moval	c_ls_start,r10		; move address of loop stack to ls pointer
                                     1ACC  3485 
                                     1ACC  3486 
                                     1ACC  3487 	newpage <Interpreter>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 152
V1.01                           Interpreter                              12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1ACC       	.sbttl	Interpreter
                                     1ACC       	
                                     1ACC  3488 ;*******************************************************************************
                                     1ACC  3489 ;
                                     1ACC  3490 ; Interpreter -- Take commands from the user (or a file) and execute them.
                                     1ACC  3491 ;
                                     1ACC  3492 ;*******************************************************************************
                                     1ACC  3493 _interpreter:
                       7B   20   D0  1ACC  3494 	movl	#c_blank,-(r11)		; set up for space delimeted token
                       F80B CF   16  1ACF  3495 	jsb	token			; get the next token
                                     1AD3  3496 ; is it a comment?
                       69   01   91  1AD3  3497 	cmpb	#1,(r9)			; token only one byte long?
                            0D   12  1AD6  3498 	bneq	10$			; no
                 01 A9   5C 8F   91  1AD8  3499 	cmpb	#c_com1_begin,1(r9)	; is it a \
                            1B   13  1ADD  3500 	beql	_strip_comment		; yes, strip comment
                    01 A9   28   91  1ADF  3501 	cmpb	#c_com2_begin,1(r9)	; Is it a (
                            1F   13  1AE3  3502 	beql	_strip_comment2		; yes, strip second type of comment
                                     1AE5  3503 10$:
                       E872 CF   16  1AE5  3504 	jsb	q_search		; search for the word
                            8B   D5  1AE9  3505 	tstl	(r11)+			; was it found?
                            02   13  1AEB  3506 	beql	30$			; no, go see if number
                            1F   11  1AED  3507 	brb	_q_execute		; yes, go see if execute or compile
                                     1AEF  3508 30$:
                       E839 CF   16  1AEF  3509 	jsb	q_number		; see if it is a number
                            8B   D5  1AF3  3510 	tstl	(r11)+			; was it valid?
                            D5   12  1AF5  3511 	bneq	_interpreter		; yes, leave with number on the stack
                          0079   31  1AF7  3512 	brw	_unknowntoken		; no, tell user bad token
                                     1AFA  3513 
                                     1AFA  3514 
                                     1AFA  3515 _strip_comment:
                       7B   00   D0  1AFA  3516 	movl	#c_com1_end,-(r11)	; end of first type of comment
                       F7DD CF   16  1AFD  3517 	jsb	token			; get the token
                          FFC8   31  1B01  3518 	brw	_interpreter		; end of strip comment
                                     1B04  3519 
                                     1B04  3520 
                                     1B04  3521 _strip_comment2:
                       7B   29   D0  1B04  3522 	movl	#c_com2_end,-(r11)	; end of second type of comment
                       F7D3 CF   16  1B07  3523 	jsb	token			; get the token
                          FFBE   31  1B0B  3524 	brw	_interpreter		; end of strip comment2
                                     1B0E  3525 
                                     1B0E  3526 
                                     1B0E  3527 _q_execute:
                       EC32 CF   16  1B0E  3528 	jsb	cfa			; get the code field address of
                                     1B12  3529 					;   the word
     00001D4C'EF   00001D4D'EF   91  1B12  3530 	cmpb	v_mode,v_state		; v_mode = v_state?~~~ what does this tell us???
                            1E   12  1B1D  3531 	bneq	10$			; no, go compile it
              00001D4C'EF   00   90  1B1F  3532 	movb	#c_false,v_state	; set v_state false~~~ Why???
                            9B   16  1B26  3533 	jsb	@(r11)+			; yes, execute it
              00000000'8F   5A   D1  1B28  3534 	cmpl	r10,#c_ds_end		; stack overflow?
                            2E   19  1B2F  3535 	blss	_overflow		; yes, go announce it
              00001000'8F   5B   D1  1B31  3536 	cmpl	r11,#c_ds_start		; stack underflow?
                            11   14  1B38  3537 	bgtr	_underflow		; yes, go announce it
                          FF8F   31  1B3A  3538 	brw	_interpreter		; everything ok, do it again
                                     1B3D  3539 10$:
              00001D4C'EF   00   90  1B3D  3540 	movb	#c_false,v_state	; set v_state false~~~ what does this tell us???
                       EC5A CF   16  1B44  3541 	jsb	i_compile_jsb		; compile a jump to the word whose
                                     1B48  3542 					;   cfa addressis at the top of stack
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 153
V1.01                           Interpreter                              12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                          FF81   31  1B48  3543 	brw	_interpreter		; everthing ok, do it again
                                     1B4B  3544 
                                     1B4B  3545 
                                     1B4B  3546 _underflow:
                       ECBB CF   16  1B4B  3547 	jsb	cr			; make sure everything is output
                   00001842'EF   7F  1B4F  3548 	pushaq	v_undermess		; push address of underflow message
              00000000'GF   01   FB  1B55  3549 	calls	#1,g^lib$put_output	; tell user
                          FEE8   31  1B5C  3550 	brw	r_warm_start			; clean up VTIL
                                     1B5F  3551 
                                     1B5F  3552 
                                     1B5F  3553 _overflow:
                       ECA7 CF   16  1B5F  3554 	jsb	cr			; make sure everything is output
                   0000185A'EF   7F  1B63  3555 	pushaq	v_overmess		; make sure everything is output
              00000000'GF   01   FB  1B69  3556 	calls	#1,g^lib$put_output	; tell user
                          FED4   31  1B70  3557 	brw	r_warm_start			; clean up VTIL
                                     1B73  3558 
                                     1B73  3559 
                                     1B73  3560 _unknowntoken:
              7B   00001871'EF   9E  1B73  3561 	movab	v_unknown,-(r11)	; push address of unknown token message
                       E8F3 CF   16  1B7A  3562 	jsb	bcount			; convert it to ( address count )
                       F8CA CF   16  1B7E  3563 	jsb	write			; tell user
                       7B   59   D0  1B82  3564 	movl	r9,-(r11)		; get address of token
                            6B   D6  1B85  3565 	incl	(r11)			; move address over byte-count
                       7B   69   9A  1B87  3566 	movzbl	(r9),-(r11)		; get byte count of string on stack
                       F8BE CF   16  1B8A  3567 	jsb	write			; show user bad token
              7B   00001883'EF   9E  1B8E  3568 	movab	v_unknown2,-(r11)	; Put address of 'In line:' on stack
                       E8D8 CF   16  1B95  3569 	jsb	bcount			; convert it to ( address count )
                       F8AF CF   16  1B99  3570 	jsb	write			; tell user
                   00001D47'EF   95  1B9D  3571 	tstb	v_infile		; In a file?
                            0B   13  1BA3  3572 	beql	10$			; no
              7B   00001D48'EF   D0  1BA5  3573 	movl	v_filelinenum,-(r11)	; yes, print line number
                       E573 CF   16  1BAC  3574 	jsb	i_dot			; put number in output buffer
                                     1BB0  3575 10$:
                       EC56 CF   16  1BB0  3576 	jsb	cr			; end line
              7B   000018F7'EF   DE  1BB4  3577 	moval	v_inbuf,-(r11)		; get address of original line
              7B   00001997'EF   32  1BBB  3578 	cvtwl	v_org_inlen,-(r11)	; length of original line
                       F886 CF   16  1BC2  3579 	jsb	write			; show user
                       EC40 CF   16  1BC6  3580 	jsb	cr			; end line
                          FE7A   31  1BCA  3581 	brw	r_warm_start		; go clean up VTIL
                                     1BCD  3582 
                                     1BCD  3583 
                                     1BCD  3584 	newpage <Exit Routines>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 154
V1.01                           Exit Routines                            12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1BCD       	.sbttl	Exit Routines
                                     1BCD       	
                                     1BCD  3585 ;*******************************************************************************
                                     1BCD  3586 ;
                                     1BCD  3587 ; Exit Routines -- Routines to handle successful and unsuccessful  exits
                                     1BCD  3588 ;
                                     1BCD  3589 ;*******************************************************************************
                                     1BCD  3590 _error_exit:				; die messily
                            50   DD  1BCD  3591 	pushl	r0			; put error message number on stack
              00000000'GF   01   FB  1BCF  3592 	calls	#1,g^lib$signal		; signal error
                                 04  1BD6  3593 	ret				; return
                                     1BD7  3594 
                                     1BD7  3595 
                         0C A6   DD  1BD7  3596 _f_err:	pushl	fab$l_stv(r6)		; push stv and sts of fab
                         08 A6   DD  1BDA  3597 	pushl	fab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1BDD  3598 	calls	#2,g^lib$signal		; signal error
                            1A   11  1BE4  3599 	brb	_exit
                                     1BE6  3600 
                                     1BE6  3601 
                         0C A6   DD  1BE6  3602 _r_err:	pushl	rab$l_stv(r6)		; push stv and sts of rab
                         08 A6   DD  1BE9  3603 	pushl	rab$l_sts(r6)		; on the stack
              00000000'GF   02   FB  1BEC  3604 	calls	#2,g^lib$signal		; signal error
                                     1BF3  3605 
                                     1BF3  3606 
                                     1BF3  3607 _done:	$close	fab=v_infile		; close input
                                     1BF3       		$RMSCALL	CLOSE,v_infile,,
                                     1BF3       	.GLOBL	SYS$CLOSE
                                     1BF3       	.IF	B <v_infile>
                                     1BF3       	CALLG	(AP),G^SYS$CLOSE
                                     1BF3       	$$.TMP=0
                                     1BF3       	.IF	NB <>
                                     1BF3       	$$.TMP=1
                                     1BF3       	.ENDC
                                     1BF3       	.IF	NB <>
                                     1BF3       	$$.TMP=1
                                     1BF3       	.ENDC
                                     1BF3       	.IF	NE $$.TMP
                                     1BF3       	.ERROR				; v_infile= parameter missing;
                                     1BF3       	.ENDC
                                     1BF3       	.ENDC
                                     1BF3       	.IF	NB <v_infile>
                           00000001  1BF3       	$$.TMP1=1
                                     1BF3       	.IF	NB <>
                                     1BF3       	PUSHAL	
                                     1BF3       	$$.TMP1=3
                                     1BF3       	.ENDC
                                     1BF3       	.IF	NB <>
                                     1BF3       	PUSHAL	
                                     1BF3       	.IF	EQ <$$.TMP1-1>
                                     1BF3       	$$.TMP1=2
                                     1BF3       	.ENDC
                                     1BF3       	.IFF
                           FFFFFFFE  1BF3       	.IF	EQ <$$.TMP1-3>
                                     1BF3       	PUSHL	#0
                                     1BF3       	.ENDC
                                     1BF3       	.ENDC
                           000000CF  1BF3       	.NTYPE	$$.TMP2,v_infile
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 155
V1.01                           Exit Routines                            12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                           00000070  1BF3       	.IF	EQ <<$$.TMP2&^XF0>-^X50>
                                     1BF3       	PUSHL	v_infile
                                     1BF3       	.IFF
                           000000B0  1BF3       	.IF	EQ <<$$.TMP2&^XF0>-^X10>
                                     1BF3       	PUSHL	v_infile
                                     1BF3       	.IFF
                   00001D47'EF   DF  1BF3       	PUSHAL	v_infile
                                     1BF9       	.ENDC
                                     1BF9       	.ENDC
              00000000'GF   01   FB  1BF9       	CALLS	#$$.TMP1,G^SYS$CLOSE
                                     1C00       	.ENDC
                                     1C00       	
                                     1C00       	
                                     1C00  3608 
                                     1C00  3609 
                                     1C00  3610 _exit:
                       50   01   D0  1C00  3611 	movl	#1,r0			; successful completion
                                     1C03  3612 	$exit_s	r0			; exit with status
                                     1C03       		.GLOBL	SYS$EXIT
                            50   DD  1C03       		PUSHL	r0
              00000000'GF   01   FB  1C05       		CALLS	#1,G^SYS$EXIT
                                     1C0C       	
                                     1C0C  3613 
                                     1C0C  3614 
                                     1C0C  3615 	newpage <Dictionary Space>
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 156
V1.01                           Dictionary Space                         12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                     1C0C       	.sbttl	Dictionary Space
                                     1C0C       	
                                     1C0C  3616 ;*******************************************************************************
                                     1C0C  3617 ;
                                     1C0C  3618 ; Dictionary
                                     1C0C  3619 ;
                                     1C0C  3620 ;*******************************************************************************
                                 00000000  3621 	.psect	vtildict
                                     0000  3622 c_dict_begin:
                           00004000  0000  3623 	. = .+<16 * 1024>		; reserve space for dictinary~~~ why not a constant
                                     4000  3624 c_dict_end:
                                     4000  3625 
                                     4000  3626 
                                     4000  3627 ;
                                     4000  3628 ; Block i/o buffers -- Here because that is the safest place for them.
                                     4000  3629 ;
                                     4000  3630 v_blkbuff:
                           00004C00  4000  3631 	.blkb	c_max_blocks * c_block_size ; buffer for block i/o
                                     4C00  3632 
                                     4C00  3633 
                                     4C00  3634 ;*******************************************************************************
                                     4C00  3635 ;
                                     4C00  3636 ; End of VTIL, and transfer address
                                     4C00  3637 ;
                                     4C00  3638 ;*******************************************************************************
                                     4C00  3639 	.end	vtil
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 157
Symbol table                                                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

$$$ADR                         = 00000060    D            C_COM2_END                     = 00000029    D            
$$.TAB                         = 00001B30 R  D  02        C_DICT_BEGIN                     00000000 R  D  05        
$$.TABEND                      = 00001B74 R  D  02        C_DICT_END                       00004000 R  D  05        
$$.TMP                         = 00000000    D            C_DS_END                         00000000 R  D  02        
$$.TMP1                        = 00000001    D            C_DS_SIZE                      = 00001000    D            
$$.TMP2                        = 000000CF                 C_DS_START                       00001000 R  D  02        
$$.TMPX                        = 0000000A R  D  03        C_D_BLKS_IN_BLK                = 00000002    D            
$$.TMPX1                       = 0000000E    D            C_FALSE                        = 00000000    D            
$$T1                           = 00000001    D            C_INUSE                        = 00000001    D            
ABORT                            000003A3 R  D  04        C_KEYSIZE                      = 00000004    D            
ABS                              000003AE R  D  04        C_LS_END                         00001000 R  D  02        
ADM_ABSOLUTE                   = 0000009F    D            C_LS_SIZE                      = 00000800    D            
ADM_ADEC_R10                   = 0000007A    D            C_LS_START                       00001800 R  D  02        
ADM_ADEC_R11                   = 0000007B    D            C_MAX_BLOCKS                   = 00000003    D            
ADM_AINC_R10                   = 0000008A    D            C_MAX_ERRS                     = 00000014    D            
ADM_AINC_R11                   = 0000008B    D            C_MAX_LEN                      = 000000A0    D            
ADM_AINC_R9                    = 00000089    D            C_MAX_NAME_LEN                 = 00000050    D            
ADM_B_DIS_R10                  = 000000AA    D            C_MODIFIED                     = 00000002    D            
ADM_B_REL                      = 000000AF    D            C_PAD_MOAT                     = 00000109    D            
ADM_DEF_R10                    = 0000006A    D            C_SCREEN_LEN                   = 00000050    D            
ADM_DEF_R11                    = 0000006B    D            C_TPU_COM_LEN                  = 0000001C    D            
ADM_DEF_R9                     = 00000069    D            C_TRUE                         = FFFFFFFF    D            
ADM_IMMEDIATE                  = 0000008F    D            DC$_TERM                         ********   X   00        
ADM_R0                         = 00000050    D            DECIMAL                          000008D1 R  D  04        
ADM_R10                        = 0000005A    D            DEFINITIONS                      000008E9 R  D  04        
ADM_R9                         = 00000059    D            DOWNLOOP                         000016BD R  D  04        
AGAIN                            00001611 R  D  04        DROP                             000008FE R  D  04        
AND                              000003EB R  D  04        DSC$K_CLASS_S                    ********   X   00        
ARRAY                            0000040C R  D  04        DSC$K_DTYPE_T                    ********   X   00        
ASCII                            00000432 R  D  04        DUP                              00000918 R  D  04        
BCOUNT                           00000471 R  D  04        ELSE                             000016F9 R  D  04        
BINARY                           00000486 R  D  04        ENABLE_CTRLC                     0000193C RG D  04        
BLANK                            000004A5 R  D  04        ENDIF                            00001721 R  D  04        
BLOCK                            000004BA R  D  04        ENDWHILE                         0000173A R  D  04        
BREAK                            00000627 R  D  04        EODP                             00000950 R  D  04        
BUFFER                           00000641 R  D  04        EVE                              00000979 R  D  04        
BYTE                             0000071D R  D  04        FAB$B_DNS                      = 00000035    D            
CA_CONTROLC                    = 00000000    D            FAB$B_FNS                      = 00000034    D            
CA_TRAPPING                    = 00000000    D            FAB$C_BID                      = 00000003    D            
CFA                              00000744 R  D  04        FAB$C_BLN                      = 00000050    D            
CHF$L_MCHARGLST                = 00000008    D            FAB$C_FIX                      = 00000001    D            
CHF$L_MCH_DEPTH                = 00000008    D            FAB$C_SEQ                      = 00000000    D            
CHF$L_SIGARGLST                = 00000004    D            FAB$C_VAR                      = 00000002    D            
CHF$L_SIG_NAME                 = 00000004    D            FAB$L_ALQ                      = 00000010    D            
CLIST                            0000075F R  D  04        FAB$L_DNA                      = 00000030    D            
COMPILER_BEGIN                   00001521 R  D  04        FAB$L_FNA                      = 0000002C    D            
COMPILETIME                      000007BD R  D  04        FAB$L_FOP                      = 00000004    D            
CONTEXT                          000007E6 R  D  04        FAB$L_STS                      = 00000008    D            
COUNT                            000007F8 R  D  04        FAB$L_STV                      = 0000000C    D            
CR                               0000080A R  D  04        FAB$V_CHAN_MODE                = 00000002    D            
CREATE                           0000083E R  D  04        FAB$V_FILE_MODE                = 00000004    D            
CURRENT                          000008BD R  D  04        FAB$V_GET                      = 00000001    D            
C_BLANK                        = 00000020    D            FAB$V_LNM_MODE                 = 00000000    D            
C_BLOCK_SIZE                   = 00000400    D            FAB$V_UPD                      = 00000003    D            
C_COM1_BEGIN                   = 0000005C    D            FAB$W_GBC                      = 00000048    D            
C_COM1_END                     = 00000000    D            FILL                             000009CB R  D  04        
C_COM2_BEGIN                   = 00000028    D            FORGET                           00000A1C R  D  04        
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 158
Symbol table                                                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

FREEMEM                          00000ACA R  D  04        I_LESS_EQUAL                     0000024D R  D  04        
HEX                              00000AEE R  D  04        I_LESS_SHARP                     00000239 R  D  04        
HLD                              00000AFE R  D  04        I_LONG                           00000BF2 R  D  04        
HOLD                             00000B0F R  D  04        I_LOOP                           000017B8 R  D  04        
IF                               0000175D R  D  04        I_LS_TO_DS                       00000C32 R  D  04        
IO$M_CTRLCAST                    ********   X   00        I_L_UP                           0000177F R  D  04        
IO$_SETMODE                      ********   X   00        I_MATCH                          00000C40 R  D  04        
I_AC_COLON                       000003BE R  D  04        I_MINUS_ROT                      0000010C R  D  04        
I_ADD                            000000C1 R  D  04        I_MOVE_FILL                      00000CDC R  D  04        
I_BIT_AND                        00000072 R  D  04        I_MULTIPLY                       000000A8 R  D  04        
I_BIT_NOT                        00000083 R  D  04        I_ONE_MINUS                      000001F2 R  D  04        
I_BIT_OR                         00000090 R  D  04        I_ONE_PLUS                       000001E8 R  D  04        
I_BIT_XOR                        0000009E R  D  04        I_PLUS_LOOP                      0000154D R  D  04        
I_BL                             00000497 R  D  04        I_PLUS_ROT                       000000DE R  D  04        
I_BLOCK_CLOSE                    0000053B R  D  04        I_PLUS_STORE                     000000CC R  D  04        
I_BLOCK_OPEN                     0000056D R  D  04        I_QUESTION                       000002CA R  D  04        
I_BLOCK_READ                     000005B3 R  D  04        I_RIGHT_BACK                     00001518 R  D  04        
I_BLOCK_WRITE                    000005E5 R  D  04        I_SAVE_BUFFERS                   00000F55 R  D  04        
I_BS_FETCH                       00000631 R  D  04        I_SEMICOLON                      000015D3 R  D  04        
I_BUFFER_READ                    000006B8 R  D  04        I_SHARP                          00000015 R  D  04        
I_BUFFER_WRITE                   000006F4 R  D  04        I_SHARP_GREATER                  00000036 R  D  04        
I_B_COMMA                        00000457 R  D  04        I_SHARP_S                        00000055 R  D  04        
I_B_FETCH                        00000461 R  D  04        I_SHORT                          00000FBA R  D  04        
I_B_STORE                        00000447 R  D  04        I_SP_0                           00001019 R  D  04        
I_B_UP                           00001636 R  D  04        I_SP_FETCH                       0000100D R  D  04        
I_COLON                          000001FB R  D  04        I_STORE                          00000006 R  D  04        
I_COMMA                          000000F5 R  D  04        I_STRING_QUOTE                   00001218 R  D  04        
I_COMPILE_ASCII                  00001897 R  D  04        I_SUBTRACT                       000000FF R  D  04        
I_COMPILE_JSB                    000007A2 R  D  04        I_S_UP                           00001815 R  D  04        
I_COUNT_BEGIN                    00000064 R  D  04        I_VARIABLE                       00001530 R  D  04        
I_COUNT_END                      000000B3 R  D  04        I_WORD_FETCH                     00000F32 R  D  04        
I_DEFER_BEGIN                    00001658 R  D  04        I_WORD_STORE                     00000F14 R  D  04        
I_DEFER_END                      000015ED R  D  04        I_WS_FETCH                       00000F3F R  D  04        
I_DIVIDE                         000001C0 R  D  04        I_W_COMMA                        00000F24 R  D  04        
I_DIV_MOD                        000001CD R  D  04        KERNEL                           00000B36 R  D  04        
I_DO                             00001688 R  D  04        LEAVE                            00000B4C R  D  04        
I_DOT                            00000123 R  D  04        LIB$GET_INPUT                    ********   X   00        
I_DOT_LPAREN                     0000015A R  D  04        LIB$PUT_OUTPUT                   ********   X   00        
I_DOT_QUOTE                      00001581 R  D  04        LIB$SIGNAL                       ********   X   00        
I_DOT_SB                         00000179 R  D  04        LIB$_INPSTRTRU                   ********   X   00        
I_DOT_ST                         0000019D R  D  04        LITERAL                          0000179F R  D  04        
I_DS_TO_LS                       0000090C R  D  04        LOAD                             00000B5A R  D  04        
I_EMPTY_BUFFERS                  0000092E R  D  04        LONGCONST                        00000C1A R  D  04        
I_EODP_PLUS_STORE                0000096D R  D  04        MAX                              00000C6B R  D  04        
I_EOD_STORE                      0000095E R  D  04        MESSAGE                          00000C85 R  D  04        
I_EQUAL                          00000264 R  D  04        MIN                              00000C98 R  D  04        
I_EQUAL_TEXT                     0000027F R  D  04        MOD                              00000CAE R  D  04        
I_EXIT                           000009BF R  D  04        MOVE                             00000CC4 R  D  04        
I_FETCH                          00000394 R  D  04        NCHR                           = 00000007                 
I_FLUSH_BUFFERS                  000009E9 R  D  04        NEGAGE                           00000CF5 R  D  04        
I_FORGET_ERASE                   00000A74 R  D  04        NOT                              00000D01 R  D  04        
I_GREATER_EQUAL                  000002B3 R  D  04        NUMBER                           00000D1C R  D  04        
I_GRETER                         0000029F R  D  04        OCTAL                            00000D9C R  D  04        
I_HALT                           00000AE0 R  D  04        OP_ACBL                        = 000000F1    D            
I_I_TO                           00000B27 R  D  04        OP_ADDL2                       = 000000C0    D            
I_LEFT_BRACK                     00001883 R  D  04        OP_BNEQ                        = 00000012    D            
I_LESS                           00000221 R  D  04        OP_BRW                         = 00000031    D            
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 159
Symbol table                                                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

OP_JSB                         = 00000016    D            SYS$EXIT                         ********  G    04        
OP_MOVAB                       = 0000009E    D            SYS$FIND                         ********  G    04        
OP_MOVAL                       = 000000DE    D            SYS$GET                          ********  G    04        
OP_MOVAW                       = 0000003E    D            SYS$GETCHN                       ********  G    04        
OP_MOVB                        = 00000090    D            SYS$OPEN                         ********  G    04        
OP_MOVC3                       = 00000028    D            SYS$PUTMSG                       ********  G    04        
OP_MOVL                        = 000000D0    D            SYS$QIO                          ********  G    04        
OP_RSB                         = 00000005    D            SYS$UNWIND                       ********  G    04        
OP_TSTL                        = 000000D5    D            SYS$UPDATE                       ********  G    04        
OR                               00000DAB R  D  04        S_COLD_START                     000019DA RG D  04        
OTS$CVT_L_TI                     ********   X   00        S_TRAP                           00001970 RG D  04        
OVER                             00000DCB R  D  04        S_WARM_START                     00001A22 RG D  04        
PAD                              00000DD8 R  D  04        TOCHAR                           000012BD R  D  04        
PUTC                             00000DEA R  D  04        TOKEN                            000012DE R  D  04        
Q_CR                             000002DB R  D  04        TPU$TPU                          ********   X   00        
Q_DUP                            000002F3 R  D  04        UNLINK                           00001362 R  D  04        
Q_NUMBER                         0000032C R  D  04        UNSMUDGE                         0000137E R  D  04        
Q_N_CR                           00000305 R  D  04        UNTIL                            00001836 R  D  04        
Q_SEARCH                         0000035B R  D  04        UPDATE                           00001398 R  D  04        
RAB$B_RAC                      = 0000001E    D            V1_COMPILER                    = 0000182C R  D  04        
RAB$C_BID                      = 00000001    D            V1_KERNEL                      = 00001512 R  D  04        
RAB$C_BLN                      = 00000044    D            VARIABLE                         000013B2 R  D  04        
RAB$C_KEY                      = 00000001    D            VLIST                            000013D3 R  D  04        
RAB$C_SEQ                      = 00000000    D            VL_COMPILER                    = 0000188B R  D  04        
RAB$L_CTX                      = 00000018    D            VL_KERNEL                      = 00000000    D            
RAB$L_RBF                      = 00000028    D            VOCABULARY                       00001416 R  D  04        
RAB$L_ROP                      = 00000004    D            VTIL                             000018A7 RG D  04        
RAB$L_STS                      = 00000008    D            VTIL_CTRLC                       ********   X   00        
RAB$L_STV                      = 0000000C    D            VTIL_EXIT                        00001932 R  D  04        
RAB$L_UBF                      = 00000024    D            VTIL_MAXERRORS                   ********   X   00        
RAB$V_RAH                      = 00000009    D            V_BLKBUFF                        00004000 R  D  05        
RAB$W_RSZ                      = 00000022    D            V_BLKFAB                         00001AE0 R  D  02        
RADIX                            00000E21 R  D  04        V_BLKKEY                         00001B74 R  D  02        
READ                             00000E32 R  D  04        V_BLKRAB                         00001B30 R  D  02        
READSTR                          00000EA6 R  D  04        V_BLOCKIO                        00001B78 R  D  02        
RECURSE                          000017EF R  D  04        V_BUF_BLK_NUMS                   00001B80 R  D  02        
REPEAT                           0000180A R  D  04        V_BUF_INUSE                      00001B7D R  D  02        
RESTART                          00000F0A R  D  04        V_COMPILER                       00001D3F R  D  02        
RMS$_EOF                         ********   X   00        V_CONTEXT                        00001D37 R  D  02        
RMS$_FNF                         ********   X   00        V_CTRLC_DEPTH                    00001D2B R  D  02        
R_WARM_START                     00001A47 R  D  04        V_CURRENT                        00001D3B R  D  02        
SEARCH                           00000F82 R  D  04        V_CURRENT_BUFF                   00001B79 R  D  02        
SIGN                             00000FDF R  D  04        V_ERRORS                         00001D2F R  D  02        
SMUDGE                           00000FF6 R  D  04        V_FILELINENUM                    00001D48 R  D  02        
SPACE                            0000102B R  D  04        V_FILENOTFOUND                   0000189A R  D  02        
SPACES                           00001064 R  D  04        V_FNAME                          00001A3D R  D  02        
SREAD                            00001084 R  D  04        V_FNAMELEN                       00001A3C R  D  02        
STRCAT                           00001141 R  D  04        V_GETCHN_BUF                     00001D1F R  D  02        
STRCMP                           00001182 R  D  04        V_GETCHN_BUF_ADR                 00001D1B R  D  02        
STRCPY                           000011BB R  D  04        V_GETCHN_IN_BUF                  00001D17 R  D  02        
STRING                           000011ED R  D  04        V_GETCHN_RET_LEN                 00001D13 R  D  02        
STRMAX                           00001260 R  D  04        V_GREETING                       00001800 R  D  02        
STRPOS                           00001273 R  D  04        V_HLD                            00001D52 R  D  02        
SWAP                             000012A6 R  D  04        V_INBUF                          000018F7 R  D  02        
SYS$ASSIGN                       ********  G    04        V_INFAB                          000019A8 R  D  02        
SYS$CLOSE                        ********  G    04        V_INFILE                         00001D47 R  D  02        
SYS$CONNECT                      ********  G    04        V_INFILEMESS                     00001890 R  D  02        
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 160
Symbol table                                                             12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

V_INLEN                          00001999 R  D  02        _UNKNOWNTOKEN                    00001B73 R  D  04        
V_INPTR                          0000199B R  D  02        
V_INPUT_CHAN                     00001D11 R  D  02        
V_INPUT_NAME                     00001CFE R  D  02        
V_INRAB                          000019F8 R  D  02        
V_IN_DSC                         0000199F R  D  02        
V_KERNEL                         00001D43 R  D  02        
V_MODE                           00001D4D R  D  02        
V_NAMETOOLONG                    000018D8 R  D  02        
V_NAMETRUNC                      000018E8 R  D  02        
V_ORG_INLEN                      00001997 R  D  02        
V_OUTBUF                         00001B9A R  D  02        
V_OUTLEN                         00001B98 R  D  02        
V_OVERMESS                       0000185A R  D  02        
V_RADIX                          00001D4E R  D  02        
V_READADDR                       00001B92 R  D  02        
V_READDSC                        00001B8E R  D  02        
V_READLEN                        00001B8C R  D  02        
V_RETURNSTACK                    00001D33 R  D  02        
V_STATE                          00001D4C R  D  02        
V_STATIC_DSC                     00001B96 R  D  02        
V_TPU_COM                        00001C3A R  D  02        
V_TPU_COM2                       00001C56 R  D  02        
V_TPU_DSC                        00001CF6 R  D  02        
V_TRAP_DEPTH                     00001D27 R  D  02        
V_UNDERMESS                      00001842 R  D  02        
V_UNKNOWN                        00001871 R  D  02        
V_UNKNOWN2                       00001883 R  D  02        
V_UNKN_BLK_MESS                  000018B1 R  D  02        
V_USRPROMPT                      00001838 R  D  02        
V_VTILPROMPT                     0000182A R  D  02        
V_WORDNOTFOUND                   000018C7 R  D  02        
WHILE                            0000185F R  D  04        
WRITE                            0000144C R  D  04        
XOR                              000014F8 R  D  04        
_CHECK_BASE                      00000D61 R  D  04        
_CHECK_LOWERCASE                 00000D50 R  D  04        
_COMPILER_END                    000018A7 R  D  04        
_DONE                            00001BF3 R  D  04        
_ERROR_EXIT                      00001BCD R  D  04        
_EXIT                            00001C00 R  D  04        
_F_ERR                           00001BD7 R  D  04        
_GETTOKEN                        00001305 R  D  04        
_INITIALIZE                      00001ABE R  D  04        
_INTERPRETER                     00001ACC R  D  04        
_INVALID_NUMBER                  00000D8E R  D  04        
_KERNEL_BEGIN                    00000000 R  D  04        
_KERNEL_END                      00001521 R  D  04        
_NUMBER_TOP                      00000D32 R  D  04        
_OVERFLOW                        00001B5F R  D  04        
_Q_EXECUTE                       00001B0E R  D  04        
_R_ERR                           00001BE6 R  D  04        
_SKIPWHITESPACE                  000012E3 R  D  04        
_STARTFOUND                      000012F7 R  D  04        
_STRIP_COMMENT                   00001AFA R  D  04        
_STRIP_COMMENT2                  00001B04 R  D  04        
_UNDERFLOW                       00001B4B R  D  04        
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 161
Psect synopsis                                                           12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)


                                                +----------------+
                                                ! Psect synopsis !
                                                +----------------+

PSECT name                      Allocation          PSECT No.  Attributes     
----------                      ----------          ---------  ----------     
.  ABS  .                       00000000  (    0.)  00 (  0.)  NOPIC   USR   CON   ABS   LCL NOSHR NOEXE NORD  NOWRT NOVEC BYTE  
$ABS$                           00000000  (    0.)  01 (  1.)  NOPIC   USR   CON   ABS   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILDATA                        00001D56  ( 7510.)  02 (  2.)  NOPIC   USR   CON   REL   LCL NOSHR NOEXE   RD    WRT NOVEC LONG  
$RMSNAM                         00000018  (   24.)  03 (  3.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTILCODE                        00001C0C  ( 7180.)  04 (  4.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD  NOWRT NOVEC BYTE  
VTILDICT                        00004C00  (19456.)  05 (  5.)  NOPIC   USR   CON   REL   LCL NOSHR   EXE   RD    WRT NOVEC BYTE  
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 162
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)


                                             +------------------------+
                                             ! Symbol Cross Reference !
                                             +------------------------+

SYMBOL                          VALUE        DEFINITION      REFERENCES... 
------                          -----        ----------      ------------- 
$$$ADR                         =00000060     3408   (1)      3326   (1)      3332   (1)      3341   (1)      3377   (1)    
                                                             3392   (1)      3400   (1)      3408   (1)    
$$.TAB                         =00001B30-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TABEND                      =00001B74-R   442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP                         =00000000     442    (1)      412    (1)      419    (1)      435    (1)      442    (1)    
$$.TMP1                        =00000001     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMP2                        =000000CF     3607   (1)      1277   (1)      1293   (1)      1297   (1)      1314   (1)    
                                                             1331   (1)      1332   (1)      1900   (1)      1902   (1)    
                                                             2462   (1)      2477   (1)      3465   (1)      3607   (1)    
$$.TMPX                        =0000000A-R   435    (1)      435    (1)    
$$.TMPX1                       =0000000E     435    (1)      435    (1)    
$$T1                           =00000001     3377   (1)      3326   (1)      3341   (1)      3377   (1)    
ABORT                           000003A3-R   1072   (1)    
ABS                             000003AE-R   1079   (1)      735    (1)    
ADM_ABSOLUTE                   =0000009F     268    (1)    #-1501   (1)    #-2794   (1)    #-2951   (1)    
ADM_ADEC_R10                   =0000007A     261    (1)    #-3060   (1)    #-3063   (1)    
ADM_ADEC_R11                   =0000007B     265    (1)    #-1134   (1)    #-1449   (1)    #-1932   (1)    #-2353   (1)    
                                                           #-2564   (1)    #-2583   (1)    #-2756   (1)    #-2897   (1)    
                                                           #-2934   (1)    #-2948   (1)    #-3183   (1)    
ADM_AINC_R10                   =0000008A     262    (1)    
ADM_AINC_R11                   =0000008B     266    (1)    #-2914   (1)    #-3056   (1)    #-3059   (1)    #-3150   (1)    
                                                           #-3252   (1)    #-3271   (1)    
ADM_AINC_R9                    =00000089     258    (1)    #-1097   (1)    
ADM_B_DIS_R10                  =000000AA     263    (1)    #-2912   (1)    #-3076   (1)    #-3194   (1)    
ADM_B_REL                      =000000AF     269    (1)    #-1095   (1)    #-1132   (1)    #-1447   (1)    #-1930   (1)    
                                                           #-2351   (1)    #-2562   (1)    #-2581   (1)    #-2754   (1)    
                                                           #-2792   (1)    #-2895   (1)    #-2932   (1)    #-3036   (1)    
ADM_DEF_R10                    =0000006A     260    (1)    #-2915   (1)    #-3080   (1)    #-3197   (1)    
ADM_DEF_R11                    =0000006B     264    (1)    
ADM_DEF_R9                     =00000069     257    (1)    #-3038   (1)    
ADM_IMMEDIATE                  =0000008F     267    (1)    #-2946   (1)    #-2981   (1)    #-3032   (1)    #-3078   (1)    
                                                           #-3181   (1)    
ADM_R0                         =00000050     255    (1)    #-3057   (1)    #-3062   (1)    
ADM_R10                        =0000005A     259    (1)    #-2922   (1)    #-3087   (1)    #-3204   (1)    
ADM_R9                         =00000059     256    (1)    #-2983   (1)    
AGAIN                           00001611-R   2991   (1)    
AND                             000003EB-R   1110   (1)    
ARRAY                           0000040C-R   1129   (1)    
ASCII                           00000432-R   1144   (1)    
BCOUNT                          00000471-R   1183   (1)      1480   (1)      1579   (1)      1587   (1)      1781   (1)    
                                                             1784   (1)      1808   (1)      1811   (1)      2771   (1)    
                                                             3469   (1)      3562   (1)      3569   (1)    
BINARY                          00000486-R   1193   (1)    
BLANK                           000004A5-R   1209   (1)    
BLOCK                           000004BA-R   1220   (1)    
BREAK                           00000627-R   1343   (1)    
BUFFER                          00000641-R   1359   (1)    
BYTE                            0000071D-R   1444   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 163
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

CA_CONTROLC                    =00000000     53     (1)    
CA_TRAPPING                    =00000000     49     (1)    
CFA                             00000744-R   1461   (1)      3214   (1)      3528   (1)    
CHF$L_MCHARGLST                =00000008                   #-3397   (1)    
CHF$L_MCH_DEPTH                =00000008                   #-3398   (1)    
CHF$L_SIGARGLST                =00000004                   #-3389   (1)    
CHF$L_SIG_NAME                 =00000004                   #-3391   (1)    
CLIST                           0000075F-R   1473   (1)    
COMPILER_BEGIN                  00001521-R   2884   (1)    
COMPILETIME                     000007BD-R   1512   (1)      1103   (1)    
CONTEXT                         000007E6-R   1534   (1)    
COUNT                           000007F8-R   1545   (1)      1998   (1)    
CR                              0000080A-R   1555   (1)      1584   (1)      2175   (1)      2408   (1)      2442   (1)    
                                                             3547   (1)      3554   (1)      3576   (1)      3580   (1)    
                                                             956    (1)      982    (1)    
CREATE                          0000083E-R   1570   (1)      1093   (1)      1130   (1)      1445   (1)      1928   (1)    
                                                             1942   (1)      2349   (1)      2560   (1)      2579   (1)    
                                                             2752   (1)      2790   (1)      842    (1)    
CURRENT                         000008BD-R   1603   (1)    
C_BLANK                        =00000020     216    (1)    #-1145   (1)    #-1202   (1)    #-1211   (1)    #-1484   (1)    
                                                           #-1574   (1)    #-1702   (1)    #-1769   (1)    #-1795   (1)    
                                                           #-1891   (1)    #-2413   (1)    #-2676   (1)    #-2775   (1)    
                                                           #-3011   (1)    #-3165   (1)    #-3234   (1)    #-3296   (1)    
                                                           #-3494   (1)    #-742    (1)    
C_BLOCK_SIZE                   =00000400     225    (1)    #-1264   (1)    #-1329   (1)    #-1401   (1)    #-1416   (1)    
                                                           #-1434   (1)      227    (1)      3631   (1)      435    (1)    
                                                             442    (1)    
C_COM1_BEGIN                   =0000005C     217    (1)    #-3499   (1)    
C_COM1_END                     =00000000     218    (1)    #-3516   (1)    
C_COM2_BEGIN                   =00000028     220    (1)    #-3501   (1)    
C_COM2_END                     =00000029     221    (1)    #-3522   (1)    
C_DICT_BEGIN                    00000000-R   3622   (1)    #-3424   (1)    
C_DICT_END                      00004000-R   3624   (1)    #-1820   (1)    
C_DS_END                        00000000-R   345    (1)    #-3534   (1)    
C_DS_SIZE                      =00001000     231    (1)      346    (1)    
C_DS_START                      00001000-R   347    (1)      2398   (1)      3483   (1)    #-3536   (1)    #-766    (1)    
                                                           #-786    (1)    
C_D_BLKS_IN_BLK                =00000002     227    (1)    
C_FALSE                        =00000000     213    (1)    #-1121   (1)    #-1281   (1)    #-1658   (1)    #-1660   (1)    
                                                           #-1751   (1)    #-1976   (1)    #-2061   (1)    #-2120   (1)    
                                                           #-2140   (1)    #-2478   (1)    #-2635   (1)    #-2857   (1)    
                                                           #-2962   (1)    #-3288   (1)    #-3459   (1)    #-3460   (1)    
                                                           #-3466   (1)    #-3532   (1)    #-3540   (1)      446    (1)    
                                                             538    (1)      542    (1)      545    (1)    #-856    (1)    
                                                           #-877    (1)    #-890    (1)    #-909    (1)    #-919    (1)    
                                                           #-922    (1)    #-932    (1)    
C_INUSE                        =00000001     222    (1)    #-1254   (1)    #-1396   (1)    #-2309   (1)    
C_KEYSIZE                      =00000004     226    (1)      442    (1)    
C_LS_END                        00001000-R   351    (1)    
C_LS_SIZE                      =00000800     233    (1)      352    (1)    
C_LS_START                      00001800-R   353    (1)      3484   (1)    
C_MAX_BLOCKS                   =00000003     224    (1)    #-1227   (1)    #-1236   (1)    #-1243   (1)    #-1366   (1)    
                                                           #-1375   (1)    #-1382   (1)    #-1662   (1)    #-1754   (1)    
                                                           #-2312   (1)      3631   (1)      451    (1)      453    (1)    
C_MAX_ERRS                     =00000014     214    (1)    #-3395   (1)    
C_MAX_LEN                      =000000A0     228    (1)    #-2173   (1)    #-2406   (1)    #-2805   (1)    #-2817   (1)    
                                                             393    (1)      401    (1)      419    (1)      423    (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 164
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                                             469    (1)      482    (1)      492    (1)    
C_MAX_NAME_LEN                 =00000050     215    (1)    #-1576   (1)    #-1585   (1)    
C_MODIFIED                     =00000002     223    (1)    #-1240   (1)    #-1379   (1)    #-1744   (1)    #-2302   (1)    
                                                           #-2739   (1)    
C_PAD_MOAT                     =00000109     230    (1)    #-2165   (1)    #-591    (1)    #-867    (1)    
C_SCREEN_LEN                   =00000050     229    (1)    #-978    (1)    
C_TPU_COM_LEN                  =0000001C     490    (1)    #-1707   (1)    
C_TRUE                         =FFFFFFFF     211    (1)    #-1003   (1)    #-1049   (1)    #-1115   (1)    #-1301   (1)    
                                                           #-1918   (1)    #-1971   (1)    #-2064   (1)    #-2117   (1)    
                                                           #-2146   (1)    #-2334   (1)    #-2631   (1)    #-2860   (1)    
                                                           #-2868   (1)    #-846    (1)    #-859    (1)    #-880    (1)    
                                                           #-893    (1)    #-905    (1)    #-935    (1)    
DC$_TERM                        00000000-XR                #-3334   (1)      65     (1)    
DECIMAL                         000008D1-R   1613   (1)    
DEFINITIONS                     000008E9-R   1623   (1)    
DOWNLOOP                        000016BD-R   3074   (1)    
DROP                            000008FE-R   1631   (1)    
DSC$K_CLASS_S                   00000000-XR                  403    (1)      471    (1)      478    (1)      496    (1)    
                                                             66     (1)    
DSC$K_DTYPE_T                   00000000-XR                  402    (1)      470    (1)      477    (1)      495    (1)    
                                                             66     (1)    
DUP                             00000918-R   1647   (1)    
ELSE                            000016F9-R   3095   (1)    
ENABLE_CTRLC                    0000193C-R   3372   (1)      3341   (1)      3377   (1)    
ENDIF                           00001721-R   3114   (1)    
ENDWHILE                        0000173A-R   3125   (1)    
EODP                            00000950-R   1677   (1)    
EVE                             00000979-R   1701   (1)    
FAB$B_DNS                      =00000035                     435    (1)    
FAB$B_FNS                      =00000034                   #-1899   (1)      435    (1)    
FAB$C_BID                      =00000003                     412    (1)      435    (1)    
FAB$C_BLN                      =00000050                     412    (1)      435    (1)    
FAB$C_FIX                      =00000001                     435    (1)    
FAB$C_SEQ                      =00000000                     412    (1)      435    (1)    
FAB$C_VAR                      =00000002                     412    (1)    
FAB$L_ALQ                      =00000010                     412    (1)      435    (1)    
FAB$L_DNA                      =00000030                     435    (1)    
FAB$L_FNA                      =0000002C                   #-1897   (1)      435    (1)    
FAB$L_FOP                      =00000004                     412    (1)      435    (1)    
FAB$L_STS                      =00000008                   #-3597   (1)    
FAB$L_STV                      =0000000C                   #-3596   (1)    
FAB$V_CHAN_MODE                =00000002                     412    (1)      435    (1)    
FAB$V_FILE_MODE                =00000004                     412    (1)      435    (1)    
FAB$V_GET                      =00000001                     435    (1)    
FAB$V_LNM_MODE                 =00000000                     412    (1)      435    (1)    
FAB$V_UPD                      =00000003                     435    (1)    
FAB$W_GBC                      =00000048                     412    (1)      435    (1)    
FILL                            000009CB-R   1730   (1)    
FORGET                          00000A1C-R   1768   (1)    
FREEMEM                         00000ACA-R   1819   (1)    
HEX                             00000AEE-R   1837   (1)    
HLD                             00000AFE-R   1845   (1)    
HOLD                            00000B0F-R   1853   (1)      2367   (1)      580    (1)    
IF                              0000175D-R   3148   (1)    
IO$M_CTRLCAST                   00000000-XR                #-3341   (1)    #-3377   (1)      67     (1)    
IO$_SETMODE                     00000000-XR                #-3341   (1)    #-3377   (1)      67     (1)    
I_AC_COLON                      000003BE-R   1092   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 165
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

I_ADD                           000000C1-R   675    (1)    
I_BIT_AND                       00000072-R   621    (1)    
I_BIT_NOT                       00000083-R   631    (1)    
I_BIT_OR                        00000090-R   639    (1)    
I_BIT_XOR                       0000009E-R   647    (1)    
I_BL                            00000497-R   1201   (1)    
I_BLOCK_CLOSE                   0000053B-R   1274   (1)    
I_BLOCK_OPEN                    0000056D-R   1289   (1)    
I_BLOCK_READ                    000005B3-R   1309   (1)      1422   (1)    
I_BLOCK_WRITE                   000005E5-R   1324   (1)      1437   (1)    
I_BS_FETCH                      00000631-R   1351   (1)    
I_BUFFER_READ                   000006B8-R   1413   (1)      1257   (1)    
I_BUFFER_WRITE                  000006F4-R   1430   (1)      1248   (1)      1387   (1)      1749   (1)      2307   (1)    
I_B_COMMA                       00000457-R   1164   (1)    
I_B_FETCH                       00000461-R   1173   (1)    
I_B_STORE                       00000447-R   1154   (1)    
I_B_UP                          00001636-R   3010   (1)    
I_COLON                         000001FB-R   840    (1)    
I_COMMA                         000000F5-R   705    (1)    
I_COMPILE_ASCII                 00001897-R   3295   (1)    
I_COMPILE_JSB                   000007A2-R   1499   (1)      3215   (1)      3541   (1)    
I_COUNT_BEGIN                   00000064-R   613    (1)    
I_COUNT_END                     000000B3-R   664    (1)    
I_DEFER_BEGIN                   00001658-R   3030   (1)    
I_DEFER_END                     000015ED-R   2975   (1)    
I_DIVIDE                        000001C0-R   801    (1)    
I_DIV_MOD                       000001CD-R   810    (1)      578    (1)    
I_DO                            00001688-R   3054   (1)    
I_DOT                           00000123-R   733    (1)      1821   (1)      3574   (1)      772    (1)      789    (1)    
                                                             946    (1)    
I_DOT_LPAREN                    0000015A-R   752    (1)    
I_DOT_QUOTE                     00001581-R   2930   (1)    
I_DOT_SB                        00000179-R   765    (1)    
I_DOT_ST                        0000019D-R   783    (1)    
I_DS_TO_LS                      0000090C-R   1639   (1)    
I_EMPTY_BUFFERS                 0000092E-R   1655   (1)    
I_EODP_PLUS_STORE               0000096D-R   1693   (1)    
I_EOD_STORE                     0000095E-R   1685   (1)    
I_EQUAL                         00000264-R   887    (1)    
I_EQUAL_TEXT                    0000027F-R   901    (1)    
I_EXIT                          000009BF-R   1723   (1)    
I_FETCH                         00000394-R   1064   (1)    
I_FLUSH_BUFFERS                 000009E9-R   1741   (1)    
I_FORGET_ERASE                  00000A74-R   1794   (1)    
I_GREATER_EQUAL                 000002B3-R   929    (1)    
I_GRETER                        0000029F-R   916    (1)    
I_HALT                          00000AE0-R   1828   (1)    
I_I_TO                          00000B27-R   1865   (1)    
I_LEFT_BRACK                    00001883-R   3287   (1)    
I_LESS                          00000221-R   853    (1)    
I_LESS_EQUAL                    0000024D-R   874    (1)    
I_LESS_SHARP                    00000239-R   866    (1)      736    (1)    
I_LONG                          00000BF2-R   1927   (1)    
I_LOOP                          000017B8-R   3192   (1)    
I_LS_TO_DS                      00000C32-R   1952   (1)    
I_L_UP                          0000177F-R   3164   (1)    
I_MATCH                         00000C40-R   1961   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 166
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

I_MINUS_ROT                     0000010C-R   722    (1)    
I_MOVE_FILL                     00000CDC-R   2039   (1)    
I_MULTIPLY                      000000A8-R   655    (1)    
I_ONE_MINUS                     000001F2-R   830    (1)    
I_ONE_PLUS                      000001E8-R   822    (1)    
I_PLUS_LOOP                     0000154D-R   2910   (1)    
I_PLUS_ROT                      000000DE-R   694    (1)    
I_PLUS_STORE                    000000CC-R   683    (1)    
I_QUESTION                      000002CA-R   944    (1)    
I_RIGHT_BACK                    00001518-R   2867   (1)    
I_SAVE_BUFFERS                  00000F55-R   2299   (1)    
I_SEMICOLON                     000015D3-R   2960   (1)    
I_SHARP                         00000015-R   576    (1)      602    (1)    
I_SHARP_GREATER                 00000036-R   588    (1)      740    (1)    
I_SHARP_S                       00000055-R   601    (1)    #-604    (1)      737    (1)    
I_SHORT                         00000FBA-R   2348   (1)    
I_SP_0                          00001019-R   2397   (1)    
I_SP_FETCH                      0000100D-R   2387   (1)    
I_STORE                         00000006-R   565    (1)    
I_STRING_QUOTE                  00001218-R   2578   (1)    
I_SUBTRACT                      000000FF-R   713    (1)    
I_S_UP                          00001815-R   3233   (1)    
I_VARIABLE                      00001530-R   2893   (1)    
I_WORD_FETCH                    00000F32-R   2283   (1)    
I_WORD_STORE                    00000F14-R   2265   (1)    
I_WS_FETCH                      00000F3F-R   2291   (1)    
I_W_COMMA                       00000F24-R   2274   (1)    
KERNEL                          00000B36-R   1873   (1)    
LEAVE                           00000B4C-R   1881   (1)    
LIB$GET_INPUT                   00000000-XR                  2214   (1)      2247   (1)      2451   (1)      69     (1)    
LIB$PUT_OUTPUT                  00000000-XR                  1560   (1)      1909   (1)      2812   (1)      2835   (1)    
                                                             3431   (1)      3445   (1)      3549   (1)      3556   (1)    
                                                             69     (1)    
LIB$SIGNAL                      00000000-XR                  1715   (1)      3365   (1)      3379   (1)      3592   (1)    
                                                             3598   (1)      3604   (1)      69     (1)    
LIB$_INPSTRTRU                  00000000-XR                #-2215   (1)    #-2248   (1)      68     (1)    
LITERAL                         0000179F-R   3179   (1)      1000   (1)      1943   (1)      3299   (1)    
LOAD                            00000B5A-R   1890   (1)    
LONGCONST                       00000C1A-R   1941   (1)    
MAX                             00000C6B-R   1983   (1)    
MESSAGE                         00000C85-R   1997   (1)    
MIN                             00000C98-R   2006   (1)    
MOD                             00000CAE-R   2019   (1)    
MOVE                            00000CC4-R   2029   (1)    
NCHR                           =00000007     3295   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1173   (1)      1183   (1)    
                                                             1193   (1)      1201   (1)      1209   (1)      1220   (1)    
                                                             1274   (1)      1289   (1)      1309   (1)      1324   (1)    
                                                             1343   (1)      1351   (1)      1359   (1)      1413   (1)    
                                                             1430   (1)      1444   (1)      1461   (1)      1473   (1)    
                                                             1499   (1)      1512   (1)      1534   (1)      1545   (1)    
                                                             1555   (1)      1570   (1)      1603   (1)      1613   (1)    
                                                             1623   (1)      1631   (1)      1639   (1)      1647   (1)    
                                                             1655   (1)      1677   (1)      1685   (1)      1693   (1)    
                                                             1701   (1)      1723   (1)      1730   (1)      1741   (1)    
                                                             1768   (1)      1794   (1)      1819   (1)      1828   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 167
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                                             1837   (1)      1845   (1)      1853   (1)      1865   (1)    
                                                             1873   (1)      1881   (1)      1890   (1)      1927   (1)    
                                                             1941   (1)      1952   (1)      1961   (1)      1983   (1)    
                                                             1997   (1)      2006   (1)      2019   (1)      2029   (1)    
                                                             2039   (1)      2050   (1)      2058   (1)      2073   (1)    
                                                             2127   (1)      2135   (1)      2154   (1)      2164   (1)    
                                                             2172   (1)      2189   (1)      2197   (1)      2229   (1)    
                                                             2257   (1)      2265   (1)      2274   (1)      2283   (1)    
                                                             2291   (1)      2299   (1)      2322   (1)      2348   (1)    
                                                             2363   (1)      2376   (1)      2387   (1)      2397   (1)    
                                                             2405   (1)      2421   (1)      2439   (1)      2488   (1)    
                                                             2514   (1)      2538   (1)      2559   (1)      2578   (1)    
                                                             2607   (1)      2620   (1)      2642   (1)      2654   (1)    
                                                             2675   (1)      2715   (1)      2727   (1)      2737   (1)    
                                                             2751   (1)      2764   (1)      2788   (1)      2804   (1)    
                                                             2847   (1)      2867   (1)      2893   (1)      2910   (1)    
                                                             2930   (1)      2960   (1)      2975   (1)      2991   (1)    
                                                             3010   (1)      3030   (1)      3054   (1)      3074   (1)    
                                                             3095   (1)      3114   (1)      3125   (1)      3148   (1)    
                                                             3164   (1)      3179   (1)      3192   (1)      3212   (1)    
                                                             3223   (1)      3233   (1)      3250   (1)      3268   (1)    
                                                             3287   (1)      3295   (1)      565    (1)      576    (1)    
                                                             588    (1)      601    (1)      613    (1)      621    (1)    
                                                             631    (1)      639    (1)      647    (1)      655    (1)    
                                                             664    (1)      675    (1)      683    (1)      694    (1)    
                                                             705    (1)      713    (1)      722    (1)      733    (1)    
                                                             752    (1)      765    (1)      783    (1)      801    (1)    
                                                             810    (1)      822    (1)      830    (1)      840    (1)    
                                                             853    (1)      866    (1)      874    (1)      887    (1)    
                                                             901    (1)      916    (1)      929    (1)      944    (1)    
                                                             953    (1)      965    (1)      976    (1)      993    (1)    
NEGAGE                          00000CF5-R   2050   (1)    
NOT                             00000D01-R   2058   (1)    
NUMBER                          00000D1C-R   2073   (1)      3013   (1)      3167   (1)      3236   (1)      994    (1)    
OCTAL                           00000D9C-R   2127   (1)    
OP_ACBL                        =000000F1     238    (1)    #-2911   (1)    #-3075   (1)    #-3193   (1)    
OP_ADDL2                       =000000C0     239    (1)    #-2920   (1)    #-2980   (1)    #-3085   (1)    #-3202   (1)    
OP_BNEQ                        =00000012     240    (1)    #-3151   (1)    #-3253   (1)    #-3272   (1)    
OP_BRW                         =00000031     241    (1)    #-2935   (1)    #-2996   (1)    #-3039   (1)    #-3096   (1)    
                                                           #-3126   (1)    #-3153   (1)    #-3255   (1)    #-3274   (1)    
OP_JSB                         =00000016     242    (1)    #-1500   (1)    #-2950   (1)    
OP_MOVAB                       =0000009E     243    (1)    #-1131   (1)    #-1446   (1)    #-2894   (1)    #-2931   (1)    
OP_MOVAL                       =000000DE     244    (1)    #-1929   (1)    #-2791   (1)    
OP_MOVAW                       =0000003E     245    (1)    #-2350   (1)    #-2561   (1)    #-2580   (1)    
OP_MOVB                        =00000090     246    (1)    #-1094   (1)    #-2753   (1)    
OP_MOVC3                       =00000028     247    (1)    #-3031   (1)    
OP_MOVL                        =000000D0     248    (1)    #-2945   (1)    #-3055   (1)    #-3058   (1)    #-3061   (1)    
                                                           #-3180   (1)    
OP_RSB                         =00000005     249    (1)    #-1098   (1)    #-1135   (1)    #-1450   (1)    #-1595   (1)    
                                                           #-1933   (1)    #-1944   (1)    #-2354   (1)    #-2565   (1)    
                                                           #-2584   (1)    #-2757   (1)      2796   (1)    #-2898   (1)    
                                                           #-2961   (1)    
OP_TSTL                        =000000D5     250    (1)    #-3149   (1)    #-3251   (1)    #-3270   (1)    
OR                              00000DAB-R   2135   (1)    
OTS$CVT_L_TI                    00000000-XR                  70     (1)    
OVER                            00000DCB-R   2154   (1)    
PAD                             00000DD8-R   2164   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 168
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

PUTC                            00000DEA-R   2172   (1)      1485   (1)      2776   (1)      743    (1)    
Q_CR                            000002DB-R   953    (1)      3475   (1)    
Q_DUP                           000002F3-R   965    (1)    
Q_NUMBER                        0000032C-R   993    (1)      3509   (1)    
Q_N_CR                          00000305-R   976    (1)      1482   (1)      2773   (1)    
Q_SEARCH                        0000035B-R   1014   (1)      3504   (1)    
RAB$B_RAC                      =0000001E                     419    (1)      442    (1)    
RAB$C_BID                      =00000001                     419    (1)      442    (1)    
RAB$C_BLN                      =00000044                     419    (1)      442    (1)    
RAB$C_KEY                      =00000001                     442    (1)    
RAB$C_SEQ                      =00000000                     419    (1)    
RAB$L_CTX                      =00000018                     419    (1)      442    (1)    
RAB$L_RBF                      =00000028                   #-1326   (1)    
RAB$L_ROP                      =00000004                     419    (1)      442    (1)    
RAB$L_STS                      =00000008                   #-3603   (1)    
RAB$L_STV                      =0000000C                   #-3602   (1)    
RAB$L_UBF                      =00000024                   #-1311   (1)    
RAB$V_RAH                      =00000009                     419    (1)    
RAB$W_RSZ                      =00000022                   #-1330   (1)    #-2470   (1)    #-2472   (1)    
RADIX                           00000E21-R   2189   (1)    
READ                            00000E32-R   2197   (1)    
READSTR                         00000EA6-R   2229   (1)    
RECURSE                         000017EF-R   3212   (1)    
REPEAT                          0000180A-R   3223   (1)    
RESTART                         00000F0A-R   2257   (1)    
RMS$_EOF                        00000000-XR                #-2453   (1)    #-2464   (1)      71     (1)    
RMS$_FNF                        00000000-XR                #-1906   (1)      71     (1)    
R_WARM_START                    00001A47-R   3451   (1)    #-1073   (1)    #-1716   (1)    #-1786   (1)    #-1813   (1)    
                                                           #-2258   (1)    #-3550   (1)    #-3557   (1)    #-3581   (1)    
SEARCH                          00000F82-R   2322   (1)      1040   (1)      1046   (1)      1772   (1)      1798   (1)    
                                                           #-2338   (1)    
SIGN                            00000FDF-R   2363   (1)      739    (1)    
SMUDGE                          00000FF6-R   2376   (1)      845    (1)    
SPACE                           0000102B-R   2405   (1)      2426   (1)    
SPACES                          00001064-R   2421   (1)    
SREAD                           00001084-R   2439   (1)      2682   (1)    
STRCAT                          00001141-R   2488   (1)    
STRCMP                          00001182-R   2514   (1)    
STRCPY                          000011BB-R   2538   (1)    
STRING                          000011ED-R   2559   (1)    
STRMAX                          00001260-R   2607   (1)    
STRPOS                          00001273-R   2620   (1)    
SWAP                            000012A6-R   2642   (1)    
SYS$ASSIGN                      00000000-XR                  3326   (1)    
SYS$CLOSE                       00000000-XR                  1277   (1)      2477   (1)      3465   (1)      3607   (1)    
SYS$CONNECT                     00000000-XR                  1297   (1)      1902   (1)    
SYS$EXIT                        00000000-XR                  3409   (1)      3612   (1)    
SYS$FIND                        00000000-XR                  1331   (1)    
SYS$GET                         00000000-XR                  1314   (1)      2462   (1)    
SYS$GETCHN                      00000000-XR                  3332   (1)    
SYS$OPEN                        00000000-XR                  1293   (1)      1900   (1)    
SYS$PUTMSG                      00000000-XR                  3392   (1)      3408   (1)    
SYS$QIO                         00000000-XR                  3341   (1)      3377   (1)    
SYS$UNWIND                      00000000-XR                  3400   (1)    
SYS$UPDATE                      00000000-XR                  1332   (1)    
S_COLD_START                    000019DA-R   3422   (1)      3351   (1)    
S_TRAP                          00001970-R   3387   (1)      3318   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 169
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

S_WARM_START                    00001A22-R   3441   (1)      3355   (1)    
TOCHAR                          000012BD-R   2654   (1)      579    (1)    
TOKEN                           000012DE-R   2675   (1)      1146   (1)      1575   (1)      1703   (1)      1770   (1)    
                                                             1796   (1)      1892   (1)      2591   (1)      2939   (1)    
                                                             3012   (1)      3166   (1)      3235   (1)      3297   (1)    
                                                             3495   (1)      3517   (1)      3523   (1)      754    (1)    
TPU$TPU                         00000000-XR                  1710   (1)      72     (1)    
UNLINK                          00001362-R   2715   (1)      3457   (1)    
UNSMUDGE                        0000137E-R   2727   (1)      2964   (1)    
UNTIL                           00001836-R   3250   (1)    
UPDATE                          00001398-R   2737   (1)    
V1_COMPILER                    =0000182C-R   3250   (1)      3250   (1)    
V1_KERNEL                      =00001512-R   2867   (1)      1014   (1)      1064   (1)      1072   (1)      1079   (1)    
                                                             1092   (1)      1110   (1)      1129   (1)      1144   (1)    
                                                             1154   (1)      1164   (1)      1183   (1)      1193   (1)    
                                                             1201   (1)      1209   (1)      1220   (1)      1274   (1)    
                                                             1289   (1)      1309   (1)      1324   (1)      1343   (1)    
                                                             1351   (1)      1359   (1)      1413   (1)      1430   (1)    
                                                             1444   (1)      1461   (1)      1473   (1)      1499   (1)    
                                                             1512   (1)      1534   (1)      1545   (1)      1555   (1)    
                                                             1570   (1)      1603   (1)      1613   (1)      1623   (1)    
                                                             1631   (1)      1639   (1)      1647   (1)      1655   (1)    
                                                             1677   (1)      1685   (1)      1693   (1)      1701   (1)    
                                                             1723   (1)      1730   (1)      1741   (1)      1768   (1)    
                                                             1794   (1)      1819   (1)      1828   (1)      1837   (1)    
                                                             1845   (1)      1853   (1)      1865   (1)      1873   (1)    
                                                             1881   (1)      1890   (1)      1927   (1)      1941   (1)    
                                                             1952   (1)      1961   (1)      1983   (1)      1997   (1)    
                                                             2006   (1)      2019   (1)      2029   (1)      2039   (1)    
                                                             2050   (1)      2058   (1)      2073   (1)      2127   (1)    
                                                             2135   (1)      2154   (1)      2164   (1)      2172   (1)    
                                                             2189   (1)      2197   (1)      2229   (1)      2257   (1)    
                                                             2265   (1)      2274   (1)      2283   (1)      2291   (1)    
                                                             2299   (1)      2322   (1)      2348   (1)      2363   (1)    
                                                             2376   (1)      2387   (1)      2397   (1)      2405   (1)    
                                                             2421   (1)      2439   (1)      2488   (1)      2514   (1)    
                                                             2538   (1)      2559   (1)      2578   (1)      2607   (1)    
                                                             2620   (1)      2642   (1)      2654   (1)      2675   (1)    
                                                             2715   (1)      2727   (1)      2737   (1)      2751   (1)    
                                                             2764   (1)      2788   (1)      2804   (1)      2847   (1)    
                                                             2867   (1)      565    (1)      576    (1)      588    (1)    
                                                             601    (1)      613    (1)      621    (1)      631    (1)    
                                                             639    (1)      647    (1)      655    (1)      664    (1)    
                                                             675    (1)      683    (1)      694    (1)      705    (1)    
                                                             713    (1)      722    (1)      733    (1)      752    (1)    
                                                             765    (1)      783    (1)      801    (1)      810    (1)    
                                                             822    (1)      830    (1)      840    (1)      853    (1)    
                                                             866    (1)      874    (1)      887    (1)      901    (1)    
                                                             916    (1)      929    (1)      944    (1)      953    (1)    
                                                             965    (1)      976    (1)      993    (1)    
VARIABLE                        000013B2-R   2751   (1)    
VLIST                           000013D3-R   2764   (1)    
VL_COMPILER                    =0000188B-R   3295   (1)      2893   (1)      2910   (1)      2930   (1)      2960   (1)    
                                                             2975   (1)      2991   (1)      3010   (1)      3030   (1)    
                                                             3054   (1)      3074   (1)      3095   (1)      3114   (1)    
                                                             3125   (1)      3148   (1)      3164   (1)      3179   (1)    
                                                             3192   (1)      3212   (1)      3223   (1)      3233   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 170
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                                             3268   (1)      3287   (1)      3295   (1)    #-3427   (1)    
VL_KERNEL                      =00000000     282    (1)    #-3428   (1)    
VOCABULARY                      00001416-R   2788   (1)    
VTIL                            000018A7-R   3315   (1)    
VTIL_CTRLC                      00000000-XR                #-3378   (1)      73     (1)    
VTIL_EXIT                       00001932-R   3363   (1)    #-3328   (1)    #-3343   (1)    
VTIL_MAXERRORS                  00000000-XR                #-3404   (1)      73     (1)    
V_BLKBUFF                       00004000-R   3630   (1)    #-1265   (1)    #-1402   (1)    #-1417   (1)    #-1435   (1)    
                                                             442    (1)    
V_BLKFAB                        00001AE0-R   430    (1)      1277   (1)      1293   (1)      442    (1)    
V_BLKKEY                        00001B74-R   443    (1)    #-1313   (1)    #-1328   (1)    
V_BLKRAB                        00001B30-R   436    (1)      1297   (1)    #-1311   (1)      1314   (1)    #-1326   (1)    
                                                           #-1330   (1)      1331   (1)      1332   (1)    
V_BLOCKIO                       00001B78-R   445    (1)    #-1275   (1)    #-1281   (1)    #-1290   (1)    #-1301   (1)    
V_BUF_BLK_NUMS                  00001B80-R   452    (1)    #-1225   (1)    #-1253   (1)    #-1364   (1)    #-1395   (1)    
                                                           #-1419   (1)    #-1432   (1)    #-1661   (1)    
V_BUF_INUSE                     00001B7D-R   450    (1)    #-1234   (1)    #-1241   (1)    #-1255   (1)    #-1373   (1)    
                                                           #-1380   (1)    #-1397   (1)    #-1659   (1)    #-1745   (1)    
                                                           #-1752   (1)    #-2303   (1)    #-2310   (1)    #-2740   (1)    
V_COMPILER                      00001D3F-R   533    (1)    #-1045   (1)    #-1474   (1)    #-1515   (1)    #-1516   (1)    
                                                           #-3427   (1)    
V_CONTEXT                       00001D37-R   529    (1)    #-1032   (1)      1535   (1)    #-1624   (1)    #-1771   (1)    
                                                           #-1776   (1)    #-1797   (1)    #-1802   (1)    #-1874   (1)    
                                                           #-2765   (1)    #-2789   (1)      2795   (1)    #-3213   (1)    
                                                           #-3432   (1)    #-3446   (1)    #-841    (1)    
V_CTRLC_DEPTH                   00001D2B-R   523    (1)    
V_CURRENT                       00001D3B-R   531    (1)    #-1513   (1)    #-1514   (1)    #-1571   (1)    #-1572   (1)    
                                                             1604   (1)    #-1624   (1)    #-2377   (1)    #-2716   (1)    
                                                           #-2717   (1)    #-2728   (1)    #-3433   (1)    #-3447   (1)    
                                                           #-841    (1)    
V_CURRENT_BUFF                  00001B79-R   447    (1)    #-1266   (1)    #-1403   (1)    #-1415   (1)    #-2738   (1)    
V_ERRORS                        00001D2F-R   525    (1)    #-3394   (1)    #-3395   (1)    
V_FILELINENUM                   00001D48-R   539    (1)    #-1919   (1)    #-2474   (1)    #-2479   (1)    #-3467   (1)    
                                                           #-3573   (1)    
V_FILENOTFOUND                  0000189A-R   377    (1)      1908   (1)    
V_FNAME                         00001A3D-R   422    (1)      1894   (1)      1896   (1)      3471   (1)    
V_FNAMELEN                      00001A3C-R   420    (1)    #-1895   (1)    #-1898   (1)    #-3472   (1)    
V_GETCHN_BUF                    00001D1F-R   515    (1)    #-3334   (1)      514    (1)    
V_GETCHN_BUF_ADR                00001D1B-R   513    (1)    
V_GETCHN_IN_BUF                 00001D17-R   510    (1)      3332   (1)    
V_GETCHN_RET_LEN                00001D13-R   508    (1)      3332   (1)    
V_GREETING                      00001800-R   361    (1)      3430   (1)      3444   (1)    
V_HLD                           00001D52-R   548    (1)      1846   (1)    #-1854   (1)    #-1855   (1)    #-589    (1)    
                                                           #-592    (1)    #-867    (1)    
V_INBUF                         000018F7-R   392    (1)      2444   (1)      3577   (1)      399    (1)      404    (1)    
                                                             419    (1)    
V_INFAB                         000019A8-R   411    (1)    #-1897   (1)    #-1899   (1)      1900   (1)      1912   (1)    
                                                             2477   (1)      3465   (1)      419    (1)    
V_INFILE                        00001D47-R   537    (1)    #-1918   (1)    #-2445   (1)    #-2478   (1)    #-3463   (1)    
                                                           #-3466   (1)    #-3571   (1)      3607   (1)    
V_INFILEMESS                    00001890-R   375    (1)      3468   (1)    
V_INLEN                         00001999-R   396    (1)      2448   (1)    #-2459   (1)    #-2471   (1)    #-2679   (1)    
                                                           #-2686   (1)    #-2690   (1)    #-2691   (1)    #-2693   (1)    
                                                           #-2700   (1)    #-2703   (1)    #-3461   (1)    
V_INPTR                         0000199B-R   398    (1)    #-2444   (1)      2679   (1)    #-2685   (1)      2690   (1)    
                                                             2698   (1)    #-2699   (1)    #-2705   (1)    
V_INPUT_CHAN                    00001D11-R   503    (1)      3326   (1)    #-3332   (1)    #-3341   (1)    #-3377   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 171
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

V_INPUT_NAME                    00001CFE-R   501    (1)      3326   (1)    
V_INRAB                         000019F8-R   415    (1)      1902   (1)      1915   (1)      2462   (1)      2467   (1)    
                                                           #-2470   (1)    #-2472   (1)    
V_IN_DSC                        0000199F-R   400    (1)      2450   (1)    
V_KERNEL                        00001D43-R   535    (1)      1874   (1)    #-3428   (1)      3432   (1)      3433   (1)    
                                                             3446   (1)      3447   (1)    
V_MODE                          00001D4D-R   544    (1)    #-1043   (1)    #-2868   (1)    #-2962   (1)    #-3288   (1)    
                                                           #-3455   (1)    #-3459   (1)    #-3530   (1)    #-846    (1)    
                                                           #-998    (1)    
V_NAMETOOLONG                   000018D8-R   383    (1)      1578   (1)    
V_NAMETRUNC                     000018E8-R   385    (1)      1586   (1)    
V_ORG_INLEN                     00001997-R   394    (1)    #-2459   (1)    #-2473   (1)    #-3462   (1)    #-3578   (1)    
V_OUTBUF                        00001B9A-R   481    (1)      1556   (1)    #-1557   (1)      2177   (1)      2207   (1)    
                                                             2238   (1)      2410   (1)      2808   (1)      2818   (1)    
                                                             2831   (1)    
V_OUTLEN                        00001B98-R   479    (1)    #-1562   (1)    #-2173   (1)    #-2178   (1)    #-2182   (1)    
                                                           #-2202   (1)    #-2208   (1)    #-2217   (1)    #-2233   (1)    
                                                           #-2239   (1)    #-2241   (1)    #-2406   (1)    #-2411   (1)    
                                                           #-2414   (1)    #-2440   (1)    #-2805   (1)    #-2809   (1)    
                                                           #-2814   (1)    #-2816   (1)    #-2823   (1)    #-2830   (1)    
                                                           #-2832   (1)    #-2836   (1)    #-954    (1)    #-977    (1)    
V_OVERMESS                      0000185A-R   369    (1)      3555   (1)    
V_RADIX                         00001D4E-R   546    (1)    #-1194   (1)    #-1614   (1)    #-1838   (1)    #-2104   (1)    
                                                           #-2106   (1)    #-2128   (1)      2190   (1)    #-577    (1)    
V_READADDR                      00001B92-R   472    (1)    #-2198   (1)    #-2199   (1)    
V_READDSC                       00001B8E-R   468    (1)      2213   (1)    
V_READLEN                       00001B8C-R   466    (1)      2200   (1)    #-2219   (1)    
V_RETURNSTACK                   00001D33-R   527    (1)    #-3423   (1)    #-3476   (1)    
V_STATE                         00001D4C-R   541    (1)    #-1049   (1)    #-3460   (1)    #-3530   (1)    #-3532   (1)    
                                                           #-3540   (1)    
V_STATIC_DSC                    00001B96-R   476    (1)    #-1558   (1)    #-2209   (1)    #-2232   (1)    #-2240   (1)    
                                                           #-2810   (1)    #-2833   (1)    
V_TPU_COM                       00001C3A-R   488    (1)      490    (1)      497    (1)    
V_TPU_COM2                      00001C56-R   491    (1)      1706   (1)    
V_TPU_DSC                       00001CF6-R   493    (1)    #-1708   (1)      1709   (1)    
V_TRAP_DEPTH                    00001D27-R   521    (1)    #-3399   (1)      3400   (1)    
V_UNDERMESS                     00001842-R   367    (1)      3548   (1)    
V_UNKNOWN                       00001871-R   371    (1)      3561   (1)    
V_UNKNOWN2                      00001883-R   373    (1)      3568   (1)    
V_UNKN_BLK_MESS                 000018B1-R   379    (1)    
V_USRPROMPT                     00001838-R   365    (1)    
V_VTILPROMPT                    0000182A-R   363    (1)      2449   (1)    
V_WORDNOTFOUND                  000018C7-R   381    (1)      1780   (1)      1807   (1)    
WHILE                           0000185F-R   3268   (1)    
WRITE                           0000144C-R   2804   (1)      1483   (1)      1580   (1)      1583   (1)      1588   (1)    
                                                             1591   (1)      1782   (1)      1785   (1)      1809   (1)    
                                                             1812   (1)      1999   (1)      2774   (1)      2952   (1)    
                                                             3470   (1)      3473   (1)      3563   (1)      3567   (1)    
                                                             3570   (1)      3579   (1)      741    (1)      757    (1)    
XOR                             000014F8-R   2847   (1)    
_CHECK_BASE                     00000D61-R   2103   (1)    #-2089   (1)    #-2095   (1)    
_CHECK_LOWERCASE                00000D50-R   2097   (1)    #-2093   (1)    
_COMPILER_END                   000018A7-R   3303   (1)    
_DONE                           00001BF3-R   3607   (1)    
_ERROR_EXIT                     00001BCD-R   3590   (1)    #-1279   (1)    #-1295   (1)    #-1299   (1)    #-1316   (1)    
                                                           #-1334   (1)    #-1830   (1)    #-2215   (1)    #-2248   (1)    
                                                           #-2457   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 172
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

_EXIT                           00001C00-R   3610   (1)    #-1724   (1)    #-2455   (1)    #-3599   (1)    
_F_ERR                          00001BD7-R   3596   (1)    #-1913   (1)    
_GETTOKEN                       00001305-R   2687   (1)    #-2677   (1)    
_INITIALIZE                     00001ABE-R   3481   (1)    #-3434   (1)    
_INTERPRETER                    00001ACC-R   3493   (1)    #-3511   (1)    #-3518   (1)    #-3524   (1)    #-3538   (1)    
                                                           #-3543   (1)    
_INVALID_NUMBER                 00000D8E-R   2119   (1)    #-2087   (1)    #-2091   (1)    #-2099   (1)    #-2101   (1)    
                                                           #-2105   (1)    
_KERNEL_BEGIN                   00000000-R   559    (1)    
_KERNEL_END                     00001521-R   2872   (1)    
_NUMBER_TOP                     00000D32-R   2083   (1)    #-2079   (1)    #-2111   (1)    
_OVERFLOW                       00001B5F-R   3553   (1)    #-3535   (1)    
_Q_EXECUTE                      00001B0E-R   3527   (1)    #-3507   (1)    
_R_ERR                          00001BE6-R   3602   (1)    #-1916   (1)    #-2468   (1)    
_SKIPWHITESPACE                 000012E3-R   2678   (1)    #-2683   (1)    
_STARTFOUND                     000012F7-R   2684   (1)    #-2680   (1)    
_STRIP_COMMENT                  00001AFA-R   3515   (1)    #-3500   (1)    
_STRIP_COMMENT2                 00001B04-R   3521   (1)    #-3502   (1)    
_UNDERFLOW                      00001B4B-R   3546   (1)    #-3537   (1)    
_UNKNOWNTOKEN                   00001B73-R   3560   (1)    #-3512   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 173
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)


                                             +------------------------+
                                             ! Macros Cross Reference !
                                             +------------------------+

MACRO             SIZE          DEFINITION       REFERENCES... 
-----             ----          ----------       ------------- 
$$R_TABINIT       1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$$R_VBFSET        1             412    (1)       412    (1)       419    (1)       435    (1)       442    (1)    
$ASNPUSH          1             3326   (1)       3326   (1)    
$ASSIGN_S         1             3325   (1)       3325   (1)    
$CHFDEF           2             74     (1)       74     (1)    
$CLOSE            1             1277   (1)       1277   (1)       2477   (1)       3465   (1)       3607   (1)    
$CONNECT          1             1297   (1)       1297   (1)       1902   (1)    
$DEFINI           1             74     (1)       412    (1)       419    (1)       74     (1)    
$EXIT_S           1             3409   (1)       3409   (1)       3612   (1)    
$FAB              4             412    (1)       412    (1)       431    (1)    
$FABDEF           1             412    (1)       412    (1)       435    (1)    
$FIND             1             1331   (1)       1331   (1)    
$GET              1             1314   (1)       1314   (1)       2462   (1)    
$GETCHN_S         1             3330   (1)       3330   (1)    
$OPEN             1             1293   (1)       1293   (1)       1900   (1)    
$PUSHADR          1             3326   (1)       3326   (1)       3332   (1)       3341   (1)       3377   (1)       3392   (1)    
                                                 3400   (1)       3408   (1)    
$PUSHTWO          1             3341   (1)       3341   (1)       3377   (1)    
$PUTMSG_S         1             3392   (1)       3392   (1)       3408   (1)    
$QIOPUSH          1             3341   (1)       3341   (1)       3377   (1)    
$QIO_S            1             3338   (1)       3338   (1)       3374   (1)    
$RAB              2             416    (1)       416    (1)       437    (1)    
$RABDEF           1             419    (1)       419    (1)       442    (1)    
$RMSCALL          2             1277   (1)       1277   (1)       1293   (1)       1297   (1)       1314   (1)       1331   (1)    
                                                 1332   (1)       1900   (1)       1902   (1)       2462   (1)       2477   (1)    
                                                 3465   (1)       3607   (1)    
$UNWIND_S         1             3400   (1)       3400   (1)    
$UPDATE           1             1332   (1)       1332   (1)    
HEADER            1             298    (1)       1014   (1)       1064   (1)       1072   (1)       1079   (1)       1092   (1)    
                                                 1110   (1)       1129   (1)       1144   (1)       1154   (1)       1164   (1)    
                                                 1173   (1)       1183   (1)       1193   (1)       1201   (1)       1209   (1)    
                                                 1220   (1)       1274   (1)       1289   (1)       1309   (1)       1324   (1)    
                                                 1343   (1)       1351   (1)       1359   (1)       1413   (1)       1430   (1)    
                                                 1444   (1)       1461   (1)       1473   (1)       1499   (1)       1512   (1)    
                                                 1534   (1)       1545   (1)       1555   (1)       1570   (1)       1603   (1)    
                                                 1613   (1)       1623   (1)       1631   (1)       1639   (1)       1647   (1)    
                                                 1655   (1)       1677   (1)       1685   (1)       1693   (1)       1701   (1)    
                                                 1723   (1)       1730   (1)       1741   (1)       1768   (1)       1794   (1)    
                                                 1819   (1)       1828   (1)       1837   (1)       1845   (1)       1853   (1)    
                                                 1865   (1)       1873   (1)       1881   (1)       1890   (1)       1927   (1)    
                                                 1941   (1)       1952   (1)       1961   (1)       1983   (1)       1997   (1)    
                                                 2006   (1)       2019   (1)       2029   (1)       2039   (1)       2050   (1)    
                                                 2058   (1)       2073   (1)       2127   (1)       2135   (1)       2154   (1)    
                                                 2164   (1)       2172   (1)       2189   (1)       2197   (1)       2229   (1)    
                                                 2257   (1)       2265   (1)       2274   (1)       2283   (1)       2291   (1)    
                                                 2299   (1)       2322   (1)       2348   (1)       2363   (1)       2376   (1)    
                                                 2387   (1)       2397   (1)       2405   (1)       2421   (1)       2439   (1)    
                                                 2488   (1)       2514   (1)       2538   (1)       2559   (1)       2578   (1)    
                                                 2607   (1)       2620   (1)       2642   (1)       2654   (1)       2675   (1)    
                                                 2715   (1)       2727   (1)       2737   (1)       2751   (1)       2764   (1)    
VTIL                            VAX Threaded Interpretive Language       12-AUG-2023 15:55:47  VAX MACRO V5.4-3            Page 174
Cross reference                                                          12-AUG-2023 15:44:51  [MPL.TKB.VTIL]VTIL.MAR;109        (1)

                                                 2788   (1)       2804   (1)       2847   (1)       2867   (1)       2893   (1)    
                                                 2910   (1)       2930   (1)       2960   (1)       2975   (1)       2991   (1)    
                                                 3010   (1)       3030   (1)       3054   (1)       3074   (1)       3095   (1)    
                                                 3114   (1)       3125   (1)       3148   (1)       3164   (1)       3179   (1)    
                                                 3192   (1)       3212   (1)       3223   (1)       3233   (1)       3250   (1)    
                                                 3268   (1)       3287   (1)       3295   (1)       565    (1)       576    (1)    
                                                 588    (1)       601    (1)       613    (1)       621    (1)       631    (1)    
                                                 639    (1)       647    (1)       655    (1)       664    (1)       675    (1)    
                                                 683    (1)       694    (1)       705    (1)       713    (1)       722    (1)    
                                                 733    (1)       752    (1)       765    (1)       783    (1)       801    (1)    
                                                 810    (1)       822    (1)       830    (1)       840    (1)       853    (1)    
                                                 866    (1)       874    (1)       887    (1)       901    (1)       916    (1)    
                                                 929    (1)       944    (1)       953    (1)       965    (1)       976    (1)    
                                                 993    (1)    
ISERROR           1             315    (1)    
ISSTRERR          1             326    (1)       2215   (1)       2248   (1)    
NEWPAGE           1             39     (1)       137    (1)       202    (1)       284    (1)       2873   (1)       3304   (1)    
                                                 334    (1)       3412   (1)       3487   (1)       3584   (1)       3615   (1)    
                                                 551    (1)       58     (1)       77     (1)    

                                             +------------------------+
                                             ! Performance indicators !
                                             +------------------------+

Phase                    Page faults    CPU Time       Elapsed Time   
-----                    -----------    --------       ------------   
Initialization                   34     00:00:00.00    00:00:00.02
Command processing              885     00:00:00.02    00:00:00.02
Pass 1                          891     00:00:00.57    00:00:00.70
Symbol table sort                 0     00:00:00.04    00:00:00.04
Pass 2                           93     00:00:00.27    00:00:00.31
Symbol table output               0     00:00:00.00    00:00:00.00
Psect synopsis output             0     00:00:00.00    00:00:00.00
Cross-reference output            7     00:00:00.08    00:00:00.08
Assembler run totals           1914     00:00:00.98    00:00:01.17

The working set limit was 3500 pages.
233011 bytes (456 pages) of virtual memory were used to buffer the intermediate code.
There were 50 pages of symbol table space allocated to hold 720 non-local and 109 local symbols.
3639 source lines were read in Pass 1, producing 96 object records in Pass 2.
49 pages of virtual memory were used to define 34 macros.

                                            +--------------------------+
                                            ! Macro library statistics !
                                            +--------------------------+

Macro library name                           Macros defined      
------------------                           --------------      
SYS$COMMON:[SYSLIB]STARLET.MLB;2                       27        

751 GETS were required to define 27 macros.

There were no errors, warnings or information messages.

MACRO/DEBUG/LIST/CROSS/OBJECT=VTIL.OBJ/SHOW=EXPANSION VTIL.MAR
